{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"chapter_appendix/","title":"Chapter 16. \u00a0 Appendix","text":""},{"location":"chapter_appendix/#chapter-contents","title":"Chapter contents","text":"<ul> <li>16.1 \u00a0 Programming Environment Installation</li> <li>16.2 \u00a0 Contributing Together</li> <li>16.3 \u00a0 Terminology Table</li> </ul>"},{"location":"chapter_appendix/contribution/","title":"16.2 \u00a0 Contributing Together","text":"<p>Due to limited capacity, there may be inevitable omissions and errors in this book. We appreciate your understanding and are grateful for your help in correcting them. If you discover typos, broken links, missing content, ambiguous wording, unclear explanations, or structural issues, please help us make corrections to provide readers with higher-quality learning resources.</p> <p>The GitHub IDs of all contributors will be displayed on the homepage of the book repository, the web version, and the PDF version to acknowledge their selfless contributions to the open source community.</p> <p>The Charm of Open Source</p> <p>The interval between two printings of a physical book is often quite long, making content updates very inconvenient.</p> <p>In this open source book, the time for content updates has been shortened to just days or even hours.</p>"},{"location":"chapter_appendix/contribution/#1-minor-content-adjustments","title":"1. \u00a0 Minor Content Adjustments","text":"<p>As shown in Figure 16-3, there is an \"edit icon\" in the top-right corner of each page. You can modify text or code by following these steps.</p> <ol> <li>Click the \"edit icon\". If you encounter a prompt asking you to \"Fork this repository\", please approve the operation.</li> <li>Modify the content of the Markdown source file, verify the correctness of the content, and maintain consistent formatting as much as possible.</li> <li>Fill in a description of your changes at the bottom of the page, then click the \"Propose file change\" button. After the page transitions, click the \"Create pull request\" button to submit your pull request.</li> </ol> <p></p> <p> Figure 16-3 \u00a0 Page edit button </p> <p>Images cannot be directly modified. Please describe the issue by creating a new Issue or leaving a comment. We will promptly redraw and replace the images.</p>"},{"location":"chapter_appendix/contribution/#2-content-creation","title":"2. \u00a0 Content Creation","text":"<p>If you are interested in contributing to this open source project, including translating code into other programming languages or expanding article content, you will need to follow the Pull Request workflow below.</p> <ol> <li>Log in to GitHub and Fork the book's code repository to your personal account.</li> <li>Enter your forked repository webpage and use the <code>git clone</code> command to clone the repository to your local machine.</li> <li>Create content locally and conduct comprehensive tests to verify code correctness.</li> <li>Commit your local changes and push them to the remote repository.</li> <li>Refresh the repository webpage and click the \"Create pull request\" button to submit your pull request.</li> </ol>"},{"location":"chapter_appendix/contribution/#3-docker-deployment","title":"3. \u00a0 Docker Deployment","text":"<p>From the root directory of <code>hello-algo</code>, run the following Docker script to access the project at <code>http://localhost:8000</code>:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Use the following command to remove the deployment:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"chapter_appendix/installation/","title":"16.1 \u00a0 Programming Environment Installation","text":""},{"location":"chapter_appendix/installation/#1611-installing-ide","title":"16.1.1 \u00a0 Installing Ide","text":"<p>We recommend using the open-source and lightweight VS Code as the local integrated development environment (IDE). Visit the VS Code official website, and download and install the appropriate version of VS Code according to your operating system.</p> <p></p> <p> Figure 16-1 \u00a0 Download VS Code from the Official Website </p> <p>VS Code has a powerful ecosystem of extensions that supports running and debugging most programming languages. For example, after installing the \"Python Extension Pack\" extension, you can debug Python code. The installation steps are shown in the following figure.</p> <p></p> <p> Figure 16-2 \u00a0 Install VS Code Extensions </p>"},{"location":"chapter_appendix/installation/#1612-installing-language-environments","title":"16.1.2 \u00a0 Installing Language Environments","text":""},{"location":"chapter_appendix/installation/#1-python-environment","title":"1. \u00a0 Python Environment","text":"<ol> <li>Download and install Miniconda3, which requires Python 3.10 or newer.</li> <li>Search for <code>python</code> in the VS Code extension marketplace and install the Python Extension Pack.</li> <li>(Optional) Enter <code>pip install black</code> on the command line to install the code formatter.</li> </ol>"},{"location":"chapter_appendix/installation/#2-cc-environment","title":"2. \u00a0 C/c++ Environment","text":"<ol> <li>Windows systems need to install MinGW (configuration tutorial); macOS comes with Clang built-in and does not require installation.</li> <li>Search for <code>c++</code> in the VS Code extension marketplace and install the C/C++ Extension Pack.</li> <li>(Optional) Open the Settings page, search for the <code>Clang_format_fallback Style</code> code formatting option, and set it to <code>{ BasedOnStyle: Microsoft, BreakBeforeBraces: Attach }</code>.</li> </ol>"},{"location":"chapter_appendix/installation/#3-java-environment","title":"3. \u00a0 Java Environment","text":"<ol> <li>Download and install OpenJDK (version must be &gt; JDK 9).</li> <li>Search for <code>java</code> in the VS Code extension marketplace and install the Extension Pack for Java.</li> </ol>"},{"location":"chapter_appendix/installation/#4-c-environment","title":"4. \u00a0 C# Environment","text":"<ol> <li>Download and install .Net 8.0.</li> <li>Search for <code>C# Dev Kit</code> in the VS Code extension marketplace and install C# Dev Kit (configuration tutorial).</li> <li>You can also use Visual Studio (installation tutorial).</li> </ol>"},{"location":"chapter_appendix/installation/#5-go-environment","title":"5. \u00a0 Go Environment","text":"<ol> <li>Download and install Go.</li> <li>Search for <code>go</code> in the VS Code extension marketplace and install Go.</li> <li>Press <code>Ctrl + Shift + P</code> to open the command palette, type <code>go</code>, select <code>Go: Install/Update Tools</code>, check all options and install.</li> </ol>"},{"location":"chapter_appendix/installation/#6-swift-environment","title":"6. \u00a0 Swift Environment","text":"<ol> <li>Download and install Swift.</li> <li>Search for <code>swift</code> in the VS Code extension marketplace and install Swift for Visual Studio Code.</li> </ol>"},{"location":"chapter_appendix/installation/#7-javascript-environment","title":"7. \u00a0 Javascript Environment","text":"<ol> <li>Download and install Node.js.</li> <li>(Optional) Search for <code>Prettier</code> in the VS Code extension marketplace and install the code formatter.</li> </ol>"},{"location":"chapter_appendix/installation/#8-typescript-environment","title":"8. \u00a0 Typescript Environment","text":"<ol> <li>Follow the same installation steps as the JavaScript environment.</li> <li>Install TypeScript Execute (tsx).</li> <li>Search for <code>typescript</code> in the VS Code extension marketplace and install Pretty TypeScript Errors.</li> </ol>"},{"location":"chapter_appendix/installation/#9-dart-environment","title":"9. \u00a0 Dart Environment","text":"<ol> <li>Download and install Dart.</li> <li>Search for <code>dart</code> in the VS Code extension marketplace and install Dart.</li> </ol>"},{"location":"chapter_appendix/installation/#10-rust-environment","title":"10. \u00a0 Rust Environment","text":"<ol> <li>Download and install Rust.</li> <li>Search for <code>rust</code> in the VS Code extension marketplace and install rust-analyzer.</li> </ol>"},{"location":"chapter_appendix/terminology/","title":"16.3 \u00a0 Terminology Table","text":"<p>The following table lists important terms that appear in this book. It is worth noting the following points:</p> <ul> <li>We recommend remembering the English names of terms to help with reading English literature.</li> <li>Some terms have different names in Simplified Chinese and Traditional Chinese.</li> </ul> <p> Table 16-1 \u00a0 Important Terms in Data Structures and Algorithms </p> English Simplified Chinese Traditional Chinese algorithm \u7b97\u6cd5 \u6f14\u7b97\u6cd5 data structure \u6570\u636e\u7ed3\u6784 \u8cc7\u6599\u7d50\u69cb code \u4ee3\u7801 \u7a0b\u5f0f\u78bc file \u6587\u4ef6 \u6a94\u6848 function \u51fd\u6570 \u51fd\u5f0f method \u65b9\u6cd5 \u65b9\u6cd5 variable \u53d8\u91cf \u8b8a\u6578 asymptotic complexity analysis \u6e10\u8fd1\u590d\u6742\u5ea6\u5206\u6790 \u6f38\u8fd1\u8907\u96dc\u5ea6\u5206\u6790 time complexity \u65f6\u95f4\u590d\u6742\u5ea6 \u6642\u9593\u8907\u96dc\u5ea6 space complexity \u7a7a\u95f4\u590d\u6742\u5ea6 \u7a7a\u9593\u8907\u96dc\u5ea6 loop \u5faa\u73af \u8ff4\u5708 iteration \u8fed\u4ee3 \u8fed\u4ee3 recursion \u9012\u5f52 \u905e\u8ff4 tail recursion \u5c3e\u9012\u5f52 \u5c3e\u905e\u8ff4 recursion tree \u9012\u5f52\u6811 \u905e\u8ff4\u6a39 big-\\(O\\) notation \u5927 \\(O\\) \u8bb0\u53f7 \u5927 \\(O\\) \u8a18\u865f asymptotic upper bound \u6e10\u8fd1\u4e0a\u754c \u6f38\u8fd1\u4e0a\u754c sign-magnitude \u539f\u7801 \u539f\u78bc 1\u2019s complement \u53cd\u7801 \u4e00\u88dc\u6578 2\u2019s complement \u8865\u7801 \u4e8c\u88dc\u6578 array \u6570\u7ec4 \u9663\u5217 index \u7d22\u5f15 \u7d22\u5f15 linked list \u94fe\u8868 \u93c8\u7d50\u4e32\u5217 linked list node, list node \u94fe\u8868\u8282\u70b9 \u93c8\u7d50\u4e32\u5217\u7bc0\u9ede head node \u5934\u8282\u70b9 \u982d\u7bc0\u9ede tail node \u5c3e\u8282\u70b9 \u5c3e\u7bc0\u9ede list \u5217\u8868 \u4e32\u5217 dynamic array \u52a8\u6001\u6570\u7ec4 \u52d5\u614b\u9663\u5217 hard disk \u786c\u76d8 \u786c\u789f random-access memory (RAM) \u5185\u5b58 \u8a18\u61b6\u9ad4 cache memory \u7f13\u5b58 \u5feb\u53d6 cache miss \u7f13\u5b58\u672a\u547d\u4e2d \u5feb\u53d6\u672a\u547d\u4e2d cache hit rate \u7f13\u5b58\u547d\u4e2d\u7387 \u5feb\u53d6\u547d\u4e2d\u7387 stack \u6808 \u5806\u758a top of the stack \u6808\u9876 \u5806\u758a\u9802 bottom of the stack \u6808\u5e95 \u5806\u758a\u5e95 queue \u961f\u5217 \u4f47\u5217 double-ended queue \u53cc\u5411\u961f\u5217 \u96d9\u5411\u4f47\u5217 front of the queue \u961f\u9996 \u4f47\u5217\u9996 rear of the queue \u961f\u5c3e \u4f47\u5217\u5c3e hash table \u54c8\u5e0c\u8868 \u96dc\u6e4a\u8868 hash set \u54c8\u5e0c\u96c6\u5408 \u96dc\u6e4a\u96c6\u5408 bucket \u6876 \u6876 hash function \u54c8\u5e0c\u51fd\u6570 \u96dc\u6e4a\u51fd\u5f0f hash collision \u54c8\u5e0c\u51b2\u7a81 \u96dc\u6e4a\u885d\u7a81 load factor \u8d1f\u8f7d\u56e0\u5b50 \u8ca0\u8f09\u56e0\u5b50 separate chaining \u94fe\u5f0f\u5730\u5740 \u93c8\u7d50\u4f4d\u5740 open addressing \u5f00\u653e\u5bfb\u5740 \u958b\u653e\u5b9a\u5740 linear probing \u7ebf\u6027\u63a2\u6d4b \u7dda\u6027\u63a2\u67e5 lazy deletion \u61d2\u5220\u9664 \u61f6\u522a\u9664 binary tree \u4e8c\u53c9\u6811 \u4e8c\u5143\u6a39 tree node \u6811\u8282\u70b9 \u6a39\u7bc0\u9ede left-child node \u5de6\u5b50\u8282\u70b9 \u5de6\u5b50\u7bc0\u9ede right-child node \u53f3\u5b50\u8282\u70b9 \u53f3\u5b50\u7bc0\u9ede parent node \u7236\u8282\u70b9 \u7236\u7bc0\u9ede left subtree \u5de6\u5b50\u6811 \u5de6\u5b50\u6a39 right subtree \u53f3\u5b50\u6811 \u53f3\u5b50\u6a39 root node \u6839\u8282\u70b9 \u6839\u7bc0\u9ede leaf node \u53f6\u8282\u70b9 \u8449\u7bc0\u9ede edge \u8fb9 \u908a level \u5c42 \u5c64 degree \u5ea6 \u5ea6 height \u9ad8\u5ea6 \u9ad8\u5ea6 depth \u6df1\u5ea6 \u6df1\u5ea6 perfect binary tree \u5b8c\u7f8e\u4e8c\u53c9\u6811 \u5b8c\u7f8e\u4e8c\u5143\u6a39 complete binary tree \u5b8c\u5168\u4e8c\u53c9\u6811 \u5b8c\u5168\u4e8c\u5143\u6a39 full binary tree \u5b8c\u6ee1\u4e8c\u53c9\u6811 \u5b8c\u6eff\u4e8c\u5143\u6a39 balanced binary tree \u5e73\u8861\u4e8c\u53c9\u6811 \u5e73\u8861\u4e8c\u5143\u6a39 binary search tree \u4e8c\u53c9\u641c\u7d22\u6811 \u4e8c\u5143\u641c\u5c0b\u6a39 AVL tree AVL \u6811 AVL \u6a39 red-black tree \u7ea2\u9ed1\u6811 \u7d05\u9ed1\u6a39 level-order traversal \u5c42\u5e8f\u904d\u5386 \u5c64\u5e8f\u8d70\u8a2a breadth-first traversal \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 \u5ee3\u5ea6\u512a\u5148\u8d70\u8a2a depth-first traversal \u6df1\u5ea6\u4f18\u5148\u904d\u5386 \u6df1\u5ea6\u512a\u5148\u8d70\u8a2a binary search tree \u4e8c\u53c9\u641c\u7d22\u6811 \u4e8c\u5143\u641c\u5c0b\u6a39 balanced binary search tree \u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811 \u5e73\u8861\u4e8c\u5143\u641c\u5c0b\u6a39 balance factor \u5e73\u8861\u56e0\u5b50 \u5e73\u8861\u56e0\u5b50 heap \u5806 \u5806\u7a4d max heap \u5927\u9876\u5806 \u5927\u9802\u5806\u7a4d min heap \u5c0f\u9876\u5806 \u5c0f\u9802\u5806\u7a4d priority queue \u4f18\u5148\u961f\u5217 \u512a\u5148\u4f47\u5217 heapify \u5806\u5316 \u5806\u7a4d\u5316 top-\\(k\\) problem Top-\\(k\\) \u95ee\u9898 Top-\\(k\\) \u554f\u984c graph \u56fe \u5716 vertex \u9876\u70b9 \u9802\u9ede undirected graph \u65e0\u5411\u56fe \u7121\u5411\u5716 directed graph \u6709\u5411\u56fe \u6709\u5411\u5716 connected graph \u8fde\u901a\u56fe \u9023\u901a\u5716 disconnected graph \u975e\u8fde\u901a\u56fe \u975e\u9023\u901a\u5716 weighted graph \u6709\u6743\u56fe \u6709\u6b0a\u5716 adjacency \u90bb\u63a5 \u9130\u63a5 path \u8def\u5f84 \u8def\u5f91 in-degree \u5165\u5ea6 \u5165\u5ea6 out-degree \u51fa\u5ea6 \u51fa\u5ea6 adjacency matrix \u90bb\u63a5\u77e9\u9635 \u9130\u63a5\u77e9\u9663 adjacency list \u90bb\u63a5\u8868 \u9130\u63a5\u8868 breadth-first search \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 \u5ee3\u5ea6\u512a\u5148\u641c\u5c0b depth-first search \u6df1\u5ea6\u4f18\u5148\u641c\u7d22 \u6df1\u5ea6\u512a\u5148\u641c\u5c0b binary search \u4e8c\u5206\u67e5\u627e \u4e8c\u5206\u641c\u5c0b searching algorithm \u641c\u7d22\u7b97\u6cd5 \u641c\u5c0b\u6f14\u7b97\u6cd5 sorting algorithm \u6392\u5e8f\u7b97\u6cd5 \u6392\u5e8f\u6f14\u7b97\u6cd5 selection sort \u9009\u62e9\u6392\u5e8f \u9078\u64c7\u6392\u5e8f bubble sort \u5192\u6ce1\u6392\u5e8f \u6ce1\u6cab\u6392\u5e8f insertion sort \u63d2\u5165\u6392\u5e8f \u63d2\u5165\u6392\u5e8f quick sort \u5feb\u901f\u6392\u5e8f \u5feb\u901f\u6392\u5e8f merge sort \u5f52\u5e76\u6392\u5e8f \u5408\u4f75\u6392\u5e8f heap sort \u5806\u6392\u5e8f \u5806\u7a4d\u6392\u5e8f bucket sort \u6876\u6392\u5e8f \u6876\u6392\u5e8f counting sort \u8ba1\u6570\u6392\u5e8f \u8a08\u6578\u6392\u5e8f radix sort \u57fa\u6570\u6392\u5e8f \u57fa\u6578\u6392\u5e8f divide and conquer \u5206\u6cbb \u5206\u6cbb hanota problem \u6c49\u8bfa\u5854\u95ee\u9898 \u6cb3\u5167\u5854\u554f\u984c backtracking algorithm \u56de\u6eaf\u7b97\u6cd5 \u56de\u6eaf\u6f14\u7b97\u6cd5 constraint \u7ea6\u675f \u7d04\u675f solution \u89e3 \u89e3 state \u72b6\u6001 \u72c0\u614b pruning \u526a\u679d \u526a\u679d permutations problem \u5168\u6392\u5217\u95ee\u9898 \u5168\u6392\u5217\u554f\u984c subset-sum problem \u5b50\u96c6\u548c\u95ee\u9898 \u5b50\u96c6\u5408\u554f\u984c \\(n\\)-queens problem \\(n\\) \u7687\u540e\u95ee\u9898 \\(n\\) \u7687\u540e\u554f\u984c dynamic programming \u52a8\u6001\u89c4\u5212 \u52d5\u614b\u898f\u5283 initial state \u521d\u59cb\u72b6\u6001 \u521d\u59cb\u72c0\u614b state-transition equation \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \u72c0\u614b\u8f49\u79fb\u65b9\u7a0b knapsack problem \u80cc\u5305\u95ee\u9898 \u80cc\u5305\u554f\u984c edit distance problem \u7f16\u8f91\u8ddd\u79bb\u95ee\u9898 \u7de8\u8f2f\u8ddd\u96e2\u554f\u984c greedy algorithm \u8d2a\u5fc3\u7b97\u6cd5 \u8caa\u5a6a\u6f14\u7b97\u6cd5"},{"location":"chapter_array_and_linkedlist/","title":"Chapter 4. \u00a0 Array and Linked List","text":"<p>Abstract</p> <p>The world of data structures is like a solid brick wall.</p> <p>Array bricks are neatly arranged, tightly packed one by one. Linked list bricks are scattered everywhere, with connecting vines freely weaving through the gaps between bricks.</p>"},{"location":"chapter_array_and_linkedlist/#chapter-contents","title":"Chapter contents","text":"<ul> <li>4.1 \u00a0 Array</li> <li>4.2 \u00a0 Linked List</li> <li>4.3 \u00a0 List</li> <li>4.4 \u00a0 Memory and Cache *</li> <li>4.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/","title":"4.1 \u00a0 Array","text":"<p>An array is a linear data structure that stores elements of the same type in contiguous memory space. The position of an element in the array is called the element's index. Figure 4-1 illustrates the main concepts and storage method of arrays.</p> <p></p> <p> Figure 4-1 \u00a0 Array definition and storage method </p>"},{"location":"chapter_array_and_linkedlist/array/#411-common-array-operations","title":"4.1.1 \u00a0 Common Array Operations","text":""},{"location":"chapter_array_and_linkedlist/array/#1-initializing-arrays","title":"1. \u00a0 Initializing Arrays","text":"<p>We can choose between two array initialization methods based on our needs: without initial values or with given initial values. When no initial values are specified, most programming languages will initialize array elements to \\(0\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array.py<pre><code># Initialize array\narr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> array.cpp<pre><code>/* Initialize array */\n// Stored on stack\nint arr[5];\nint nums[5] = { 1, 3, 2, 5, 4 };\n// Stored on heap (requires manual memory release)\nint* arr1 = new int[5];\nint* nums1 = new int[5] { 1, 3, 2, 5, 4 };\n</code></pre> array.java<pre><code>/* Initialize array */\nint[] arr = new int[5]; // { 0, 0, 0, 0, 0 }\nint[] nums = { 1, 3, 2, 5, 4 };\n</code></pre> array.cs<pre><code>/* Initialize array */\nint[] arr = new int[5]; // [ 0, 0, 0, 0, 0 ]\nint[] nums = [1, 3, 2, 5, 4];\n</code></pre> array.go<pre><code>/* Initialize array */\nvar arr [5]int\n// In Go, specifying length ([5]int) creates an array; not specifying length ([]int) creates a slice\n// Since Go's arrays are designed to have their length determined at compile time, only constants can be used to specify the length\n// For convenience in implementing the extend() method, slices are treated as arrays below\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> array.swift<pre><code>/* Initialize array */\nlet arr = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\nlet nums = [1, 3, 2, 5, 4]\n</code></pre> array.js<pre><code>/* Initialize array */\nvar arr = new Array(5).fill(0);\nvar nums = [1, 3, 2, 5, 4];\n</code></pre> array.ts<pre><code>/* Initialize array */\nlet arr: number[] = new Array(5).fill(0);\nlet nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> array.dart<pre><code>/* Initialize array */\nList&lt;int&gt; arr = List.filled(5, 0); // [0, 0, 0, 0, 0]\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> array.rs<pre><code>/* Initialize array */\nlet arr: [i32; 5] = [0; 5]; // [0, 0, 0, 0, 0]\nlet slice: &amp;[i32] = &amp;[0; 5];\n// In Rust, specifying length ([i32; 5]) creates an array; not specifying length (&amp;[i32]) creates a slice\n// Since Rust's arrays are designed to have their length determined at compile time, only constants can be used to specify the length\n// Vector is the type generally used as a dynamic array in Rust\n// For convenience in implementing the extend() method, vectors are treated as arrays below\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> array.c<pre><code>/* Initialize array */\nint arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }\nint nums[5] = { 1, 3, 2, 5, 4 };\n</code></pre> array.kt<pre><code>/* Initialize array */\nvar arr = IntArray(5) // { 0, 0, 0, 0, 0 }\nvar nums = intArrayOf(1, 3, 2, 5, 4)\n</code></pre> array.rb<pre><code># Initialize array\narr = Array.new(5, 0)\nnums = [1, 3, 2, 5, 4]\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/array/#2-accessing-elements","title":"2. \u00a0 Accessing Elements","text":"<p>Array elements are stored in contiguous memory space, which means calculating the memory address of array elements is very easy. Given the array's memory address (the memory address of the first element) and an element's index, we can use the formula shown in Figure 4-2 to calculate the element's memory address and directly access that element.</p> <p></p> <p> Figure 4-2 \u00a0 Memory address calculation for array elements </p> <p>Observing Figure 4-2, we find that the first element of an array has an index of \\(0\\), which may seem counterintuitive since counting from \\(1\\) would be more natural. However, from the perspective of the address calculation formula, an index is essentially an offset from the memory address. The address offset of the first element is \\(0\\), so it is reasonable for its index to be \\(0\\).</p> <p>Accessing elements in an array is highly efficient; we can randomly access any element in the array in \\(O(1)\\) time.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array.py<pre><code>def random_access(nums: list[int]) -&gt; int:\n    \"\"\"Random access to element\"\"\"\n    # Randomly select a number from the interval [0, len(nums)-1]\n    random_index = random.randint(0, len(nums) - 1)\n    # Retrieve and return the random element\n    random_num = nums[random_index]\n    return random_num\n</code></pre> array.cpp<pre><code>/* Random access to element */\nint randomAccess(int *nums, int size) {\n    // Randomly select a number from interval [0, size)\n    int randomIndex = rand() % size;\n    // Retrieve and return the random element\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.java<pre><code>/* Random access to element */\nint randomAccess(int[] nums) {\n    // Randomly select a number in the interval [0, nums.length)\n    int randomIndex = ThreadLocalRandom.current().nextInt(0, nums.length);\n    // Retrieve and return the random element\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.cs<pre><code>/* Random access to element */\nint RandomAccess(int[] nums) {\n    Random random = new();\n    // Randomly select a number in interval [0, nums.Length)\n    int randomIndex = random.Next(nums.Length);\n    // Retrieve and return the random element\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.go<pre><code>/* Random access to element */\nfunc randomAccess(nums []int) (randomNum int) {\n    // Randomly select a number in the interval [0, nums.length)\n    randomIndex := rand.Intn(len(nums))\n    // Retrieve and return the random element\n    randomNum = nums[randomIndex]\n    return\n}\n</code></pre> array.swift<pre><code>/* Random access to element */\nfunc randomAccess(nums: [Int]) -&gt; Int {\n    // Randomly select a number in interval [0, nums.count)\n    let randomIndex = nums.indices.randomElement()!\n    // Retrieve and return the random element\n    let randomNum = nums[randomIndex]\n    return randomNum\n}\n</code></pre> array.js<pre><code>/* Random access to element */\nfunction randomAccess(nums) {\n    // Randomly select a number in the interval [0, nums.length)\n    const random_index = Math.floor(Math.random() * nums.length);\n    // Retrieve and return the random element\n    const random_num = nums[random_index];\n    return random_num;\n}\n</code></pre> array.ts<pre><code>/* Random access to element */\nfunction randomAccess(nums: number[]): number {\n    // Randomly select a number in the interval [0, nums.length)\n    const random_index = Math.floor(Math.random() * nums.length);\n    // Retrieve and return the random element\n    const random_num = nums[random_index];\n    return random_num;\n}\n</code></pre> array.dart<pre><code>/* Random access to element */\nint randomAccess(List&lt;int&gt; nums) {\n  // Randomly select a number in the interval [0, nums.length)\n  int randomIndex = Random().nextInt(nums.length);\n  // Retrieve and return the random element\n  int randomNum = nums[randomIndex];\n  return randomNum;\n}\n</code></pre> array.rs<pre><code>/* Random access to element */\nfn random_access(nums: &amp;[i32]) -&gt; i32 {\n    // Randomly select a number in interval [0, nums.len())\n    let random_index = rand::thread_rng().gen_range(0..nums.len());\n    // Retrieve and return the random element\n    let random_num = nums[random_index];\n    random_num\n}\n</code></pre> array.c<pre><code>/* Random access to element */\nint randomAccess(int *nums, int size) {\n    // Randomly select a number from interval [0, size)\n    int randomIndex = rand() % size;\n    // Retrieve and return the random element\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.kt<pre><code>/* Random access to element */\nfun randomAccess(nums: IntArray): Int {\n    // Randomly select a number in interval [0, nums.size)\n    val randomIndex = ThreadLocalRandom.current().nextInt(0, nums.size)\n    // Retrieve and return the random element\n    val randomNum = nums[randomIndex]\n    return randomNum\n}\n</code></pre> array.rb<pre><code>### Random access element ###\ndef random_access(nums)\n  # Randomly select a number in the interval [0, nums.length)\n  random_index = Random.rand(0...nums.length)\n\n  # Retrieve and return the random element\n  nums[random_index]\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#3-inserting-elements","title":"3. \u00a0 Inserting Elements","text":"<p>Array elements are stored \"tightly adjacent\" in memory, with no space between them to store any additional data. As shown in Figure 4-3, if we want to insert an element in the middle of an array, we need to shift all elements after that position backward by one position, and then assign the value to that index.</p> <p></p> <p> Figure 4-3 \u00a0 Example of inserting an element into an array </p> <p>It is worth noting that since the length of an array is fixed, inserting an element will inevitably cause the element at the end of the array to be \"lost\". We will leave the solution to this problem for discussion in the \"List\" chapter.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array.py<pre><code>def insert(nums: list[int], num: int, index: int):\n    \"\"\"Insert element num at index index in the array\"\"\"\n    # Move all elements at and after index index backward by one position\n    for i in range(len(nums) - 1, index, -1):\n        nums[i] = nums[i - 1]\n    # Assign num to the element at index index\n    nums[index] = num\n</code></pre> array.cpp<pre><code>/* Insert element num at index index in the array */\nvoid insert(int *nums, int size, int num, int index) {\n    // Move all elements at and after index index backward by one position\n    for (int i = size - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // Assign num to the element at index index\n    nums[index] = num;\n}\n</code></pre> array.java<pre><code>/* Insert element num at index index in the array */\nvoid insert(int[] nums, int num, int index) {\n    // Move all elements at and after index index backward by one position\n    for (int i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // Assign num to the element at index index\n    nums[index] = num;\n}\n</code></pre> array.cs<pre><code>/* Insert element num at index index in the array */\nvoid Insert(int[] nums, int num, int index) {\n    // Move all elements at and after index index backward by one position\n    for (int i = nums.Length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // Assign num to the element at index index\n    nums[index] = num;\n}\n</code></pre> array.go<pre><code>/* Insert element num at index index in the array */\nfunc insert(nums []int, num int, index int) {\n    // Move all elements at and after index index backward by one position\n    for i := len(nums) - 1; i &gt; index; i-- {\n        nums[i] = nums[i-1]\n    }\n    // Assign num to the element at index index\n    nums[index] = num\n}\n</code></pre> array.swift<pre><code>/* Insert element num at index index in the array */\nfunc insert(nums: inout [Int], num: Int, index: Int) {\n    // Move all elements at and after index index backward by one position\n    for i in nums.indices.dropFirst(index).reversed() {\n        nums[i] = nums[i - 1]\n    }\n    // Assign num to the element at index index\n    nums[index] = num\n}\n</code></pre> array.js<pre><code>/* Insert element num at index index in the array */\nfunction insert(nums, num, index) {\n    // Move all elements at and after index index backward by one position\n    for (let i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // Assign num to the element at index index\n    nums[index] = num;\n}\n</code></pre> array.ts<pre><code>/* Insert element num at index index in the array */\nfunction insert(nums: number[], num: number, index: number): void {\n    // Move all elements at and after index index backward by one position\n    for (let i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // Assign num to the element at index index\n    nums[index] = num;\n}\n</code></pre> array.dart<pre><code>/* Insert element _num at array index index */\nvoid insert(List&lt;int&gt; nums, int _num, int index) {\n  // Move all elements at and after index index backward by one position\n  for (var i = nums.length - 1; i &gt; index; i--) {\n    nums[i] = nums[i - 1];\n  }\n  // Assign _num to element at index\n  nums[index] = _num;\n}\n</code></pre> array.rs<pre><code>/* Insert element num at index index in the array */\nfn insert(nums: &amp;mut [i32], num: i32, index: usize) {\n    // Move all elements at and after index index backward by one position\n    for i in (index + 1..nums.len()).rev() {\n        nums[i] = nums[i - 1];\n    }\n    // Assign num to the element at index index\n    nums[index] = num;\n}\n</code></pre> array.c<pre><code>/* Insert element num at index index in the array */\nvoid insert(int *nums, int size, int num, int index) {\n    // Move all elements at and after index index backward by one position\n    for (int i = size - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // Assign num to the element at index index\n    nums[index] = num;\n}\n</code></pre> array.kt<pre><code>/* Insert element num at index index in the array */\nfun insert(nums: IntArray, num: Int, index: Int) {\n    // Move all elements at and after index index backward by one position\n    for (i in nums.size - 1 downTo index + 1) {\n        nums[i] = nums[i - 1]\n    }\n    // Assign num to the element at index index\n    nums[index] = num\n}\n</code></pre> array.rb<pre><code>### Insert element num at index in array ###\ndef insert(nums, num, index)\n  # Move all elements at and after index index backward by one position\n  for i in (nums.length - 1).downto(index + 1)\n    nums[i] = nums[i - 1]\n  end\n\n  # Assign num to the element at index index\n  nums[index] = num\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#4-removing-elements","title":"4. \u00a0 Removing Elements","text":"<p>Similarly, as shown in Figure 4-4, to delete the element at index \\(i\\), we need to shift all elements after index \\(i\\) forward by one position.</p> <p></p> <p> Figure 4-4 \u00a0 Example of removing an element from an array </p> <p>Note that after the deletion is complete, the original last element becomes \"meaningless\", so we do not need to specifically modify it.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array.py<pre><code>def remove(nums: list[int], index: int):\n    \"\"\"Remove the element at index index\"\"\"\n    # Move all elements after index index forward by one position\n    for i in range(index, len(nums) - 1):\n        nums[i] = nums[i + 1]\n</code></pre> array.cpp<pre><code>/* Remove the element at index index */\nvoid remove(int *nums, int size, int index) {\n    // Move all elements after index index forward by one position\n    for (int i = index; i &lt; size - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.java<pre><code>/* Remove the element at index index */\nvoid remove(int[] nums, int index) {\n    // Move all elements after index index forward by one position\n    for (int i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.cs<pre><code>/* Remove the element at index index */\nvoid Remove(int[] nums, int index) {\n    // Move all elements after index index forward by one position\n    for (int i = index; i &lt; nums.Length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.go<pre><code>/* Remove the element at index index */\nfunc remove(nums []int, index int) {\n    // Move all elements after index index forward by one position\n    for i := index; i &lt; len(nums)-1; i++ {\n        nums[i] = nums[i+1]\n    }\n}\n</code></pre> array.swift<pre><code>/* Remove the element at index index */\nfunc remove(nums: inout [Int], index: Int) {\n    // Move all elements after index index forward by one position\n    for i in nums.indices.dropFirst(index).dropLast() {\n        nums[i] = nums[i + 1]\n    }\n}\n</code></pre> array.js<pre><code>/* Remove the element at index index */\nfunction remove(nums, index) {\n    // Move all elements after index index forward by one position\n    for (let i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.ts<pre><code>/* Remove the element at index index */\nfunction remove(nums: number[], index: number): void {\n    // Move all elements after index index forward by one position\n    for (let i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.dart<pre><code>/* Remove the element at index index */\nvoid remove(List&lt;int&gt; nums, int index) {\n  // Move all elements after index index forward by one position\n  for (var i = index; i &lt; nums.length - 1; i++) {\n    nums[i] = nums[i + 1];\n  }\n}\n</code></pre> array.rs<pre><code>/* Remove the element at index index */\nfn remove(nums: &amp;mut [i32], index: usize) {\n    // Move all elements after index index forward by one position\n    for i in index..nums.len() - 1 {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.c<pre><code>/* Remove the element at index index */\n// Note: stdio.h occupies the remove keyword\nvoid removeItem(int *nums, int size, int index) {\n    // Move all elements after index index forward by one position\n    for (int i = index; i &lt; size - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.kt<pre><code>/* Remove the element at index index */\nfun remove(nums: IntArray, index: Int) {\n    // Move all elements after index index forward by one position\n    for (i in index..&lt;nums.size - 1) {\n        nums[i] = nums[i + 1]\n    }\n}\n</code></pre> array.rb<pre><code>### Delete element at index ###\ndef remove(nums, index)\n  # Move all elements after index index forward by one position\n  for i in index...(nums.length - 1)\n    nums[i] = nums[i + 1]\n  end\nend\n</code></pre> <p>Overall, array insertion and deletion operations have the following drawbacks:</p> <ul> <li>High time complexity: The average time complexity for both insertion and deletion in arrays is \\(O(n)\\), where \\(n\\) is the length of the array.</li> <li>Loss of elements: Since the length of an array is immutable, after inserting an element, elements that exceed the array's length will be lost.</li> <li>Memory waste: We can initialize a relatively long array and only use the front portion, so that when inserting data, the lost elements at the end are \"meaningless\", but this causes some memory space to be wasted.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#5-traversing-arrays","title":"5. \u00a0 Traversing Arrays","text":"<p>In most programming languages, we can traverse an array either by index or by directly iterating through each element in the array:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array.py<pre><code>def traverse(nums: list[int]):\n    \"\"\"Traverse array\"\"\"\n    count = 0\n    # Traverse array by index\n    for i in range(len(nums)):\n        count += nums[i]\n    # Direct traversal of array elements\n    for num in nums:\n        count += num\n    # Traverse simultaneously data index and elements\n    for i, num in enumerate(nums):\n        count += nums[i]\n        count += num\n</code></pre> array.cpp<pre><code>/* Traverse array */\nvoid traverse(int *nums, int size) {\n    int count = 0;\n    // Traverse array by index\n    for (int i = 0; i &lt; size; i++) {\n        count += nums[i];\n    }\n}\n</code></pre> array.java<pre><code>/* Traverse array */\nvoid traverse(int[] nums) {\n    int count = 0;\n    // Traverse array by index\n    for (int i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // Direct traversal of array elements\n    for (int num : nums) {\n        count += num;\n    }\n}\n</code></pre> array.cs<pre><code>/* Traverse array */\nvoid Traverse(int[] nums) {\n    int count = 0;\n    // Traverse array by index\n    for (int i = 0; i &lt; nums.Length; i++) {\n        count += nums[i];\n    }\n    // Direct traversal of array elements\n    foreach (int num in nums) {\n        count += num;\n    }\n}\n</code></pre> array.go<pre><code>/* Traverse array */\nfunc traverse(nums []int) {\n    count := 0\n    // Traverse array by index\n    for i := 0; i &lt; len(nums); i++ {\n        count += nums[i]\n    }\n    count = 0\n    // Direct traversal of array elements\n    for _, num := range nums {\n        count += num\n    }\n    // Traverse simultaneously data index and elements\n    for i, num := range nums {\n        count += nums[i]\n        count += num\n    }\n}\n</code></pre> array.swift<pre><code>/* Traverse array */\nfunc traverse(nums: [Int]) {\n    var count = 0\n    // Traverse array by index\n    for i in nums.indices {\n        count += nums[i]\n    }\n    // Direct traversal of array elements\n    for num in nums {\n        count += num\n    }\n    // Traverse simultaneously data index and elements\n    for (i, num) in nums.enumerated() {\n        count += nums[i]\n        count += num\n    }\n}\n</code></pre> array.js<pre><code>/* Traverse array */\nfunction traverse(nums) {\n    let count = 0;\n    // Traverse array by index\n    for (let i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // Direct traversal of array elements\n    for (const num of nums) {\n        count += num;\n    }\n}\n</code></pre> array.ts<pre><code>/* Traverse array */\nfunction traverse(nums: number[]): void {\n    let count = 0;\n    // Traverse array by index\n    for (let i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // Direct traversal of array elements\n    for (const num of nums) {\n        count += num;\n    }\n}\n</code></pre> array.dart<pre><code>/* Traverse array elements */\nvoid traverse(List&lt;int&gt; nums) {\n  int count = 0;\n  // Traverse array by index\n  for (var i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n  }\n  // Direct traversal of array elements\n  for (int _num in nums) {\n    count += _num;\n  }\n  // Traverse array using forEach method\n  nums.forEach((_num) {\n    count += _num;\n  });\n}\n</code></pre> array.rs<pre><code>/* Traverse array */\nfn traverse(nums: &amp;[i32]) {\n    let mut _count = 0;\n    // Traverse array by index\n    for i in 0..nums.len() {\n        _count += nums[i];\n    }\n    // Direct traversal of array elements\n    _count = 0;\n    for &amp;num in nums {\n        _count += num;\n    }\n}\n</code></pre> array.c<pre><code>/* Traverse array */\nvoid traverse(int *nums, int size) {\n    int count = 0;\n    // Traverse array by index\n    for (int i = 0; i &lt; size; i++) {\n        count += nums[i];\n    }\n}\n</code></pre> array.kt<pre><code>/* Traverse array */\nfun traverse(nums: IntArray) {\n    var count = 0\n    // Traverse array by index\n    for (i in nums.indices) {\n        count += nums[i]\n    }\n    // Direct traversal of array elements\n    for (j in nums) {\n        count += j\n    }\n}\n</code></pre> array.rb<pre><code>### Traverse array ###\ndef traverse(nums)\n  count = 0\n\n  # Traverse array by index\n  for i in 0...nums.length\n    count += nums[i]\n  end\n\n  # Direct traversal of array elements\n  for num in nums\n    count += num\n  end\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#6-finding-elements","title":"6. \u00a0 Finding Elements","text":"<p>Finding a specified element in an array requires traversing the array and checking whether the element value matches in each iteration; if it matches, output the corresponding index.</p> <p>Since an array is a linear data structure, the above search operation is called a \"linear search\".</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array.py<pre><code>def find(nums: list[int], target: int) -&gt; int:\n    \"\"\"Find the specified element in the array\"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1\n</code></pre> array.cpp<pre><code>/* Find the specified element in the array */\nint find(int *nums, int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.java<pre><code>/* Find the specified element in the array */\nint find(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.cs<pre><code>/* Find the specified element in the array */\nint Find(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.Length; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.go<pre><code>/* Find the specified element in the array */\nfunc find(nums []int, target int) (index int) {\n    index = -1\n    for i := 0; i &lt; len(nums); i++ {\n        if nums[i] == target {\n            index = i\n            break\n        }\n    }\n    return\n}\n</code></pre> array.swift<pre><code>/* Find the specified element in the array */\nfunc find(nums: [Int], target: Int) -&gt; Int {\n    for i in nums.indices {\n        if nums[i] == target {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> array.js<pre><code>/* Find the specified element in the array */\nfunction find(nums, target) {\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (nums[i] === target) return i;\n    }\n    return -1;\n}\n</code></pre> array.ts<pre><code>/* Find the specified element in the array */\nfunction find(nums: number[], target: number): number {\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (nums[i] === target) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> array.dart<pre><code>/* Find the specified element in the array */\nint find(List&lt;int&gt; nums, int target) {\n  for (var i = 0; i &lt; nums.length; i++) {\n    if (nums[i] == target) return i;\n  }\n  return -1;\n}\n</code></pre> array.rs<pre><code>/* Find the specified element in the array */\nfn find(nums: &amp;[i32], target: i32) -&gt; Option&lt;usize&gt; {\n    for i in 0..nums.len() {\n        if nums[i] == target {\n            return Some(i);\n        }\n    }\n    None\n}\n</code></pre> array.c<pre><code>/* Find the specified element in the array */\nint find(int *nums, int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.kt<pre><code>/* Find the specified element in the array */\nfun find(nums: IntArray, target: Int): Int {\n    for (i in nums.indices) {\n        if (nums[i] == target)\n            return i\n    }\n    return -1\n}\n</code></pre> array.rb<pre><code>### Find specified element in array ###\ndef find(nums, target)\n  for i in 0...nums.length\n    return i if nums[i] == target\n  end\n\n  -1\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#7-expanding-arrays","title":"7. \u00a0 Expanding Arrays","text":"<p>In complex system environments, programs cannot guarantee that the memory space after an array is available, making it unsafe to expand the array's capacity. Therefore, in most programming languages, the length of an array is immutable.</p> <p>If we want to expand an array, we need to create a new, larger array and then copy the original array elements to the new array one by one. This is an \\(O(n)\\) operation, which is very time-consuming when the array is large. The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array.py<pre><code>def extend(nums: list[int], enlarge: int) -&gt; list[int]:\n    \"\"\"Extend array length\"\"\"\n    # Initialize an array with extended length\n    res = [0] * (len(nums) + enlarge)\n    # Copy all elements from the original array to the new array\n    for i in range(len(nums)):\n        res[i] = nums[i]\n    # Return the extended new array\n    return res\n</code></pre> array.cpp<pre><code>/* Extend array length */\nint *extend(int *nums, int size, int enlarge) {\n    // Initialize an array with extended length\n    int *res = new int[size + enlarge];\n    // Copy all elements from the original array to the new array\n    for (int i = 0; i &lt; size; i++) {\n        res[i] = nums[i];\n    }\n    // Free memory\n    delete[] nums;\n    // Return the extended new array\n    return res;\n}\n</code></pre> array.java<pre><code>/* Extend array length */\nint[] extend(int[] nums, int enlarge) {\n    // Initialize an array with extended length\n    int[] res = new int[nums.length + enlarge];\n    // Copy all elements from the original array to the new array\n    for (int i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // Return the extended new array\n    return res;\n}\n</code></pre> array.cs<pre><code>/* Extend array length */\nint[] Extend(int[] nums, int enlarge) {\n    // Initialize an array with extended length\n    int[] res = new int[nums.Length + enlarge];\n    // Copy all elements from the original array to the new array\n    for (int i = 0; i &lt; nums.Length; i++) {\n        res[i] = nums[i];\n    }\n    // Return the extended new array\n    return res;\n}\n</code></pre> array.go<pre><code>/* Extend array length */\nfunc extend(nums []int, enlarge int) []int {\n    // Initialize an array with extended length\n    res := make([]int, len(nums)+enlarge)\n    // Copy all elements from the original array to the new array\n    for i, num := range nums {\n        res[i] = num\n    }\n    // Return the extended new array\n    return res\n}\n</code></pre> array.swift<pre><code>/* Extend array length */\nfunc extend(nums: [Int], enlarge: Int) -&gt; [Int] {\n    // Initialize an array with extended length\n    var res = Array(repeating: 0, count: nums.count + enlarge)\n    // Copy all elements from the original array to the new array\n    for i in nums.indices {\n        res[i] = nums[i]\n    }\n    // Return the extended new array\n    return res\n}\n</code></pre> array.js<pre><code>/* Extend array length */\n// Note: JavaScript's Array is dynamic array, can be directly expanded\n// For learning purposes, this function treats Array as fixed-length array\nfunction extend(nums, enlarge) {\n    // Initialize an array with extended length\n    const res = new Array(nums.length + enlarge).fill(0);\n    // Copy all elements from the original array to the new array\n    for (let i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // Return the extended new array\n    return res;\n}\n</code></pre> array.ts<pre><code>/* Extend array length */\n// Note: TypeScript's Array is dynamic array, can be directly expanded\n// For learning purposes, this function treats Array as fixed-length array\nfunction extend(nums: number[], enlarge: number): number[] {\n    // Initialize an array with extended length\n    const res = new Array(nums.length + enlarge).fill(0);\n    // Copy all elements from the original array to the new array\n    for (let i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // Return the extended new array\n    return res;\n}\n</code></pre> array.dart<pre><code>/* Extend array length */\nList&lt;int&gt; extend(List&lt;int&gt; nums, int enlarge) {\n  // Initialize an array with extended length\n  List&lt;int&gt; res = List.filled(nums.length + enlarge, 0);\n  // Copy all elements from the original array to the new array\n  for (var i = 0; i &lt; nums.length; i++) {\n    res[i] = nums[i];\n  }\n  // Return the extended new array\n  return res;\n}\n</code></pre> array.rs<pre><code>/* Extend array length */\nfn extend(nums: &amp;[i32], enlarge: usize) -&gt; Vec&lt;i32&gt; {\n    // Initialize an array with extended length\n    let mut res: Vec&lt;i32&gt; = vec![0; nums.len() + enlarge];\n    // Copy all elements from original array to new\n    res[0..nums.len()].copy_from_slice(nums);\n\n    // Return the extended new array\n    res\n}\n</code></pre> array.c<pre><code>/* Extend array length */\nint *extend(int *nums, int size, int enlarge) {\n    // Initialize an array with extended length\n    int *res = (int *)malloc(sizeof(int) * (size + enlarge));\n    // Copy all elements from the original array to the new array\n    for (int i = 0; i &lt; size; i++) {\n        res[i] = nums[i];\n    }\n    // Initialize expanded space\n    for (int i = size; i &lt; size + enlarge; i++) {\n        res[i] = 0;\n    }\n    // Return the extended new array\n    return res;\n}\n</code></pre> array.kt<pre><code>/* Extend array length */\nfun extend(nums: IntArray, enlarge: Int): IntArray {\n    // Initialize an array with extended length\n    val res = IntArray(nums.size + enlarge)\n    // Copy all elements from the original array to the new array\n    for (i in nums.indices) {\n        res[i] = nums[i]\n    }\n    // Return the extended new array\n    return res\n}\n</code></pre> array.rb<pre><code>### Extend array length ###\n# Note: Ruby's Array is dynamic array, can be directly expanded\n# For learning purposes, this function treats Array as fixed-length array\ndef extend(nums, enlarge)\n  # Initialize an array with extended length\n  res = Array.new(nums.length + enlarge, 0)\n\n  # Copy all elements from the original array to the new array\n  for i in 0...nums.length\n    res[i] = nums[i]\n  end\n\n  # Return the extended new array\n  res\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#412-advantages-and-limitations-of-arrays","title":"4.1.2 \u00a0 Advantages and Limitations of Arrays","text":"<p>Arrays are stored in contiguous memory space with elements of the same type. This approach contains rich prior information that the system can use to optimize the efficiency of data structure operations.</p> <ul> <li>High space efficiency: Arrays allocate contiguous memory blocks for data without additional structural overhead.</li> <li>Support for random access: Arrays allow accessing any element in \\(O(1)\\) time.</li> <li>Cache locality: When accessing array elements, the computer not only loads the element but also caches the surrounding data, thereby leveraging the cache to improve the execution speed of subsequent operations.</li> </ul> <p>Contiguous space storage is a double-edged sword with the following limitations:</p> <ul> <li>Low insertion and deletion efficiency: When an array has many elements, insertion and deletion operations require shifting a large number of elements.</li> <li>Immutable length: After an array is initialized, its length is fixed. Expanding the array requires copying all data to a new array, which is very costly.</li> <li>Space waste: If the allocated size of an array exceeds what is actually needed, the extra space is wasted.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#413-typical-applications-of-arrays","title":"4.1.3 \u00a0 Typical Applications of Arrays","text":"<p>Arrays are a fundamental and common data structure, frequently used in various algorithms and for implementing various complex data structures.</p> <ul> <li>Random access: If we want to randomly sample some items, we can use an array to store them and generate a random sequence to implement random sampling based on indices.</li> <li>Sorting and searching: Arrays are the most commonly used data structure for sorting and searching algorithms. Quick sort, merge sort, binary search, and others are primarily performed on arrays.</li> <li>Lookup tables: When we need to quickly find an element or its corresponding relationship, we can use an array as a lookup table. For example, if we want to implement a mapping from characters to ASCII codes, we can use the ASCII code value of a character as an index, with the corresponding element stored at that position in the array.</li> <li>Machine learning: Neural networks make extensive use of linear algebra operations between vectors, matrices, and tensors, all of which are constructed in the form of arrays. Arrays are the most commonly used data structure in neural network programming.</li> <li>Data structure implementation: Arrays can be used to implement stacks, queues, hash tables, heaps, graphs, and other data structures. For example, the adjacency matrix representation of a graph is essentially a two-dimensional array.</li> </ul>"},{"location":"chapter_array_and_linkedlist/linked_list/","title":"4.2 \u00a0 Linked List","text":"<p>Memory space is a shared resource for all programs. In a complex system runtime environment, available memory space may be scattered throughout the memory. We know that the memory space for storing an array must be contiguous, and when the array is very large, the memory may not be able to provide such a large contiguous space. This is where the flexibility advantage of linked lists becomes apparent.</p> <p>A linked list is a linear data structure in which each element is a node object, and the nodes are connected through \"references\". A reference records the memory address of the next node, through which the next node can be accessed from the current node.</p> <p>The design of linked lists allows nodes to be stored scattered throughout the memory, and their memory addresses do not need to be contiguous.</p> <p></p> <p> Figure 4-5 \u00a0 Linked list definition and storage method </p> <p>Observing Figure 4-5, the basic unit of a linked list is a node object. Each node contains two pieces of data: the node's \"value\" and a \"reference\" to the next node.</p> <ul> <li>The first node of a linked list is called the \"head node\", and the last node is called the \"tail node\".</li> <li>The tail node points to \"null\", which is denoted as <code>null</code>, <code>nullptr</code>, and <code>None</code> in Java, C++, and Python, respectively.</li> <li>In languages that support pointers, such as C, C++, Go, and Rust, the aforementioned \"reference\" should be replaced with \"pointer\".</li> </ul> <p>As shown in the following code, a linked list node <code>ListNode</code> contains not only a value but also an additional reference (pointer). Therefore, linked lists occupy more memory space than arrays when storing the same amount of data.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>class ListNode:\n    \"\"\"Linked list node class\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val               # Node value\n        self.next: ListNode | None = None # Reference to the next node\n</code></pre> <pre><code>/* Linked list node structure */\nstruct ListNode {\n    int val;         // Node value\n    ListNode *next;  // Pointer to the next node\n    ListNode(int x) : val(x), next(nullptr) {}  // Constructor\n};\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the next node\n    ListNode(int x) { val = x; }  // Constructor\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode(int x) {  // Constructor\n    int val = x;         // Node value\n    ListNode? next;      // Reference to the next node\n}\n</code></pre> <pre><code>/* Linked list node structure */\ntype ListNode struct {\n    Val  int       // Node value\n    Next *ListNode // Pointer to the next node\n}\n\n// NewListNode Constructor, creates a new linked list\nfunc NewListNode(val int) *ListNode {\n    return &amp;ListNode{\n        Val:  val,\n        Next: nil,\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    var val: Int // Node value\n    var next: ListNode? // Reference to the next node\n\n    init(x: Int) { // Constructor\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    constructor(val, next) {\n        this.val = (val === undefined ? 0 : val);       // Node value\n        this.next = (next === undefined ? null : next); // Reference to the next node\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = val === undefined ? 0 : val;        // Node value\n        this.next = next === undefined ? null : next;  // Reference to the next node\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n  int val; // Node value\n  ListNode? next; // Reference to the next node\n  ListNode(this.val, [this.next]); // Constructor\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n/* Linked list node class */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Node value\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to the next node\n}\n</code></pre> <pre><code>/* Linked list node structure */\ntypedef struct ListNode {\n    int val;               // Node value\n    struct ListNode *next; // Pointer to the next node\n} ListNode;\n\n/* Constructor */\nListNode *newListNode(int val) {\n    ListNode *node;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* Linked list node class */\n// Constructor\nclass ListNode(x: Int) {\n    val _val: Int = x          // Node value\n    val next: ListNode? = null // Reference to the next node\n}\n</code></pre> <pre><code># Linked list node class\nclass ListNode\n  attr_accessor :val  # Node value\n  attr_accessor :next # Reference to the next node\n\n  def initialize(val=0, next_node=nil)\n    @val = val\n    @next = next_node\n  end\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#421-common-linked-list-operations","title":"4.2.1 \u00a0 Common Linked List Operations","text":""},{"location":"chapter_array_and_linkedlist/linked_list/#1-initializing-a-linked-list","title":"1. \u00a0 Initializing a Linked List","text":"<p>Building a linked list involves two steps: first, initializing each node object; second, constructing the reference relationships between nodes. Once initialization is complete, we can traverse all nodes starting from the head node of the linked list through the reference <code>next</code>.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linked_list.py<pre><code># Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4\n# Initialize each node\nn0 = ListNode(1)\nn1 = ListNode(3)\nn2 = ListNode(2)\nn3 = ListNode(5)\nn4 = ListNode(4)\n# Build references between nodes\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.cpp<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode* n0 = new ListNode(1);\nListNode* n1 = new ListNode(3);\nListNode* n2 = new ListNode(2);\nListNode* n3 = new ListNode(5);\nListNode* n4 = new ListNode(4);\n// Build references between nodes\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.java<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = new ListNode(1);\nListNode n1 = new ListNode(3);\nListNode n2 = new ListNode(2);\nListNode n3 = new ListNode(5);\nListNode n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.cs<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = new(1);\nListNode n1 = new(3);\nListNode n2 = new(2);\nListNode n3 = new(5);\nListNode n4 = new(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.go<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nn0 := NewListNode(1)\nn1 := NewListNode(3)\nn2 := NewListNode(2)\nn3 := NewListNode(5)\nn4 := NewListNode(4)\n// Build references between nodes\nn0.Next = n1\nn1.Next = n2\nn2.Next = n3\nn3.Next = n4\n</code></pre> linked_list.swift<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nlet n0 = ListNode(x: 1)\nlet n1 = ListNode(x: 3)\nlet n2 = ListNode(x: 2)\nlet n3 = ListNode(x: 5)\nlet n4 = ListNode(x: 4)\n// Build references between nodes\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.js<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.ts<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.dart<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\\\n// Initialize each node\nListNode n0 = ListNode(1);\nListNode n1 = ListNode(3);\nListNode n2 = ListNode(2);\nListNode n3 = ListNode(5);\nListNode n4 = ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.rs<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nlet n0 = Rc::new(RefCell::new(ListNode { val: 1, next: None }));\nlet n1 = Rc::new(RefCell::new(ListNode { val: 3, next: None }));\nlet n2 = Rc::new(RefCell::new(ListNode { val: 2, next: None }));\nlet n3 = Rc::new(RefCell::new(ListNode { val: 5, next: None }));\nlet n4 = Rc::new(RefCell::new(ListNode { val: 4, next: None }));\n\n// Build references between nodes\nn0.borrow_mut().next = Some(n1.clone());\nn1.borrow_mut().next = Some(n2.clone());\nn2.borrow_mut().next = Some(n3.clone());\nn3.borrow_mut().next = Some(n4.clone());\n</code></pre> linked_list.c<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode* n0 = newListNode(1);\nListNode* n1 = newListNode(3);\nListNode* n2 = newListNode(2);\nListNode* n3 = newListNode(5);\nListNode* n4 = newListNode(4);\n// Build references between nodes\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.kt<pre><code>/* Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nval n0 = ListNode(1)\nval n1 = ListNode(3)\nval n2 = ListNode(2)\nval n3 = ListNode(5)\nval n4 = ListNode(4)\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.rb<pre><code># Initialize linked list 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4\n# Initialize each node\nn0 = ListNode.new(1)\nn1 = ListNode.new(3)\nn2 = ListNode.new(2)\nn3 = ListNode.new(5)\nn4 = ListNode.new(4)\n# Build references between nodes\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>An array is a single variable; for example, an array <code>nums</code> contains elements <code>nums[0]</code>, <code>nums[1]</code>, etc. A linked list, however, is composed of multiple independent node objects. We typically use the head node as the reference to the linked list; for example, the linked list in the above code can be referred to as linked list <code>n0</code>.</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#2-inserting-a-node","title":"2. \u00a0 Inserting a Node","text":"<p>Inserting a node in a linked list is very easy. As shown in Figure 4-6, suppose we want to insert a new node <code>P</code> between two adjacent nodes <code>n0</code> and <code>n1</code>. We only need to change two node references (pointers), with a time complexity of \\(O(1)\\).</p> <p>In contrast, the time complexity of inserting an element in an array is \\(O(n)\\), which is inefficient when dealing with large amounts of data.</p> <p></p> <p> Figure 4-6 \u00a0 Example of inserting a node into a linked list </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linked_list.py<pre><code>def insert(n0: ListNode, P: ListNode):\n    \"\"\"Insert node P after node n0 in the linked list\"\"\"\n    n1 = n0.next\n    P.next = n1\n    n0.next = P\n</code></pre> linked_list.cpp<pre><code>/* Insert node P after node n0 in the linked list */\nvoid insert(ListNode *n0, ListNode *P) {\n    ListNode *n1 = n0-&gt;next;\n    P-&gt;next = n1;\n    n0-&gt;next = P;\n}\n</code></pre> linked_list.java<pre><code>/* Insert node P after node n0 in the linked list */\nvoid insert(ListNode n0, ListNode P) {\n    ListNode n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.cs<pre><code>/* Insert node P after node n0 in the linked list */\nvoid Insert(ListNode n0, ListNode P) {\n    ListNode? n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.go<pre><code>/* Insert node P after node n0 in the linked list */\nfunc insertNode(n0 *ListNode, P *ListNode) {\n    n1 := n0.Next\n    P.Next = n1\n    n0.Next = P\n}\n</code></pre> linked_list.swift<pre><code>/* Insert node P after node n0 in the linked list */\nfunc insert(n0: ListNode, P: ListNode) {\n    let n1 = n0.next\n    P.next = n1\n    n0.next = P\n}\n</code></pre> linked_list.js<pre><code>/* Insert node P after node n0 in the linked list */\nfunction insert(n0, P) {\n    const n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.ts<pre><code>/* Insert node P after node n0 in the linked list */\nfunction insert(n0: ListNode, P: ListNode): void {\n    const n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.dart<pre><code>/* Insert node P after node n0 in the linked list */\nvoid insert(ListNode n0, ListNode P) {\n  ListNode? n1 = n0.next;\n  P.next = n1;\n  n0.next = P;\n}\n</code></pre> linked_list.rs<pre><code>/* Insert node P after node n0 in the linked list */\n#[allow(non_snake_case)]\npub fn insert&lt;T&gt;(n0: &amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, P: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;) {\n    let n1 = n0.borrow_mut().next.take();\n    P.borrow_mut().next = n1;\n    n0.borrow_mut().next = Some(P);\n}\n</code></pre> linked_list.c<pre><code>/* Insert node P after node n0 in the linked list */\nvoid insert(ListNode *n0, ListNode *P) {\n    ListNode *n1 = n0-&gt;next;\n    P-&gt;next = n1;\n    n0-&gt;next = P;\n}\n</code></pre> linked_list.kt<pre><code>/* Insert node P after node n0 in the linked list */\nfun insert(n0: ListNode?, p: ListNode?) {\n    val n1 = n0?.next\n    p?.next = n1\n    n0?.next = p\n}\n</code></pre> linked_list.rb<pre><code>### Insert node _p after node n0 in linked list ###\n# Ruby's `p` is a built-in function, `P` is a constant, so use `_p` instead\ndef insert(n0, _p)\n  n1 = n0.next\n  _p.next = n1\n  n0.next = _p\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#3-removing-a-node","title":"3. \u00a0 Removing a Node","text":"<p>As shown in Figure 4-7, removing a node in a linked list is also very convenient. We only need to change one node's reference (pointer).</p> <p>Note that although node <code>P</code> still points to <code>n1</code> after the deletion operation is complete, the linked list can no longer access <code>P</code> when traversing, which means <code>P</code> no longer belongs to this linked list.</p> <p></p> <p> Figure 4-7 \u00a0 Removing a node from a linked list </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linked_list.py<pre><code>def remove(n0: ListNode):\n    \"\"\"Remove the first node after node n0 in the linked list\"\"\"\n    if not n0.next:\n        return\n    # n0 -&gt; P -&gt; n1\n    P = n0.next\n    n1 = P.next\n    n0.next = n1\n</code></pre> linked_list.cpp<pre><code>/* Remove the first node after node n0 in the linked list */\nvoid remove(ListNode *n0) {\n    if (n0-&gt;next == nullptr)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode *P = n0-&gt;next;\n    ListNode *n1 = P-&gt;next;\n    n0-&gt;next = n1;\n    // Free memory\n    delete P;\n}\n</code></pre> linked_list.java<pre><code>/* Remove the first node after node n0 in the linked list */\nvoid remove(ListNode n0) {\n    if (n0.next == null)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode P = n0.next;\n    ListNode n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.cs<pre><code>/* Remove the first node after node n0 in the linked list */\nvoid Remove(ListNode n0) {\n    if (n0.next == null)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode P = n0.next;\n    ListNode? n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.go<pre><code>/* Remove the first node after node n0 in the linked list */\nfunc removeItem(n0 *ListNode) {\n    if n0.Next == nil {\n        return\n    }\n    // n0 -&gt; P -&gt; n1\n    P := n0.Next\n    n1 := P.Next\n    n0.Next = n1\n}\n</code></pre> linked_list.swift<pre><code>/* Remove the first node after node n0 in the linked list */\nfunc remove(n0: ListNode) {\n    if n0.next == nil {\n        return\n    }\n    // n0 -&gt; P -&gt; n1\n    let P = n0.next\n    let n1 = P?.next\n    n0.next = n1\n}\n</code></pre> linked_list.js<pre><code>/* Remove the first node after node n0 in the linked list */\nfunction remove(n0) {\n    if (!n0.next) return;\n    // n0 -&gt; P -&gt; n1\n    const P = n0.next;\n    const n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.ts<pre><code>/* Remove the first node after node n0 in the linked list */\nfunction remove(n0: ListNode): void {\n    if (!n0.next) {\n        return;\n    }\n    // n0 -&gt; P -&gt; n1\n    const P = n0.next;\n    const n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.dart<pre><code>/* Remove the first node after node n0 in the linked list */\nvoid remove(ListNode n0) {\n  if (n0.next == null) return;\n  // n0 -&gt; P -&gt; n1\n  ListNode P = n0.next!;\n  ListNode? n1 = P.next;\n  n0.next = n1;\n}\n</code></pre> linked_list.rs<pre><code>/* Remove the first node after node n0 in the linked list */\n#[allow(non_snake_case)]\npub fn remove&lt;T&gt;(n0: &amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;) {\n    // n0 -&gt; P -&gt; n1\n    let P = n0.borrow_mut().next.take();\n    if let Some(node) = P {\n        let n1 = node.borrow_mut().next.take();\n        n0.borrow_mut().next = n1;\n    }\n}\n</code></pre> linked_list.c<pre><code>/* Remove the first node after node n0 in the linked list */\n// Note: stdio.h occupies the remove keyword\nvoid removeItem(ListNode *n0) {\n    if (!n0-&gt;next)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode *P = n0-&gt;next;\n    ListNode *n1 = P-&gt;next;\n    n0-&gt;next = n1;\n    // Free memory\n    free(P);\n}\n</code></pre> linked_list.kt<pre><code>/* Remove the first node after node n0 in the linked list */\nfun remove(n0: ListNode?) {\n    if (n0?.next == null)\n        return\n    // n0 -&gt; P -&gt; n1\n    val p = n0.next\n    val n1 = p?.next\n    n0.next = n1\n}\n</code></pre> linked_list.rb<pre><code>### Delete first node after node n0 in linked list ###\ndef remove(n0)\n  return if n0.next.nil?\n\n  # n0 -&gt; remove_node -&gt; n1\n  remove_node = n0.next\n  n1 = remove_node.next\n  n0.next = n1\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#4-accessing-a-node","title":"4. \u00a0 Accessing a Node","text":"<p>Accessing nodes in a linked list is less efficient. As mentioned in the previous section, we can access any element in an array in \\(O(1)\\) time. This is not the case with linked lists. The program needs to start from the head node and traverse backward one by one until the target node is found. That is, accessing the \\(i\\)-th node in a linked list requires \\(i - 1\\) iterations, with a time complexity of \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linked_list.py<pre><code>def access(head: ListNode, index: int) -&gt; ListNode | None:\n    \"\"\"Access the node at index index in the linked list\"\"\"\n    for _ in range(index):\n        if not head:\n            return None\n        head = head.next\n    return head\n</code></pre> linked_list.cpp<pre><code>/* Access the node at index index in the linked list */\nListNode *access(ListNode *head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == nullptr)\n            return nullptr;\n        head = head-&gt;next;\n    }\n    return head;\n}\n</code></pre> linked_list.java<pre><code>/* Access the node at index index in the linked list */\nListNode access(ListNode head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == null)\n            return null;\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.cs<pre><code>/* Access the node at index index in the linked list */\nListNode? Access(ListNode? head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == null)\n            return null;\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.go<pre><code>/* Access the node at index index in the linked list */\nfunc access(head *ListNode, index int) *ListNode {\n    for i := 0; i &lt; index; i++ {\n        if head == nil {\n            return nil\n        }\n        head = head.Next\n    }\n    return head\n}\n</code></pre> linked_list.swift<pre><code>/* Access the node at index index in the linked list */\nfunc access(head: ListNode, index: Int) -&gt; ListNode? {\n    var head: ListNode? = head\n    for _ in 0 ..&lt; index {\n        if head == nil {\n            return nil\n        }\n        head = head?.next\n    }\n    return head\n}\n</code></pre> linked_list.js<pre><code>/* Access the node at index index in the linked list */\nfunction access(head, index) {\n    for (let i = 0; i &lt; index; i++) {\n        if (!head) {\n            return null;\n        }\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.ts<pre><code>/* Access the node at index index in the linked list */\nfunction access(head: ListNode | null, index: number): ListNode | null {\n    for (let i = 0; i &lt; index; i++) {\n        if (!head) {\n            return null;\n        }\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.dart<pre><code>/* Access the node at index index in the linked list */\nListNode? access(ListNode? head, int index) {\n  for (var i = 0; i &lt; index; i++) {\n    if (head == null) return null;\n    head = head.next;\n  }\n  return head;\n}\n</code></pre> linked_list.rs<pre><code>/* Access the node at index index in the linked list */\npub fn access&lt;T&gt;(head: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, index: i32) -&gt; Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n    fn dfs&lt;T&gt;(\n        head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;,\n        index: i32,\n    ) -&gt; Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        if index &lt;= 0 {\n            return head.cloned();\n        }\n\n        if let Some(node) = head {\n            dfs(node.borrow().next.as_ref(), index - 1)\n        } else {\n            None\n        }\n    }\n\n    dfs(Some(head).as_ref(), index)\n}\n</code></pre> linked_list.c<pre><code>/* Access the node at index index in the linked list */\nListNode *access(ListNode *head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == NULL)\n            return NULL;\n        head = head-&gt;next;\n    }\n    return head;\n}\n</code></pre> linked_list.kt<pre><code>/* Access the node at index index in the linked list */\nfun access(head: ListNode?, index: Int): ListNode? {\n    var h = head\n    for (i in 0..&lt;index) {\n        if (h == null)\n            return null\n        h = h.next\n    }\n    return h\n}\n</code></pre> linked_list.rb<pre><code>### Access node at index in linked list ###\ndef access(head, index)\n  for i in 0...index\n    return nil if head.nil?\n    head = head.next\n  end\n\n  head\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#5-finding-a-node","title":"5. \u00a0 Finding a Node","text":"<p>Traverse the linked list to find a node with value <code>target</code>, and output the index of that node in the linked list. This process is also a linear search. The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linked_list.py<pre><code>def find(head: ListNode, target: int) -&gt; int:\n    \"\"\"Find the first node with value target in the linked list\"\"\"\n    index = 0\n    while head:\n        if head.val == target:\n            return index\n        head = head.next\n        index += 1\n    return -1\n</code></pre> linked_list.cpp<pre><code>/* Find the first node with value target in the linked list */\nint find(ListNode *head, int target) {\n    int index = 0;\n    while (head != nullptr) {\n        if (head-&gt;val == target)\n            return index;\n        head = head-&gt;next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.java<pre><code>/* Find the first node with value target in the linked list */\nint find(ListNode head, int target) {\n    int index = 0;\n    while (head != null) {\n        if (head.val == target)\n            return index;\n        head = head.next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.cs<pre><code>/* Find the first node with value target in the linked list */\nint Find(ListNode? head, int target) {\n    int index = 0;\n    while (head != null) {\n        if (head.val == target)\n            return index;\n        head = head.next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.go<pre><code>/* Find the first node with value target in the linked list */\nfunc findNode(head *ListNode, target int) int {\n    index := 0\n    for head != nil {\n        if head.Val == target {\n            return index\n        }\n        head = head.Next\n        index++\n    }\n    return -1\n}\n</code></pre> linked_list.swift<pre><code>/* Find the first node with value target in the linked list */\nfunc find(head: ListNode, target: Int) -&gt; Int {\n    var head: ListNode? = head\n    var index = 0\n    while head != nil {\n        if head?.val == target {\n            return index\n        }\n        head = head?.next\n        index += 1\n    }\n    return -1\n}\n</code></pre> linked_list.js<pre><code>/* Find the first node with value target in the linked list */\nfunction find(head, target) {\n    let index = 0;\n    while (head !== null) {\n        if (head.val === target) {\n            return index;\n        }\n        head = head.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre> linked_list.ts<pre><code>/* Find the first node with value target in the linked list */\nfunction find(head: ListNode | null, target: number): number {\n    let index = 0;\n    while (head !== null) {\n        if (head.val === target) {\n            return index;\n        }\n        head = head.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre> linked_list.dart<pre><code>/* Find the first node with value target in the linked list */\nint find(ListNode? head, int target) {\n  int index = 0;\n  while (head != null) {\n    if (head.val == target) {\n      return index;\n    }\n    head = head.next;\n    index++;\n  }\n  return -1;\n}\n</code></pre> linked_list.rs<pre><code>/* Find the first node with value target in the linked list */\npub fn find&lt;T: PartialEq&gt;(head: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, target: T) -&gt; i32 {\n    fn find&lt;T: PartialEq&gt;(head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, target: T, idx: i32) -&gt; i32 {\n        if let Some(node) = head {\n            if node.borrow().val == target {\n                return idx;\n            }\n            return find(node.borrow().next.as_ref(), target, idx + 1);\n        } else {\n            -1\n        }\n    }\n\n    find(Some(head).as_ref(), target, 0)\n}\n</code></pre> linked_list.c<pre><code>/* Find the first node with value target in the linked list */\nint find(ListNode *head, int target) {\n    int index = 0;\n    while (head) {\n        if (head-&gt;val == target)\n            return index;\n        head = head-&gt;next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.kt<pre><code>/* Find the first node with value target in the linked list */\nfun find(head: ListNode?, target: Int): Int {\n    var index = 0\n    var h = head\n    while (h != null) {\n        if (h._val == target)\n            return index\n        h = h.next\n        index++\n    }\n    return -1\n}\n</code></pre> linked_list.rb<pre><code>### Find first node with value target in linked list ###\ndef find(head, target)\n  index = 0\n  while head\n    return index if head.val == target\n    head = head.next\n    index += 1\n  end\n\n  -1\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#422-arrays-vs-linked-lists","title":"4.2.2 \u00a0 Arrays vs. Linked Lists","text":"<p>Table 4-1 summarizes the characteristics of arrays and linked lists and compares their operational efficiencies. Since they employ two opposite storage strategies, their various properties and operational efficiencies also exhibit contrasting characteristics.</p> <p> Table 4-1 \u00a0 Comparison of array and linked list efficiencies </p> Array Linked List Storage method Contiguous memory space Scattered memory space Capacity expansion Immutable length Flexible expansion Memory efficiency Elements occupy less memory, but space may be wasted Elements occupy more memory Accessing an element \\(O(1)\\) \\(O(n)\\) Adding an element \\(O(n)\\) \\(O(1)\\) Removing an element \\(O(n)\\) \\(O(1)\\)"},{"location":"chapter_array_and_linkedlist/linked_list/#423-common-types-of-linked-lists","title":"4.2.3 \u00a0 Common Types of Linked Lists","text":"<p>As shown in Figure 4-8, there are three common types of linked lists:</p> <ul> <li>Singly linked list: This is the ordinary linked list introduced earlier. The nodes of a singly linked list contain a value and a reference to the next node. We call the first node the head node and the last node the tail node, which points to null <code>None</code>.</li> <li>Circular linked list: If we make the tail node of a singly linked list point to the head node (connecting the tail to the head), we get a circular linked list. In a circular linked list, any node can be viewed as the head node.</li> <li>Doubly linked list: Compared to a singly linked list, a doubly linked list records references in both directions. The node definition of a doubly linked list includes references to both the successor node (next node) and the predecessor node (previous node). Compared to a singly linked list, a doubly linked list is more flexible and can traverse the linked list in both directions, but it also requires more memory space.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>class ListNode:\n    \"\"\"Doubly linked list node class\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                # Node value\n        self.next: ListNode | None = None  # Reference to the successor node\n        self.prev: ListNode | None = None  # Reference to the predecessor node\n</code></pre> <pre><code>/* Doubly linked list node structure */\nstruct ListNode {\n    int val;         // Node value\n    ListNode *next;  // Pointer to the successor node\n    ListNode *prev;  // Pointer to the predecessor node\n    ListNode(int x) : val(x), next(nullptr), prev(nullptr) {}  // Constructor\n};\n</code></pre> <pre><code>/* Doubly linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the successor node\n    ListNode prev;  // Reference to the predecessor node\n    ListNode(int x) { val = x; }  // Constructor\n}\n</code></pre> <pre><code>/* Doubly linked list node class */\nclass ListNode(int x) {  // Constructor\n    int val = x;    // Node value\n    ListNode next;  // Reference to the successor node\n    ListNode prev;  // Reference to the predecessor node\n}\n</code></pre> <pre><code>/* Doubly linked list node structure */\ntype DoublyListNode struct {\n    Val  int             // Node value\n    Next *DoublyListNode // Pointer to the successor node\n    Prev *DoublyListNode // Pointer to the predecessor node\n}\n\n// NewDoublyListNode Initialization\nfunc NewDoublyListNode(val int) *DoublyListNode {\n    return &amp;DoublyListNode{\n        Val:  val,\n        Next: nil,\n        Prev: nil,\n    }\n}\n</code></pre> <pre><code>/* Doubly linked list node class */\nclass ListNode {\n    var val: Int // Node value\n    var next: ListNode? // Reference to the successor node\n    var prev: ListNode? // Reference to the predecessor node\n\n    init(x: Int) { // Constructor\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Doubly linked list node class */\nclass ListNode {\n    constructor(val, next, prev) {\n        this.val = val  ===  undefined ? 0 : val;        // Node value\n        this.next = next  ===  undefined ? null : next;  // Reference to the successor node\n        this.prev = prev  ===  undefined ? null : prev;  // Reference to the predecessor node\n    }\n}\n</code></pre> <pre><code>/* Doubly linked list node class */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    prev: ListNode | null;\n    constructor(val?: number, next?: ListNode | null, prev?: ListNode | null) {\n        this.val = val  ===  undefined ? 0 : val;        // Node value\n        this.next = next  ===  undefined ? null : next;  // Reference to the successor node\n        this.prev = prev  ===  undefined ? null : prev;  // Reference to the predecessor node\n    }\n}\n</code></pre> <pre><code>/* Doubly linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode? next;  // Reference to the successor node\n    ListNode? prev;  // Reference to the predecessor node\n    ListNode(this.val, [this.next, this.prev]);  // Constructor\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Doubly linked list node type */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Node value\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to the successor node\n    prev: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to the predecessor node\n}\n\n/* Constructor */\nimpl ListNode {\n    fn new(val: i32) -&gt; Self {\n        ListNode {\n            val,\n            next: None,\n            prev: None,\n        }\n    }\n}\n</code></pre> <pre><code>/* Doubly linked list node structure */\ntypedef struct ListNode {\n    int val;               // Node value\n    struct ListNode *next; // Pointer to the successor node\n    struct ListNode *prev; // Pointer to the predecessor node\n} ListNode;\n\n/* Constructor */\nListNode *newListNode(int val) {\n    ListNode *node;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    node-&gt;prev = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* Doubly linked list node class */\n// Constructor\nclass ListNode(x: Int) {\n    val _val: Int = x           // Node value\n    val next: ListNode? = null  // Reference to the successor node\n    val prev: ListNode? = null  // Reference to the predecessor node\n}\n</code></pre> <pre><code># Doubly linked list node class\nclass ListNode\n  attr_accessor :val    # Node value\n  attr_accessor :next   # Reference to the successor node\n  attr_accessor :prev   # Reference to the predecessor node\n\n  def initialize(val=0, next_node=nil, prev_node=nil)\n    @val = val\n    @next = next_node\n    @prev = prev_node\n  end\nend\n</code></pre> <p></p> <p> Figure 4-8 \u00a0 Common types of linked lists </p>"},{"location":"chapter_array_and_linkedlist/linked_list/#424-typical-applications-of-linked-lists","title":"4.2.4 \u00a0 Typical Applications of Linked Lists","text":"<p>Singly linked lists are commonly used to implement stacks, queues, hash tables, and graphs.</p> <ul> <li>Stacks and queues: When insertion and deletion operations both occur at one end of the linked list, it exhibits last-in-first-out characteristics, corresponding to a stack. When insertion operations occur at one end of the linked list and deletion operations occur at the other end, it exhibits first-in-first-out characteristics, corresponding to a queue.</li> <li>Hash tables: Separate chaining is one of the mainstream solutions for resolving hash collisions. In this approach, all colliding elements are placed in a linked list.</li> <li>Graphs: An adjacency list is a common way to represent a graph, where each vertex in the graph is associated with a linked list, and each element in the linked list represents another vertex connected to that vertex.</li> </ul> <p>Doubly linked lists are commonly used in scenarios where quick access to the previous and next elements is needed.</p> <ul> <li>Advanced data structures: For example, in red-black trees and B-trees, we need to access the parent node of a node, which can be achieved by saving a reference to the parent node in the node, similar to a doubly linked list.</li> <li>Browser history: In web browsers, when a user clicks the forward or backward button, the browser needs to know the previous and next web pages the user visited. The characteristics of doubly linked lists make this operation simple.</li> <li>LRU algorithm: In cache eviction (LRU) algorithms, we need to quickly find the least recently used data and support quick addition and deletion of nodes. Using a doubly linked list is very suitable for this.</li> </ul> <p>Circular linked lists are commonly used in scenarios that require periodic operations, such as operating system resource scheduling.</p> <ul> <li>Round-robin scheduling algorithm: In operating systems, round-robin scheduling is a common CPU scheduling algorithm that needs to cycle through a set of processes. Each process is assigned a time slice, and when the time slice expires, the CPU switches to the next process. This cyclic operation can be implemented using a circular linked list.</li> <li>Data buffers: In some data buffer implementations, circular linked lists may also be used. For example, in audio and video players, the data stream may be divided into multiple buffer blocks and placed in a circular linked list to achieve seamless playback.</li> </ul>"},{"location":"chapter_array_and_linkedlist/list/","title":"4.3 \u00a0 List","text":"<p>A list is an abstract data structure concept that represents an ordered collection of elements, supporting operations such as element access, modification, insertion, deletion, and traversal, without requiring users to consider capacity limitations. Lists can be implemented based on linked lists or arrays.</p> <ul> <li>A linked list can naturally be viewed as a list, supporting element insertion, deletion, search, and modification operations, and can flexibly expand dynamically.</li> <li>An array also supports element insertion, deletion, search, and modification, but since its length is immutable, it can only be viewed as a list with length limitations.</li> </ul> <p>When implementing lists using arrays, the immutable length property reduces the practicality of the list. This is because we usually cannot determine in advance how much data we need to store, making it difficult to choose an appropriate list length. If the length is too small, it may fail to meet usage requirements; if the length is too large, it will waste memory space.</p> <p>To solve this problem, we can use a dynamic array to implement a list. It inherits all the advantages of arrays and can dynamically expand during program execution.</p> <p>In fact, the lists provided in the standard libraries of many programming languages are implemented based on dynamic arrays, such as <code>list</code> in Python, <code>ArrayList</code> in Java, <code>vector</code> in C++, and <code>List</code> in C#. In the following discussion, we will treat \"list\" and \"dynamic array\" as equivalent concepts.</p>"},{"location":"chapter_array_and_linkedlist/list/#431-common-list-operations","title":"4.3.1 \u00a0 Common List Operations","text":""},{"location":"chapter_array_and_linkedlist/list/#1-initialize-a-list","title":"1. \u00a0 Initialize a List","text":"<p>We typically use two initialization methods: \"without initial values\" and \"with initial values\":</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby list.py<pre><code># Initialize a list\n# Without initial values\nnums1: list[int] = []\n# With initial values\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> list.cpp<pre><code>/* Initialize a list */\n// Note that vector in C++ is equivalent to nums as described in this article\n// Without initial values\nvector&lt;int&gt; nums1;\n// With initial values\nvector&lt;int&gt; nums = { 1, 3, 2, 5, 4 };\n</code></pre> list.java<pre><code>/* Initialize a list */\n// Without initial values\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;();\n// With initial values (note that array elements should use the wrapper class Integer[] instead of int[])\nInteger[] numbers = new Integer[] { 1, 3, 2, 5, 4 };\nList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(Arrays.asList(numbers));\n</code></pre> list.cs<pre><code>/* Initialize a list */\n// Without initial values\nList&lt;int&gt; nums1 = [];\n// With initial values\nint[] numbers = [1, 3, 2, 5, 4];\nList&lt;int&gt; nums = [.. numbers];\n</code></pre> list_test.go<pre><code>/* Initialize a list */\n// Without initial values\nnums1 := []int{}\n// With initial values\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> list.swift<pre><code>/* Initialize a list */\n// Without initial values\nlet nums1: [Int] = []\n// With initial values\nvar nums = [1, 3, 2, 5, 4]\n</code></pre> list.js<pre><code>/* Initialize a list */\n// Without initial values\nconst nums1 = [];\n// With initial values\nconst nums = [1, 3, 2, 5, 4];\n</code></pre> list.ts<pre><code>/* Initialize a list */\n// Without initial values\nconst nums1: number[] = [];\n// With initial values\nconst nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> list.dart<pre><code>/* Initialize a list */\n// Without initial values\nList&lt;int&gt; nums1 = [];\n// With initial values\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> list.rs<pre><code>/* Initialize a list */\n// Without initial values\nlet nums1: Vec&lt;i32&gt; = Vec::new();\n// With initial values\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>/* Initialize a list */\n// Without initial values\nvar nums1 = listOf&lt;Int&gt;()\n// With initial values\nvar numbers = arrayOf(1, 3, 2, 5, 4)\nvar nums = numbers.toMutableList()\n</code></pre> list.rb<pre><code># Initialize a list\n# Without initial values\nnums1 = []\n# With initial values\nnums = [1, 3, 2, 5, 4]\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/list/#2-access-elements","title":"2. \u00a0 Access Elements","text":"<p>Since a list is essentially an array, we can access and update elements in \\(O(1)\\) time complexity, which is very efficient.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby list.py<pre><code># Access an element\nnum: int = nums[1]  # Access element at index 1\n\n# Update an element\nnums[1] = 0    # Update element at index 1 to 0\n</code></pre> list.cpp<pre><code>/* Access an element */\nint num = nums[1];  // Access element at index 1\n\n/* Update an element */\nnums[1] = 0;  // Update element at index 1 to 0\n</code></pre> list.java<pre><code>/* Access an element */\nint num = nums.get(1);  // Access element at index 1\n\n/* Update an element */\nnums.set(1, 0);  // Update element at index 1 to 0\n</code></pre> list.cs<pre><code>/* Access an element */\nint num = nums[1];  // Access element at index 1\n\n/* Update an element */\nnums[1] = 0;  // Update element at index 1 to 0\n</code></pre> list_test.go<pre><code>/* Access an element */\nnum := nums[1]  // Access element at index 1\n\n/* Update an element */\nnums[1] = 0     // Update element at index 1 to 0\n</code></pre> list.swift<pre><code>/* Access an element */\nlet num = nums[1] // Access element at index 1\n\n/* Update an element */\nnums[1] = 0 // Update element at index 1 to 0\n</code></pre> list.js<pre><code>/* Access an element */\nconst num = nums[1];  // Access element at index 1\n\n/* Update an element */\nnums[1] = 0;  // Update element at index 1 to 0\n</code></pre> list.ts<pre><code>/* Access an element */\nconst num: number = nums[1];  // Access element at index 1\n\n/* Update an element */\nnums[1] = 0;  // Update element at index 1 to 0\n</code></pre> list.dart<pre><code>/* Access an element */\nint num = nums[1];  // Access element at index 1\n\n/* Update an element */\nnums[1] = 0;  // Update element at index 1 to 0\n</code></pre> list.rs<pre><code>/* Access an element */\nlet num: i32 = nums[1];  // Access element at index 1\n/* Update an element */\nnums[1] = 0;             // Update element at index 1 to 0\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>/* Access an element */\nval num = nums[1]       // Access element at index 1\n/* Update an element */\nnums[1] = 0             // Update element at index 1 to 0\n</code></pre> list.rb<pre><code># Access an element\nnum = nums[1] # Access element at index 1\n# Update an element\nnums[1] = 0 # Update element at index 1 to 0\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/list/#3-insert-and-delete-elements","title":"3. \u00a0 Insert and Delete Elements","text":"<p>Compared to arrays, lists can freely add and delete elements. Adding an element at the end of a list has a time complexity of \\(O(1)\\), but inserting and deleting elements still have the same efficiency as arrays, with a time complexity of \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby list.py<pre><code># Clear the list\nnums.clear()\n\n# Add elements at the end\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n# Insert an element in the middle\nnums.insert(3, 6)  # Insert number 6 at index 3\n\n# Delete an element\nnums.pop(3)        # Delete element at index 3\n</code></pre> list.cpp<pre><code>/* Clear the list */\nnums.clear();\n\n/* Add elements at the end */\nnums.push_back(1);\nnums.push_back(3);\nnums.push_back(2);\nnums.push_back(5);\nnums.push_back(4);\n\n/* Insert an element in the middle */\nnums.insert(nums.begin() + 3, 6);  // Insert number 6 at index 3\n\n/* Delete an element */\nnums.erase(nums.begin() + 3);      // Delete element at index 3\n</code></pre> list.java<pre><code>/* Clear the list */\nnums.clear();\n\n/* Add elements at the end */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Insert an element in the middle */\nnums.add(3, 6);  // Insert number 6 at index 3\n\n/* Delete an element */\nnums.remove(3);  // Delete element at index 3\n</code></pre> list.cs<pre><code>/* Clear the list */\nnums.Clear();\n\n/* Add elements at the end */\nnums.Add(1);\nnums.Add(3);\nnums.Add(2);\nnums.Add(5);\nnums.Add(4);\n\n/* Insert an element in the middle */\nnums.Insert(3, 6);  // Insert number 6 at index 3\n\n/* Delete an element */\nnums.RemoveAt(3);  // Delete element at index 3\n</code></pre> list_test.go<pre><code>/* Clear the list */\nnums = nil\n\n/* Add elements at the end */\nnums = append(nums, 1)\nnums = append(nums, 3)\nnums = append(nums, 2)\nnums = append(nums, 5)\nnums = append(nums, 4)\n\n/* Insert an element in the middle */\nnums = append(nums[:3], append([]int{6}, nums[3:]...)...) // Insert number 6 at index 3\n\n/* Delete an element */\nnums = append(nums[:3], nums[4:]...) // Delete element at index 3\n</code></pre> list.swift<pre><code>/* Clear the list */\nnums.removeAll()\n\n/* Add elements at the end */\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n/* Insert an element in the middle */\nnums.insert(6, at: 3) // Insert number 6 at index 3\n\n/* Delete an element */\nnums.remove(at: 3) // Delete element at index 3\n</code></pre> list.js<pre><code>/* Clear the list */\nnums.length = 0;\n\n/* Add elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert an element in the middle */\nnums.splice(3, 0, 6); // Insert number 6 at index 3\n\n/* Delete an element */\nnums.splice(3, 1);  // Delete element at index 3\n</code></pre> list.ts<pre><code>/* Clear the list */\nnums.length = 0;\n\n/* Add elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert an element in the middle */\nnums.splice(3, 0, 6); // Insert number 6 at index 3\n\n/* Delete an element */\nnums.splice(3, 1);  // Delete element at index 3\n</code></pre> list.dart<pre><code>/* Clear the list */\nnums.clear();\n\n/* Add elements at the end */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Insert an element in the middle */\nnums.insert(3, 6); // Insert number 6 at index 3\n\n/* Delete an element */\nnums.removeAt(3); // Delete element at index 3\n</code></pre> list.rs<pre><code>/* Clear the list */\nnums.clear();\n\n/* Add elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert an element in the middle */\nnums.insert(3, 6);  // Insert number 6 at index 3\n\n/* Delete an element */\nnums.remove(3);    // Delete element at index 3\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>/* Clear the list */\nnums.clear();\n\n/* Add elements at the end */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Insert an element in the middle */\nnums.add(3, 6);  // Insert number 6 at index 3\n\n/* Delete an element */\nnums.remove(3);  // Delete element at index 3\n</code></pre> list.rb<pre><code># Clear the list\nnums.clear\n\n# Add elements at the end\nnums &lt;&lt; 1\nnums &lt;&lt; 3\nnums &lt;&lt; 2\nnums &lt;&lt; 5\nnums &lt;&lt; 4\n\n# Insert an element in the middle\nnums.insert(3, 6) # Insert number 6 at index 3\n\n# Delete an element\nnums.delete_at(3) # Delete element at index 3\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/list/#4-traverse-a-list","title":"4. \u00a0 Traverse a List","text":"<p>Like arrays, lists can be traversed by index or by directly iterating through elements.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby list.py<pre><code># Traverse the list by index\ncount = 0\nfor i in range(len(nums)):\n    count += nums[i]\n\n# Traverse list elements directly\nfor num in nums:\n    count += num\n</code></pre> list.cpp<pre><code>/* Traverse the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums[i];\n}\n\n/* Traverse list elements directly */\ncount = 0;\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.java<pre><code>/* Traverse the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums.get(i);\n}\n\n/* Traverse list elements directly */\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.cs<pre><code>/* Traverse the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.Count; i++) {\n    count += nums[i];\n}\n\n/* Traverse list elements directly */\ncount = 0;\nforeach (int num in nums) {\n    count += num;\n}\n</code></pre> list_test.go<pre><code>/* Traverse the list by index */\ncount := 0\nfor i := 0; i &lt; len(nums); i++ {\n    count += nums[i]\n}\n\n/* Traverse list elements directly */\ncount = 0\nfor _, num := range nums {\n    count += num\n}\n</code></pre> list.swift<pre><code>/* Traverse the list by index */\nvar count = 0\nfor i in nums.indices {\n    count += nums[i]\n}\n\n/* Traverse list elements directly */\ncount = 0\nfor num in nums {\n    count += num\n}\n</code></pre> list.js<pre><code>/* Traverse the list by index */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Traverse list elements directly */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.ts<pre><code>/* Traverse the list by index */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Traverse list elements directly */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.dart<pre><code>/* Traverse the list by index */\nint count = 0;\nfor (var i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Traverse list elements directly */\ncount = 0;\nfor (var num in nums) {\n    count += num;\n}\n</code></pre> list.rs<pre><code>// Traverse the list by index\nlet mut _count = 0;\nfor i in 0..nums.len() {\n    _count += nums[i];\n}\n\n// Traverse list elements directly\n_count = 0;\nfor num in &amp;nums {\n    _count += num;\n}\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>/* Traverse the list by index */\nvar count = 0\nfor (i in nums.indices) {\n    count += nums[i]\n}\n\n/* Traverse list elements directly */\nfor (num in nums) {\n    count += num\n}\n</code></pre> list.rb<pre><code># Traverse the list by index\ncount = 0\nfor i in 0...nums.length\n    count += nums[i]\nend\n\n# Traverse list elements directly\ncount = 0\nfor num in nums\n    count += num\nend\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/list/#5-concatenate-lists","title":"5. \u00a0 Concatenate Lists","text":"<p>Given a new list <code>nums1</code>, we can concatenate it to the end of the original list.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby list.py<pre><code># Concatenate two lists\nnums1: list[int] = [6, 8, 7, 10, 9]\nnums += nums1  # Concatenate list nums1 to the end of nums\n</code></pre> list.cpp<pre><code>/* Concatenate two lists */\nvector&lt;int&gt; nums1 = { 6, 8, 7, 10, 9 };\n// Concatenate list nums1 to the end of nums\nnums.insert(nums.end(), nums1.begin(), nums1.end());\n</code></pre> list.java<pre><code>/* Concatenate two lists */\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;(Arrays.asList(new Integer[] { 6, 8, 7, 10, 9 }));\nnums.addAll(nums1);  // Concatenate list nums1 to the end of nums\n</code></pre> list.cs<pre><code>/* Concatenate two lists */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.AddRange(nums1);  // Concatenate list nums1 to the end of nums\n</code></pre> list_test.go<pre><code>/* Concatenate two lists */\nnums1 := []int{6, 8, 7, 10, 9}\nnums = append(nums, nums1...)  // Concatenate list nums1 to the end of nums\n</code></pre> list.swift<pre><code>/* Concatenate two lists */\nlet nums1 = [6, 8, 7, 10, 9]\nnums.append(contentsOf: nums1) // Concatenate list nums1 to the end of nums\n</code></pre> list.js<pre><code>/* Concatenate two lists */\nconst nums1 = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // Concatenate list nums1 to the end of nums\n</code></pre> list.ts<pre><code>/* Concatenate two lists */\nconst nums1: number[] = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // Concatenate list nums1 to the end of nums\n</code></pre> list.dart<pre><code>/* Concatenate two lists */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.addAll(nums1);  // Concatenate list nums1 to the end of nums\n</code></pre> list.rs<pre><code>/* Concatenate two lists */\nlet nums1: Vec&lt;i32&gt; = vec![6, 8, 7, 10, 9];\nnums.extend(nums1);\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>/* Concatenate two lists */\nval nums1 = intArrayOf(6, 8, 7, 10, 9).toMutableList()\nnums.addAll(nums1)  // Concatenate list nums1 to the end of nums\n</code></pre> list.rb<pre><code># Concatenate two lists\nnums1 = [6, 8, 7, 10, 9]\nnums += nums1\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/list/#6-sort-a-list","title":"6. \u00a0 Sort a List","text":"<p>After sorting a list, we can use \"binary search\" and \"two-pointer\" algorithms, which are frequently tested in array algorithm problems.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby list.py<pre><code># Sort a list\nnums.sort()  # After sorting, list elements are arranged from smallest to largest\n</code></pre> list.cpp<pre><code>/* Sort a list */\nsort(nums.begin(), nums.end());  // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.java<pre><code>/* Sort a list */\nCollections.sort(nums);  // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.cs<pre><code>/* Sort a list */\nnums.Sort(); // After sorting, list elements are arranged from smallest to largest\n</code></pre> list_test.go<pre><code>/* Sort a list */\nsort.Ints(nums)  // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.swift<pre><code>/* Sort a list */\nnums.sort() // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.js<pre><code>/* Sort a list */\nnums.sort((a, b) =&gt; a - b);  // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.ts<pre><code>/* Sort a list */\nnums.sort((a, b) =&gt; a - b);  // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.dart<pre><code>/* Sort a list */\nnums.sort(); // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.rs<pre><code>/* Sort a list */\nnums.sort(); // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>/* Sort a list */\nnums.sort() // After sorting, list elements are arranged from smallest to largest\n</code></pre> list.rb<pre><code># Sort a list\nnums = nums.sort { |a, b| a &lt;=&gt; b } # After sorting, list elements are arranged from smallest to largest\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/list/#432-list-implementation","title":"4.3.2 \u00a0 List Implementation","text":"<p>Many programming languages have built-in lists, such as Java, C++, and Python. Their implementations are quite complex, and the parameters are carefully considered, such as initial capacity, expansion multiples, and so on. Interested readers can consult the source code to learn more.</p> <p>To deepen our understanding of how lists work, we attempt to implement a simple list with three key design considerations:</p> <ul> <li>Initial capacity: Select a reasonable initial capacity for the underlying array. In this example, we choose 10 as the initial capacity.</li> <li>Size tracking: Declare a variable <code>size</code> to record the current number of elements in the list and update it in real-time as elements are inserted and deleted. Based on this variable, we can locate the end of the list and determine whether expansion is needed.</li> <li>Expansion mechanism: When the list capacity is full upon inserting an element, we need to expand. We create a larger array based on the expansion multiple and then move all elements from the current array to the new array in order. In this example, we specify that the array should be expanded to 2 times its previous size each time.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby my_list.py<pre><code>class MyList:\n    \"\"\"List class\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self._capacity: int = 10  # List capacity\n        self._arr: list[int] = [0] * self._capacity  # Array (stores list elements)\n        self._size: int = 0  # List length (current number of elements)\n        self._extend_ratio: int = 2  # Multiple by which the list capacity is extended each time\n\n    def size(self) -&gt; int:\n        \"\"\"Get list length (current number of elements)\"\"\"\n        return self._size\n\n    def capacity(self) -&gt; int:\n        \"\"\"Get list capacity\"\"\"\n        return self._capacity\n\n    def get(self, index: int) -&gt; int:\n        \"\"\"Access element\"\"\"\n        # If the index is out of bounds, throw an exception, as below\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"Index out of bounds\")\n        return self._arr[index]\n\n    def set(self, num: int, index: int):\n        \"\"\"Update element\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"Index out of bounds\")\n        self._arr[index] = num\n\n    def add(self, num: int):\n        \"\"\"Add element at the end\"\"\"\n        # When the number of elements exceeds capacity, trigger the extension mechanism\n        if self.size() == self.capacity():\n            self.extend_capacity()\n        self._arr[self._size] = num\n        self._size += 1\n\n    def insert(self, num: int, index: int):\n        \"\"\"Insert element in the middle\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"Index out of bounds\")\n        # When the number of elements exceeds capacity, trigger the extension mechanism\n        if self._size == self.capacity():\n            self.extend_capacity()\n        # Move all elements at and after index index backward by one position\n        for j in range(self._size - 1, index - 1, -1):\n            self._arr[j + 1] = self._arr[j]\n        self._arr[index] = num\n        # Update the number of elements\n        self._size += 1\n\n    def remove(self, index: int) -&gt; int:\n        \"\"\"Remove element\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"Index out of bounds\")\n        num = self._arr[index]\n        # Move all elements after index index forward by one position\n        for j in range(index, self._size - 1):\n            self._arr[j] = self._arr[j + 1]\n        # Update the number of elements\n        self._size -= 1\n        # Return the removed element\n        return num\n\n    def extend_capacity(self):\n        \"\"\"Extend list capacity\"\"\"\n        # Create a new array with length _extend_ratio times the original array, and copy the original array to the new array\n        self._arr = self._arr + [0] * self.capacity() * (self._extend_ratio - 1)\n        # Update list capacity\n        self._capacity = len(self._arr)\n\n    def to_array(self) -&gt; list[int]:\n        \"\"\"Return list with valid length\"\"\"\n        return self._arr[: self._size]\n</code></pre> my_list.cpp<pre><code>/* List class */\nclass MyList {\n  private:\n    int *arr;             // Array (stores list elements)\n    int arrCapacity = 10; // List capacity\n    int arrSize = 0;      // List length (current number of elements)\n    int extendRatio = 2;   // Multiple by which the list capacity is extended each time\n\n  public:\n    /* Constructor */\n    MyList() {\n        arr = new int[arrCapacity];\n    }\n\n    /* Destructor */\n    ~MyList() {\n        delete[] arr;\n    }\n\n    /* Get list length (current number of elements)*/\n    int size() {\n        return arrSize;\n    }\n\n    /* Get list capacity */\n    int capacity() {\n        return arrCapacity;\n    }\n\n    /* Update element */\n    int get(int index) {\n        // If the index is out of bounds, throw an exception, as below\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"Index out of bounds\");\n        return arr[index];\n    }\n\n    /* Add elements at the end */\n    void set(int index, int num) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"Index out of bounds\");\n        arr[index] = num;\n    }\n\n    /* Direct traversal of list elements */\n    void add(int num) {\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (size() == capacity())\n            extendCapacity();\n        arr[size()] = num;\n        // Update the number of elements\n        arrSize++;\n    }\n\n    /* Sort list */\n    void insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"Index out of bounds\");\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (size() == capacity())\n            extendCapacity();\n        // Move all elements after index index forward by one position\n        for (int j = size() - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // Update the number of elements\n        arrSize++;\n    }\n\n    /* Remove element */\n    int remove(int index) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"Index out of bounds\");\n        int num = arr[index];\n        // Create a new array with length _extend_ratio times the original array, and copy the original array to the new array\n        for (int j = index; j &lt; size() - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // Update the number of elements\n        arrSize--;\n        // Return the removed element\n        return num;\n    }\n\n    /* Driver Code */\n    void extendCapacity() {\n        // Create a new array with length extendRatio times the original array\n        int newCapacity = capacity() * extendRatio;\n        int *tmp = arr;\n        arr = new int[newCapacity];\n        // Copy all elements from the original array to the new array\n        for (int i = 0; i &lt; size(); i++) {\n            arr[i] = tmp[i];\n        }\n        // Free memory\n        delete[] tmp;\n        arrCapacity = newCapacity;\n    }\n\n    /* Convert list to Vector for printing */\n    vector&lt;int&gt; toVector() {\n        // Elements enqueue\n        vector&lt;int&gt; vec(size());\n        for (int i = 0; i &lt; size(); i++) {\n            vec[i] = arr[i];\n        }\n        return vec;\n    }\n};\n</code></pre> my_list.java<pre><code>/* List class */\nclass MyList {\n    private int[] arr; // Array (stores list elements)\n    private int capacity = 10; // List capacity\n    private int size = 0; // List length (current number of elements)\n    private int extendRatio = 2; // Multiple by which the list capacity is extended each time\n\n    /* Constructor */\n    public MyList() {\n        arr = new int[capacity];\n    }\n\n    /* Get list length (current number of elements) */\n    public int size() {\n        return size;\n    }\n\n    /* Get list capacity */\n    public int capacity() {\n        return capacity;\n    }\n\n    /* Update element */\n    public int get(int index) {\n        // If the index is out of bounds, throw an exception, as below\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"Index out of bounds\");\n        return arr[index];\n    }\n\n    /* Add elements at the end */\n    public void set(int index, int num) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"Index out of bounds\");\n        arr[index] = num;\n    }\n\n    /* Direct traversal of list elements */\n    public void add(int num) {\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (size == capacity())\n            extendCapacity();\n        arr[size] = num;\n        // Update the number of elements\n        size++;\n    }\n\n    /* Sort list */\n    public void insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"Index out of bounds\");\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (size == capacity())\n            extendCapacity();\n        // Move all elements after index index forward by one position\n        for (int j = size - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // Update the number of elements\n        size++;\n    }\n\n    /* Remove element */\n    public int remove(int index) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"Index out of bounds\");\n        int num = arr[index];\n        // Move all elements after index forward by one position\n        for (int j = index; j &lt; size - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // Update the number of elements\n        size--;\n        // Return the removed element\n        return num;\n    }\n\n    /* Driver Code */\n    public void extendCapacity() {\n        // Create a new array with length extendRatio times the original array and copy the original array to the new array\n        arr = Arrays.copyOf(arr, capacity() * extendRatio);\n        // Add elements at the end\n        capacity = arr.length;\n    }\n\n    /* Convert list to array */\n    public int[] toArray() {\n        int size = size();\n        // Elements enqueue\n        int[] arr = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            arr[i] = get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.cs<pre><code>/* List class */\nclass MyList {\n    private int[] arr;           // Array (stores list elements)\n    private int arrCapacity = 10;    // List capacity\n    private int arrSize = 0;         // List length (current number of elements)\n    private readonly int extendRatio = 2;  // Multiple by which the list capacity is extended each time\n\n    /* Constructor */\n    public MyList() {\n        arr = new int[arrCapacity];\n    }\n\n    /* Get list length (current number of elements) */\n    public int Size() {\n        return arrSize;\n    }\n\n    /* Get list capacity */\n    public int Capacity() {\n        return arrCapacity;\n    }\n\n    /* Update element */\n    public int Get(int index) {\n        // If the index is out of bounds, throw an exception, as below\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"Index out of bounds\");\n        return arr[index];\n    }\n\n    /* Add elements at the end */\n    public void Set(int index, int num) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"Index out of bounds\");\n        arr[index] = num;\n    }\n\n    /* Direct traversal of list elements */\n    public void Add(int num) {\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (arrSize == arrCapacity)\n            ExtendCapacity();\n        arr[arrSize] = num;\n        // Update the number of elements\n        arrSize++;\n    }\n\n    /* Sort list */\n    public void Insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"Index out of bounds\");\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (arrSize == arrCapacity)\n            ExtendCapacity();\n        // Move all elements after index index forward by one position\n        for (int j = arrSize - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // Update the number of elements\n        arrSize++;\n    }\n\n    /* Remove element */\n    public int Remove(int index) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"Index out of bounds\");\n        int num = arr[index];\n        // Move all elements after index forward by one position\n        for (int j = index; j &lt; arrSize - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // Update the number of elements\n        arrSize--;\n        // Return the removed element\n        return num;\n    }\n\n    /* Driver Code */\n    public void ExtendCapacity() {\n        // Create new array of length arrCapacity * extendRatio and copy original array to new array\n        Array.Resize(ref arr, arrCapacity * extendRatio);\n        // Add elements at the end\n        arrCapacity = arr.Length;\n    }\n\n    /* Convert list to array */\n    public int[] ToArray() {\n        // Elements enqueue\n        int[] arr = new int[arrSize];\n        for (int i = 0; i &lt; arrSize; i++) {\n            arr[i] = Get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.go<pre><code>/* List class */\ntype myList struct {\n    arrCapacity int\n    arr         []int\n    arrSize     int\n    extendRatio int\n}\n\n/* Constructor */\nfunc newMyList() *myList {\n    return &amp;myList{\n        arrCapacity: 10,              // List capacity\n        arr:         make([]int, 10), // Array (stores list elements)\n        arrSize:     0,               // List length (current number of elements)\n        extendRatio: 2,               // Multiple by which the list capacity is extended each time\n    }\n}\n\n/* Get list length (current number of elements) */\nfunc (l *myList) size() int {\n    return l.arrSize\n}\n\n/* Get list capacity */\nfunc (l *myList) capacity() int {\n    return l.arrCapacity\n}\n\n/* Update element */\nfunc (l *myList) get(index int) int {\n    // If the index is out of bounds, throw an exception, as below\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"Index out of bounds\")\n    }\n    return l.arr[index]\n}\n\n/* Add elements at the end */\nfunc (l *myList) set(num, index int) {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"Index out of bounds\")\n    }\n    l.arr[index] = num\n}\n\n/* Direct traversal of list elements */\nfunc (l *myList) add(num int) {\n    // When the number of elements exceeds capacity, trigger the extension mechanism\n    if l.arrSize == l.arrCapacity {\n        l.extendCapacity()\n    }\n    l.arr[l.arrSize] = num\n    // Update the number of elements\n    l.arrSize++\n}\n\n/* Sort list */\nfunc (l *myList) insert(num, index int) {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"Index out of bounds\")\n    }\n    // When the number of elements exceeds capacity, trigger the extension mechanism\n    if l.arrSize == l.arrCapacity {\n        l.extendCapacity()\n    }\n    // Move all elements after index index forward by one position\n    for j := l.arrSize - 1; j &gt;= index; j-- {\n        l.arr[j+1] = l.arr[j]\n    }\n    l.arr[index] = num\n    // Update the number of elements\n    l.arrSize++\n}\n\n/* Remove element */\nfunc (l *myList) remove(index int) int {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"Index out of bounds\")\n    }\n    num := l.arr[index]\n    // Create a new array with length _extend_ratio times the original array, and copy the original array to the new array\n    for j := index; j &lt; l.arrSize-1; j++ {\n        l.arr[j] = l.arr[j+1]\n    }\n    // Update the number of elements\n    l.arrSize--\n    // Return the removed element\n    return num\n}\n\n/* Driver Code */\nfunc (l *myList) extendCapacity() {\n    // Create a new array with length extendRatio times the original array and copy the original array to the new array\n    l.arr = append(l.arr, make([]int, l.arrCapacity*(l.extendRatio-1))...)\n    // Add elements at the end\n    l.arrCapacity = len(l.arr)\n}\n\n/* Return list with valid length */\nfunc (l *myList) toArray() []int {\n    // Elements enqueue\n    return l.arr[:l.arrSize]\n}\n</code></pre> my_list.swift<pre><code>/* List class */\nclass MyList {\n    private var arr: [Int] // Array (stores list elements)\n    private var _capacity: Int // List capacity\n    private var _size: Int // List length (current number of elements)\n    private let extendRatio: Int // Multiple by which the list capacity is extended each time\n\n    /* Constructor */\n    init() {\n        _capacity = 10\n        _size = 0\n        extendRatio = 2\n        arr = Array(repeating: 0, count: _capacity)\n    }\n\n    /* Get list length (current number of elements) */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* Get list capacity */\n    func capacity() -&gt; Int {\n        _capacity\n    }\n\n    /* Update element */\n    func get(index: Int) -&gt; Int {\n        // Throw error if index out of bounds, same below\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"Index out of bounds\")\n        }\n        return arr[index]\n    }\n\n    /* Add elements at the end */\n    func set(index: Int, num: Int) {\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"Index out of bounds\")\n        }\n        arr[index] = num\n    }\n\n    /* Direct traversal of list elements */\n    func add(num: Int) {\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if size() == capacity() {\n            extendCapacity()\n        }\n        arr[size()] = num\n        // Update the number of elements\n        _size += 1\n    }\n\n    /* Sort list */\n    func insert(index: Int, num: Int) {\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"Index out of bounds\")\n        }\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if size() == capacity() {\n            extendCapacity()\n        }\n        // Move all elements after index index forward by one position\n        for j in (index ..&lt; size()).reversed() {\n            arr[j + 1] = arr[j]\n        }\n        arr[index] = num\n        // Update the number of elements\n        _size += 1\n    }\n\n    /* Remove element */\n    @discardableResult\n    func remove(index: Int) -&gt; Int {\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"Index out of bounds\")\n        }\n        let num = arr[index]\n        // Move all elements after index forward by one position\n        for j in index ..&lt; (size() - 1) {\n            arr[j] = arr[j + 1]\n        }\n        // Update the number of elements\n        _size -= 1\n        // Return the removed element\n        return num\n    }\n\n    /* Driver Code */\n    func extendCapacity() {\n        // Create a new array with length extendRatio times the original array and copy the original array to the new array\n        arr = arr + Array(repeating: 0, count: capacity() * (extendRatio - 1))\n        // Add elements at the end\n        _capacity = arr.count\n    }\n\n    /* Convert list to array */\n    func toArray() -&gt; [Int] {\n        Array(arr.prefix(size()))\n    }\n}\n</code></pre> my_list.js<pre><code>/* List class */\nclass MyList {\n    #arr = new Array(); // Array (stores list elements)\n    #capacity = 10; // List capacity\n    #size = 0; // List length (current number of elements)\n    #extendRatio = 2; // Multiple by which the list capacity is extended each time\n\n    /* Constructor */\n    constructor() {\n        this.#arr = new Array(this.#capacity);\n    }\n\n    /* Get list length (current number of elements) */\n    size() {\n        return this.#size;\n    }\n\n    /* Get list capacity */\n    capacity() {\n        return this.#capacity;\n    }\n\n    /* Update element */\n    get(index) {\n        // If the index is out of bounds, throw an exception, as below\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('Index out of bounds');\n        return this.#arr[index];\n    }\n\n    /* Add elements at the end */\n    set(index, num) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('Index out of bounds');\n        this.#arr[index] = num;\n    }\n\n    /* Direct traversal of list elements */\n    add(num) {\n        // If length equals capacity, need to expand\n        if (this.#size === this.#capacity) {\n            this.extendCapacity();\n        }\n        // Add new element to end of list\n        this.#arr[this.#size] = num;\n        this.#size++;\n    }\n\n    /* Sort list */\n    insert(index, num) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('Index out of bounds');\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (this.#size === this.#capacity) {\n            this.extendCapacity();\n        }\n        // Move all elements after index index forward by one position\n        for (let j = this.#size - 1; j &gt;= index; j--) {\n            this.#arr[j + 1] = this.#arr[j];\n        }\n        // Update the number of elements\n        this.#arr[index] = num;\n        this.#size++;\n    }\n\n    /* Remove element */\n    remove(index) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('Index out of bounds');\n        let num = this.#arr[index];\n        // Create a new array with length _extend_ratio times the original array, and copy the original array to the new array\n        for (let j = index; j &lt; this.#size - 1; j++) {\n            this.#arr[j] = this.#arr[j + 1];\n        }\n        // Update the number of elements\n        this.#size--;\n        // Return the removed element\n        return num;\n    }\n\n    /* Driver Code */\n    extendCapacity() {\n        // Create a new array with length extendRatio times the original array and copy the original array to the new array\n        this.#arr = this.#arr.concat(\n            new Array(this.capacity() * (this.#extendRatio - 1))\n        );\n        // Add elements at the end\n        this.#capacity = this.#arr.length;\n    }\n\n    /* Convert list to array */\n    toArray() {\n        let size = this.size();\n        // Elements enqueue\n        const arr = new Array(size);\n        for (let i = 0; i &lt; size; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.ts<pre><code>/* List class */\nclass MyList {\n    private arr: Array&lt;number&gt;; // Array (stores list elements)\n    private _capacity: number = 10; // List capacity\n    private _size: number = 0; // List length (current number of elements)\n    private extendRatio: number = 2; // Multiple by which the list capacity is extended each time\n\n    /* Constructor */\n    constructor() {\n        this.arr = new Array(this._capacity);\n    }\n\n    /* Get list length (current number of elements) */\n    public size(): number {\n        return this._size;\n    }\n\n    /* Get list capacity */\n    public capacity(): number {\n        return this._capacity;\n    }\n\n    /* Update element */\n    public get(index: number): number {\n        // If the index is out of bounds, throw an exception, as below\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('Index out of bounds');\n        return this.arr[index];\n    }\n\n    /* Add elements at the end */\n    public set(index: number, num: number): void {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('Index out of bounds');\n        this.arr[index] = num;\n    }\n\n    /* Direct traversal of list elements */\n    public add(num: number): void {\n        // If length equals capacity, need to expand\n        if (this._size === this._capacity) this.extendCapacity();\n        // Add new element to end of list\n        this.arr[this._size] = num;\n        this._size++;\n    }\n\n    /* Sort list */\n    public insert(index: number, num: number): void {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('Index out of bounds');\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (this._size === this._capacity) {\n            this.extendCapacity();\n        }\n        // Move all elements after index index forward by one position\n        for (let j = this._size - 1; j &gt;= index; j--) {\n            this.arr[j + 1] = this.arr[j];\n        }\n        // Update the number of elements\n        this.arr[index] = num;\n        this._size++;\n    }\n\n    /* Remove element */\n    public remove(index: number): number {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('Index out of bounds');\n        let num = this.arr[index];\n        // Move all elements after index forward by one position\n        for (let j = index; j &lt; this._size - 1; j++) {\n            this.arr[j] = this.arr[j + 1];\n        }\n        // Update the number of elements\n        this._size--;\n        // Return the removed element\n        return num;\n    }\n\n    /* Driver Code */\n    public extendCapacity(): void {\n        // Create new array of length size and copy original array to new array\n        this.arr = this.arr.concat(\n            new Array(this.capacity() * (this.extendRatio - 1))\n        );\n        // Add elements at the end\n        this._capacity = this.arr.length;\n    }\n\n    /* Convert list to array */\n    public toArray(): number[] {\n        let size = this.size();\n        // Elements enqueue\n        const arr = new Array(size);\n        for (let i = 0; i &lt; size; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.dart<pre><code>/* List class */\nclass MyList {\n  late List&lt;int&gt; _arr; // Array (stores list elements)\n  int _capacity = 10; // List capacity\n  int _size = 0; // List length (current number of elements)\n  int _extendRatio = 2; // Multiple by which the list capacity is extended each time\n\n  /* Constructor */\n  MyList() {\n    _arr = List.filled(_capacity, 0);\n  }\n\n  /* Get list length (current number of elements) */\n  int size() =&gt; _size;\n\n  /* Get list capacity */\n  int capacity() =&gt; _capacity;\n\n  /* Update element */\n  int get(int index) {\n    if (index &gt;= _size) throw RangeError('Index out of bounds');\n    return _arr[index];\n  }\n\n  /* Add elements at the end */\n  void set(int index, int _num) {\n    if (index &gt;= _size) throw RangeError('Index out of bounds');\n    _arr[index] = _num;\n  }\n\n  /* Direct traversal of list elements */\n  void add(int _num) {\n    // When the number of elements exceeds capacity, trigger the extension mechanism\n    if (_size == _capacity) extendCapacity();\n    _arr[_size] = _num;\n    // Update the number of elements\n    _size++;\n  }\n\n  /* Sort list */\n  void insert(int index, int _num) {\n    if (index &gt;= _size) throw RangeError('Index out of bounds');\n    // When the number of elements exceeds capacity, trigger the extension mechanism\n    if (_size == _capacity) extendCapacity();\n    // Move all elements after index index forward by one position\n    for (var j = _size - 1; j &gt;= index; j--) {\n      _arr[j + 1] = _arr[j];\n    }\n    _arr[index] = _num;\n    // Update the number of elements\n    _size++;\n  }\n\n  /* Remove element */\n  int remove(int index) {\n    if (index &gt;= _size) throw RangeError('Index out of bounds');\n    int _num = _arr[index];\n    // Move all elements after index forward by one position\n    for (var j = index; j &lt; _size - 1; j++) {\n      _arr[j] = _arr[j + 1];\n    }\n    // Update the number of elements\n    _size--;\n    // Return the removed element\n    return _num;\n  }\n\n  /* Driver Code */\n  void extendCapacity() {\n    // Create new array with length _extendRatio times original array\n    final _newNums = List.filled(_capacity * _extendRatio, 0);\n    // Copy original array to new array\n    List.copyRange(_newNums, 0, _arr);\n    // Update _arr reference\n    _arr = _newNums;\n    // Add elements at the end\n    _capacity = _arr.length;\n  }\n\n  /* Convert list to array */\n  List&lt;int&gt; toArray() {\n    List&lt;int&gt; arr = [];\n    for (var i = 0; i &lt; _size; i++) {\n      arr.add(get(i));\n    }\n    return arr;\n  }\n}\n</code></pre> my_list.rs<pre><code>/* List class */\n#[allow(dead_code)]\nstruct MyList {\n    arr: Vec&lt;i32&gt;,       // Array (stores list elements)\n    capacity: usize,     // List capacity\n    size: usize,         // List length (current number of elements)\n    extend_ratio: usize, // Multiple by which the list capacity is extended each time\n}\n\n#[allow(unused, unused_comparisons)]\nimpl MyList {\n    /* Constructor */\n    pub fn new(capacity: usize) -&gt; Self {\n        let mut vec = vec![0; capacity];\n        Self {\n            arr: vec,\n            capacity,\n            size: 0,\n            extend_ratio: 2,\n        }\n    }\n\n    /* Get list length (current number of elements) */\n    pub fn size(&amp;self) -&gt; usize {\n        return self.size;\n    }\n\n    /* Get list capacity */\n    pub fn capacity(&amp;self) -&gt; usize {\n        return self.capacity;\n    }\n\n    /* Update element */\n    pub fn get(&amp;self, index: usize) -&gt; i32 {\n        // If the index is out of bounds, throw an exception, as below\n        if index &gt;= self.size {\n            panic!(\"Index out of bounds\")\n        };\n        return self.arr[index];\n    }\n\n    /* Add elements at the end */\n    pub fn set(&amp;mut self, index: usize, num: i32) {\n        if index &gt;= self.size {\n            panic!(\"Index out of bounds\")\n        };\n        self.arr[index] = num;\n    }\n\n    /* Direct traversal of list elements */\n    pub fn add(&amp;mut self, num: i32) {\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if self.size == self.capacity() {\n            self.extend_capacity();\n        }\n        self.arr[self.size] = num;\n        // Update the number of elements\n        self.size += 1;\n    }\n\n    /* Sort list */\n    pub fn insert(&amp;mut self, index: usize, num: i32) {\n        if index &gt;= self.size() {\n            panic!(\"Index out of bounds\")\n        };\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if self.size == self.capacity() {\n            self.extend_capacity();\n        }\n        // Move all elements after index index forward by one position\n        for j in (index..self.size).rev() {\n            self.arr[j + 1] = self.arr[j];\n        }\n        self.arr[index] = num;\n        // Update the number of elements\n        self.size += 1;\n    }\n\n    /* Remove element */\n    pub fn remove(&amp;mut self, index: usize) -&gt; i32 {\n        if index &gt;= self.size() {\n            panic!(\"Index out of bounds\")\n        };\n        let num = self.arr[index];\n        // Create a new array with length _extend_ratio times the original array, and copy the original array to the new array\n        for j in index..self.size - 1 {\n            self.arr[j] = self.arr[j + 1];\n        }\n        // Update the number of elements\n        self.size -= 1;\n        // Return the removed element\n        return num;\n    }\n\n    /* Driver Code */\n    pub fn extend_capacity(&amp;mut self) {\n        // Create new array with length extend_ratio times original, copy original array to new array\n        let new_capacity = self.capacity * self.extend_ratio;\n        self.arr.resize(new_capacity, 0);\n        // Add elements at the end\n        self.capacity = new_capacity;\n    }\n\n    /* Convert list to array */\n    pub fn to_array(&amp;self) -&gt; Vec&lt;i32&gt; {\n        // Elements enqueue\n        let mut arr = Vec::new();\n        for i in 0..self.size {\n            arr.push(self.get(i));\n        }\n        arr\n    }\n}\n</code></pre> my_list.c<pre><code>/* List class */\ntypedef struct {\n    int *arr;        // Array (stores list elements)\n    int capacity;    // List capacity\n    int size;        // List size\n    int extendRatio; // List expansion multiplier\n} MyList;\n\n/* Constructor */\nMyList *newMyList() {\n    MyList *nums = malloc(sizeof(MyList));\n    nums-&gt;capacity = 10;\n    nums-&gt;arr = malloc(sizeof(int) * nums-&gt;capacity);\n    nums-&gt;size = 0;\n    nums-&gt;extendRatio = 2;\n    return nums;\n}\n\n/* Destructor */\nvoid delMyList(MyList *nums) {\n    free(nums-&gt;arr);\n    free(nums);\n}\n\n/* Get list length */\nint size(MyList *nums) {\n    return nums-&gt;size;\n}\n\n/* Get list capacity */\nint capacity(MyList *nums) {\n    return nums-&gt;capacity;\n}\n\n/* Update element */\nint get(MyList *nums, int index) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; nums-&gt;size);\n    return nums-&gt;arr[index];\n}\n\n/* Add elements at the end */\nvoid set(MyList *nums, int index, int num) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; nums-&gt;size);\n    nums-&gt;arr[index] = num;\n}\n\n/* Direct traversal of list elements */\nvoid add(MyList *nums, int num) {\n    if (size(nums) == capacity(nums)) {\n        extendCapacity(nums); // Expand capacity\n    }\n    nums-&gt;arr[size(nums)] = num;\n    nums-&gt;size++;\n}\n\n/* Sort list */\nvoid insert(MyList *nums, int index, int num) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; size(nums));\n    // When the number of elements exceeds capacity, trigger the extension mechanism\n    if (size(nums) == capacity(nums)) {\n        extendCapacity(nums); // Expand capacity\n    }\n    for (int i = size(nums); i &gt; index; --i) {\n        nums-&gt;arr[i] = nums-&gt;arr[i - 1];\n    }\n    nums-&gt;arr[index] = num;\n    nums-&gt;size++;\n}\n\n/* Remove element */\n// Note: stdio.h occupies the remove keyword\nint removeItem(MyList *nums, int index) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; size(nums));\n    int num = nums-&gt;arr[index];\n    for (int i = index; i &lt; size(nums) - 1; i++) {\n        nums-&gt;arr[i] = nums-&gt;arr[i + 1];\n    }\n    nums-&gt;size--;\n    return num;\n}\n\n/* Driver Code */\nvoid extendCapacity(MyList *nums) {\n    // Allocate space first\n    int newCapacity = capacity(nums) * nums-&gt;extendRatio;\n    int *extend = (int *)malloc(sizeof(int) * newCapacity);\n    int *temp = nums-&gt;arr;\n\n    // Copy old data to new data\n    for (int i = 0; i &lt; size(nums); i++)\n        extend[i] = nums-&gt;arr[i];\n\n    // Free old data\n    free(temp);\n\n    // Update new data\n    nums-&gt;arr = extend;\n    nums-&gt;capacity = newCapacity;\n}\n\n/* Convert list to Array for printing */\nint *toArray(MyList *nums) {\n    return nums-&gt;arr;\n}\n</code></pre> my_list.kt<pre><code>/* List class */\nclass MyList {\n    private var arr: IntArray = intArrayOf() // Array (stores list elements)\n    private var capacity: Int = 10 // List capacity\n    private var size: Int = 0 // List length (current number of elements)\n    private var extendRatio: Int = 2 // Multiple by which the list capacity is extended each time\n\n    /* Constructor */\n    init {\n        arr = IntArray(capacity)\n    }\n\n    /* Get list length (current number of elements) */\n    fun size(): Int {\n        return size\n    }\n\n    /* Get list capacity */\n    fun capacity(): Int {\n        return capacity\n    }\n\n    /* Update element */\n    fun get(index: Int): Int {\n        // If the index is out of bounds, throw an exception, as below\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"Index out of bounds\")\n        return arr[index]\n    }\n\n    /* Add elements at the end */\n    fun set(index: Int, num: Int) {\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"Index out of bounds\")\n        arr[index] = num\n    }\n\n    /* Direct traversal of list elements */\n    fun add(num: Int) {\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (size == capacity())\n            extendCapacity()\n        arr[size] = num\n        // Update the number of elements\n        size++\n    }\n\n    /* Sort list */\n    fun insert(index: Int, num: Int) {\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"Index out of bounds\")\n        // When the number of elements exceeds capacity, trigger the extension mechanism\n        if (size == capacity())\n            extendCapacity()\n        // Move all elements after index index forward by one position\n        for (j in size - 1 downTo index)\n            arr[j + 1] = arr[j]\n        arr[index] = num\n        // Update the number of elements\n        size++\n    }\n\n    /* Remove element */\n    fun remove(index: Int): Int {\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"Index out of bounds\")\n        val num = arr[index]\n        // Move all elements after index forward by one position\n        for (j in index..&lt;size - 1)\n            arr[j] = arr[j + 1]\n        // Update the number of elements\n        size--\n        // Return the removed element\n        return num\n    }\n\n    /* Driver Code */\n    fun extendCapacity() {\n        // Create a new array with length extendRatio times the original array and copy the original array to the new array\n        arr = arr.copyOf(capacity() * extendRatio)\n        // Add elements at the end\n        capacity = arr.size\n    }\n\n    /* Convert list to array */\n    fun toArray(): IntArray {\n        val size = size()\n        // Elements enqueue\n        val arr = IntArray(size)\n        for (i in 0..&lt;size) {\n            arr[i] = get(i)\n        }\n        return arr\n    }\n}\n</code></pre> my_list.rb<pre><code>### List class ###\nclass MyList\n  attr_reader :size       # Get list length (current number of elements)\n  attr_reader :capacity   # Get list capacity\n\n  ### Constructor ###\n  def initialize\n    @capacity = 10\n    @size = 0\n    @extend_ratio = 2\n    @arr = Array.new(capacity)\n  end\n\n  ### Access element ###\n  def get(index)\n    # If the index is out of bounds, throw an exception, as below\n    raise IndexError, \"Index out of bounds\" if index &lt; 0 || index &gt;= size\n    @arr[index]\n  end\n\n  ### Access element ###\n  def set(index, num)\n    raise IndexError, \"Index out of bounds\" if index &lt; 0 || index &gt;= size\n    @arr[index] = num\n  end\n\n  ### Add element at end ###\n  def add(num)\n    # When the number of elements exceeds capacity, trigger the extension mechanism\n    extend_capacity if size == capacity\n    @arr[size] = num\n\n    # Update the number of elements\n    @size += 1\n  end\n\n  ### Insert element in middle ###\n  def insert(index, num)\n    raise IndexError, \"Index out of bounds\" if index &lt; 0 || index &gt;= size\n\n    # When the number of elements exceeds capacity, trigger the extension mechanism\n    extend_capacity if size == capacity\n\n    # Move all elements after index index forward by one position\n    for j in (size - 1).downto(index)\n      @arr[j + 1] = @arr[j]\n    end\n    @arr[index] = num\n\n    # Update the number of elements\n    @size += 1\n  end\n\n  ### Delete element ###\n  def remove(index)\n    raise IndexError, \"Index out of bounds\" if index &lt; 0 || index &gt;= size\n    num = @arr[index]\n\n    # Move all elements after index forward by one position\n    for j in index...size\n      @arr[j] = @arr[j + 1]\n    end\n\n    # Update the number of elements\n    @size -= 1\n\n    # Return the removed element\n    num\n  end\n\n  ### Expand list capacity ###\n  def extend_capacity\n    # Create new array with length extend_ratio times original, copy original array to new array\n    arr = @arr.dup + Array.new(capacity * (@extend_ratio - 1))\n    # Add elements at the end\n    @capacity = arr.length\n  end\n\n  ### Convert list to array ###\n  def to_array\n    sz = size\n    # Elements enqueue\n    arr = Array.new(sz)\n    for i in 0...sz\n      arr[i] = get(i)\n    end\n    arr\n  end\nend\n</code></pre>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/","title":"4.4 \u00a0 Random-Access Memory and Cache *","text":"<p>In the first two sections of this chapter, we explored arrays and linked lists, two fundamental and important data structures that represent \"contiguous storage\" and \"distributed storage\" as two physical structures, respectively.</p> <p>In fact, physical structure largely determines the efficiency with which programs utilize memory and cache, which in turn affects the overall performance of algorithmic programs.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#441-computer-storage-devices","title":"4.4.1 \u00a0 Computer Storage Devices","text":"<p>Computers include three types of storage devices: hard disk, random-access memory (RAM), and cache memory. The following table shows their different roles and performance characteristics in a computer system.</p> <p> Table 4-2 \u00a0 Computer Storage Devices </p> Hard Disk RAM Cache Purpose Long-term storage of data, including operating systems, programs, and files Temporary storage of currently running programs and data being processed Storage of frequently accessed data and instructions to reduce CPU's accesses to memory Volatility Data is not lost after power-off Data is lost after power-off Data is lost after power-off Capacity Large, on the order of terabytes (TB) Small, on the order of gigabytes (GB) Very small, on the order of megabytes (MB) Speed Slow, hundreds to thousands of MB/s Fast, tens of GB/s Very fast, tens to hundreds of GB/s Cost (USD/GB) Inexpensive, fractions of a dollar to a few dollars per GB Expensive, tens to hundreds of dollars per GB Very expensive, priced as part of the CPU package <p>We can imagine the computer storage system as a pyramid structure as shown in the diagram below. Storage devices closer to the top of the pyramid are faster, have smaller capacity, and are more expensive. This multi-layered design is not by accident, but rather the result of careful consideration by computer scientists and engineers.</p> <ul> <li>Hard disk cannot be easily replaced by RAM. First, data in memory is lost after power-off, making it unsuitable for long-term data storage. Second, memory is tens of times more expensive than hard disk, which makes it difficult to popularize in the consumer market.</li> <li>Cache cannot simultaneously achieve large capacity and high speed. As the capacity of L1, L2, and L3 caches increases, their physical size becomes larger, and the physical distance between them and the CPU core increases, resulting in longer data transmission time and higher element access latency. With current technology, the multi-layered cache structure represents the best balance point between capacity, speed, and cost.</li> </ul> <p></p> <p> Figure 4-9 \u00a0 Computer Storage System </p> <p>Tip</p> <p>The storage hierarchy of computers embodies a delicate balance among speed, capacity, and cost. In fact, such trade-offs are common across all industrial fields, requiring us to find the optimal balance point between different advantages and constraints.</p> <p>In summary, hard disk is used for long-term storage of large amounts of data, RAM is used for temporary storage of data being processed during program execution, and cache is used for storage of frequently accessed data and instructions, to improve program execution efficiency. The three work together to ensure efficient operation of the computer system.</p> <p>As shown in the diagram below, during program execution, data is read from the hard disk into RAM for CPU computation. Cache can be viewed as part of the CPU, it intelligently loads data from RAM, providing the CPU with high-speed data reading, thereby significantly improving program execution efficiency and reducing reliance on slower RAM.</p> <p></p> <p> Figure 4-10 \u00a0 Data Flow Among Hard Disk, RAM, and Cache </p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#442-memory-efficiency-of-data-structures","title":"4.4.2 \u00a0 Memory Efficiency of Data Structures","text":"<p>In terms of memory space utilization, arrays and linked lists each have advantages and limitations.</p> <p>On one hand, memory is limited, and the same memory cannot be shared by multiple programs, so we hope data structures can utilize space as efficiently as possible. Array elements are tightly packed and do not require additional space to store references (pointers) between linked list nodes, thus having higher space efficiency. However, arrays need to allocate sufficient contiguous memory space at once, which may lead to memory waste, and array expansion requires additional time and space costs. In comparison, linked lists perform dynamic memory allocation and deallocation on a \"node\" basis, providing greater flexibility.</p> <p>On the other hand, during program execution, as memory is repeatedly allocated and freed, the degree of fragmentation of free memory becomes increasingly severe, leading to reduced memory utilization efficiency. Arrays, due to their contiguous storage approach, are relatively less prone to memory fragmentation. Conversely, linked list elements are distributed in storage, and frequent insertion and deletion operations are more likely to cause memory fragmentation.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#443-cache-efficiency-of-data-structures","title":"4.4.3 \u00a0 Cache Efficiency of Data Structures","text":"<p>Although cache has much smaller space capacity than memory, it is much faster than memory and plays a crucial role in program execution speed. Since cache capacity is limited and can only store a small portion of frequently accessed data, when the CPU attempts to access data that is not in the cache, a cache miss occurs, and the CPU must load the required data from the slower memory.</p> <p>Clearly, the fewer \"cache misses,\" the higher the efficiency of CPU data reads and writes, and the better the program performance. We call the proportion of data that the CPU successfully obtains from the cache the cache hit rate, a metric typically used to measure cache efficiency.</p> <p>To achieve the highest efficiency possible, cache employs the following data loading mechanisms.</p> <ul> <li>Cache lines: The cache does not store and load data on a byte-by-byte basis, but rather as cache lines. Compared to byte-by-byte transmission, cache line transmission is more efficient.</li> <li>Prefetching mechanism: The processor attempts to predict data access patterns (e.g., sequential access, fixed-stride jumping access, etc.) and loads data into the cache according to specific patterns, thereby improving hit rate.</li> <li>Spatial locality: If a piece of data is accessed, nearby data may also be accessed in the near future. Therefore, when the cache loads a particular piece of data, it also loads nearby data to improve hit rate.</li> <li>Temporal locality: If a piece of data is accessed, it is likely to be accessed again in the near future. Cache leverages this principle by retaining recently accessed data to improve hit rate.</li> </ul> <p>In fact, arrays and linked lists have different efficiencies in utilizing cache, manifested in the following aspects.</p> <ul> <li>Space occupied: Linked list elements occupy more space than array elements, resulting in fewer effective data in the cache.</li> <li>Cache lines: Linked list data are scattered throughout memory, while cache loads \"by lines,\" so the proportion of invalid data loaded is higher.</li> <li>Prefetching mechanism: Arrays have more \"predictable\" data access patterns than linked lists, making it easier for the system to guess which data will be loaded next.</li> <li>Spatial locality: Arrays are stored in centralized memory space, so data near loaded data is more likely to be accessed soon.</li> </ul> <p>Overall, arrays have higher cache hit rates, thus they usually outperform linked lists in operation efficiency. This makes data structures implemented based on arrays more popular when solving algorithmic problems.</p> <p>It is important to note that high cache efficiency does not mean arrays are superior to linked lists in all cases. In practical applications, which data structure to choose should be determined based on specific requirements. For example, both arrays and linked lists can implement the \"stack\" data structure (which will be discussed in detail in the next chapter), but they are suitable for different scenarios.</p> <ul> <li>When solving algorithm problems, we tend to prefer stack implementations based on arrays, because they provide higher operation efficiency and the ability of random access, at the cost of needing to pre-allocate a certain amount of memory space for the array.</li> <li>If the data volume is very large, the dynamic nature is high, and the expected size of the stack is difficult to estimate, then a stack implementation based on linked lists is more suitable. Linked lists can distribute large amounts of data across different parts of memory and avoid the additional overhead produced by array expansion.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/","title":"4.5 \u00a0 Summary","text":""},{"location":"chapter_array_and_linkedlist/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Arrays and linked lists are two fundamental data structures, representing two different ways data can be stored in computer memory: contiguous memory storage and scattered memory storage. The characteristics of the two complement each other.</li> <li>Arrays support random access and use less memory; however, inserting and deleting elements is inefficient, and the length is immutable after initialization.</li> <li>Linked lists achieve efficient insertion and deletion of nodes by modifying references (pointers), and can flexibly adjust length; however, node access is inefficient and memory consumption is higher. Common linked list types include singly linked lists, circular linked lists, and doubly linked lists.</li> <li>A list is an ordered collection of elements that supports insertion, deletion, search, and modification, typically implemented based on dynamic arrays. It retains the advantages of arrays while allowing flexible adjustment of length.</li> <li>The emergence of lists has greatly improved the practicality of arrays, but may result in some wasted memory space.</li> <li>During program execution, data is primarily stored in memory. Arrays provide higher memory space efficiency, while linked lists offer greater flexibility in memory usage.</li> <li>Caches provide fast data access to the CPU through mechanisms such as cache lines, prefetching, and spatial and temporal locality, significantly improving program execution efficiency.</li> <li>Because arrays have higher cache hit rates, they are generally more efficient than linked lists. When choosing a data structure, appropriate selection should be made based on specific requirements and scenarios.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Does storing an array on the stack versus on the heap affect time efficiency and space efficiency?</p> <p>Arrays stored on the stack and on the heap are both stored in contiguous memory space, so data operation efficiency is basically the same. However, the stack and heap have their own characteristics, leading to the following differences.</p> <ol> <li>Allocation and deallocation efficiency: The stack is a relatively small piece of memory, with allocation automatically handled by the compiler; the heap is relatively larger and can be dynamically allocated in code, more prone to fragmentation. Therefore, allocation and deallocation operations on the heap are usually slower than on the stack.</li> <li>Size limitations: Stack memory is relatively small, and the heap size is generally limited by available memory. Therefore, the heap is more suitable for storing large arrays.</li> <li>Flexibility: The size of an array on the stack must be determined at compile time, while the size of an array on the heap can be determined dynamically at runtime.</li> </ol> <p>Q: Why do arrays require elements of the same type, while linked lists do not emphasize this requirement?</p> <p>Linked lists are composed of nodes, with nodes connected through references (pointers), and each node can store different types of data, such as <code>int</code>, <code>double</code>, <code>string</code>, <code>object</code>, etc.</p> <p>In contrast, array elements must be of the same type, so that the corresponding element position can be obtained by calculating the offset. For example, if an array contains both <code>int</code> and <code>long</code> types, with individual elements occupying 4 bytes and 8 bytes respectively, then the following formula cannot be used to calculate the offset, because the array contains two different \"element lengths\".</p> <pre><code># Element Memory Address = Array Memory Address (first Element Memory address) + Element Length * Element Index\n</code></pre> <p>Q: After deleting node <code>P</code>, do we need to set <code>P.next</code> to <code>None</code>?</p> <p>It is not necessary to modify <code>P.next</code>. From the perspective of the linked list, traversing from the head node to the tail node will no longer encounter <code>P</code>. This means that node <code>P</code> has been removed from the linked list, and it doesn't matter where node <code>P</code> points to at this time\u2014it won't affect the linked list.</p> <p>From a data structures and algorithms perspective (problem-solving), not disconnecting the pointer doesn't matter as long as the program logic is correct. From the perspective of standard libraries, disconnecting is safer and the logic is clearer. If not disconnected, assuming the deleted node is not properly reclaimed, it may affect the memory reclamation of its successor nodes.</p> <p>Q: In a linked list, the time complexity of insertion and deletion operations is \\(O(1)\\). However, both insertion and deletion require \\(O(n)\\) time to find the element; why isn't the time complexity \\(O(n)\\)?</p> <p>If the element is first found and then deleted, the time complexity is indeed \\(O(n)\\). However, the advantage of \\(O(1)\\) insertion and deletion in linked lists can be demonstrated in other applications. For example, a deque is well-suited for linked list implementation, where we maintain pointer variables always pointing to the head and tail nodes, with each insertion and deletion operation being \\(O(1)\\).</p> <p>Q: In the diagram \"Linked List Definition and Storage Methods\", does the light blue pointer node occupy a single memory address, or does it share equally with the node value?</p> <p>This diagram is a qualitative representation; a quantitative representation requires analysis based on the specific situation.</p> <ul> <li>Different types of node values occupy different amounts of space, such as <code>int</code>, <code>long</code>, <code>double</code>, and instance objects, etc.</li> <li>The amount of memory space occupied by pointer variables depends on the operating system and compilation environment used, usually 8 bytes or 4 bytes.</li> </ul> <p>Q: Is appending an element at the end of a list always \\(O(1)\\)?</p> <p>If appending an element exceeds the list length, the list must first be expanded before adding. The system allocates a new block of memory and moves all elements from the original list to it, in which case the time complexity becomes \\(O(n)\\).</p> <p>Q: \"The emergence of lists has greatly improved the practicality of arrays, but may result in some wasted memory space\"\u2014does this space waste refer to the memory occupied by additional variables such as capacity, length, and expansion factor?</p> <p>This space waste mainly has two aspects: on one hand, lists typically set an initial length, which we may not need to fully utilize; on the other hand, to prevent frequent expansion, expansion generally multiplies by a coefficient, such as \\(\\times 1.5\\). As a result, there will be many empty positions that we typically cannot completely fill.</p> <p>Q: In Python, after initializing <code>n = [1, 2, 3]</code>, the addresses of these 3 elements are contiguous, but initializing <code>m = [2, 1, 3]</code> reveals that each element's id is not continuous; rather, they are the same as those in <code>n</code>. Since the addresses of these elements are not contiguous, is <code>m</code> still an array?</p> <p>If we replace list elements with linked list nodes <code>n = [n1, n2, n3, n4, n5]</code>, usually these 5 node objects are also scattered throughout memory. However, given a list index, we can still obtain the node memory address in \\(O(1)\\) time, thereby accessing the corresponding node. This is because the array stores references to nodes, not the nodes themselves.</p> <p>Unlike many languages, numbers in Python are wrapped as objects, and lists store not the numbers themselves, but references to the numbers. Therefore, we find that the same numbers in two arrays have the same id, and the memory addresses of these numbers need not be contiguous.</p> <p>Q: C++ STL has <code>std::list</code> which has already implemented a doubly linked list, but it seems that some algorithm books don't use it directly. Is there a limitation?</p> <p>On one hand, we often prefer to use arrays for implementing algorithms and only use linked lists when necessary, mainly for two reasons.</p> <ul> <li>Space overhead: Since each element requires two additional pointers (one for the previous element and one for the next element), <code>std::list</code> typically consumes more space than <code>std::vector</code>.</li> <li>Cache unfriendliness: Since data is not stored contiguously, <code>std::list</code> has lower cache utilization. In general, <code>std::vector</code> has better performance.</li> </ul> <p>On the other hand, cases where linked lists are necessary mainly involve binary trees and graphs. Stacks and queues usually use the <code>stack</code> and <code>queue</code> provided by the programming language, rather than linked lists.</p> <p>Q: Does the operation <code>res = [[0]] * n</code> create a 2D list where each <code>[0]</code> is independent?</p> <p>No, they are not independent. In this 2D list, all the <code>[0]</code> are actually references to the same object. If we modify one element, we will find that all corresponding elements change accordingly.</p> <p>If we want each <code>[0]</code> in the 2D list to be independent, we can use <code>res = [[0] for _ in range(n)]</code> to achieve this. The principle of this approach is to initialize \\(n\\) independent <code>[0]</code> list objects.</p> <p>Q: Does the operation <code>res = [0] * n</code> create a list where each integer 0 is independent?</p> <p>In this list, all integer 0s are references to the same object. This is because Python uses a caching mechanism for small integers (typically -5 to 256) to maximize object reuse and improve performance.</p> <p>Although they point to the same object, we can still independently modify each element in the list. This is because Python integers are \"immutable objects\". When we modify an element, we are actually switching to a reference of another object, rather than changing the original object itself.</p> <p>However, when list elements are \"mutable objects\" (such as lists, dictionaries, or class instances), modifying an element directly changes the object itself, and all elements referencing that object will have the same change.</p>"},{"location":"chapter_backtracking/","title":"Chapter 13. \u00a0 Backtracking","text":"<p>Abstract</p> <p>We are like explorers in a maze, and may encounter difficulties on the path forward.</p> <p>The power of backtracking allows us to start over, keep trying, and eventually find the exit leading to light.</p>"},{"location":"chapter_backtracking/#chapter-contents","title":"Chapter contents","text":"<ul> <li>13.1 \u00a0 Backtracking Algorithm</li> <li>13.2 \u00a0 Permutations Problem</li> <li>13.3 \u00a0 Subset-Sum Problem</li> <li>13.4 \u00a0 N-Queens Problem</li> <li>13.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_backtracking/backtracking_algorithm/","title":"13.1 \u00a0 Backtracking Algorithm","text":"<p>The backtracking algorithm is a method for solving problems through exhaustive search. Its core idea is to start from an initial state and exhaustively search all possible solutions. When a correct solution is found, it is recorded. This process continues until a solution is found or all possible choices have been tried without finding a solution.</p> <p>The backtracking algorithm typically employs \"depth-first search\" to traverse the solution space. In the \"Binary Tree\" chapter, we mentioned that preorder, inorder, and postorder traversals all belong to depth-first search. Next, we will construct a backtracking problem using preorder traversal to progressively understand how the backtracking algorithm works.</p> <p>Example 1</p> <p>Given a binary tree, search and record all nodes with value \\(7\\), and return a list of these nodes.</p> <p>For this problem, we perform a preorder traversal of the tree and check whether the current node's value is \\(7\\). If it is, we add the node to the result list <code>res</code>. The relevant implementation is shown in the following figure and code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby preorder_traversal_i_compact.py<pre><code>def pre_order(root: TreeNode):\n    \"\"\"Preorder traversal: Example 1\"\"\"\n    if root is None:\n        return\n    if root.val == 7:\n        # Record solution\n        res.append(root)\n    pre_order(root.left)\n    pre_order(root.right)\n</code></pre> preorder_traversal_i_compact.cpp<pre><code>/* Preorder traversal: Example 1 */\nvoid preOrder(TreeNode *root) {\n    if (root == nullptr) {\n        return;\n    }\n    if (root-&gt;val == 7) {\n        // Record solution\n        res.push_back(root);\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n}\n</code></pre> preorder_traversal_i_compact.java<pre><code>/* Preorder traversal: Example 1 */\nvoid preOrder(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    if (root.val == 7) {\n        // Record solution\n        res.add(root);\n    }\n    preOrder(root.left);\n    preOrder(root.right);\n}\n</code></pre> preorder_traversal_i_compact.cs<pre><code>/* Preorder traversal: Example 1 */\nvoid PreOrder(TreeNode? root) {\n    if (root == null) {\n        return;\n    }\n    if (root.val == 7) {\n        // Record solution\n        res.Add(root);\n    }\n    PreOrder(root.left);\n    PreOrder(root.right);\n}\n</code></pre> preorder_traversal_i_compact.go<pre><code>/* Preorder traversal: Example 1 */\nfunc preOrderI(root *TreeNode, res *[]*TreeNode) {\n    if root == nil {\n        return\n    }\n    if (root.Val).(int) == 7 {\n        // Record solution\n        *res = append(*res, root)\n    }\n    preOrderI(root.Left, res)\n    preOrderI(root.Right, res)\n}\n</code></pre> preorder_traversal_i_compact.swift<pre><code>/* Preorder traversal: Example 1 */\nfunc preOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    if root.val == 7 {\n        // Record solution\n        res.append(root)\n    }\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n}\n</code></pre> preorder_traversal_i_compact.js<pre><code>/* Preorder traversal: Example 1 */\nfunction preOrder(root, res) {\n    if (root === null) {\n        return;\n    }\n    if (root.val === 7) {\n        // Record solution\n        res.push(root);\n    }\n    preOrder(root.left, res);\n    preOrder(root.right, res);\n}\n</code></pre> preorder_traversal_i_compact.ts<pre><code>/* Preorder traversal: Example 1 */\nfunction preOrder(root: TreeNode | null, res: TreeNode[]): void {\n    if (root === null) {\n        return;\n    }\n    if (root.val === 7) {\n        // Record solution\n        res.push(root);\n    }\n    preOrder(root.left, res);\n    preOrder(root.right, res);\n}\n</code></pre> preorder_traversal_i_compact.dart<pre><code>/* Preorder traversal: Example 1 */\nvoid preOrder(TreeNode? root, List&lt;TreeNode&gt; res) {\n  if (root == null) {\n    return;\n  }\n  if (root.val == 7) {\n    // Record solution\n    res.add(root);\n  }\n  preOrder(root.left, res);\n  preOrder(root.right, res);\n}\n</code></pre> preorder_traversal_i_compact.rs<pre><code>/* Preorder traversal: Example 1 */\nfn pre_order(res: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) {\n    if root.is_none() {\n        return;\n    }\n    if let Some(node) = root {\n        if node.borrow().val == 7 {\n            // Record solution\n            res.push(node.clone());\n        }\n        pre_order(res, node.borrow().left.as_ref());\n        pre_order(res, node.borrow().right.as_ref());\n    }\n}\n</code></pre> preorder_traversal_i_compact.c<pre><code>/* Preorder traversal: Example 1 */\nvoid preOrder(TreeNode *root) {\n    if (root == NULL) {\n        return;\n    }\n    if (root-&gt;val == 7) {\n        // Record solution\n        res[resSize++] = root;\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n}\n</code></pre> preorder_traversal_i_compact.kt<pre><code>/* Preorder traversal: Example 1 */\nfun preOrder(root: TreeNode?) {\n    if (root == null) {\n        return\n    }\n    if (root._val == 7) {\n        // Record solution\n        res!!.add(root)\n    }\n    preOrder(root.left)\n    preOrder(root.right)\n}\n</code></pre> preorder_traversal_i_compact.rb<pre><code>### Pre-order traversal: example 1 ###\ndef pre_order(root)\n  return unless root\n\n  # Record solution\n  $res &lt;&lt; root if root.val == 7\n\n  pre_order(root.left)\n  pre_order(root.right)\nend\n</code></pre> <p></p> <p> Figure 13-1 \u00a0 Search for nodes in preorder traversal </p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1311-attempt-and-backtrack","title":"13.1.1 \u00a0 Attempt and Backtrack","text":"<p>The reason it is called a backtracking algorithm is that it employs \"attempt\" and \"backtrack\" strategies when searching the solution space. When the algorithm encounters a state where it cannot continue forward or cannot find a solution that satisfies the constraints, it will undo the previous choice, return to a previous state, and try other possible choices.</p> <p>For Example 1, visiting each node represents an \"attempt\", while skipping over a leaf node or a function <code>return</code> from the parent node represents a \"backtrack\".</p> <p>It is worth noting that backtracking is not limited to function returns alone. To illustrate this, let's extend Example 1 slightly.</p> <p>Example 2</p> <p>In a binary tree, search all nodes with value \\(7\\), and return the paths from the root node to these nodes.</p> <p>Based on the code from Example 1, we need to use a list <code>path</code> to record the visited node path. When we reach a node with value \\(7\\), we copy <code>path</code> and add it to the result list <code>res</code>. After traversal is complete, <code>res</code> contains all the solutions. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby preorder_traversal_ii_compact.py<pre><code>def pre_order(root: TreeNode):\n    \"\"\"Preorder traversal: Example 2\"\"\"\n    if root is None:\n        return\n    # Attempt\n    path.append(root)\n    if root.val == 7:\n        # Record solution\n        res.append(list(path))\n    pre_order(root.left)\n    pre_order(root.right)\n    # Backtrack\n    path.pop()\n</code></pre> preorder_traversal_ii_compact.cpp<pre><code>/* Preorder traversal: Example 2 */\nvoid preOrder(TreeNode *root) {\n    if (root == nullptr) {\n        return;\n    }\n    // Attempt\n    path.push_back(root);\n    if (root-&gt;val == 7) {\n        // Record solution\n        res.push_back(path);\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // Backtrack\n    path.pop_back();\n}\n</code></pre> preorder_traversal_ii_compact.java<pre><code>/* Preorder traversal: Example 2 */\nvoid preOrder(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    // Attempt\n    path.add(root);\n    if (root.val == 7) {\n        // Record solution\n        res.add(new ArrayList&lt;&gt;(path));\n    }\n    preOrder(root.left);\n    preOrder(root.right);\n    // Backtrack\n    path.remove(path.size() - 1);\n}\n</code></pre> preorder_traversal_ii_compact.cs<pre><code>/* Preorder traversal: Example 2 */\nvoid PreOrder(TreeNode? root) {\n    if (root == null) {\n        return;\n    }\n    // Attempt\n    path.Add(root);\n    if (root.val == 7) {\n        // Record solution\n        res.Add(new List&lt;TreeNode&gt;(path));\n    }\n    PreOrder(root.left);\n    PreOrder(root.right);\n    // Backtrack\n    path.RemoveAt(path.Count - 1);\n}\n</code></pre> preorder_traversal_ii_compact.go<pre><code>/* Preorder traversal: Example 2 */\nfunc preOrderII(root *TreeNode, res *[][]*TreeNode, path *[]*TreeNode) {\n    if root == nil {\n        return\n    }\n    // Attempt\n    *path = append(*path, root)\n    if root.Val.(int) == 7 {\n        // Record solution\n        *res = append(*res, append([]*TreeNode{}, *path...))\n    }\n    preOrderII(root.Left, res, path)\n    preOrderII(root.Right, res, path)\n    // Backtrack\n    *path = (*path)[:len(*path)-1]\n}\n</code></pre> preorder_traversal_ii_compact.swift<pre><code>/* Preorder traversal: Example 2 */\nfunc preOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // Attempt\n    path.append(root)\n    if root.val == 7 {\n        // Record solution\n        res.append(path)\n    }\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n    // Backtrack\n    path.removeLast()\n}\n</code></pre> preorder_traversal_ii_compact.js<pre><code>/* Preorder traversal: Example 2 */\nfunction preOrder(root, path, res) {\n    if (root === null) {\n        return;\n    }\n    // Attempt\n    path.push(root);\n    if (root.val === 7) {\n        // Record solution\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // Backtrack\n    path.pop();\n}\n</code></pre> preorder_traversal_ii_compact.ts<pre><code>/* Preorder traversal: Example 2 */\nfunction preOrder(\n    root: TreeNode | null,\n    path: TreeNode[],\n    res: TreeNode[][]\n): void {\n    if (root === null) {\n        return;\n    }\n    // Attempt\n    path.push(root);\n    if (root.val === 7) {\n        // Record solution\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // Backtrack\n    path.pop();\n}\n</code></pre> preorder_traversal_ii_compact.dart<pre><code>/* Preorder traversal: Example 2 */\nvoid preOrder(\n  TreeNode? root,\n  List&lt;TreeNode&gt; path,\n  List&lt;List&lt;TreeNode&gt;&gt; res,\n) {\n  if (root == null) {\n    return;\n  }\n\n  // Attempt\n  path.add(root);\n  if (root.val == 7) {\n    // Record solution\n    res.add(List.from(path));\n  }\n  preOrder(root.left, path, res);\n  preOrder(root.right, path, res);\n  // Backtrack\n  path.removeLast();\n}\n</code></pre> preorder_traversal_ii_compact.rs<pre><code>/* Preorder traversal: Example 2 */\nfn pre_order(\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n    path: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n) {\n    if root.is_none() {\n        return;\n    }\n    if let Some(node) = root {\n        // Attempt\n        path.push(node.clone());\n        if node.borrow().val == 7 {\n            // Record solution\n            res.push(path.clone());\n        }\n        pre_order(res, path, node.borrow().left.as_ref());\n        pre_order(res, path, node.borrow().right.as_ref());\n        // Backtrack\n        path.pop();\n    }\n}\n</code></pre> preorder_traversal_ii_compact.c<pre><code>/* Preorder traversal: Example 2 */\nvoid preOrder(TreeNode *root) {\n    if (root == NULL) {\n        return;\n    }\n    // Attempt\n    path[pathSize++] = root;\n    if (root-&gt;val == 7) {\n        // Record solution\n        for (int i = 0; i &lt; pathSize; ++i) {\n            res[resSize][i] = path[i];\n        }\n        resSize++;\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // Backtrack\n    pathSize--;\n}\n</code></pre> preorder_traversal_ii_compact.kt<pre><code>/* Preorder traversal: Example 2 */\nfun preOrder(root: TreeNode?) {\n    if (root == null) {\n        return\n    }\n    // Attempt\n    path!!.add(root)\n    if (root._val == 7) {\n        // Record solution\n        res!!.add(path!!.toMutableList())\n    }\n    preOrder(root.left)\n    preOrder(root.right)\n    // Backtrack\n    path!!.removeAt(path!!.size - 1)\n}\n</code></pre> preorder_traversal_ii_compact.rb<pre><code>### Pre-order traversal: example 2 ###\ndef pre_order(root)\n  return unless root\n\n  # Attempt\n  $path &lt;&lt; root\n\n  # Record solution\n  $res &lt;&lt; $path.dup if root.val == 7\n\n  pre_order(root.left)\n  pre_order(root.right)\n\n  # Backtrack\n  $path.pop\nend\n</code></pre> <p>In each \"attempt\", we record the path by adding the current node to <code>path</code>; before \"backtracking\", we need to remove the node from <code>path</code>, to restore the state before this attempt.</p> <p>Observing the process shown in the following figure, we can understand attempt and backtrack as \"advance\" and \"undo\", two operations that are the reverse of each other.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 13-2 \u00a0 Attempt and backtrack </p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1312-pruning","title":"13.1.2 \u00a0 Pruning","text":"<p>Complex backtracking problems usually contain one or more constraints. Constraints can typically be used for \"pruning\".</p> <p>Example 3</p> <p>In a binary tree, search all nodes with value \\(7\\) and return the paths from the root node to these nodes, but require that the paths do not contain nodes with value \\(3\\).</p> <p>To satisfy the above constraints, we need to add pruning operations: during the search process, if we encounter a node with value \\(3\\), we return early and do not continue searching. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby preorder_traversal_iii_compact.py<pre><code>def pre_order(root: TreeNode):\n    \"\"\"Preorder traversal: Example 3\"\"\"\n    # Pruning\n    if root is None or root.val == 3:\n        return\n    # Attempt\n    path.append(root)\n    if root.val == 7:\n        # Record solution\n        res.append(list(path))\n    pre_order(root.left)\n    pre_order(root.right)\n    # Backtrack\n    path.pop()\n</code></pre> preorder_traversal_iii_compact.cpp<pre><code>/* Preorder traversal: Example 3 */\nvoid preOrder(TreeNode *root) {\n    // Pruning\n    if (root == nullptr || root-&gt;val == 3) {\n        return;\n    }\n    // Attempt\n    path.push_back(root);\n    if (root-&gt;val == 7) {\n        // Record solution\n        res.push_back(path);\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // Backtrack\n    path.pop_back();\n}\n</code></pre> preorder_traversal_iii_compact.java<pre><code>/* Preorder traversal: Example 3 */\nvoid preOrder(TreeNode root) {\n    // Pruning\n    if (root == null || root.val == 3) {\n        return;\n    }\n    // Attempt\n    path.add(root);\n    if (root.val == 7) {\n        // Record solution\n        res.add(new ArrayList&lt;&gt;(path));\n    }\n    preOrder(root.left);\n    preOrder(root.right);\n    // Backtrack\n    path.remove(path.size() - 1);\n}\n</code></pre> preorder_traversal_iii_compact.cs<pre><code>/* Preorder traversal: Example 3 */\nvoid PreOrder(TreeNode? root) {\n    // Pruning\n    if (root == null || root.val == 3) {\n        return;\n    }\n    // Attempt\n    path.Add(root);\n    if (root.val == 7) {\n        // Record solution\n        res.Add(new List&lt;TreeNode&gt;(path));\n    }\n    PreOrder(root.left);\n    PreOrder(root.right);\n    // Backtrack\n    path.RemoveAt(path.Count - 1);\n}\n</code></pre> preorder_traversal_iii_compact.go<pre><code>/* Preorder traversal: Example 3 */\nfunc preOrderIII(root *TreeNode, res *[][]*TreeNode, path *[]*TreeNode) {\n    // Pruning\n    if root == nil || root.Val == 3 {\n        return\n    }\n    // Attempt\n    *path = append(*path, root)\n    if root.Val.(int) == 7 {\n        // Record solution\n        *res = append(*res, append([]*TreeNode{}, *path...))\n    }\n    preOrderIII(root.Left, res, path)\n    preOrderIII(root.Right, res, path)\n    // Backtrack\n    *path = (*path)[:len(*path)-1]\n}\n</code></pre> preorder_traversal_iii_compact.swift<pre><code>/* Preorder traversal: Example 3 */\nfunc preOrder(root: TreeNode?) {\n    // Pruning\n    guard let root = root, root.val != 3 else {\n        return\n    }\n    // Attempt\n    path.append(root)\n    if root.val == 7 {\n        // Record solution\n        res.append(path)\n    }\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n    // Backtrack\n    path.removeLast()\n}\n</code></pre> preorder_traversal_iii_compact.js<pre><code>/* Preorder traversal: Example 3 */\nfunction preOrder(root, path, res) {\n    // Pruning\n    if (root === null || root.val === 3) {\n        return;\n    }\n    // Attempt\n    path.push(root);\n    if (root.val === 7) {\n        // Record solution\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // Backtrack\n    path.pop();\n}\n</code></pre> preorder_traversal_iii_compact.ts<pre><code>/* Preorder traversal: Example 3 */\nfunction preOrder(\n    root: TreeNode | null,\n    path: TreeNode[],\n    res: TreeNode[][]\n): void {\n    // Pruning\n    if (root === null || root.val === 3) {\n        return;\n    }\n    // Attempt\n    path.push(root);\n    if (root.val === 7) {\n        // Record solution\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // Backtrack\n    path.pop();\n}\n</code></pre> preorder_traversal_iii_compact.dart<pre><code>/* Preorder traversal: Example 3 */\nvoid preOrder(\n  TreeNode? root,\n  List&lt;TreeNode&gt; path,\n  List&lt;List&lt;TreeNode&gt;&gt; res,\n) {\n  if (root == null || root.val == 3) {\n    return;\n  }\n\n  // Attempt\n  path.add(root);\n  if (root.val == 7) {\n    // Record solution\n    res.add(List.from(path));\n  }\n  preOrder(root.left, path, res);\n  preOrder(root.right, path, res);\n  // Backtrack\n  path.removeLast();\n}\n</code></pre> preorder_traversal_iii_compact.rs<pre><code>/* Preorder traversal: Example 3 */\nfn pre_order(\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n    path: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n) {\n    // Pruning\n    if root.is_none() || root.as_ref().unwrap().borrow().val == 3 {\n        return;\n    }\n    if let Some(node) = root {\n        // Attempt\n        path.push(node.clone());\n        if node.borrow().val == 7 {\n            // Record solution\n            res.push(path.clone());\n        }\n        pre_order(res, path, node.borrow().left.as_ref());\n        pre_order(res, path, node.borrow().right.as_ref());\n        // Backtrack\n        path.pop();\n    }\n}\n</code></pre> preorder_traversal_iii_compact.c<pre><code>/* Preorder traversal: Example 3 */\nvoid preOrder(TreeNode *root) {\n    // Pruning\n    if (root == NULL || root-&gt;val == 3) {\n        return;\n    }\n    // Attempt\n    path[pathSize++] = root;\n    if (root-&gt;val == 7) {\n        // Record solution\n        for (int i = 0; i &lt; pathSize; i++) {\n            res[resSize][i] = path[i];\n        }\n        resSize++;\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // Backtrack\n    pathSize--;\n}\n</code></pre> preorder_traversal_iii_compact.kt<pre><code>/* Preorder traversal: Example 3 */\nfun preOrder(root: TreeNode?) {\n    // Pruning\n    if (root == null || root._val == 3) {\n        return\n    }\n    // Attempt\n    path!!.add(root)\n    if (root._val == 7) {\n        // Record solution\n        res!!.add(path!!.toMutableList())\n    }\n    preOrder(root.left)\n    preOrder(root.right)\n    // Backtrack\n    path!!.removeAt(path!!.size - 1)\n}\n</code></pre> preorder_traversal_iii_compact.rb<pre><code>### Pre-order traversal: example 3 ###\ndef pre_order(root)\n  # Pruning\n  return if !root || root.val == 3\n\n  # Attempt\n  $path.append(root)\n\n  # Record solution\n  $res &lt;&lt; $path.dup if root.val == 7\n\n  pre_order(root.left)\n  pre_order(root.right)\n\n  # Backtrack\n  $path.pop\nend\n</code></pre> <p>\"Pruning\" is a vivid term. As shown in the following figure, during the search process, we \"prune\" search branches that do not satisfy the constraints, avoiding many meaningless attempts and thus improving search efficiency.</p> <p></p> <p> Figure 13-3 \u00a0 Pruning according to constraints </p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1313-framework-code","title":"13.1.3 \u00a0 Framework Code","text":"<p>Next, we attempt to extract the main framework of backtracking's \"attempt, backtrack, and pruning\", to improve code generality.</p> <p>In the following framework code, <code>state</code> represents the current state of the problem, and <code>choices</code> represents the choices available in the current state:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>def backtrack(state: State, choices: list[choice], res: list[state]):\n    \"\"\"Backtracking algorithm framework\"\"\"\n    # Check if it is a solution\n    if is_solution(state):\n        # Record the solution\n        record_solution(state, res)\n        # Stop searching\n        return\n    # Traverse all choices\n    for choice in choices:\n        # Pruning: check if the choice is valid\n        if is_valid(state, choice):\n            # Attempt: make a choice and update the state\n            make_choice(state, choice)\n            backtrack(state, choices, res)\n            # Backtrack: undo the choice and restore to the previous state\n            undo_choice(state, choice)\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State *state, vector&lt;Choice *&gt; &amp;choices, vector&lt;State *&gt; &amp;res) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Traverse all choices\n    for (Choice choice : choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make a choice and update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Traverse all choices\n    for (Choice choice : choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make a choice and update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid Backtrack(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res) {\n    // Check if it is a solution\n    if (IsSolution(state)) {\n        // Record the solution\n        RecordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Traverse all choices\n    foreach (Choice choice in choices) {\n        // Pruning: check if the choice is valid\n        if (IsValid(state, choice)) {\n            // Attempt: make a choice and update the state\n            MakeChoice(state, choice);\n            Backtrack(state, choices, res);\n            // Backtrack: undo the choice and restore to the previous state\n            UndoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunc backtrack(state *State, choices []Choice, res *[]State) {\n    // Check if it is a solution\n    if isSolution(state) {\n        // Record the solution\n        recordSolution(state, res)\n        // Stop searching\n        return\n    }\n    // Traverse all choices\n    for _, choice := range choices {\n        // Pruning: check if the choice is valid\n        if isValid(state, choice) {\n            // Attempt: make a choice and update the state\n            makeChoice(state, choice)\n            backtrack(state, choices, res)\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunc backtrack(state: inout State, choices: [Choice], res: inout [State]) {\n    // Check if it is a solution\n    if isSolution(state: state) {\n        // Record the solution\n        recordSolution(state: state, res: &amp;res)\n        // Stop searching\n        return\n    }\n    // Traverse all choices\n    for choice in choices {\n        // Pruning: check if the choice is valid\n        if isValid(state: state, choice: choice) {\n            // Attempt: make a choice and update the state\n            makeChoice(state: &amp;state, choice: choice)\n            backtrack(state: &amp;state, choices: choices, res: &amp;res)\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state: &amp;state, choice: choice)\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunction backtrack(state, choices, res) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Traverse all choices\n    for (let choice of choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make a choice and update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunction backtrack(state: State, choices: Choice[], res: State[]): void {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Traverse all choices\n    for (let choice of choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make a choice and update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State state, List&lt;Choice&gt;, List&lt;State&gt; res) {\n  // Check if it is a solution\n  if (isSolution(state)) {\n    // Record the solution\n    recordSolution(state, res);\n    // Stop searching\n    return;\n  }\n  // Traverse all choices\n  for (Choice choice in choices) {\n    // Pruning: check if the choice is valid\n    if (isValid(state, choice)) {\n      // Attempt: make a choice and update the state\n      makeChoice(state, choice);\n      backtrack(state, choices, res);\n      // Backtrack: undo the choice and restore to the previous state\n      undoChoice(state, choice);\n    }\n  }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfn backtrack(state: &amp;mut State, choices: &amp;Vec&lt;Choice&gt;, res: &amp;mut Vec&lt;State&gt;) {\n    // Check if it is a solution\n    if is_solution(state) {\n        // Record the solution\n        record_solution(state, res);\n        // Stop searching\n        return;\n    }\n    // Traverse all choices\n    for choice in choices {\n        // Pruning: check if the choice is valid\n        if is_valid(state, choice) {\n            // Attempt: make a choice and update the state\n            make_choice(state, choice);\n            backtrack(state, choices, res);\n            // Backtrack: undo the choice and restore to the previous state\n            undo_choice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State *state, Choice *choices, int numChoices, State *res, int numRes) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res, numRes);\n        // Stop searching\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; numChoices; i++) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, &amp;choices[i])) {\n            // Attempt: make a choice and update the state\n            makeChoice(state, &amp;choices[i]);\n            backtrack(state, choices, numChoices, res, numRes);\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state, &amp;choices[i]);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfun backtrack(state: State?, choices: List&lt;Choice?&gt;, res: List&lt;State?&gt;?) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res)\n        // Stop searching\n        return\n    }\n    // Traverse all choices\n    for (choice in choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make a choice and update the state\n            makeChoice(state, choice)\n            backtrack(state, choices, res)\n            // Backtrack: undo the choice and restore to the previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> <pre><code>### Backtracking algorithm framework ###\ndef backtrack(state, choices, res)\n    # Check if it is a solution\n    if is_solution?(state)\n        # Record the solution\n        record_solution(state, res)\n        return\n    end\n\n    # Traverse all choices\n    for choice in choices\n        # Pruning: check if the choice is valid\n        if is_valid?(state, choice)\n            # Attempt: make a choice and update the state\n            make_choice(state, choice)\n            backtrack(state, choices, res)\n            # Backtrack: undo the choice and restore to the previous state\n            undo_choice(state, choice)\n        end\n    end\nend\n</code></pre> <p>Next, we solve Example 3 based on the framework code. The state <code>state</code> is the node traversal path, the choices <code>choices</code> are the left and right child nodes of the current node, and the result <code>res</code> is a list of paths:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby preorder_traversal_iii_template.py<pre><code>def is_solution(state: list[TreeNode]) -&gt; bool:\n    \"\"\"Check if the current state is a solution\"\"\"\n    return state and state[-1].val == 7\n\ndef record_solution(state: list[TreeNode], res: list[list[TreeNode]]):\n    \"\"\"Record solution\"\"\"\n    res.append(list(state))\n\ndef is_valid(state: list[TreeNode], choice: TreeNode) -&gt; bool:\n    \"\"\"Check if the choice is valid under the current state\"\"\"\n    return choice is not None and choice.val != 3\n\ndef make_choice(state: list[TreeNode], choice: TreeNode):\n    \"\"\"Update state\"\"\"\n    state.append(choice)\n\ndef undo_choice(state: list[TreeNode], choice: TreeNode):\n    \"\"\"Restore state\"\"\"\n    state.pop()\n\ndef backtrack(\n    state: list[TreeNode], choices: list[TreeNode], res: list[list[TreeNode]]\n):\n    \"\"\"Backtracking algorithm: Example 3\"\"\"\n    # Check if it is a solution\n    if is_solution(state):\n        # Record solution\n        record_solution(state, res)\n    # Traverse all choices\n    for choice in choices:\n        # Pruning: check if the choice is valid\n        if is_valid(state, choice):\n            # Attempt: make choice, update state\n            make_choice(state, choice)\n            # Proceed to the next round of selection\n            backtrack(state, [choice.left, choice.right], res)\n            # Backtrack: undo choice, restore to previous state\n            undo_choice(state, choice)\n</code></pre> preorder_traversal_iii_template.cpp<pre><code>/* Check if the current state is a solution */\nbool isSolution(vector&lt;TreeNode *&gt; &amp;state) {\n    return !state.empty() &amp;&amp; state.back()-&gt;val == 7;\n}\n\n/* Record solution */\nvoid recordSolution(vector&lt;TreeNode *&gt; &amp;state, vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;res) {\n    res.push_back(state);\n}\n\n/* Check if the choice is valid under the current state */\nbool isValid(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice) {\n    return choice != nullptr &amp;&amp; choice-&gt;val != 3;\n}\n\n/* Update state */\nvoid makeChoice(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice) {\n    state.push_back(choice);\n}\n\n/* Restore state */\nvoid undoChoice(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice) {\n    state.pop_back();\n}\n\n/* Backtracking algorithm: Example 3 */\nvoid backtrack(vector&lt;TreeNode *&gt; &amp;state, vector&lt;TreeNode *&gt; &amp;choices, vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;res) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record solution\n        recordSolution(state, res);\n    }\n    // Traverse all choices\n    for (TreeNode *choice : choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make choice, update state\n            makeChoice(state, choice);\n            // Proceed to the next round of selection\n            vector&lt;TreeNode *&gt; nextChoices{choice-&gt;left, choice-&gt;right};\n            backtrack(state, nextChoices, res);\n            // Backtrack: undo choice, restore to previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.java<pre><code>/* Check if the current state is a solution */\nboolean isSolution(List&lt;TreeNode&gt; state) {\n    return !state.isEmpty() &amp;&amp; state.get(state.size() - 1).val == 7;\n}\n\n/* Record solution */\nvoid recordSolution(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    res.add(new ArrayList&lt;&gt;(state));\n}\n\n/* Check if the choice is valid under the current state */\nboolean isValid(List&lt;TreeNode&gt; state, TreeNode choice) {\n    return choice != null &amp;&amp; choice.val != 3;\n}\n\n/* Update state */\nvoid makeChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.add(choice);\n}\n\n/* Restore state */\nvoid undoChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.remove(state.size() - 1);\n}\n\n/* Backtracking algorithm: Example 3 */\nvoid backtrack(List&lt;TreeNode&gt; state, List&lt;TreeNode&gt; choices, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record solution\n        recordSolution(state, res);\n    }\n    // Traverse all choices\n    for (TreeNode choice : choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make choice, update state\n            makeChoice(state, choice);\n            // Proceed to the next round of selection\n            backtrack(state, Arrays.asList(choice.left, choice.right), res);\n            // Backtrack: undo choice, restore to previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.cs<pre><code>/* Check if the current state is a solution */\nbool IsSolution(List&lt;TreeNode&gt; state) {\n    return state.Count != 0 &amp;&amp; state[^1].val == 7;\n}\n\n/* Record solution */\nvoid RecordSolution(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    res.Add(new List&lt;TreeNode&gt;(state));\n}\n\n/* Check if the choice is valid under the current state */\nbool IsValid(List&lt;TreeNode&gt; state, TreeNode choice) {\n    return choice != null &amp;&amp; choice.val != 3;\n}\n\n/* Update state */\nvoid MakeChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.Add(choice);\n}\n\n/* Restore state */\nvoid UndoChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.RemoveAt(state.Count - 1);\n}\n\n/* Backtracking algorithm: Example 3 */\nvoid Backtrack(List&lt;TreeNode&gt; state, List&lt;TreeNode&gt; choices, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    // Check if it is a solution\n    if (IsSolution(state)) {\n        // Record solution\n        RecordSolution(state, res);\n    }\n    // Traverse all choices\n    foreach (TreeNode choice in choices) {\n        // Pruning: check if the choice is valid\n        if (IsValid(state, choice)) {\n            // Attempt: make choice, update state\n            MakeChoice(state, choice);\n            // Proceed to the next round of selection\n            Backtrack(state, [choice.left!, choice.right!], res);\n            // Backtrack: undo choice, restore to previous state\n            UndoChoice(state, choice);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.go<pre><code>/* Check if the current state is a solution */\nfunc isSolution(state *[]*TreeNode) bool {\n    return len(*state) != 0 &amp;&amp; (*state)[len(*state)-1].Val == 7\n}\n\n/* Record solution */\nfunc recordSolution(state *[]*TreeNode, res *[][]*TreeNode) {\n    *res = append(*res, append([]*TreeNode{}, *state...))\n}\n\n/* Check if the choice is valid under the current state */\nfunc isValid(state *[]*TreeNode, choice *TreeNode) bool {\n    return choice != nil &amp;&amp; choice.Val != 3\n}\n\n/* Update state */\nfunc makeChoice(state *[]*TreeNode, choice *TreeNode) {\n    *state = append(*state, choice)\n}\n\n/* Restore state */\nfunc undoChoice(state *[]*TreeNode, choice *TreeNode) {\n    *state = (*state)[:len(*state)-1]\n}\n\n/* Backtracking algorithm: Example 3 */\nfunc backtrackIII(state *[]*TreeNode, choices *[]*TreeNode, res *[][]*TreeNode) {\n    // Check if it is a solution\n    if isSolution(state) {\n        // Record solution\n        recordSolution(state, res)\n    }\n    // Traverse all choices\n    for _, choice := range *choices {\n        // Pruning: check if the choice is valid\n        if isValid(state, choice) {\n            // Attempt: make choice, update state\n            makeChoice(state, choice)\n            // Proceed to the next round of selection\n            temp := make([]*TreeNode, 0)\n            temp = append(temp, choice.Left, choice.Right)\n            backtrackIII(state, &amp;temp, res)\n            // Backtrack: undo choice, restore to previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.swift<pre><code>/* Check if the current state is a solution */\nfunc isSolution(state: [TreeNode]) -&gt; Bool {\n    !state.isEmpty &amp;&amp; state.last!.val == 7\n}\n\n/* Record solution */\nfunc recordSolution(state: [TreeNode], res: inout [[TreeNode]]) {\n    res.append(state)\n}\n\n/* Check if the choice is valid under the current state */\nfunc isValid(state: [TreeNode], choice: TreeNode?) -&gt; Bool {\n    choice != nil &amp;&amp; choice!.val != 3\n}\n\n/* Update state */\nfunc makeChoice(state: inout [TreeNode], choice: TreeNode) {\n    state.append(choice)\n}\n\n/* Restore state */\nfunc undoChoice(state: inout [TreeNode], choice: TreeNode) {\n    state.removeLast()\n}\n\n/* Backtracking algorithm: Example 3 */\nfunc backtrack(state: inout [TreeNode], choices: [TreeNode], res: inout [[TreeNode]]) {\n    // Check if it is a solution\n    if isSolution(state: state) {\n        recordSolution(state: state, res: &amp;res)\n    }\n    // Traverse all choices\n    for choice in choices {\n        // Pruning: check if the choice is valid\n        if isValid(state: state, choice: choice) {\n            // Attempt: make choice, update state\n            makeChoice(state: &amp;state, choice: choice)\n            // Proceed to the next round of selection\n            backtrack(state: &amp;state, choices: [choice.left, choice.right].compactMap { $0 }, res: &amp;res)\n            // Backtrack: undo choice, restore to previous state\n            undoChoice(state: &amp;state, choice: choice)\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.js<pre><code>/* Check if the current state is a solution */\nfunction isSolution(state) {\n    return state &amp;&amp; state[state.length - 1]?.val === 7;\n}\n\n/* Record solution */\nfunction recordSolution(state, res) {\n    res.push([...state]);\n}\n\n/* Check if the choice is valid under the current state */\nfunction isValid(state, choice) {\n    return choice !== null &amp;&amp; choice.val !== 3;\n}\n\n/* Update state */\nfunction makeChoice(state, choice) {\n    state.push(choice);\n}\n\n/* Restore state */\nfunction undoChoice(state) {\n    state.pop();\n}\n\n/* Backtracking algorithm: Example 3 */\nfunction backtrack(state, choices, res) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record solution\n        recordSolution(state, res);\n    }\n    // Traverse all choices\n    for (const choice of choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make choice, update state\n            makeChoice(state, choice);\n            // Proceed to the next round of selection\n            backtrack(state, [choice.left, choice.right], res);\n            // Backtrack: undo choice, restore to previous state\n            undoChoice(state);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.ts<pre><code>/* Check if the current state is a solution */\nfunction isSolution(state: TreeNode[]): boolean {\n    return state &amp;&amp; state[state.length - 1]?.val === 7;\n}\n\n/* Record solution */\nfunction recordSolution(state: TreeNode[], res: TreeNode[][]): void {\n    res.push([...state]);\n}\n\n/* Check if the choice is valid under the current state */\nfunction isValid(state: TreeNode[], choice: TreeNode): boolean {\n    return choice !== null &amp;&amp; choice.val !== 3;\n}\n\n/* Update state */\nfunction makeChoice(state: TreeNode[], choice: TreeNode): void {\n    state.push(choice);\n}\n\n/* Restore state */\nfunction undoChoice(state: TreeNode[]): void {\n    state.pop();\n}\n\n/* Backtracking algorithm: Example 3 */\nfunction backtrack(\n    state: TreeNode[],\n    choices: TreeNode[],\n    res: TreeNode[][]\n): void {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record solution\n        recordSolution(state, res);\n    }\n    // Traverse all choices\n    for (const choice of choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make choice, update state\n            makeChoice(state, choice);\n            // Proceed to the next round of selection\n            backtrack(state, [choice.left, choice.right], res);\n            // Backtrack: undo choice, restore to previous state\n            undoChoice(state);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.dart<pre><code>/* Check if the current state is a solution */\nbool isSolution(List&lt;TreeNode&gt; state) {\n  return state.isNotEmpty &amp;&amp; state.last.val == 7;\n}\n\n/* Record solution */\nvoid recordSolution(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res) {\n  res.add(List.from(state));\n}\n\n/* Check if the choice is valid under the current state */\nbool isValid(List&lt;TreeNode&gt; state, TreeNode? choice) {\n  return choice != null &amp;&amp; choice.val != 3;\n}\n\n/* Update state */\nvoid makeChoice(List&lt;TreeNode&gt; state, TreeNode? choice) {\n  state.add(choice!);\n}\n\n/* Restore state */\nvoid undoChoice(List&lt;TreeNode&gt; state, TreeNode? choice) {\n  state.removeLast();\n}\n\n/* Backtracking algorithm: Example 3 */\nvoid backtrack(\n  List&lt;TreeNode&gt; state,\n  List&lt;TreeNode?&gt; choices,\n  List&lt;List&lt;TreeNode&gt;&gt; res,\n) {\n  // Check if it is a solution\n  if (isSolution(state)) {\n    // Record solution\n    recordSolution(state, res);\n  }\n  // Traverse all choices\n  for (TreeNode? choice in choices) {\n    // Pruning: check if the choice is valid\n    if (isValid(state, choice)) {\n      // Attempt: make choice, update state\n      makeChoice(state, choice);\n      // Proceed to the next round of selection\n      backtrack(state, [choice!.left, choice.right], res);\n      // Backtrack: undo choice, restore to previous state\n      undoChoice(state, choice);\n    }\n  }\n}\n</code></pre> preorder_traversal_iii_template.rs<pre><code>/* Check if the current state is a solution */\nfn is_solution(state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {\n    return !state.is_empty() &amp;&amp; state.last().unwrap().borrow().val == 7;\n}\n\n/* Record solution */\nfn record_solution(\n    state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n) {\n    res.push(state.clone());\n}\n\n/* Check if the choice is valid under the current state */\nfn is_valid(_: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, choice: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {\n    return choice.is_some() &amp;&amp; choice.unwrap().borrow().val != 3;\n}\n\n/* Update state */\nfn make_choice(state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, choice: Rc&lt;RefCell&lt;TreeNode&gt;&gt;) {\n    state.push(choice);\n}\n\n/* Restore state */\nfn undo_choice(state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, _: Rc&lt;RefCell&lt;TreeNode&gt;&gt;) {\n    state.pop();\n}\n\n/* Backtracking algorithm: Example 3 */\nfn backtrack(\n    state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    choices: &amp;Vec&lt;Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n) {\n    // Check if it is a solution\n    if is_solution(state) {\n        // Record solution\n        record_solution(state, res);\n    }\n    // Traverse all choices\n    for &amp;choice in choices.iter() {\n        // Pruning: check if the choice is valid\n        if is_valid(state, choice) {\n            // Attempt: make choice, update state\n            make_choice(state, choice.unwrap().clone());\n            // Proceed to the next round of selection\n            backtrack(\n                state,\n                &amp;vec![\n                    choice.unwrap().borrow().left.as_ref(),\n                    choice.unwrap().borrow().right.as_ref(),\n                ],\n                res,\n            );\n            // Backtrack: undo choice, restore to previous state\n            undo_choice(state, choice.unwrap().clone());\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.c<pre><code>/* Check if the current state is a solution */\nbool isSolution(void) {\n    return pathSize &gt; 0 &amp;&amp; path[pathSize - 1]-&gt;val == 7;\n}\n\n/* Record solution */\nvoid recordSolution(void) {\n    for (int i = 0; i &lt; pathSize; i++) {\n        res[resSize][i] = path[i];\n    }\n    resSize++;\n}\n\n/* Check if the choice is valid under the current state */\nbool isValid(TreeNode *choice) {\n    return choice != NULL &amp;&amp; choice-&gt;val != 3;\n}\n\n/* Update state */\nvoid makeChoice(TreeNode *choice) {\n    path[pathSize++] = choice;\n}\n\n/* Restore state */\nvoid undoChoice(void) {\n    pathSize--;\n}\n\n/* Backtracking algorithm: Example 3 */\nvoid backtrack(TreeNode *choices[2]) {\n    // Check if it is a solution\n    if (isSolution()) {\n        // Record solution\n        recordSolution();\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; 2; i++) {\n        TreeNode *choice = choices[i];\n        // Pruning: check if the choice is valid\n        if (isValid(choice)) {\n            // Attempt: make choice, update state\n            makeChoice(choice);\n            // Proceed to the next round of selection\n            TreeNode *nextChoices[2] = {choice-&gt;left, choice-&gt;right};\n            backtrack(nextChoices);\n            // Backtrack: undo choice, restore to previous state\n            undoChoice();\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.kt<pre><code>/* Check if the current state is a solution */\nfun isSolution(state: MutableList&lt;TreeNode?&gt;): Boolean {\n    return state.isNotEmpty() &amp;&amp; state[state.size - 1]?._val == 7\n}\n\n/* Record solution */\nfun recordSolution(state: MutableList&lt;TreeNode?&gt;?, res: MutableList&lt;MutableList&lt;TreeNode?&gt;?&gt;) {\n    res.add(state!!.toMutableList())\n}\n\n/* Check if the choice is valid under the current state */\nfun isValid(state: MutableList&lt;TreeNode?&gt;?, choice: TreeNode?): Boolean {\n    return choice != null &amp;&amp; choice._val != 3\n}\n\n/* Update state */\nfun makeChoice(state: MutableList&lt;TreeNode?&gt;, choice: TreeNode?) {\n    state.add(choice)\n}\n\n/* Restore state */\nfun undoChoice(state: MutableList&lt;TreeNode?&gt;, choice: TreeNode?) {\n    state.removeLast()\n}\n\n/* Backtracking algorithm: Example 3 */\nfun backtrack(\n    state: MutableList&lt;TreeNode?&gt;,\n    choices: MutableList&lt;TreeNode?&gt;,\n    res: MutableList&lt;MutableList&lt;TreeNode?&gt;?&gt;\n) {\n    // Check if it is a solution\n    if (isSolution(state)) {\n        // Record solution\n        recordSolution(state, res)\n    }\n    // Traverse all choices\n    for (choice in choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Attempt: make choice, update state\n            makeChoice(state, choice)\n            // Proceed to the next round of selection\n            backtrack(state, mutableListOf(choice!!.left, choice.right), res)\n            // Backtrack: undo choice, restore to previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.rb<pre><code>### Check if current state is solution ###\ndef is_solution?(state)\n  !state.empty? &amp;&amp; state.last.val == 7\nend\n\n### Record solution ###\ndef record_solution(state, res)\n  res &lt;&lt; state.dup\nend\n\n### Check if choice is valid in current state ###\ndef is_valid?(state, choice)\n  choice &amp;&amp; choice.val != 3\nend\n\n### Update state ###\ndef make_choice(state, choice)\n  state &lt;&lt; choice\nend\n\n### Restore state ###\ndef undo_choice(state, choice)\n  state.pop\nend\n\n### Backtracking: example 3 ###\ndef backtrack(state, choices, res)\n  # Check if it is a solution\n  record_solution(state, res) if is_solution?(state)\n\n  # Traverse all choices\n  for choice in choices\n    # Pruning: check if the choice is valid\n    if is_valid?(state, choice)\n      # Attempt: make choice, update state\n      make_choice(state, choice)\n      # Proceed to the next round of selection\n      backtrack(state, [choice.left, choice.right], res)\n      # Backtrack: undo choice, restore to previous state\n      undo_choice(state, choice)\n    end\n  end\nend\n</code></pre> <p>As per the problem statement, we should continue searching after finding a node with value \\(7\\). Therefore, we need to remove the <code>return</code> statement after recording the solution. The following figure compares the search process with and without the <code>return</code> statement.</p> <p></p> <p> Figure 13-4 \u00a0 Comparison of search process with and without return statement </p> <p>Compared to code based on preorder traversal, code based on the backtracking algorithm framework appears more verbose, but has better generality. In fact, many backtracking problems can be solved within this framework. We only need to define <code>state</code> and <code>choices</code> for the specific problem and implement each method in the framework.</p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1314-common-terminology","title":"13.1.4 \u00a0 Common Terminology","text":"<p>To analyze algorithmic problems more clearly, we summarize the meanings of common terminology used in backtracking algorithms and provide corresponding examples from Example 3, as shown in the following table.</p> <p> Table 13-1 \u00a0 Common Backtracking Algorithm Terminology </p> Term Definition Example 3 Solution (solution) A solution is an answer that satisfies the specific conditions of a problem; there may be one or more solutions All paths from root to nodes with value \\(7\\) that satisfy the constraint Constraint (constraint) A constraint is a condition in the problem that limits the feasibility of solutions, typically used for pruning Paths do not contain nodes with value \\(3\\) State (state) State represents the situation of a problem at a certain moment, including the choices already made The currently visited node path, i.e., the <code>path</code> list of nodes Attempt (attempt) An attempt is the process of exploring the solution space according to available choices, including making choices, updating state, and checking if it is a solution Recursively visit left (right) child nodes, add nodes to <code>path</code>, check if node value is \\(7\\) Backtrack (backtracking) Backtracking refers to undoing previous choices and returning to a previous state when encountering a state that does not satisfy constraints Stop searching when passing over leaf nodes, ending node visits, or encountering nodes with value \\(3\\); function returns Pruning (pruning) Pruning is a method of avoiding meaningless search paths according to problem characteristics and constraints, which can improve search efficiency When encountering a node with value \\(3\\), do not continue searching <p>Tip</p> <p>The concepts of problem, solution, state, etc. are universal and are involved in divide-and-conquer, backtracking, dynamic programming, greedy and other algorithms.</p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1315-advantages-and-limitations","title":"13.1.5 \u00a0 Advantages and Limitations","text":"<p>The backtracking algorithm is essentially a depth-first search algorithm that tries all possible solutions until it finds one that satisfies the conditions. The advantage of this approach is that it can find all possible solutions, and with reasonable pruning operations, it achieves high efficiency.</p> <p>However, when dealing with large-scale or complex problems, the running efficiency of the backtracking algorithm may be unacceptable.</p> <ul> <li>Time: The backtracking algorithm usually needs to traverse all possibilities in the solution space, and the time complexity can reach exponential or factorial order.</li> <li>Space: During recursive calls, the current state needs to be saved (such as paths, auxiliary variables used for pruning, etc.), and when the depth is large, the space requirement can become very large.</li> </ul> <p>Nevertheless, the backtracking algorithm is still the best solution for certain search problems and constraint satisfaction problems. For these problems, since we cannot predict which choices will generate valid solutions, we must traverse all possible choices. In this case, the key is how to optimize efficiency. There are two common efficiency optimization methods.</p> <ul> <li>Pruning: Avoid searching paths that are guaranteed not to produce solutions, thereby saving time and space.</li> <li>Heuristic search: Introduce certain strategies or estimation values during the search process to prioritize searching paths that are most likely to produce valid solutions.</li> </ul>"},{"location":"chapter_backtracking/backtracking_algorithm/#1316-typical-backtracking-examples","title":"13.1.6 \u00a0 Typical Backtracking Examples","text":"<p>The backtracking algorithm can be used to solve many search problems, constraint satisfaction problems, and combinatorial optimization problems.</p> <p>Search problems: The goal of these problems is to find solutions that satisfy specific conditions.</p> <ul> <li>Permutation problem: Given a set, find all possible permutations and combinations.</li> <li>Subset sum problem: Given a set and a target sum, find all subsets in the set whose elements sum to the target.</li> <li>Tower of Hanoi: Given three pegs and a series of disks of different sizes, move all disks from one peg to another, moving only one disk at a time, and never placing a larger disk on a smaller disk.</li> </ul> <p>Constraint satisfaction problems: The goal of these problems is to find solutions that satisfy all constraints.</p> <ul> <li>N-Queens: Place \\(n\\) queens on an \\(n \\times n\\) chessboard such that they do not attack each other.</li> <li>Sudoku: Fill numbers \\(1\\) to \\(9\\) in a \\(9 \\times 9\\) grid such that each row, column, and \\(3 \\times 3\\) subgrid contains no repeated digits.</li> <li>Graph coloring: Given an undirected graph, color each vertex with the minimum number of colors such that adjacent vertices have different colors.</li> </ul> <p>Combinatorial optimization problems: The goal of these problems is to find an optimal solution that satisfies certain conditions in a combinatorial space.</p> <ul> <li>0-1 Knapsack: Given a set of items and a knapsack, each item has a value and weight. Under the knapsack capacity constraint, select items to maximize total value.</li> <li>Traveling Salesman Problem: Starting from a point in a graph, visit all other points exactly once and return to the starting point, finding the shortest path.</li> <li>Maximum Clique: Given an undirected graph, find the largest complete subgraph, i.e., a subgraph where any two vertices are connected by an edge.</li> </ul> <p>Note that for many combinatorial optimization problems, backtracking is not the optimal solution.</p> <ul> <li>The 0-1 Knapsack problem is usually solved using dynamic programming to achieve higher time efficiency.</li> <li>The Traveling Salesman Problem is a famous NP-Hard problem; common solutions include genetic algorithms and ant colony algorithms.</li> <li>The Maximum Clique problem is a classical problem in graph theory and can be solved using heuristic algorithms such as greedy algorithms.</li> </ul>"},{"location":"chapter_backtracking/n_queens_problem/","title":"13.4 \u00a0 N-Queens Problem","text":"<p>Question</p> <p>According to the rules of chess, a queen can attack pieces that share the same row, column, or diagonal line. Given \\(n\\) queens and an \\(n \\times n\\) chessboard, find a placement scheme such that no two queens can attack each other.</p> <p>As shown in Figure 13-15, when \\(n = 4\\), there are two solutions that can be found. From the perspective of the backtracking algorithm, an \\(n \\times n\\) chessboard has \\(n^2\\) squares, which provide all the choices <code>choices</code>. During the process of placing queens one by one, the chessboard state changes continuously, and the chessboard at each moment represents the state <code>state</code>.</p> <p></p> <p> Figure 13-15 \u00a0 Solution to the 4-queens problem </p> <p>Figure 13-16 illustrates the three constraints of this problem: multiple queens cannot be in the same row, the same column, or on the same diagonal. It is worth noting that diagonals are divided into two types: the main diagonal <code>\\</code> and the anti-diagonal <code>/</code>.</p> <p></p> <p> Figure 13-16 \u00a0 Constraints of the n-queens problem </p>"},{"location":"chapter_backtracking/n_queens_problem/#1-row-by-row-placement-strategy","title":"1. \u00a0 Row-By-Row Placement Strategy","text":"<p>Since both the number of queens and the number of rows on the chessboard are \\(n\\), we can easily derive a conclusion: each row of the chessboard allows and only allows exactly one queen to be placed.</p> <p>This means we can adopt a row-by-row placement strategy: starting from the first row, place one queen in each row until the last row is completed.</p> <p>Figure 13-17 shows the row-by-row placement process for the 4-queens problem. Due to space limitations, the figure only expands one search branch of the first row, and all schemes that do not satisfy the column constraint and diagonal constraints are pruned.</p> <p></p> <p> Figure 13-17 \u00a0 Row-by-row placement strategy </p> <p>Essentially, the row-by-row placement strategy serves a pruning function, as it avoids all search branches where multiple queens appear in the same row.</p>"},{"location":"chapter_backtracking/n_queens_problem/#2-column-and-diagonal-pruning","title":"2. \u00a0 Column and Diagonal Pruning","text":"<p>To satisfy the column constraint, we can use a boolean array <code>cols</code> of length \\(n\\) to record whether each column has a queen. Before each placement decision, we use <code>cols</code> to prune columns that already have queens, and dynamically update the state of <code>cols</code> during backtracking.</p> <p>Tip</p> <p>Please note that the origin of the matrix is located in the upper-left corner, where the row index increases from top to bottom, and the column index increases from left to right.</p> <p>So how do we handle diagonal constraints? Consider a square on the chessboard with row and column indices \\((row, col)\\). If we select a specific main diagonal in the matrix, we find that all squares on that diagonal have the same difference between their row and column indices, meaning that \\(row - col\\) is a constant value for all squares on the main diagonal.</p> <p>In other words, if two squares satisfy \\(row_1 - col_1 = row_2 - col_2\\), they must be on the same main diagonal. Using this pattern, we can use the array <code>diags1</code> shown in Figure 13-18 to record whether there is a queen on each main diagonal.</p> <p>Similarly, for all squares on an anti-diagonal, the sum \\(row + col\\) is a constant value. We can likewise use the array <code>diags2</code> to handle anti-diagonal constraints.</p> <p></p> <p> Figure 13-18 \u00a0 Handling column and diagonal constraints </p>"},{"location":"chapter_backtracking/n_queens_problem/#3-code-implementation","title":"3. \u00a0 Code Implementation","text":"<p>Please note that in an \\(n\\)-dimensional square matrix, the range of \\(row - col\\) is \\([-n + 1, n - 1]\\), and the range of \\(row + col\\) is \\([0, 2n - 2]\\). Therefore, the number of both main diagonals and anti-diagonals is \\(2n - 1\\), meaning the length of both arrays <code>diags1</code> and <code>diags2</code> is \\(2n - 1\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby n_queens.py<pre><code>def backtrack(\n    row: int,\n    n: int,\n    state: list[list[str]],\n    res: list[list[list[str]]],\n    cols: list[bool],\n    diags1: list[bool],\n    diags2: list[bool],\n):\n    \"\"\"Backtracking algorithm: N queens\"\"\"\n    # When all rows are placed, record the solution\n    if row == n:\n        res.append([list(row) for row in state])\n        return\n    # Traverse all columns\n    for col in range(n):\n        # Calculate the main diagonal and anti-diagonal corresponding to this cell\n        diag1 = row - col + n - 1\n        diag2 = row + col\n        # Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if not cols[col] and not diags1[diag1] and not diags2[diag2]:\n            # Attempt: place the queen in this cell\n            state[row][col] = \"Q\"\n            cols[col] = diags1[diag1] = diags2[diag2] = True\n            # Place the next row\n            backtrack(row + 1, n, state, res, cols, diags1, diags2)\n            # Backtrack: restore this cell to an empty cell\n            state[row][col] = \"#\"\n            cols[col] = diags1[diag1] = diags2[diag2] = False\n\ndef n_queens(n: int) -&gt; list[list[list[str]]]:\n    \"\"\"Solve N queens\"\"\"\n    # Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    state = [[\"#\" for _ in range(n)] for _ in range(n)]\n    cols = [False] * n  # Record whether there is a queen in the column\n    diags1 = [False] * (2 * n - 1)  # Record whether there is a queen on the main diagonal\n    diags2 = [False] * (2 * n - 1)  # Record whether there is a queen on the anti-diagonal\n    res = []\n    backtrack(0, n, state, res, cols, diags1, diags2)\n\n    return res\n</code></pre> n_queens.cpp<pre><code>/* Backtracking algorithm: N queens */\nvoid backtrack(int row, int n, vector&lt;vector&lt;string&gt;&gt; &amp;state, vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; &amp;res, vector&lt;bool&gt; &amp;cols,\n               vector&lt;bool&gt; &amp;diags1, vector&lt;bool&gt; &amp;diags2) {\n    // When all rows are placed, record the solution\n    if (row == n) {\n        res.push_back(state);\n        return;\n    }\n    // Traverse all columns\n    for (int col = 0; col &lt; n; col++) {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // Attempt: place the queen in this cell\n            state[row][col] = \"Q\";\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // Place the next row\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = \"#\";\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* Solve N queens */\nvector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; nQueens(int n) {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    vector&lt;vector&lt;string&gt;&gt; state(n, vector&lt;string&gt;(n, \"#\"));\n    vector&lt;bool&gt; cols(n, false);           // Record whether there is a queen in the column\n    vector&lt;bool&gt; diags1(2 * n - 1, false); // Record whether there is a queen on the main diagonal\n    vector&lt;bool&gt; diags2(2 * n - 1, false); // Record whether there is a queen on the anti-diagonal\n    vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; res;\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n\n    return res;\n}\n</code></pre> n_queens.java<pre><code>/* Backtracking algorithm: N queens */\nvoid backtrack(int row, int n, List&lt;List&lt;String&gt;&gt; state, List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,\n        boolean[] cols, boolean[] diags1, boolean[] diags2) {\n    // When all rows are placed, record the solution\n    if (row == n) {\n        List&lt;List&lt;String&gt;&gt; copyState = new ArrayList&lt;&gt;();\n        for (List&lt;String&gt; sRow : state) {\n            copyState.add(new ArrayList&lt;&gt;(sRow));\n        }\n        res.add(copyState);\n        return;\n    }\n    // Traverse all columns\n    for (int col = 0; col &lt; n; col++) {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // Attempt: place the queen in this cell\n            state.get(row).set(col, \"Q\");\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // Place the next row\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // Backtrack: restore this cell to an empty cell\n            state.get(row).set(col, \"#\");\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* Solve N queens */\nList&lt;List&lt;List&lt;String&gt;&gt;&gt; nQueens(int n) {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    List&lt;List&lt;String&gt;&gt; state = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;String&gt; row = new ArrayList&lt;&gt;();\n        for (int j = 0; j &lt; n; j++) {\n            row.add(\"#\");\n        }\n        state.add(row);\n    }\n    boolean[] cols = new boolean[n]; // Record whether there is a queen in the column\n    boolean[] diags1 = new boolean[2 * n - 1]; // Record whether there is a queen on the main diagonal\n    boolean[] diags2 = new boolean[2 * n - 1]; // Record whether there is a queen on the anti-diagonal\n    List&lt;List&lt;List&lt;String&gt;&gt;&gt; res = new ArrayList&lt;&gt;();\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n\n    return res;\n}\n</code></pre> n_queens.cs<pre><code>/* Backtracking algorithm: N queens */\nvoid Backtrack(int row, int n, List&lt;List&lt;string&gt;&gt; state, List&lt;List&lt;List&lt;string&gt;&gt;&gt; res,\n        bool[] cols, bool[] diags1, bool[] diags2) {\n    // When all rows are placed, record the solution\n    if (row == n) {\n        List&lt;List&lt;string&gt;&gt; copyState = [];\n        foreach (List&lt;string&gt; sRow in state) {\n            copyState.Add(new List&lt;string&gt;(sRow));\n        }\n        res.Add(copyState);\n        return;\n    }\n    // Traverse all columns\n    for (int col = 0; col &lt; n; col++) {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // Attempt: place the queen in this cell\n            state[row][col] = \"Q\";\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // Place the next row\n            Backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = \"#\";\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* Solve N queens */\nList&lt;List&lt;List&lt;string&gt;&gt;&gt; NQueens(int n) {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    List&lt;List&lt;string&gt;&gt; state = [];\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;string&gt; row = [];\n        for (int j = 0; j &lt; n; j++) {\n            row.Add(\"#\");\n        }\n        state.Add(row);\n    }\n    bool[] cols = new bool[n]; // Record whether there is a queen in the column\n    bool[] diags1 = new bool[2 * n - 1]; // Record whether there is a queen on the main diagonal\n    bool[] diags2 = new bool[2 * n - 1]; // Record whether there is a queen on the anti-diagonal\n    List&lt;List&lt;List&lt;string&gt;&gt;&gt; res = [];\n\n    Backtrack(0, n, state, res, cols, diags1, diags2);\n\n    return res;\n}\n</code></pre> n_queens.go<pre><code>/* Backtracking algorithm: N queens */\nfunc backtrack(row, n int, state *[][]string, res *[][][]string, cols, diags1, diags2 *[]bool) {\n    // When all rows are placed, record the solution\n    if row == n {\n        newState := make([][]string, len(*state))\n        for i, _ := range newState {\n            newState[i] = make([]string, len((*state)[0]))\n            copy(newState[i], (*state)[i])\n\n        }\n        *res = append(*res, newState)\n        return\n    }\n    // Traverse all columns\n    for col := 0; col &lt; n; col++ {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        diag1 := row - col + n - 1\n        diag2 := row + col\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if !(*cols)[col] &amp;&amp; !(*diags1)[diag1] &amp;&amp; !(*diags2)[diag2] {\n            // Attempt: place the queen in this cell\n            (*state)[row][col] = \"Q\"\n            (*cols)[col], (*diags1)[diag1], (*diags2)[diag2] = true, true, true\n            // Place the next row\n            backtrack(row+1, n, state, res, cols, diags1, diags2)\n            // Backtrack: restore this cell to an empty cell\n            (*state)[row][col] = \"#\"\n            (*cols)[col], (*diags1)[diag1], (*diags2)[diag2] = false, false, false\n        }\n    }\n}\n\n/* Solve N queens */\nfunc nQueens(n int) [][][]string {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    state := make([][]string, n)\n    for i := 0; i &lt; n; i++ {\n        row := make([]string, n)\n        for i := 0; i &lt; n; i++ {\n            row[i] = \"#\"\n        }\n        state[i] = row\n    }\n    // Record whether there is a queen in the column\n    cols := make([]bool, n)\n    diags1 := make([]bool, 2*n-1)\n    diags2 := make([]bool, 2*n-1)\n    res := make([][][]string, 0)\n    backtrack(0, n, &amp;state, &amp;res, &amp;cols, &amp;diags1, &amp;diags2)\n    return res\n}\n</code></pre> n_queens.swift<pre><code>/* Backtracking algorithm: N queens */\nfunc backtrack(row: Int, n: Int, state: inout [[String]], res: inout [[[String]]], cols: inout [Bool], diags1: inout [Bool], diags2: inout [Bool]) {\n    // When all rows are placed, record the solution\n    if row == n {\n        res.append(state)\n        return\n    }\n    // Traverse all columns\n    for col in 0 ..&lt; n {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        let diag1 = row - col + n - 1\n        let diag2 = row + col\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if !cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2] {\n            // Attempt: place the queen in this cell\n            state[row][col] = \"Q\"\n            cols[col] = true\n            diags1[diag1] = true\n            diags2[diag2] = true\n            // Place the next row\n            backtrack(row: row + 1, n: n, state: &amp;state, res: &amp;res, cols: &amp;cols, diags1: &amp;diags1, diags2: &amp;diags2)\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = \"#\"\n            cols[col] = false\n            diags1[diag1] = false\n            diags2[diag2] = false\n        }\n    }\n}\n\n/* Solve N queens */\nfunc nQueens(n: Int) -&gt; [[[String]]] {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    var state = Array(repeating: Array(repeating: \"#\", count: n), count: n)\n    var cols = Array(repeating: false, count: n) // Record whether there is a queen in the column\n    var diags1 = Array(repeating: false, count: 2 * n - 1) // Record whether there is a queen on the main diagonal\n    var diags2 = Array(repeating: false, count: 2 * n - 1) // Record whether there is a queen on the anti-diagonal\n    var res: [[[String]]] = []\n\n    backtrack(row: 0, n: n, state: &amp;state, res: &amp;res, cols: &amp;cols, diags1: &amp;diags1, diags2: &amp;diags2)\n\n    return res\n}\n</code></pre> n_queens.js<pre><code>/* Backtracking algorithm: N queens */\nfunction backtrack(row, n, state, res, cols, diags1, diags2) {\n    // When all rows are placed, record the solution\n    if (row === n) {\n        res.push(state.map((row) =&gt; row.slice()));\n        return;\n    }\n    // Traverse all columns\n    for (let col = 0; col &lt; n; col++) {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        const diag1 = row - col + n - 1;\n        const diag2 = row + col;\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // Attempt: place the queen in this cell\n            state[row][col] = 'Q';\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // Place the next row\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = '#';\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* Solve N queens */\nfunction nQueens(n) {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    const state = Array.from({ length: n }, () =&gt; Array(n).fill('#'));\n    const cols = Array(n).fill(false); // Record whether there is a queen in the column\n    const diags1 = Array(2 * n - 1).fill(false); // Record whether there is a queen on the main diagonal\n    const diags2 = Array(2 * n - 1).fill(false); // Record whether there is a queen on the anti-diagonal\n    const res = [];\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n    return res;\n}\n</code></pre> n_queens.ts<pre><code>/* Backtracking algorithm: N queens */\nfunction backtrack(\n    row: number,\n    n: number,\n    state: string[][],\n    res: string[][][],\n    cols: boolean[],\n    diags1: boolean[],\n    diags2: boolean[]\n): void {\n    // When all rows are placed, record the solution\n    if (row === n) {\n        res.push(state.map((row) =&gt; row.slice()));\n        return;\n    }\n    // Traverse all columns\n    for (let col = 0; col &lt; n; col++) {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        const diag1 = row - col + n - 1;\n        const diag2 = row + col;\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // Attempt: place the queen in this cell\n            state[row][col] = 'Q';\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // Place the next row\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = '#';\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* Solve N queens */\nfunction nQueens(n: number): string[][][] {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    const state = Array.from({ length: n }, () =&gt; Array(n).fill('#'));\n    const cols = Array(n).fill(false); // Record whether there is a queen in the column\n    const diags1 = Array(2 * n - 1).fill(false); // Record whether there is a queen on the main diagonal\n    const diags2 = Array(2 * n - 1).fill(false); // Record whether there is a queen on the anti-diagonal\n    const res: string[][][] = [];\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n    return res;\n}\n</code></pre> n_queens.dart<pre><code>/* Backtracking algorithm: N queens */\nvoid backtrack(\n  int row,\n  int n,\n  List&lt;List&lt;String&gt;&gt; state,\n  List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,\n  List&lt;bool&gt; cols,\n  List&lt;bool&gt; diags1,\n  List&lt;bool&gt; diags2,\n) {\n  // When all rows are placed, record the solution\n  if (row == n) {\n    List&lt;List&lt;String&gt;&gt; copyState = [];\n    for (List&lt;String&gt; sRow in state) {\n      copyState.add(List.from(sRow));\n    }\n    res.add(copyState);\n    return;\n  }\n  // Traverse all columns\n  for (int col = 0; col &lt; n; col++) {\n    // Calculate the main diagonal and anti-diagonal corresponding to this cell\n    int diag1 = row - col + n - 1;\n    int diag2 = row + col;\n    // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n    if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n      // Attempt: place the queen in this cell\n      state[row][col] = \"Q\";\n      cols[col] = true;\n      diags1[diag1] = true;\n      diags2[diag2] = true;\n      // Place the next row\n      backtrack(row + 1, n, state, res, cols, diags1, diags2);\n      // Backtrack: restore this cell to an empty cell\n      state[row][col] = \"#\";\n      cols[col] = false;\n      diags1[diag1] = false;\n      diags2[diag2] = false;\n    }\n  }\n}\n\n/* Solve N queens */\nList&lt;List&lt;List&lt;String&gt;&gt;&gt; nQueens(int n) {\n  // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n  List&lt;List&lt;String&gt;&gt; state = List.generate(n, (index) =&gt; List.filled(n, \"#\"));\n  List&lt;bool&gt; cols = List.filled(n, false); // Record whether there is a queen in the column\n  List&lt;bool&gt; diags1 = List.filled(2 * n - 1, false); // Record whether there is a queen on the main diagonal\n  List&lt;bool&gt; diags2 = List.filled(2 * n - 1, false); // Record whether there is a queen on the anti-diagonal\n  List&lt;List&lt;List&lt;String&gt;&gt;&gt; res = [];\n\n  backtrack(0, n, state, res, cols, diags1, diags2);\n\n  return res;\n}\n</code></pre> n_queens.rs<pre><code>/* Backtracking algorithm: N queens */\nfn backtrack(\n    row: usize,\n    n: usize,\n    state: &amp;mut Vec&lt;Vec&lt;String&gt;&gt;,\n    res: &amp;mut Vec&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt;,\n    cols: &amp;mut [bool],\n    diags1: &amp;mut [bool],\n    diags2: &amp;mut [bool],\n) {\n    // When all rows are placed, record the solution\n    if row == n {\n        res.push(state.clone());\n        return;\n    }\n    // Traverse all columns\n    for col in 0..n {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        let diag1 = row + n - 1 - col;\n        let diag2 = row + col;\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if !cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2] {\n            // Attempt: place the queen in this cell\n            state[row][col] = \"Q\".into();\n            (cols[col], diags1[diag1], diags2[diag2]) = (true, true, true);\n            // Place the next row\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = \"#\".into();\n            (cols[col], diags1[diag1], diags2[diag2]) = (false, false, false);\n        }\n    }\n}\n\n/* Solve N queens */\nfn n_queens(n: usize) -&gt; Vec&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt; {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    let mut state: Vec&lt;Vec&lt;String&gt;&gt; = vec![vec![\"#\".to_string(); n]; n];\n    let mut cols = vec![false; n]; // Record whether there is a queen in the column\n    let mut diags1 = vec![false; 2 * n - 1]; // Record whether there is a queen on the main diagonal\n    let mut diags2 = vec![false; 2 * n - 1]; // Record whether there is a queen on the anti-diagonal\n    let mut res: Vec&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt; = Vec::new();\n\n    backtrack(\n        0,\n        n,\n        &amp;mut state,\n        &amp;mut res,\n        &amp;mut cols,\n        &amp;mut diags1,\n        &amp;mut diags2,\n    );\n\n    res\n}\n</code></pre> n_queens.c<pre><code>/* Backtracking algorithm: N queens */\nvoid backtrack(int row, int n, char state[MAX_SIZE][MAX_SIZE], char ***res, int *resSize, bool cols[MAX_SIZE],\n               bool diags1[2 * MAX_SIZE - 1], bool diags2[2 * MAX_SIZE - 1]) {\n    // When all rows are placed, record the solution\n    if (row == n) {\n        res[*resSize] = (char **)malloc(sizeof(char *) * n);\n        for (int i = 0; i &lt; n; ++i) {\n            res[*resSize][i] = (char *)malloc(sizeof(char) * (n + 1));\n            strcpy(res[*resSize][i], state[i]);\n        }\n        (*resSize)++;\n        return;\n    }\n    // Traverse all columns\n    for (int col = 0; col &lt; n; col++) {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // Attempt: place the queen in this cell\n            state[row][col] = 'Q';\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // Place the next row\n            backtrack(row + 1, n, state, res, resSize, cols, diags1, diags2);\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = '#';\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* Solve N queens */\nchar ***nQueens(int n, int *returnSize) {\n    char state[MAX_SIZE][MAX_SIZE];\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            state[i][j] = '#';\n        }\n        state[i][n] = '\\0';\n    }\n    bool cols[MAX_SIZE] = {false};           // Record whether there is a queen in the column\n    bool diags1[2 * MAX_SIZE - 1] = {false}; // Record whether there is a queen on the main diagonal\n    bool diags2[2 * MAX_SIZE - 1] = {false}; // Record whether there is a queen on the anti-diagonal\n\n    char ***res = (char ***)malloc(sizeof(char **) * MAX_SIZE);\n    *returnSize = 0;\n    backtrack(0, n, state, res, returnSize, cols, diags1, diags2);\n    return res;\n}\n</code></pre> n_queens.kt<pre><code>/* Backtracking algorithm: N queens */\nfun backtrack(\n    row: Int,\n    n: Int,\n    state: MutableList&lt;MutableList&lt;String&gt;&gt;,\n    res: MutableList&lt;MutableList&lt;MutableList&lt;String&gt;&gt;?&gt;,\n    cols: BooleanArray,\n    diags1: BooleanArray,\n    diags2: BooleanArray\n) {\n    // When all rows are placed, record the solution\n    if (row == n) {\n        val copyState = mutableListOf&lt;MutableList&lt;String&gt;&gt;()\n        for (sRow in state) {\n            copyState.add(sRow.toMutableList())\n        }\n        res.add(copyState)\n        return\n    }\n    // Traverse all columns\n    for (col in 0..&lt;n) {\n        // Calculate the main diagonal and anti-diagonal corresponding to this cell\n        val diag1 = row - col + n - 1\n        val diag2 = row + col\n        // Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // Attempt: place the queen in this cell\n            state[row][col] = \"Q\"\n            diags2[diag2] = true\n            diags1[diag1] = diags2[diag2]\n            cols[col] = diags1[diag1]\n            // Place the next row\n            backtrack(row + 1, n, state, res, cols, diags1, diags2)\n            // Backtrack: restore this cell to an empty cell\n            state[row][col] = \"#\"\n            diags2[diag2] = false\n            diags1[diag1] = diags2[diag2]\n            cols[col] = diags1[diag1]\n        }\n    }\n}\n\n/* Solve N queens */\nfun nQueens(n: Int): MutableList&lt;MutableList&lt;MutableList&lt;String&gt;&gt;?&gt; {\n    // Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n    val state = mutableListOf&lt;MutableList&lt;String&gt;&gt;()\n    for (i in 0..&lt;n) {\n        val row = mutableListOf&lt;String&gt;()\n        for (j in 0..&lt;n) {\n            row.add(\"#\")\n        }\n        state.add(row)\n    }\n    val cols = BooleanArray(n) // Record whether there is a queen in the column\n    val diags1 = BooleanArray(2 * n - 1) // Record whether there is a queen on the main diagonal\n    val diags2 = BooleanArray(2 * n - 1) // Record whether there is a queen on the anti-diagonal\n    val res = mutableListOf&lt;MutableList&lt;MutableList&lt;String&gt;&gt;?&gt;()\n\n    backtrack(0, n, state, res, cols, diags1, diags2)\n\n    return res\n}\n</code></pre> n_queens.rb<pre><code>### Backtracking: n queens ###\ndef backtrack(row, n, state, res, cols, diags1, diags2)\n  # When all rows are placed, record the solution\n  if row == n\n    res &lt;&lt; state.map { |row| row.dup }\n    return\n  end\n\n  # Traverse all columns\n  for col in 0...n\n    # Calculate the main diagonal and anti-diagonal corresponding to this cell\n    diag1 = row - col + n - 1\n    diag2 = row + col\n    # Pruning: do not allow queens to exist in the column, main diagonal, and anti-diagonal of this cell\n    if !cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]\n      # Attempt: place the queen in this cell\n      state[row][col] = \"Q\"\n      cols[col] = diags1[diag1] = diags2[diag2] = true\n      # Place the next row\n      backtrack(row + 1, n, state, res, cols, diags1, diags2)\n      # Backtrack: restore this cell to an empty cell\n      state[row][col] = \"#\"\n      cols[col] = diags1[diag1] = diags2[diag2] = false\n    end\n  end\nend\n\n### Solve n queens ###\ndef n_queens(n)\n  # Initialize an n*n chessboard, where 'Q' represents a queen and '#' represents an empty cell\n  state = Array.new(n) { Array.new(n, \"#\") }\n  cols = Array.new(n, false) # Record whether there is a queen in the column\n  diags1 = Array.new(2 * n - 1, false) # Record whether there is a queen on the main diagonal\n  diags2 = Array.new(2 * n - 1, false) # Record whether there is a queen on the anti-diagonal\n  res = []\n  backtrack(0, n, state, res, cols, diags1, diags2)\n\n  res\nend\n</code></pre> <p>Placing \\(n\\) queens row by row, considering the column constraint, from the first row to the last row there are \\(n\\), \\(n-1\\), \\(\\dots\\), \\(2\\), \\(1\\) choices, using \\(O(n!)\\) time. When recording a solution, it is necessary to copy the matrix <code>state</code> and add it to <code>res</code>, and the copy operation uses \\(O(n^2)\\) time. Therefore, the overall time complexity is \\(O(n! \\cdot n^2)\\). In practice, pruning based on diagonal constraints can also significantly reduce the search space, so the search efficiency is often better than the time complexity mentioned above.</p> <p>The array <code>state</code> uses \\(O(n^2)\\) space, and the arrays <code>cols</code>, <code>diags1</code>, and <code>diags2</code> each use \\(O(n)\\) space. The maximum recursion depth is \\(n\\), using \\(O(n)\\) stack frame space. Therefore, the space complexity is \\(O(n^2)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/","title":"13.2 \u00a0 Permutations Problem","text":"<p>The permutations problem is a classic application of backtracking algorithms. It is defined as finding all possible arrangements of elements in a given collection (such as an array or string).</p> <p>Table 13-2 shows several example datasets, including input arrays and their corresponding permutations.</p> <p> Table 13-2 \u00a0 Permutations Examples </p> Input Array All Permutations \\([1]\\) \\([1]\\) \\([1, 2]\\) \\([1, 2], [2, 1]\\) \\([1, 2, 3]\\) \\([1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\\)"},{"location":"chapter_backtracking/permutations_problem/#1321-case-with-distinct-elements","title":"13.2.1 \u00a0 Case with Distinct Elements","text":"<p>Question</p> <p>Given an integer array with no duplicate elements, return all possible permutations.</p> <p>From the perspective of backtracking algorithms, we can imagine the process of generating permutations as the result of a series of choices. Suppose the input array is \\([1, 2, 3]\\). If we first choose \\(1\\), then choose \\(3\\), and finally choose \\(2\\), we obtain the permutation \\([1, 3, 2]\\). Backtracking means undoing a choice and then trying other choices.</p> <p>From the perspective of backtracking code, the candidate set <code>choices</code> consists of all elements in the input array, and the state <code>state</code> is the elements that have been chosen so far. Note that each element can only be chosen once, therefore all elements in <code>state</code> should be unique.</p> <p>As shown in Figure 13-5, we can unfold the search process into a recursion tree, where each node in the tree represents the current state <code>state</code>. Starting from the root node, after three rounds of choices, we reach a leaf node, and each leaf node corresponds to a permutation.</p> <p></p> <p> Figure 13-5 \u00a0 Recursion tree of permutations </p>"},{"location":"chapter_backtracking/permutations_problem/#1-pruning-duplicate-choices","title":"1. \u00a0 Pruning Duplicate Choices","text":"<p>To ensure that each element is chosen only once, we consider introducing a boolean array <code>selected</code>, where <code>selected[i]</code> indicates whether <code>choices[i]</code> has been chosen. We implement the following pruning operation based on it.</p> <ul> <li>After making a choice <code>choice[i]</code>, we set <code>selected[i]</code> to \\(\\text{True}\\), indicating that it has been chosen.</li> <li>When traversing the candidate list <code>choices</code>, we skip all nodes that have been chosen, which is pruning.</li> </ul> <p>As shown in Figure 13-6, suppose we choose \\(1\\) in the first round, \\(3\\) in the second round, and \\(2\\) in the third round. Then we need to prune the branch of element \\(1\\) in the second round and prune the branches of elements \\(1\\) and \\(3\\) in the third round.</p> <p></p> <p> Figure 13-6 \u00a0 Pruning example of permutations </p> <p>Observing the above figure, we find that this pruning operation reduces the search space size from \\(O(n^n)\\) to \\(O(n!)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/#2-code-implementation","title":"2. \u00a0 Code Implementation","text":"<p>After understanding the above information, we can fill in the blanks in the template code. To shorten the overall code, we do not implement each function in the template separately, but instead unfold them in the <code>backtrack()</code> function:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby permutations_i.py<pre><code>def backtrack(\n    state: list[int], choices: list[int], selected: list[bool], res: list[list[int]]\n):\n    \"\"\"Backtracking algorithm: Permutations I\"\"\"\n    # When the state length equals the number of elements, record the solution\n    if len(state) == len(choices):\n        res.append(list(state))\n        return\n    # Traverse all choices\n    for i, choice in enumerate(choices):\n        # Pruning: do not allow repeated selection of elements\n        if not selected[i]:\n            # Attempt: make choice, update state\n            selected[i] = True\n            state.append(choice)\n            # Proceed to the next round of selection\n            backtrack(state, choices, selected, res)\n            # Backtrack: undo choice, restore to previous state\n            selected[i] = False\n            state.pop()\n\ndef permutations_i(nums: list[int]) -&gt; list[list[int]]:\n    \"\"\"Permutations I\"\"\"\n    res = []\n    backtrack(state=[], choices=nums, selected=[False] * len(nums), res=res)\n    return res\n</code></pre> permutations_i.cpp<pre><code>/* Backtracking algorithm: Permutations I */\nvoid backtrack(vector&lt;int&gt; &amp;state, const vector&lt;int&gt; &amp;choices, vector&lt;bool&gt; &amp;selected, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.size() == choices.size()) {\n        res.push_back(state);\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; choices.size(); i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements\n        if (!selected[i]) {\n            // Attempt: make choice, update state\n            selected[i] = true;\n            state.push_back(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop_back();\n        }\n    }\n}\n\n/* Permutations I */\nvector&lt;vector&lt;int&gt;&gt; permutationsI(vector&lt;int&gt; nums) {\n    vector&lt;int&gt; state;\n    vector&lt;bool&gt; selected(nums.size(), false);\n    vector&lt;vector&lt;int&gt;&gt; res;\n    backtrack(state, nums, selected, res);\n    return res;\n}\n</code></pre> permutations_i.java<pre><code>/* Backtracking algorithm: Permutations I */\nvoid backtrack(List&lt;Integer&gt; state, int[] choices, boolean[] selected, List&lt;List&lt;Integer&gt;&gt; res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.size() == choices.length) {\n        res.add(new ArrayList&lt;Integer&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; choices.length; i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements\n        if (!selected[i]) {\n            // Attempt: make choice, update state\n            selected[i] = true;\n            state.add(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.remove(state.size() - 1);\n        }\n    }\n}\n\n/* Permutations I */\nList&lt;List&lt;Integer&gt;&gt; permutationsI(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    backtrack(new ArrayList&lt;Integer&gt;(), nums, new boolean[nums.length], res);\n    return res;\n}\n</code></pre> permutations_i.cs<pre><code>/* Backtracking algorithm: Permutations I */\nvoid Backtrack(List&lt;int&gt; state, int[] choices, bool[] selected, List&lt;List&lt;int&gt;&gt; res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.Count == choices.Length) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; choices.Length; i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements\n        if (!selected[i]) {\n            // Attempt: make choice, update state\n            selected[i] = true;\n            state.Add(choice);\n            // Proceed to the next round of selection\n            Backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.RemoveAt(state.Count - 1);\n        }\n    }\n}\n\n/* Permutations I */\nList&lt;List&lt;int&gt;&gt; PermutationsI(int[] nums) {\n    List&lt;List&lt;int&gt;&gt; res = [];\n    Backtrack([], nums, new bool[nums.Length], res);\n    return res;\n}\n</code></pre> permutations_i.go<pre><code>/* Backtracking algorithm: Permutations I */\nfunc backtrackI(state *[]int, choices *[]int, selected *[]bool, res *[][]int) {\n    // When the state length equals the number of elements, record the solution\n    if len(*state) == len(*choices) {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n    }\n    // Traverse all choices\n    for i := 0; i &lt; len(*choices); i++ {\n        choice := (*choices)[i]\n        // Pruning: do not allow repeated selection of elements\n        if !(*selected)[i] {\n            // Attempt: make choice, update state\n            (*selected)[i] = true\n            *state = append(*state, choice)\n            // Proceed to the next round of selection\n            backtrackI(state, choices, selected, res)\n            // Backtrack: undo choice, restore to previous state\n            (*selected)[i] = false\n            *state = (*state)[:len(*state)-1]\n        }\n    }\n}\n\n/* Permutations I */\nfunc permutationsI(nums []int) [][]int {\n    res := make([][]int, 0)\n    state := make([]int, 0)\n    selected := make([]bool, len(nums))\n    backtrackI(&amp;state, &amp;nums, &amp;selected, &amp;res)\n    return res\n}\n</code></pre> permutations_i.swift<pre><code>/* Backtracking algorithm: Permutations I */\nfunc backtrack(state: inout [Int], choices: [Int], selected: inout [Bool], res: inout [[Int]]) {\n    // When the state length equals the number of elements, record the solution\n    if state.count == choices.count {\n        res.append(state)\n        return\n    }\n    // Traverse all choices\n    for (i, choice) in choices.enumerated() {\n        // Pruning: do not allow repeated selection of elements\n        if !selected[i] {\n            // Attempt: make choice, update state\n            selected[i] = true\n            state.append(choice)\n            // Proceed to the next round of selection\n            backtrack(state: &amp;state, choices: choices, selected: &amp;selected, res: &amp;res)\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false\n            state.removeLast()\n        }\n    }\n}\n\n/* Permutations I */\nfunc permutationsI(nums: [Int]) -&gt; [[Int]] {\n    var state: [Int] = []\n    var selected = Array(repeating: false, count: nums.count)\n    var res: [[Int]] = []\n    backtrack(state: &amp;state, choices: nums, selected: &amp;selected, res: &amp;res)\n    return res\n}\n</code></pre> permutations_i.js<pre><code>/* Backtracking algorithm: Permutations I */\nfunction backtrack(state, choices, selected, res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    choices.forEach((choice, i) =&gt; {\n        // Pruning: do not allow repeated selection of elements\n        if (!selected[i]) {\n            // Attempt: make choice, update state\n            selected[i] = true;\n            state.push(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* Permutations I */\nfunction permutationsI(nums) {\n    const res = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_i.ts<pre><code>/* Backtracking algorithm: Permutations I */\nfunction backtrack(\n    state: number[],\n    choices: number[],\n    selected: boolean[],\n    res: number[][]\n): void {\n    // When the state length equals the number of elements, record the solution\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    choices.forEach((choice, i) =&gt; {\n        // Pruning: do not allow repeated selection of elements\n        if (!selected[i]) {\n            // Attempt: make choice, update state\n            selected[i] = true;\n            state.push(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* Permutations I */\nfunction permutationsI(nums: number[]): number[][] {\n    const res: number[][] = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_i.dart<pre><code>/* Backtracking algorithm: Permutations I */\nvoid backtrack(\n  List&lt;int&gt; state,\n  List&lt;int&gt; choices,\n  List&lt;bool&gt; selected,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // When the state length equals the number of elements, record the solution\n  if (state.length == choices.length) {\n    res.add(List.from(state));\n    return;\n  }\n  // Traverse all choices\n  for (int i = 0; i &lt; choices.length; i++) {\n    int choice = choices[i];\n    // Pruning: do not allow repeated selection of elements\n    if (!selected[i]) {\n      // Attempt: make choice, update state\n      selected[i] = true;\n      state.add(choice);\n      // Proceed to the next round of selection\n      backtrack(state, choices, selected, res);\n      // Backtrack: undo choice, restore to previous state\n      selected[i] = false;\n      state.removeLast();\n    }\n  }\n}\n\n/* Permutations I */\nList&lt;List&lt;int&gt;&gt; permutationsI(List&lt;int&gt; nums) {\n  List&lt;List&lt;int&gt;&gt; res = [];\n  backtrack([], nums, List.filled(nums.length, false), res);\n  return res;\n}\n</code></pre> permutations_i.rs<pre><code>/* Backtracking algorithm: Permutations I */\nfn backtrack(mut state: Vec&lt;i32&gt;, choices: &amp;[i32], selected: &amp;mut [bool], res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n    // When the state length equals the number of elements, record the solution\n    if state.len() == choices.len() {\n        res.push(state);\n        return;\n    }\n    // Traverse all choices\n    for i in 0..choices.len() {\n        let choice = choices[i];\n        // Pruning: do not allow repeated selection of elements\n        if !selected[i] {\n            // Attempt: make choice, update state\n            selected[i] = true;\n            state.push(choice);\n            // Proceed to the next round of selection\n            backtrack(state.clone(), choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop();\n        }\n    }\n}\n\n/* Permutations I */\nfn permutations_i(nums: &amp;mut [i32]) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut res = Vec::new(); // State (subset)\n    backtrack(Vec::new(), nums, &amp;mut vec![false; nums.len()], &amp;mut res);\n    res\n}\n</code></pre> permutations_i.c<pre><code>/* Backtracking algorithm: Permutations I */\nvoid backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) {\n    // When the state length equals the number of elements, record the solution\n    if (stateSize == choicesSize) {\n        res[*resSize] = (int *)malloc(choicesSize * sizeof(int));\n        for (int i = 0; i &lt; choicesSize; i++) {\n            res[*resSize][i] = state[i];\n        }\n        (*resSize)++;\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; choicesSize; i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements\n        if (!selected[i]) {\n            // Attempt: make choice, update state\n            selected[i] = true;\n            state[stateSize] = choice;\n            // Proceed to the next round of selection\n            backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n        }\n    }\n}\n\n/* Permutations I */\nint **permutationsI(int *nums, int numsSize, int *returnSize) {\n    int *state = (int *)malloc(numsSize * sizeof(int));\n    bool *selected = (bool *)malloc(numsSize * sizeof(bool));\n    for (int i = 0; i &lt; numsSize; i++) {\n        selected[i] = false;\n    }\n    int **res = (int **)malloc(MAX_SIZE * sizeof(int *));\n    *returnSize = 0;\n\n    backtrack(state, 0, nums, numsSize, selected, res, returnSize);\n\n    free(state);\n    free(selected);\n\n    return res;\n}\n</code></pre> permutations_i.kt<pre><code>/* Backtracking algorithm: Permutations I */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    choices: IntArray,\n    selected: BooleanArray,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // When the state length equals the number of elements, record the solution\n    if (state.size == choices.size) {\n        res.add(state.toMutableList())\n        return\n    }\n    // Traverse all choices\n    for (i in choices.indices) {\n        val choice = choices[i]\n        // Pruning: do not allow repeated selection of elements\n        if (!selected[i]) {\n            // Attempt: make choice, update state\n            selected[i] = true\n            state.add(choice)\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res)\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false\n            state.removeAt(state.size - 1)\n        }\n    }\n}\n\n/* Permutations I */\nfun permutationsI(nums: IntArray): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;()\n    backtrack(mutableListOf(), nums, BooleanArray(nums.size), res)\n    return res\n}\n</code></pre> permutations_i.rb<pre><code>### Backtracking: permutations I ###\ndef backtrack(state, choices, selected, res)\n  # When the state length equals the number of elements, record the solution\n  if state.length == choices.length\n    res &lt;&lt; state.dup\n    return\n  end\n\n  # Traverse all choices\n  choices.each_with_index do |choice, i|\n    # Pruning: do not allow repeated selection of elements\n    unless selected[i]\n      # Attempt: make choice, update state\n      selected[i] = true\n      state &lt;&lt; choice\n      # Proceed to the next round of selection\n      backtrack(state, choices, selected, res)\n      # Backtrack: undo choice, restore to previous state\n      selected[i] = false\n      state.pop\n    end\n  end\nend\n\n### Permutations I ###\ndef permutations_i(nums)\n  res = []\n  backtrack([], nums, Array.new(nums.length, false), res)\n  res\nend\n</code></pre>"},{"location":"chapter_backtracking/permutations_problem/#1322-case-with-duplicate-elements","title":"13.2.2 \u00a0 Case with Duplicate Elements","text":"<p>Question</p> <p>Given an integer array that may contain duplicate elements, return all unique permutations.</p> <p>Suppose the input array is \\([1, 1, 2]\\). To distinguish the two duplicate elements \\(1\\), we denote the second \\(1\\) as \\(\\hat{1}\\).</p> <p>As shown in Figure 13-7, the method described above generates permutations where half are duplicates.</p> <p></p> <p> Figure 13-7 \u00a0 Duplicate permutations </p> <p>So how do we remove duplicate permutations? The most direct approach is to use a hash set to directly deduplicate the permutation results. However, this is not elegant because the search branches that generate duplicate permutations are unnecessary and should be identified and pruned early, which can further improve algorithm efficiency.</p>"},{"location":"chapter_backtracking/permutations_problem/#1-pruning-duplicate-elements","title":"1. \u00a0 Pruning Duplicate Elements","text":"<p>Observe Figure 13-8. In the first round, choosing \\(1\\) or choosing \\(\\hat{1}\\) is equivalent. All permutations generated under these two choices are duplicates. Therefore, we should prune \\(\\hat{1}\\).</p> <p>Similarly, after choosing \\(2\\) in the first round, the \\(1\\) and \\(\\hat{1}\\) in the second round also produce duplicate branches, so the second round's \\(\\hat{1}\\) should also be pruned.</p> <p>Essentially, our goal is to ensure that multiple equal elements are chosen only once in a certain round of choices.</p> <p></p> <p> Figure 13-8 \u00a0 Pruning duplicate permutations </p>"},{"location":"chapter_backtracking/permutations_problem/#2-code-implementation_1","title":"2. \u00a0 Code Implementation","text":"<p>Building on the code from the previous problem, we consider opening a hash set <code>duplicated</code> in each round of choices to record which elements have been tried in this round, and prune duplicate elements:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby permutations_ii.py<pre><code>def backtrack(\n    state: list[int], choices: list[int], selected: list[bool], res: list[list[int]]\n):\n    \"\"\"Backtracking algorithm: Permutations II\"\"\"\n    # When the state length equals the number of elements, record the solution\n    if len(state) == len(choices):\n        res.append(list(state))\n        return\n    # Traverse all choices\n    duplicated = set[int]()\n    for i, choice in enumerate(choices):\n        # Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if not selected[i] and choice not in duplicated:\n            # Attempt: make choice, update state\n            duplicated.add(choice)  # Record the selected element value\n            selected[i] = True\n            state.append(choice)\n            # Proceed to the next round of selection\n            backtrack(state, choices, selected, res)\n            # Backtrack: undo choice, restore to previous state\n            selected[i] = False\n            state.pop()\n\ndef permutations_ii(nums: list[int]) -&gt; list[list[int]]:\n    \"\"\"Permutations II\"\"\"\n    res = []\n    backtrack(state=[], choices=nums, selected=[False] * len(nums), res=res)\n    return res\n</code></pre> permutations_ii.cpp<pre><code>/* Backtracking algorithm: Permutations II */\nvoid backtrack(vector&lt;int&gt; &amp;state, const vector&lt;int&gt; &amp;choices, vector&lt;bool&gt; &amp;selected, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.size() == choices.size()) {\n        res.push_back(state);\n        return;\n    }\n    // Traverse all choices\n    unordered_set&lt;int&gt; duplicated;\n    for (int i = 0; i &lt; choices.size(); i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if (!selected[i] &amp;&amp; duplicated.find(choice) == duplicated.end()) {\n            // Attempt: make choice, update state\n            duplicated.emplace(choice); // Record the selected element value\n            selected[i] = true;\n            state.push_back(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop_back();\n        }\n    }\n}\n\n/* Permutations II */\nvector&lt;vector&lt;int&gt;&gt; permutationsII(vector&lt;int&gt; nums) {\n    vector&lt;int&gt; state;\n    vector&lt;bool&gt; selected(nums.size(), false);\n    vector&lt;vector&lt;int&gt;&gt; res;\n    backtrack(state, nums, selected, res);\n    return res;\n}\n</code></pre> permutations_ii.java<pre><code>/* Backtracking algorithm: Permutations II */\nvoid backtrack(List&lt;Integer&gt; state, int[] choices, boolean[] selected, List&lt;List&lt;Integer&gt;&gt; res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.size() == choices.length) {\n        res.add(new ArrayList&lt;Integer&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    Set&lt;Integer&gt; duplicated = new HashSet&lt;Integer&gt;();\n    for (int i = 0; i &lt; choices.length; i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if (!selected[i] &amp;&amp; !duplicated.contains(choice)) {\n            // Attempt: make choice, update state\n            duplicated.add(choice); // Record the selected element value\n            selected[i] = true;\n            state.add(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.remove(state.size() - 1);\n        }\n    }\n}\n\n/* Permutations II */\nList&lt;List&lt;Integer&gt;&gt; permutationsII(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    backtrack(new ArrayList&lt;Integer&gt;(), nums, new boolean[nums.length], res);\n    return res;\n}\n</code></pre> permutations_ii.cs<pre><code>/* Backtracking algorithm: Permutations II */\nvoid Backtrack(List&lt;int&gt; state, int[] choices, bool[] selected, List&lt;List&lt;int&gt;&gt; res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.Count == choices.Length) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    HashSet&lt;int&gt; duplicated = [];\n    for (int i = 0; i &lt; choices.Length; i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if (!selected[i] &amp;&amp; !duplicated.Contains(choice)) {\n            // Attempt: make choice, update state\n            duplicated.Add(choice); // Record the selected element value\n            selected[i] = true;\n            state.Add(choice);\n            // Proceed to the next round of selection\n            Backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.RemoveAt(state.Count - 1);\n        }\n    }\n}\n\n/* Permutations II */\nList&lt;List&lt;int&gt;&gt; PermutationsII(int[] nums) {\n    List&lt;List&lt;int&gt;&gt; res = [];\n    Backtrack([], nums, new bool[nums.Length], res);\n    return res;\n}\n</code></pre> permutations_ii.go<pre><code>/* Backtracking algorithm: Permutations II */\nfunc backtrackII(state *[]int, choices *[]int, selected *[]bool, res *[][]int) {\n    // When the state length equals the number of elements, record the solution\n    if len(*state) == len(*choices) {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n    }\n    // Traverse all choices\n    duplicated := make(map[int]struct{}, 0)\n    for i := 0; i &lt; len(*choices); i++ {\n        choice := (*choices)[i]\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if _, ok := duplicated[choice]; !ok &amp;&amp; !(*selected)[i] {\n            // Attempt: make choice, update state\n            // Record the selected element value\n            duplicated[choice] = struct{}{}\n            (*selected)[i] = true\n            *state = append(*state, choice)\n            // Proceed to the next round of selection\n            backtrackII(state, choices, selected, res)\n            // Backtrack: undo choice, restore to previous state\n            (*selected)[i] = false\n            *state = (*state)[:len(*state)-1]\n        }\n    }\n}\n\n/* Permutations II */\nfunc permutationsII(nums []int) [][]int {\n    res := make([][]int, 0)\n    state := make([]int, 0)\n    selected := make([]bool, len(nums))\n    backtrackII(&amp;state, &amp;nums, &amp;selected, &amp;res)\n    return res\n}\n</code></pre> permutations_ii.swift<pre><code>/* Backtracking algorithm: Permutations II */\nfunc backtrack(state: inout [Int], choices: [Int], selected: inout [Bool], res: inout [[Int]]) {\n    // When the state length equals the number of elements, record the solution\n    if state.count == choices.count {\n        res.append(state)\n        return\n    }\n    // Traverse all choices\n    var duplicated: Set&lt;Int&gt; = []\n    for (i, choice) in choices.enumerated() {\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if !selected[i], !duplicated.contains(choice) {\n            // Attempt: make choice, update state\n            duplicated.insert(choice) // Record the selected element value\n            selected[i] = true\n            state.append(choice)\n            // Proceed to the next round of selection\n            backtrack(state: &amp;state, choices: choices, selected: &amp;selected, res: &amp;res)\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false\n            state.removeLast()\n        }\n    }\n}\n\n/* Permutations II */\nfunc permutationsII(nums: [Int]) -&gt; [[Int]] {\n    var state: [Int] = []\n    var selected = Array(repeating: false, count: nums.count)\n    var res: [[Int]] = []\n    backtrack(state: &amp;state, choices: nums, selected: &amp;selected, res: &amp;res)\n    return res\n}\n</code></pre> permutations_ii.js<pre><code>/* Backtracking algorithm: Permutations II */\nfunction backtrack(state, choices, selected, res) {\n    // When the state length equals the number of elements, record the solution\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    const duplicated = new Set();\n    choices.forEach((choice, i) =&gt; {\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if (!selected[i] &amp;&amp; !duplicated.has(choice)) {\n            // Attempt: make choice, update state\n            duplicated.add(choice); // Record the selected element value\n            selected[i] = true;\n            state.push(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* Permutations II */\nfunction permutationsII(nums) {\n    const res = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_ii.ts<pre><code>/* Backtracking algorithm: Permutations II */\nfunction backtrack(\n    state: number[],\n    choices: number[],\n    selected: boolean[],\n    res: number[][]\n): void {\n    // When the state length equals the number of elements, record the solution\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    const duplicated = new Set();\n    choices.forEach((choice, i) =&gt; {\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if (!selected[i] &amp;&amp; !duplicated.has(choice)) {\n            // Attempt: make choice, update state\n            duplicated.add(choice); // Record the selected element value\n            selected[i] = true;\n            state.push(choice);\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* Permutations II */\nfunction permutationsII(nums: number[]): number[][] {\n    const res: number[][] = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_ii.dart<pre><code>/* Backtracking algorithm: Permutations II */\nvoid backtrack(\n  List&lt;int&gt; state,\n  List&lt;int&gt; choices,\n  List&lt;bool&gt; selected,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // When the state length equals the number of elements, record the solution\n  if (state.length == choices.length) {\n    res.add(List.from(state));\n    return;\n  }\n  // Traverse all choices\n  Set&lt;int&gt; duplicated = {};\n  for (int i = 0; i &lt; choices.length; i++) {\n    int choice = choices[i];\n    // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n    if (!selected[i] &amp;&amp; !duplicated.contains(choice)) {\n      // Attempt: make choice, update state\n      duplicated.add(choice); // Record the selected element value\n      selected[i] = true;\n      state.add(choice);\n      // Proceed to the next round of selection\n      backtrack(state, choices, selected, res);\n      // Backtrack: undo choice, restore to previous state\n      selected[i] = false;\n      state.removeLast();\n    }\n  }\n}\n\n/* Permutations II */\nList&lt;List&lt;int&gt;&gt; permutationsII(List&lt;int&gt; nums) {\n  List&lt;List&lt;int&gt;&gt; res = [];\n  backtrack([], nums, List.filled(nums.length, false), res);\n  return res;\n}\n</code></pre> permutations_ii.rs<pre><code>/* Backtracking algorithm: Permutations II */\nfn backtrack(mut state: Vec&lt;i32&gt;, choices: &amp;[i32], selected: &amp;mut [bool], res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n    // When the state length equals the number of elements, record the solution\n    if state.len() == choices.len() {\n        res.push(state);\n        return;\n    }\n    // Traverse all choices\n    let mut duplicated = HashSet::&lt;i32&gt;::new();\n    for i in 0..choices.len() {\n        let choice = choices[i];\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if !selected[i] &amp;&amp; !duplicated.contains(&amp;choice) {\n            // Attempt: make choice, update state\n            duplicated.insert(choice); // Record the selected element value\n            selected[i] = true;\n            state.push(choice);\n            // Proceed to the next round of selection\n            backtrack(state.clone(), choices, selected, res);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n            state.pop();\n        }\n    }\n}\n\n/* Permutations II */\nfn permutations_ii(nums: &amp;mut [i32]) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut res = Vec::new();\n    backtrack(Vec::new(), nums, &amp;mut vec![false; nums.len()], &amp;mut res);\n    res\n}\n</code></pre> permutations_ii.c<pre><code>/* Backtracking algorithm: Permutations II */\nvoid backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) {\n    // When the state length equals the number of elements, record the solution\n    if (stateSize == choicesSize) {\n        res[*resSize] = (int *)malloc(choicesSize * sizeof(int));\n        for (int i = 0; i &lt; choicesSize; i++) {\n            res[*resSize][i] = state[i];\n        }\n        (*resSize)++;\n        return;\n    }\n    // Traverse all choices\n    bool duplicated[MAX_SIZE] = {false};\n    for (int i = 0; i &lt; choicesSize; i++) {\n        int choice = choices[i];\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if (!selected[i] &amp;&amp; !duplicated[choice]) {\n            // Attempt: make choice, update state\n            duplicated[choice] = true; // Record the selected element value\n            selected[i] = true;\n            state[stateSize] = choice;\n            // Proceed to the next round of selection\n            backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize);\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false;\n        }\n    }\n}\n\n/* Permutations II */\nint **permutationsII(int *nums, int numsSize, int *returnSize) {\n    int *state = (int *)malloc(numsSize * sizeof(int));\n    bool *selected = (bool *)malloc(numsSize * sizeof(bool));\n    for (int i = 0; i &lt; numsSize; i++) {\n        selected[i] = false;\n    }\n    int **res = (int **)malloc(MAX_SIZE * sizeof(int *));\n    *returnSize = 0;\n\n    backtrack(state, 0, nums, numsSize, selected, res, returnSize);\n\n    free(state);\n    free(selected);\n\n    return res;\n}\n</code></pre> permutations_ii.kt<pre><code>/* Backtracking algorithm: Permutations II */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    choices: IntArray,\n    selected: BooleanArray,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // When the state length equals the number of elements, record the solution\n    if (state.size == choices.size) {\n        res.add(state.toMutableList())\n        return\n    }\n    // Traverse all choices\n    val duplicated = HashSet&lt;Int&gt;()\n    for (i in choices.indices) {\n        val choice = choices[i]\n        // Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n        if (!selected[i] &amp;&amp; !duplicated.contains(choice)) {\n            // Attempt: make choice, update state\n            duplicated.add(choice) // Record the selected element value\n            selected[i] = true\n            state.add(choice)\n            // Proceed to the next round of selection\n            backtrack(state, choices, selected, res)\n            // Backtrack: undo choice, restore to previous state\n            selected[i] = false\n            state.removeAt(state.size - 1)\n        }\n    }\n}\n\n/* Permutations II */\nfun permutationsII(nums: IntArray): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;()\n    backtrack(mutableListOf(), nums, BooleanArray(nums.size), res)\n    return res\n}\n</code></pre> permutations_ii.rb<pre><code>### Backtracking: permutations II ###\ndef backtrack(state, choices, selected, res)\n  # When the state length equals the number of elements, record the solution\n  if state.length == choices.length\n    res &lt;&lt; state.dup\n    return\n  end\n\n  # Traverse all choices\n  duplicated = Set.new\n  choices.each_with_index do |choice, i|\n    # Pruning: do not allow repeated selection of elements and do not allow repeated selection of equal elements\n    if !selected[i] &amp;&amp; !duplicated.include?(choice)\n      # Attempt: make choice, update state\n      duplicated.add(choice)\n      selected[i] = true\n      state &lt;&lt; choice\n      # Proceed to the next round of selection\n      backtrack(state, choices, selected, res)\n      # Backtrack: undo choice, restore to previous state\n      selected[i] = false\n      state.pop\n    end\n  end\nend\n\n### Permutations II ###\ndef permutations_ii(nums)\n  res = []\n  backtrack([], nums, Array.new(nums.length, false), res)\n  res\nend\n</code></pre> <p>Assuming elements are pairwise distinct, there are \\(n!\\) (factorial) permutations of \\(n\\) elements. When recording results, we need to copy a list of length \\(n\\), using \\(O(n)\\) time. Therefore, the time complexity is \\(O(n! \\cdot n)\\).</p> <p>The maximum recursion depth is \\(n\\), using \\(O(n)\\) stack frame space. <code>selected</code> uses \\(O(n)\\) space. At most \\(n\\) <code>duplicated</code> sets exist simultaneously, using \\(O(n^2)\\) space. Therefore, the space complexity is \\(O(n^2)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/#3-comparison-of-two-pruning-methods","title":"3. \u00a0 Comparison of Two Pruning Methods","text":"<p>Note that although both <code>selected</code> and <code>duplicated</code> are used for pruning, they have different objectives.</p> <ul> <li>Pruning duplicate choices: There is only one <code>selected</code> throughout the entire search process. It records which elements are included in the current state, and its purpose is to prevent an element from appearing repeatedly in <code>state</code>.</li> <li>Pruning duplicate elements: Each round of choices (each <code>backtrack</code> function call) contains a <code>duplicated</code> set. It records which elements have been chosen in this round's iteration (the <code>for</code> loop), and its purpose is to ensure that equal elements are chosen only once.</li> </ul> <p>Figure 13-9 shows the effective scope of the two pruning conditions. Note that each node in the tree represents a choice, and the nodes on the path from the root to a leaf node form a permutation.</p> <p></p> <p> Figure 13-9 \u00a0 Effective scope of two pruning conditions </p>"},{"location":"chapter_backtracking/subset_sum_problem/","title":"13.3 \u00a0 Subset-Sum Problem","text":""},{"location":"chapter_backtracking/subset_sum_problem/#1331-without-duplicate-elements","title":"13.3.1 \u00a0 Without Duplicate Elements","text":"<p>Question</p> <p>Given a positive integer array <code>nums</code> and a target positive integer <code>target</code>, find all possible combinations where the sum of elements in the combination equals <code>target</code>. The given array has no duplicate elements, and each element can be selected multiple times. Return these combinations in list form, where the list should not contain duplicate combinations.</p> <p>For example, given the set \\(\\{3, 4, 5\\}\\) and target integer \\(9\\), the solutions are \\(\\{3, 3, 3\\}, \\{4, 5\\}\\). Note the following two points:</p> <ul> <li>Elements in the input set can be selected repeatedly without limit.</li> <li>Subsets do not distinguish element order; for example, \\(\\{4, 5\\}\\) and \\(\\{5, 4\\}\\) are the same subset.</li> </ul>"},{"location":"chapter_backtracking/subset_sum_problem/#1-reference-to-full-permutation-solution","title":"1. \u00a0 Reference to Full Permutation Solution","text":"<p>Similar to the full permutation problem, we can imagine the process of generating subsets as a series of choices, and update the \"sum of elements\" in real-time during the selection process. When the sum equals <code>target</code>, we record the subset to the result list.</p> <p>Unlike the full permutation problem, elements in this problem's set can be selected unlimited times, so we do not need to use a <code>selected</code> boolean list to track whether an element has been selected. We can make minor modifications to the full permutation code and initially obtain the solution:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby subset_sum_i_naive.py<pre><code>def backtrack(\n    state: list[int],\n    target: int,\n    total: int,\n    choices: list[int],\n    res: list[list[int]],\n):\n    \"\"\"Backtracking algorithm: Subset sum I\"\"\"\n    # When the subset sum equals target, record the solution\n    if total == target:\n        res.append(list(state))\n        return\n    # Traverse all choices\n    for i in range(len(choices)):\n        # Pruning: if the subset sum exceeds target, skip this choice\n        if total + choices[i] &gt; target:\n            continue\n        # Attempt: make choice, update element sum total\n        state.append(choices[i])\n        # Proceed to the next round of selection\n        backtrack(state, target, total + choices[i], choices, res)\n        # Backtrack: undo choice, restore to previous state\n        state.pop()\n\ndef subset_sum_i_naive(nums: list[int], target: int) -&gt; list[list[int]]:\n    \"\"\"Solve subset sum I (including duplicate subsets)\"\"\"\n    state = []  # State (subset)\n    total = 0  # Subset sum\n    res = []  # Result list (subset list)\n    backtrack(state, target, total, nums, res)\n    return res\n</code></pre> subset_sum_i_naive.cpp<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(vector&lt;int&gt; &amp;state, int target, int total, vector&lt;int&gt; &amp;choices, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // When the subset sum equals target, record the solution\n    if (total == target) {\n        res.push_back(state);\n        return;\n    }\n    // Traverse all choices\n    for (size_t i = 0; i &lt; choices.size(); i++) {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // Attempt: make choice, update element sum total\n        state.push_back(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target, total + choices[i], choices, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop_back();\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nvector&lt;vector&lt;int&gt;&gt; subsetSumINaive(vector&lt;int&gt; &amp;nums, int target) {\n    vector&lt;int&gt; state;       // State (subset)\n    int total = 0;           // Subset sum\n    vector&lt;vector&lt;int&gt;&gt; res; // Result list (subset list)\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.java<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(List&lt;Integer&gt; state, int target, int total, int[] choices, List&lt;List&lt;Integer&gt;&gt; res) {\n    // When the subset sum equals target, record the solution\n    if (total == target) {\n        res.add(new ArrayList&lt;&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; choices.length; i++) {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // Attempt: make choice, update element sum total\n        state.add(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target, total + choices[i], choices, res);\n        // Backtrack: undo choice, restore to previous state\n        state.remove(state.size() - 1);\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nList&lt;List&lt;Integer&gt;&gt; subsetSumINaive(int[] nums, int target) {\n    List&lt;Integer&gt; state = new ArrayList&lt;&gt;(); // State (subset)\n    int total = 0; // Subset sum\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // Result list (subset list)\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.cs<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid Backtrack(List&lt;int&gt; state, int target, int total, int[] choices, List&lt;List&lt;int&gt;&gt; res) {\n    // When the subset sum equals target, record the solution\n    if (total == target) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; choices.Length; i++) {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // Attempt: make choice, update element sum total\n        state.Add(choices[i]);\n        // Proceed to the next round of selection\n        Backtrack(state, target, total + choices[i], choices, res);\n        // Backtrack: undo choice, restore to previous state\n        state.RemoveAt(state.Count - 1);\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nList&lt;List&lt;int&gt;&gt; SubsetSumINaive(int[] nums, int target) {\n    List&lt;int&gt; state = []; // State (subset)\n    int total = 0; // Subset sum\n    List&lt;List&lt;int&gt;&gt; res = []; // Result list (subset list)\n    Backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.go<pre><code>/* Backtracking algorithm: Subset sum I */\nfunc backtrackSubsetSumINaive(total, target int, state, choices *[]int, res *[][]int) {\n    // When the subset sum equals target, record the solution\n    if target == total {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n        return\n    }\n    // Traverse all choices\n    for i := 0; i &lt; len(*choices); i++ {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if total+(*choices)[i] &gt; target {\n            continue\n        }\n        // Attempt: make choice, update element sum total\n        *state = append(*state, (*choices)[i])\n        // Proceed to the next round of selection\n        backtrackSubsetSumINaive(total+(*choices)[i], target, state, choices, res)\n        // Backtrack: undo choice, restore to previous state\n        *state = (*state)[:len(*state)-1]\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nfunc subsetSumINaive(nums []int, target int) [][]int {\n    state := make([]int, 0) // State (subset)\n    total := 0              // Subset sum\n    res := make([][]int, 0) // Result list (subset list)\n    backtrackSubsetSumINaive(total, target, &amp;state, &amp;nums, &amp;res)\n    return res\n}\n</code></pre> subset_sum_i_naive.swift<pre><code>/* Backtracking algorithm: Subset sum I */\nfunc backtrack(state: inout [Int], target: Int, total: Int, choices: [Int], res: inout [[Int]]) {\n    // When the subset sum equals target, record the solution\n    if total == target {\n        res.append(state)\n        return\n    }\n    // Traverse all choices\n    for i in choices.indices {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if total + choices[i] &gt; target {\n            continue\n        }\n        // Attempt: make choice, update element sum total\n        state.append(choices[i])\n        // Proceed to the next round of selection\n        backtrack(state: &amp;state, target: target, total: total + choices[i], choices: choices, res: &amp;res)\n        // Backtrack: undo choice, restore to previous state\n        state.removeLast()\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nfunc subsetSumINaive(nums: [Int], target: Int) -&gt; [[Int]] {\n    var state: [Int] = [] // State (subset)\n    let total = 0 // Subset sum\n    var res: [[Int]] = [] // Result list (subset list)\n    backtrack(state: &amp;state, target: target, total: total, choices: nums, res: &amp;res)\n    return res\n}\n</code></pre> subset_sum_i_naive.js<pre><code>/* Backtracking algorithm: Subset sum I */\nfunction backtrack(state, target, total, choices, res) {\n    // When the subset sum equals target, record the solution\n    if (total === target) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    for (let i = 0; i &lt; choices.length; i++) {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // Attempt: make choice, update element sum total\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target, total + choices[i], choices, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nfunction subsetSumINaive(nums, target) {\n    const state = []; // State (subset)\n    const total = 0; // Subset sum\n    const res = []; // Result list (subset list)\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.ts<pre><code>/* Backtracking algorithm: Subset sum I */\nfunction backtrack(\n    state: number[],\n    target: number,\n    total: number,\n    choices: number[],\n    res: number[][]\n): void {\n    // When the subset sum equals target, record the solution\n    if (total === target) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    for (let i = 0; i &lt; choices.length; i++) {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // Attempt: make choice, update element sum total\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target, total + choices[i], choices, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nfunction subsetSumINaive(nums: number[], target: number): number[][] {\n    const state = []; // State (subset)\n    const total = 0; // Subset sum\n    const res = []; // Result list (subset list)\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.dart<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(\n  List&lt;int&gt; state,\n  int target,\n  int total,\n  List&lt;int&gt; choices,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // When the subset sum equals target, record the solution\n  if (total == target) {\n    res.add(List.from(state));\n    return;\n  }\n  // Traverse all choices\n  for (int i = 0; i &lt; choices.length; i++) {\n    // Pruning: if the subset sum exceeds target, skip this choice\n    if (total + choices[i] &gt; target) {\n      continue;\n    }\n    // Attempt: make choice, update element sum total\n    state.add(choices[i]);\n    // Proceed to the next round of selection\n    backtrack(state, target, total + choices[i], choices, res);\n    // Backtrack: undo choice, restore to previous state\n    state.removeLast();\n  }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nList&lt;List&lt;int&gt;&gt; subsetSumINaive(List&lt;int&gt; nums, int target) {\n  List&lt;int&gt; state = []; // State (subset)\n  int total = 0; // Sum of elements\n  List&lt;List&lt;int&gt;&gt; res = []; // Result list (subset list)\n  backtrack(state, target, total, nums, res);\n  return res;\n}\n</code></pre> subset_sum_i_naive.rs<pre><code>/* Backtracking algorithm: Subset sum I */\nfn backtrack(\n    state: &amp;mut Vec&lt;i32&gt;,\n    target: i32,\n    total: i32,\n    choices: &amp;[i32],\n    res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,\n) {\n    // When the subset sum equals target, record the solution\n    if total == target {\n        res.push(state.clone());\n        return;\n    }\n    // Traverse all choices\n    for i in 0..choices.len() {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if total + choices[i] &gt; target {\n            continue;\n        }\n        // Attempt: make choice, update element sum total\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target, total + choices[i], choices, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nfn subset_sum_i_naive(nums: &amp;[i32], target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut state = Vec::new(); // State (subset)\n    let total = 0; // Subset sum\n    let mut res = Vec::new(); // Result list (subset list)\n    backtrack(&amp;mut state, target, total, nums, &amp;mut res);\n    res\n}\n</code></pre> subset_sum_i_naive.c<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(int target, int total, int *choices, int choicesSize) {\n    // When the subset sum equals target, record the solution\n    if (total == target) {\n        for (int i = 0; i &lt; stateSize; i++) {\n            res[resSize][i] = state[i];\n        }\n        resColSizes[resSize++] = stateSize;\n        return;\n    }\n    // Traverse all choices\n    for (int i = 0; i &lt; choicesSize; i++) {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // Attempt: make choice, update element sum total\n        state[stateSize++] = choices[i];\n        // Proceed to the next round of selection\n        backtrack(target, total + choices[i], choices, choicesSize);\n        // Backtrack: undo choice, restore to previous state\n        stateSize--;\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nvoid subsetSumINaive(int *nums, int numsSize, int target) {\n    resSize = 0; // Initialize solution count to 0\n    backtrack(target, 0, nums, numsSize);\n}\n</code></pre> subset_sum_i_naive.kt<pre><code>/* Backtracking algorithm: Subset sum I */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    target: Int,\n    total: Int,\n    choices: IntArray,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // When the subset sum equals target, record the solution\n    if (total == target) {\n        res.add(state.toMutableList())\n        return\n    }\n    // Traverse all choices\n    for (i in choices.indices) {\n        // Pruning: if the subset sum exceeds target, skip this choice\n        if (total + choices[i] &gt; target) {\n            continue\n        }\n        // Attempt: make choice, update element sum total\n        state.add(choices[i])\n        // Proceed to the next round of selection\n        backtrack(state, target, total + choices[i], choices, res)\n        // Backtrack: undo choice, restore to previous state\n        state.removeAt(state.size - 1)\n    }\n}\n\n/* Solve subset sum I (including duplicate subsets) */\nfun subsetSumINaive(nums: IntArray, target: Int): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val state = mutableListOf&lt;Int&gt;() // State (subset)\n    val total = 0 // Subset sum\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;() // Result list (subset list)\n    backtrack(state, target, total, nums, res)\n    return res\n}\n</code></pre> subset_sum_i_naive.rb<pre><code>### Backtracking: subset sum I ###\ndef backtrack(state, target, total, choices, res)\n  # When the subset sum equals target, record the solution\n  if total == target\n    res &lt;&lt; state.dup\n    return\n  end\n\n  # Traverse all choices\n  for i in 0...choices.length\n    # Pruning: if the subset sum exceeds target, skip this choice\n    next if total + choices[i] &gt; target\n    # Attempt: make choice, update element sum total\n    state &lt;&lt; choices[i]\n    # Proceed to the next round of selection\n    backtrack(state, target, total + choices[i], choices, res)\n    # Backtrack: undo choice, restore to previous state\n    state.pop\n  end\nend\n\n### Solve subset sum I (with duplicate subsets) ###\ndef subset_sum_i_naive(nums, target)\n  state = [] # State (subset)\n  total = 0 # Subset sum\n  res = [] # Result list (subset list)\n  backtrack(state, target, total, nums, res)\n  res\nend\n</code></pre> <p>When we input array \\([3, 4, 5]\\) and target element \\(9\\) to the above code, the output is \\([3, 3, 3], [4, 5], [5, 4]\\). Although we successfully find all subsets that sum to \\(9\\), there are duplicate subsets \\([4, 5]\\) and \\([5, 4]\\).</p> <p>This is because the search process distinguishes the order of selections, but subsets do not distinguish selection order. As shown in Figure 13-10, selecting 4 first and then 5 versus selecting 5 first and then 4 are different branches, but they correspond to the same subset.</p> <p></p> <p> Figure 13-10 \u00a0 Subset search and boundary pruning </p> <p>To eliminate duplicate subsets, one straightforward idea is to deduplicate the result list. However, this approach is very inefficient for two reasons:</p> <ul> <li>When there are many array elements, especially when <code>target</code> is large, the search process generates many duplicate subsets.</li> <li>Comparing subsets (arrays) is very time-consuming, requiring sorting the arrays first, then comparing each element in them.</li> </ul>"},{"location":"chapter_backtracking/subset_sum_problem/#2-pruning-duplicate-subsets","title":"2. \u00a0 Pruning Duplicate Subsets","text":"<p>We consider deduplication through pruning during the search process. Observing Figure 13-11, duplicate subsets occur when array elements are selected in different orders, as in the following cases:</p> <ol> <li>When the first and second rounds select \\(3\\) and \\(4\\) respectively, all subsets containing these two elements are generated, denoted as \\([3, 4, \\dots]\\).</li> <li>Afterward, when the first round selects \\(4\\), the second round should skip \\(3\\), because the subset \\([4, 3, \\dots]\\) generated by this choice is completely duplicate with the subset generated in step <code>1.</code></li> </ol> <p>In the search process, each level's choices are tried from left to right, so the rightmost branches are pruned more.</p> <ol> <li>The first two rounds select \\(3\\) and \\(5\\), generating subset \\([3, 5, \\dots]\\).</li> <li>The first two rounds select \\(4\\) and \\(5\\), generating subset \\([4, 5, \\dots]\\).</li> <li>If the first round selects \\(5\\), the second round should skip \\(3\\) and \\(4\\), because subsets \\([5, 3, \\dots]\\) and \\([5, 4, \\dots]\\) are completely duplicate with the subsets described in steps <code>1.</code> and <code>2.</code></li> </ol> <p></p> <p> Figure 13-11 \u00a0 Different selection orders leading to duplicate subsets </p> <p>In summary, given an input array \\([x_1, x_2, \\dots, x_n]\\), let the selection sequence in the search process be \\([x_{i_1}, x_{i_2}, \\dots, x_{i_m}]\\). This selection sequence must satisfy \\(i_1 \\leq i_2 \\leq \\dots \\leq i_m\\); any selection sequence that does not satisfy this condition will cause duplicates and should be pruned.</p>"},{"location":"chapter_backtracking/subset_sum_problem/#3-code-implementation","title":"3. \u00a0 Code Implementation","text":"<p>To implement this pruning, we initialize a variable <code>start</code> to indicate the starting point of traversal. After making choice \\(x_{i}\\), set the next round to start traversal from index \\(i\\). This ensures that the selection sequence satisfies \\(i_1 \\leq i_2 \\leq \\dots \\leq i_m\\), guaranteeing subset uniqueness.</p> <p>In addition, we have made the following two optimizations to the code:</p> <ul> <li>Before starting the search, first sort the array <code>nums</code>. When traversing all choices, end the loop immediately when the subset sum exceeds <code>target</code>, because subsequent elements are larger, and their subset sums must exceed <code>target</code>.</li> <li>Omit the element sum variable <code>total</code> and use subtraction on <code>target</code> to track the sum of elements. Record the solution when <code>target</code> equals \\(0\\).</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby subset_sum_i.py<pre><code>def backtrack(\n    state: list[int], target: int, choices: list[int], start: int, res: list[list[int]]\n):\n    \"\"\"Backtracking algorithm: Subset sum I\"\"\"\n    # When the subset sum equals target, record the solution\n    if target == 0:\n        res.append(list(state))\n        return\n    # Traverse all choices\n    # Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for i in range(start, len(choices)):\n        # Pruning 1: if the subset sum exceeds target, end the loop directly\n        # This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target - choices[i] &lt; 0:\n            break\n        # Attempt: make choice, update target, start\n        state.append(choices[i])\n        # Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i, res)\n        # Backtrack: undo choice, restore to previous state\n        state.pop()\n\ndef subset_sum_i(nums: list[int], target: int) -&gt; list[list[int]]:\n    \"\"\"Solve subset sum I\"\"\"\n    state = []  # State (subset)\n    nums.sort()  # Sort nums\n    start = 0  # Start point for traversal\n    res = []  # Result list (subset list)\n    backtrack(state, target, nums, start, res)\n    return res\n</code></pre> subset_sum_i.cpp<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(vector&lt;int&gt; &amp;state, int target, vector&lt;int&gt; &amp;choices, int start, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.push_back(state);\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for (int i = start; i &lt; choices.size(); i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Attempt: make choice, update target, start\n        state.push_back(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop_back();\n    }\n}\n\n/* Solve subset sum I */\nvector&lt;vector&lt;int&gt;&gt; subsetSumI(vector&lt;int&gt; &amp;nums, int target) {\n    vector&lt;int&gt; state;              // State (subset)\n    sort(nums.begin(), nums.end()); // Sort nums\n    int start = 0;                  // Start point for traversal\n    vector&lt;vector&lt;int&gt;&gt; res;        // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.java<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(List&lt;Integer&gt; state, int target, int[] choices, int start, List&lt;List&lt;Integer&gt;&gt; res) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.add(new ArrayList&lt;&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for (int i = start; i &lt; choices.length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Attempt: make choice, update target, start\n        state.add(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i, res);\n        // Backtrack: undo choice, restore to previous state\n        state.remove(state.size() - 1);\n    }\n}\n\n/* Solve subset sum I */\nList&lt;List&lt;Integer&gt;&gt; subsetSumI(int[] nums, int target) {\n    List&lt;Integer&gt; state = new ArrayList&lt;&gt;(); // State (subset)\n    Arrays.sort(nums); // Sort nums\n    int start = 0; // Start point for traversal\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.cs<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid Backtrack(List&lt;int&gt; state, int target, int[] choices, int start, List&lt;List&lt;int&gt;&gt; res) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for (int i = start; i &lt; choices.Length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Attempt: make choice, update target, start\n        state.Add(choices[i]);\n        // Proceed to the next round of selection\n        Backtrack(state, target - choices[i], choices, i, res);\n        // Backtrack: undo choice, restore to previous state\n        state.RemoveAt(state.Count - 1);\n    }\n}\n\n/* Solve subset sum I */\nList&lt;List&lt;int&gt;&gt; SubsetSumI(int[] nums, int target) {\n    List&lt;int&gt; state = []; // State (subset)\n    Array.Sort(nums); // Sort nums\n    int start = 0; // Start point for traversal\n    List&lt;List&lt;int&gt;&gt; res = []; // Result list (subset list)\n    Backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.go<pre><code>/* Backtracking algorithm: Subset sum I */\nfunc backtrackSubsetSumI(start, target int, state, choices *[]int, res *[][]int) {\n    // When the subset sum equals target, record the solution\n    if target == 0 {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n        return\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for i := start; i &lt; len(*choices); i++ {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target-(*choices)[i] &lt; 0 {\n            break\n        }\n        // Attempt: make choice, update target, start\n        *state = append(*state, (*choices)[i])\n        // Proceed to the next round of selection\n        backtrackSubsetSumI(i, target-(*choices)[i], state, choices, res)\n        // Backtrack: undo choice, restore to previous state\n        *state = (*state)[:len(*state)-1]\n    }\n}\n\n/* Solve subset sum I */\nfunc subsetSumI(nums []int, target int) [][]int {\n    state := make([]int, 0) // State (subset)\n    sort.Ints(nums)         // Sort nums\n    start := 0              // Start point for traversal\n    res := make([][]int, 0) // Result list (subset list)\n    backtrackSubsetSumI(start, target, &amp;state, &amp;nums, &amp;res)\n    return res\n}\n</code></pre> subset_sum_i.swift<pre><code>/* Backtracking algorithm: Subset sum I */\nfunc backtrack(state: inout [Int], target: Int, choices: [Int], start: Int, res: inout [[Int]]) {\n    // When the subset sum equals target, record the solution\n    if target == 0 {\n        res.append(state)\n        return\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for i in choices.indices.dropFirst(start) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target - choices[i] &lt; 0 {\n            break\n        }\n        // Attempt: make choice, update target, start\n        state.append(choices[i])\n        // Proceed to the next round of selection\n        backtrack(state: &amp;state, target: target - choices[i], choices: choices, start: i, res: &amp;res)\n        // Backtrack: undo choice, restore to previous state\n        state.removeLast()\n    }\n}\n\n/* Solve subset sum I */\nfunc subsetSumI(nums: [Int], target: Int) -&gt; [[Int]] {\n    var state: [Int] = [] // State (subset)\n    let nums = nums.sorted() // Sort nums\n    let start = 0 // Start point for traversal\n    var res: [[Int]] = [] // Result list (subset list)\n    backtrack(state: &amp;state, target: target, choices: nums, start: start, res: &amp;res)\n    return res\n}\n</code></pre> subset_sum_i.js<pre><code>/* Backtracking algorithm: Subset sum I */\nfunction backtrack(state, target, choices, start, res) {\n    // When the subset sum equals target, record the solution\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for (let i = start; i &lt; choices.length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Attempt: make choice, update target, start\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum I */\nfunction subsetSumI(nums, target) {\n    const state = []; // State (subset)\n    nums.sort((a, b) =&gt; a - b); // Sort nums\n    const start = 0; // Start point for traversal\n    const res = []; // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.ts<pre><code>/* Backtracking algorithm: Subset sum I */\nfunction backtrack(\n    state: number[],\n    target: number,\n    choices: number[],\n    start: number,\n    res: number[][]\n): void {\n    // When the subset sum equals target, record the solution\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for (let i = start; i &lt; choices.length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Attempt: make choice, update target, start\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum I */\nfunction subsetSumI(nums: number[], target: number): number[][] {\n    const state = []; // State (subset)\n    nums.sort((a, b) =&gt; a - b); // Sort nums\n    const start = 0; // Start point for traversal\n    const res = []; // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.dart<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(\n  List&lt;int&gt; state,\n  int target,\n  List&lt;int&gt; choices,\n  int start,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // When the subset sum equals target, record the solution\n  if (target == 0) {\n    res.add(List.from(state));\n    return;\n  }\n  // Traverse all choices\n  // Pruning 2: start traversing from start to avoid generating duplicate subsets\n  for (int i = start; i &lt; choices.length; i++) {\n    // Pruning 1: if the subset sum exceeds target, end the loop directly\n    // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n    if (target - choices[i] &lt; 0) {\n      break;\n    }\n    // Attempt: make choice, update target, start\n    state.add(choices[i]);\n    // Proceed to the next round of selection\n    backtrack(state, target - choices[i], choices, i, res);\n    // Backtrack: undo choice, restore to previous state\n    state.removeLast();\n  }\n}\n\n/* Solve subset sum I */\nList&lt;List&lt;int&gt;&gt; subsetSumI(List&lt;int&gt; nums, int target) {\n  List&lt;int&gt; state = []; // State (subset)\n  nums.sort(); // Sort nums\n  int start = 0; // Start point for traversal\n  List&lt;List&lt;int&gt;&gt; res = []; // Result list (subset list)\n  backtrack(state, target, nums, start, res);\n  return res;\n}\n</code></pre> subset_sum_i.rs<pre><code>/* Backtracking algorithm: Subset sum I */\nfn backtrack(\n    state: &amp;mut Vec&lt;i32&gt;,\n    target: i32,\n    choices: &amp;[i32],\n    start: usize,\n    res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,\n) {\n    // When the subset sum equals target, record the solution\n    if target == 0 {\n        res.push(state.clone());\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for i in start..choices.len() {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target - choices[i] &lt; 0 {\n            break;\n        }\n        // Attempt: make choice, update target, start\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum I */\nfn subset_sum_i(nums: &amp;mut [i32], target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut state = Vec::new(); // State (subset)\n    nums.sort(); // Sort nums\n    let start = 0; // Start point for traversal\n    let mut res = Vec::new(); // Result list (subset list)\n    backtrack(&amp;mut state, target, nums, start, &amp;mut res);\n    res\n}\n</code></pre> subset_sum_i.c<pre><code>/* Backtracking algorithm: Subset sum I */\nvoid backtrack(int target, int *choices, int choicesSize, int start) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        for (int i = 0; i &lt; stateSize; ++i) {\n            res[resSize][i] = state[i];\n        }\n        resColSizes[resSize++] = stateSize;\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for (int i = start; i &lt; choicesSize; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Attempt: make choice, update target, start\n        state[stateSize] = choices[i];\n        stateSize++;\n        // Proceed to the next round of selection\n        backtrack(target - choices[i], choices, choicesSize, i);\n        // Backtrack: undo choice, restore to previous state\n        stateSize--;\n    }\n}\n\n/* Solve subset sum I */\nvoid subsetSumI(int *nums, int numsSize, int target) {\n    qsort(nums, numsSize, sizeof(int), cmp); // Sort nums\n    int start = 0;                           // Start point for traversal\n    backtrack(target, nums, numsSize, start);\n}\n</code></pre> subset_sum_i.kt<pre><code>/* Backtracking algorithm: Subset sum I */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    target: Int,\n    choices: IntArray,\n    start: Int,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.add(state.toMutableList())\n        return\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    for (i in start..&lt;choices.size) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break\n        }\n        // Attempt: make choice, update target, start\n        state.add(choices[i])\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i, res)\n        // Backtrack: undo choice, restore to previous state\n        state.removeAt(state.size - 1)\n    }\n}\n\n/* Solve subset sum I */\nfun subsetSumI(nums: IntArray, target: Int): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val state = mutableListOf&lt;Int&gt;() // State (subset)\n    nums.sort() // Sort nums\n    val start = 0 // Start point for traversal\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;() // Result list (subset list)\n    backtrack(state, target, nums, start, res)\n    return res\n}\n</code></pre> subset_sum_i.rb<pre><code>### Backtracking: subset sum I ###\ndef backtrack(state, target, choices, start, res)\n  # When the subset sum equals target, record the solution\n  if target.zero?\n    res &lt;&lt; state.dup\n    return\n  end\n  # Traverse all choices\n  # Pruning 2: start traversing from start to avoid generating duplicate subsets\n  for i in start...choices.length\n    # Pruning 1: if the subset sum exceeds target, end the loop directly\n    # This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n    break if target - choices[i] &lt; 0\n    # Attempt: make choice, update target, start\n    state &lt;&lt; choices[i]\n    # Proceed to the next round of selection\n    backtrack(state, target - choices[i], choices, i, res)\n    # Backtrack: undo choice, restore to previous state\n    state.pop\n  end\nend\n\n### Solve subset sum I ###\ndef subset_sum_i(nums, target)\n  state = [] # State (subset)\n  nums.sort! # Sort nums\n  start = 0 # Start point for traversal\n  res = [] # Result list (subset list)\n  backtrack(state, target, nums, start, res)\n  res\nend\n</code></pre> <p>Figure 13-12 shows the complete backtracking process when array \\([3, 4, 5]\\) and target element \\(9\\) are input to the above code.</p> <p></p> <p> Figure 13-12 \u00a0 Subset-sum I backtracking process </p>"},{"location":"chapter_backtracking/subset_sum_problem/#1332-with-duplicate-elements-in-array","title":"13.3.2 \u00a0 With Duplicate Elements in Array","text":"<p>Question</p> <p>Given a positive integer array <code>nums</code> and a target positive integer <code>target</code>, find all possible combinations where the sum of elements in the combination equals <code>target</code>. The given array may contain duplicate elements, and each element can be selected at most once. Return these combinations in list form, where the list should not contain duplicate combinations.</p> <p>Compared to the previous problem, the input array in this problem may contain duplicate elements, which introduces new challenges. For example, given array \\([4, \\hat{4}, 5]\\) and target element \\(9\\), the output of the existing code is \\([4, 5], [\\hat{4}, 5]\\), which contains duplicate subsets.</p> <p>The reason for this duplication is that equal elements are selected multiple times in a certain round. In Figure 13-13, the first round has three choices, two of which are \\(4\\), creating two duplicate search branches that output duplicate subsets. Similarly, the two \\(4\\)'s in the second round also produce duplicate subsets.</p> <p></p> <p> Figure 13-13 \u00a0 Duplicate subsets caused by equal elements </p>"},{"location":"chapter_backtracking/subset_sum_problem/#1-pruning-equal-elements","title":"1. \u00a0 Pruning Equal Elements","text":"<p>To solve this problem, we need to limit equal elements to be selected only once in each round. The implementation is quite clever: since the array is already sorted, equal elements are adjacent. This means that in a certain round of selection, if the current element equals the element to its left, it means this element has already been selected, so we skip the current element directly.</p> <p>At the same time, this problem specifies that each array element can only be selected once. Fortunately, we can also use the variable <code>start</code> to satisfy this constraint: after making choice \\(x_{i}\\), set the next round to start traversal from index \\(i + 1\\) onwards. This both eliminates duplicate subsets and avoids selecting elements multiple times.</p>"},{"location":"chapter_backtracking/subset_sum_problem/#2-code-implementation","title":"2. \u00a0 Code Implementation","text":"PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby subset_sum_ii.py<pre><code>def backtrack(\n    state: list[int], target: int, choices: list[int], start: int, res: list[list[int]]\n):\n    \"\"\"Backtracking algorithm: Subset sum II\"\"\"\n    # When the subset sum equals target, record the solution\n    if target == 0:\n        res.append(list(state))\n        return\n    # Traverse all choices\n    # Pruning 2: start traversing from start to avoid generating duplicate subsets\n    # Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for i in range(start, len(choices)):\n        # Pruning 1: if the subset sum exceeds target, end the loop directly\n        # This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target - choices[i] &lt; 0:\n            break\n        # Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if i &gt; start and choices[i] == choices[i - 1]:\n            continue\n        # Attempt: make choice, update target, start\n        state.append(choices[i])\n        # Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i + 1, res)\n        # Backtrack: undo choice, restore to previous state\n        state.pop()\n\ndef subset_sum_ii(nums: list[int], target: int) -&gt; list[list[int]]:\n    \"\"\"Solve subset sum II\"\"\"\n    state = []  # State (subset)\n    nums.sort()  # Sort nums\n    start = 0  # Start point for traversal\n    res = []  # Result list (subset list)\n    backtrack(state, target, nums, start, res)\n    return res\n</code></pre> subset_sum_ii.cpp<pre><code>/* Backtracking algorithm: Subset sum II */\nvoid backtrack(vector&lt;int&gt; &amp;state, int target, vector&lt;int&gt; &amp;choices, int start, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.push_back(state);\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for (int i = start; i &lt; choices.size(); i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // Attempt: make choice, update target, start\n        state.push_back(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop_back();\n    }\n}\n\n/* Solve subset sum II */\nvector&lt;vector&lt;int&gt;&gt; subsetSumII(vector&lt;int&gt; &amp;nums, int target) {\n    vector&lt;int&gt; state;              // State (subset)\n    sort(nums.begin(), nums.end()); // Sort nums\n    int start = 0;                  // Start point for traversal\n    vector&lt;vector&lt;int&gt;&gt; res;        // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.java<pre><code>/* Backtracking algorithm: Subset sum II */\nvoid backtrack(List&lt;Integer&gt; state, int target, int[] choices, int start, List&lt;List&lt;Integer&gt;&gt; res) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.add(new ArrayList&lt;&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for (int i = start; i &lt; choices.length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // Attempt: make choice, update target, start\n        state.add(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // Backtrack: undo choice, restore to previous state\n        state.remove(state.size() - 1);\n    }\n}\n\n/* Solve subset sum II */\nList&lt;List&lt;Integer&gt;&gt; subsetSumII(int[] nums, int target) {\n    List&lt;Integer&gt; state = new ArrayList&lt;&gt;(); // State (subset)\n    Arrays.sort(nums); // Sort nums\n    int start = 0; // Start point for traversal\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.cs<pre><code>/* Backtracking algorithm: Subset sum II */\nvoid Backtrack(List&lt;int&gt; state, int target, int[] choices, int start, List&lt;List&lt;int&gt;&gt; res) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for (int i = start; i &lt; choices.Length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // Attempt: make choice, update target, start\n        state.Add(choices[i]);\n        // Proceed to the next round of selection\n        Backtrack(state, target - choices[i], choices, i + 1, res);\n        // Backtrack: undo choice, restore to previous state\n        state.RemoveAt(state.Count - 1);\n    }\n}\n\n/* Solve subset sum II */\nList&lt;List&lt;int&gt;&gt; SubsetSumII(int[] nums, int target) {\n    List&lt;int&gt; state = []; // State (subset)\n    Array.Sort(nums); // Sort nums\n    int start = 0; // Start point for traversal\n    List&lt;List&lt;int&gt;&gt; res = []; // Result list (subset list)\n    Backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.go<pre><code>/* Backtracking algorithm: Subset sum II */\nfunc backtrackSubsetSumII(start, target int, state, choices *[]int, res *[][]int) {\n    // When the subset sum equals target, record the solution\n    if target == 0 {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n        return\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for i := start; i &lt; len(*choices); i++ {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target-(*choices)[i] &lt; 0 {\n            break\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if i &gt; start &amp;&amp; (*choices)[i] == (*choices)[i-1] {\n            continue\n        }\n        // Attempt: make choice, update target, start\n        *state = append(*state, (*choices)[i])\n        // Proceed to the next round of selection\n        backtrackSubsetSumII(i+1, target-(*choices)[i], state, choices, res)\n        // Backtrack: undo choice, restore to previous state\n        *state = (*state)[:len(*state)-1]\n    }\n}\n\n/* Solve subset sum II */\nfunc subsetSumII(nums []int, target int) [][]int {\n    state := make([]int, 0) // State (subset)\n    sort.Ints(nums)         // Sort nums\n    start := 0              // Start point for traversal\n    res := make([][]int, 0) // Result list (subset list)\n    backtrackSubsetSumII(start, target, &amp;state, &amp;nums, &amp;res)\n    return res\n}\n</code></pre> subset_sum_ii.swift<pre><code>/* Backtracking algorithm: Subset sum II */\nfunc backtrack(state: inout [Int], target: Int, choices: [Int], start: Int, res: inout [[Int]]) {\n    // When the subset sum equals target, record the solution\n    if target == 0 {\n        res.append(state)\n        return\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for i in choices.indices.dropFirst(start) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target - choices[i] &lt; 0 {\n            break\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if i &gt; start, choices[i] == choices[i - 1] {\n            continue\n        }\n        // Attempt: make choice, update target, start\n        state.append(choices[i])\n        // Proceed to the next round of selection\n        backtrack(state: &amp;state, target: target - choices[i], choices: choices, start: i + 1, res: &amp;res)\n        // Backtrack: undo choice, restore to previous state\n        state.removeLast()\n    }\n}\n\n/* Solve subset sum II */\nfunc subsetSumII(nums: [Int], target: Int) -&gt; [[Int]] {\n    var state: [Int] = [] // State (subset)\n    let nums = nums.sorted() // Sort nums\n    let start = 0 // Start point for traversal\n    var res: [[Int]] = [] // Result list (subset list)\n    backtrack(state: &amp;state, target: target, choices: nums, start: start, res: &amp;res)\n    return res\n}\n</code></pre> subset_sum_ii.js<pre><code>/* Backtracking algorithm: Subset sum II */\nfunction backtrack(state, target, choices, start, res) {\n    // When the subset sum equals target, record the solution\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for (let i = start; i &lt; choices.length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if (i &gt; start &amp;&amp; choices[i] === choices[i - 1]) {\n            continue;\n        }\n        // Attempt: make choice, update target, start\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum II */\nfunction subsetSumII(nums, target) {\n    const state = []; // State (subset)\n    nums.sort((a, b) =&gt; a - b); // Sort nums\n    const start = 0; // Start point for traversal\n    const res = []; // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.ts<pre><code>/* Backtracking algorithm: Subset sum II */\nfunction backtrack(\n    state: number[],\n    target: number,\n    choices: number[],\n    start: number,\n    res: number[][]\n): void {\n    // When the subset sum equals target, record the solution\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for (let i = start; i &lt; choices.length; i++) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if (i &gt; start &amp;&amp; choices[i] === choices[i - 1]) {\n            continue;\n        }\n        // Attempt: make choice, update target, start\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum II */\nfunction subsetSumII(nums: number[], target: number): number[][] {\n    const state = []; // State (subset)\n    nums.sort((a, b) =&gt; a - b); // Sort nums\n    const start = 0; // Start point for traversal\n    const res = []; // Result list (subset list)\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.dart<pre><code>/* Backtracking algorithm: Subset sum II */\nvoid backtrack(\n  List&lt;int&gt; state,\n  int target,\n  List&lt;int&gt; choices,\n  int start,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // When the subset sum equals target, record the solution\n  if (target == 0) {\n    res.add(List.from(state));\n    return;\n  }\n  // Traverse all choices\n  // Pruning 2: start traversing from start to avoid generating duplicate subsets\n  // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n  for (int i = start; i &lt; choices.length; i++) {\n    // Pruning 1: if the subset sum exceeds target, end the loop directly\n    // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n    if (target - choices[i] &lt; 0) {\n      break;\n    }\n    // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n    if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n      continue;\n    }\n    // Attempt: make choice, update target, start\n    state.add(choices[i]);\n    // Proceed to the next round of selection\n    backtrack(state, target - choices[i], choices, i + 1, res);\n    // Backtrack: undo choice, restore to previous state\n    state.removeLast();\n  }\n}\n\n/* Solve subset sum II */\nList&lt;List&lt;int&gt;&gt; subsetSumII(List&lt;int&gt; nums, int target) {\n  List&lt;int&gt; state = []; // State (subset)\n  nums.sort(); // Sort nums\n  int start = 0; // Start point for traversal\n  List&lt;List&lt;int&gt;&gt; res = []; // Result list (subset list)\n  backtrack(state, target, nums, start, res);\n  return res;\n}\n</code></pre> subset_sum_ii.rs<pre><code>/* Backtracking algorithm: Subset sum II */\nfn backtrack(\n    state: &amp;mut Vec&lt;i32&gt;,\n    target: i32,\n    choices: &amp;[i32],\n    start: usize,\n    res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,\n) {\n    // When the subset sum equals target, record the solution\n    if target == 0 {\n        res.push(state.clone());\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for i in start..choices.len() {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if target - choices[i] &lt; 0 {\n            break;\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if i &gt; start &amp;&amp; choices[i] == choices[i - 1] {\n            continue;\n        }\n        // Attempt: make choice, update target, start\n        state.push(choices[i]);\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // Backtrack: undo choice, restore to previous state\n        state.pop();\n    }\n}\n\n/* Solve subset sum II */\nfn subset_sum_ii(nums: &amp;mut [i32], target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut state = Vec::new(); // State (subset)\n    nums.sort(); // Sort nums\n    let start = 0; // Start point for traversal\n    let mut res = Vec::new(); // Result list (subset list)\n    backtrack(&amp;mut state, target, nums, start, &amp;mut res);\n    res\n}\n</code></pre> subset_sum_ii.c<pre><code>/* Backtracking algorithm: Subset sum II */\nvoid backtrack(int target, int *choices, int choicesSize, int start) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        for (int i = 0; i &lt; stateSize; i++) {\n            res[resSize][i] = state[i];\n        }\n        resColSizes[resSize++] = stateSize;\n        return;\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for (int i = start; i &lt; choicesSize; i++) {\n        // Pruning 1: Skip if subset sum exceeds target\n        if (target - choices[i] &lt; 0) {\n            continue;\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // Attempt: make choice, update target, start\n        state[stateSize] = choices[i];\n        stateSize++;\n        // Proceed to the next round of selection\n        backtrack(target - choices[i], choices, choicesSize, i + 1);\n        // Backtrack: undo choice, restore to previous state\n        stateSize--;\n    }\n}\n\n/* Solve subset sum II */\nvoid subsetSumII(int *nums, int numsSize, int target) {\n    // Sort nums\n    qsort(nums, numsSize, sizeof(int), cmp);\n    // Start backtracking\n    backtrack(target, nums, numsSize, 0);\n}\n</code></pre> subset_sum_ii.kt<pre><code>/* Backtracking algorithm: Subset sum II */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    target: Int,\n    choices: IntArray,\n    start: Int,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // When the subset sum equals target, record the solution\n    if (target == 0) {\n        res.add(state.toMutableList())\n        return\n    }\n    // Traverse all choices\n    // Pruning 2: start traversing from start to avoid generating duplicate subsets\n    // Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n    for (i in start..&lt;choices.size) {\n        // Pruning 1: if the subset sum exceeds target, end the loop directly\n        // This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n        if (target - choices[i] &lt; 0) {\n            break\n        }\n        // Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue\n        }\n        // Attempt: make choice, update target, start\n        state.add(choices[i])\n        // Proceed to the next round of selection\n        backtrack(state, target - choices[i], choices, i + 1, res)\n        // Backtrack: undo choice, restore to previous state\n        state.removeAt(state.size - 1)\n    }\n}\n\n/* Solve subset sum II */\nfun subsetSumII(nums: IntArray, target: Int): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val state = mutableListOf&lt;Int&gt;() // State (subset)\n    nums.sort() // Sort nums\n    val start = 0 // Start point for traversal\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;() // Result list (subset list)\n    backtrack(state, target, nums, start, res)\n    return res\n}\n</code></pre> subset_sum_ii.rb<pre><code>### Backtracking: subset sum II ###\ndef backtrack(state, target, choices, start, res)\n  # When the subset sum equals target, record the solution\n  if target.zero?\n    res &lt;&lt; state.dup\n    return\n  end\n\n  # Traverse all choices\n  # Pruning 2: start traversing from start to avoid generating duplicate subsets\n  # Pruning 3: start traversing from start to avoid repeatedly selecting the same element\n  for i in start...choices.length\n    # Pruning 1: if the subset sum exceeds target, end the loop directly\n    # This is because the array is sorted, and later elements are larger, so the subset sum will definitely exceed target\n    break if target - choices[i] &lt; 0\n    # Pruning 4: if this element equals the left element, it means this search branch is duplicate, skip it directly\n    next if i &gt; start &amp;&amp; choices[i] == choices[i - 1]\n    # Attempt: make choice, update target, start\n    state &lt;&lt; choices[i]\n    # Proceed to the next round of selection\n    backtrack(state, target - choices[i], choices, i + 1, res)\n    # Backtrack: undo choice, restore to previous state\n    state.pop\n  end\nend\n\n### Solve subset sum II ###\ndef subset_sum_ii(nums, target)\n  state = [] # State (subset)\n  nums.sort! # Sort nums\n  start = 0 # Start point for traversal\n  res = [] # Result list (subset list)\n  backtrack(state, target, nums, start, res)\n  res\nend\n</code></pre> <p>Figure 13-14 shows the backtracking process for array \\([4, 4, 5]\\) and target element \\(9\\), which includes four types of pruning operations. Combine the illustration with the code comments to understand the entire search process and how each pruning operation works.</p> <p></p> <p> Figure 13-14 \u00a0 Subset-sum II backtracking process </p>"},{"location":"chapter_backtracking/summary/","title":"13.5 \u00a0 Summary","text":""},{"location":"chapter_backtracking/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>The backtracking algorithm is fundamentally an exhaustive search method. It finds solutions that meet specified conditions by performing a depth-first traversal of the solution space. During the search process, when a solution satisfying the conditions is found, it is recorded. The search ends either after finding all solutions or when the traversal is complete.</li> <li>The backtracking algorithm search process consists of two parts: attempting and backtracking. It tries various choices through depth-first search. When encountering situations that violate constraints, it reverts the previous choice, returns to the previous state, and continues exploring other options. Attempting and backtracking are operations in opposite directions.</li> <li>Backtracking problems typically contain multiple constraints, which can be utilized to implement pruning operations. Pruning can terminate unnecessary search branches early, significantly improving search efficiency.</li> <li>The backtracking algorithm is primarily used to solve search problems and constraint satisfaction problems. While combinatorial optimization problems can be solved with backtracking, there are often more efficient or better-performing solutions available.</li> <li>The permutation problem aims to find all possible permutations of elements in a given set. We use an array to record whether each element has been selected, thereby pruning search branches that attempt to select the same element repeatedly, ensuring each element is selected exactly once.</li> <li>In the permutation problem, if the set contains duplicate elements, the final result will contain duplicate permutations. We need to impose a constraint so that equal elements can only be selected once per round, which is typically achieved using a hash set.</li> <li>The subset-sum problem aims to find all subsets of a given set that sum to a target value. Since the set is unordered but the search process outputs results in all orders, duplicate subsets are generated. We sort the data before backtracking and use a variable to indicate the starting point of each round's traversal, thereby pruning search branches that generate duplicate subsets.</li> <li>For the subset-sum problem, equal elements in the array produce duplicate sets. We leverage the precondition that the array is sorted by checking whether adjacent elements are equal to implement pruning, ensuring that equal elements can only be selected once per round.</li> <li>The \\(n\\) queens problem aims to find placements of \\(n\\) queens on an \\(n \\times n\\) chessboard such that no two queens can attack each other. The constraints of this problem include row constraints, column constraints, and main and anti-diagonal constraints. To satisfy row constraints, we adopt a row-by-row placement strategy, ensuring exactly one queen is placed in each row.</li> <li>The handling of column constraints and diagonal constraints is similar. For column constraints, we use an array to record whether each column has a queen, thereby indicating whether a selected cell is valid. For diagonal constraints, we use two arrays to separately record whether queens exist on each main or anti-diagonal. The challenge lies in finding the row-column index pattern that characterizes cells on the same main (anti-)diagonal.</li> </ul>"},{"location":"chapter_backtracking/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: How should we understand the relationship between backtracking and recursion?</p> <p>Overall, backtracking is an \"algorithm strategy\", while recursion is more like a \"tool\".</p> <ul> <li>The backtracking algorithm is typically implemented based on recursion. However, backtracking is one application scenario of recursion and represents the application of recursion in search problems.</li> <li>The structure of recursion embodies the \"subproblem decomposition\" problem-solving paradigm, commonly used to solve problems involving divide-and-conquer, backtracking, and dynamic programming (memoized recursion).</li> </ul>"},{"location":"chapter_computational_complexity/","title":"Chapter 2. \u00a0 Complexity Analysis","text":"<p>Abstract</p> <p>Complexity analysis is like a space-time guide in the vast universe of algorithms.</p> <p>It leads us to explore deeply within the two dimensions of time and space, seeking more elegant solutions.</p>"},{"location":"chapter_computational_complexity/#chapter-contents","title":"Chapter contents","text":"<ul> <li>2.1 \u00a0 Algorithm Efficiency Evaluation</li> <li>2.2 \u00a0 Iteration and Recursion</li> <li>2.3 \u00a0 Time Complexity</li> <li>2.4 \u00a0 Space Complexity</li> <li>2.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/","title":"2.2 \u00a0 Iteration and Recursion","text":"<p>In algorithms, repeatedly executing a task is very common and closely related to complexity analysis. Therefore, before introducing time complexity and space complexity, let's first understand how to implement repeated task execution in programs, namely the two basic program control structures: iteration and recursion.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#221-iteration","title":"2.2.1 \u00a0 Iteration","text":"<p>Iteration is a control structure for repeatedly executing a task. In iteration, a program repeatedly executes a segment of code under certain conditions until those conditions are no longer satisfied.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#1-for-loop","title":"1. \u00a0 For Loop","text":"<p>The <code>for</code> loop is one of the most common forms of iteration, suitable for use when the number of iterations is known in advance.</p> <p>The following function implements the summation \\(1 + 2 + \\dots + n\\) based on a <code>for</code> loop, with the sum result recorded using the variable <code>res</code>. Note that in Python, <code>range(a, b)</code> corresponds to a \"left-closed, right-open\" interval, with the traversal range being \\(a, a + 1, \\dots, b-1\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby iteration.py<pre><code>def for_loop(n: int) -&gt; int:\n    \"\"\"for loop\"\"\"\n    res = 0\n    # Sum 1, 2, ..., n-1, n\n    for i in range(1, n + 1):\n        res += i\n    return res\n</code></pre> iteration.cpp<pre><code>/* for loop */\nint forLoop(int n) {\n    int res = 0;\n    // Sum 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; ++i) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* for loop */\nint forLoop(int n) {\n    int res = 0;\n    // Sum 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* for loop */\nint ForLoop(int n) {\n    int res = 0;\n    // Sum 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* for loop */\nfunc forLoop(n int) int {\n    res := 0\n    // Sum 1, 2, ..., n-1, n\n    for i := 1; i &lt;= n; i++ {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* for loop */\nfunc forLoop(n: Int) -&gt; Int {\n    var res = 0\n    // Sum 1, 2, ..., n-1, n\n    for i in 1 ... n {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* for loop */\nfunction forLoop(n) {\n    let res = 0;\n    // Sum 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* for loop */\nfunction forLoop(n: number): number {\n    let res = 0;\n    // Sum 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* for loop */\nint forLoop(int n) {\n  int res = 0;\n  // Sum 1, 2, ..., n-1, n\n  for (int i = 1; i &lt;= n; i++) {\n    res += i;\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* for loop */\nfn for_loop(n: i32) -&gt; i32 {\n    let mut res = 0;\n    // Sum 1, 2, ..., n-1, n\n    for i in 1..=n {\n        res += i;\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* for loop */\nint forLoop(int n) {\n    int res = 0;\n    // Sum 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* for loop */\nfun forLoop(n: Int): Int {\n    var res = 0\n    // Sum 1, 2, ..., n-1, n\n    for (i in 1..n) {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.rb<pre><code>### for loop ###\ndef for_loop(n)\n  res = 0\n\n  # Sum 1, 2, ..., n-1, n\n  for i in 1..n\n    res += i\n  end\n\n  res\nend\n</code></pre> <p>Figure 2-1 shows the flowchart of this summation function.</p> <p></p> <p> Figure 2-1 \u00a0 Flowchart of the summation function </p> <p>The number of operations in this summation function is proportional to the input data size \\(n\\), or has a \"linear relationship\". In fact, time complexity describes precisely this \"linear relationship\". Related content will be introduced in detail in the next section.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#2-while-loop","title":"2. \u00a0 While Loop","text":"<p>Similar to the <code>for</code> loop, the <code>while</code> loop is also a method for implementing iteration. In a <code>while</code> loop, the program first checks the condition in each round; if the condition is true, it continues execution, otherwise it ends the loop.</p> <p>Below we use a <code>while</code> loop to implement the summation \\(1 + 2 + \\dots + n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby iteration.py<pre><code>def while_loop(n: int) -&gt; int:\n    \"\"\"while loop\"\"\"\n    res = 0\n    i = 1  # Initialize condition variable\n    # Sum 1, 2, ..., n-1, n\n    while i &lt;= n:\n        res += i\n        i += 1  # Update condition variable\n    return res\n</code></pre> iteration.cpp<pre><code>/* while loop */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // Update condition variable\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* while loop */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // Update condition variable\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* while loop */\nint WhileLoop(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i += 1; // Update condition variable\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* while loop */\nfunc whileLoop(n int) int {\n    res := 0\n    // Initialize condition variable\n    i := 1\n    // Sum 1, 2, ..., n-1, n\n    for i &lt;= n {\n        res += i\n        // Update condition variable\n        i++\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* while loop */\nfunc whileLoop(n: Int) -&gt; Int {\n    var res = 0\n    var i = 1 // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while i &lt;= n {\n        res += i\n        i += 1 // Update condition variable\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* while loop */\nfunction whileLoop(n) {\n    let res = 0;\n    let i = 1; // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // Update condition variable\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* while loop */\nfunction whileLoop(n: number): number {\n    let res = 0;\n    let i = 1; // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // Update condition variable\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* while loop */\nint whileLoop(int n) {\n  int res = 0;\n  int i = 1; // Initialize condition variable\n  // Sum 1, 2, ..., n-1, n\n  while (i &lt;= n) {\n    res += i;\n    i++; // Update condition variable\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* while loop */\nfn while_loop(n: i32) -&gt; i32 {\n    let mut res = 0;\n    let mut i = 1; // Initialize condition variable\n\n    // Sum 1, 2, ..., n-1, n\n    while i &lt;= n {\n        res += i;\n        i += 1; // Update condition variable\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* while loop */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // Update condition variable\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* while loop */\nfun whileLoop(n: Int): Int {\n    var res = 0\n    var i = 1 // Initialize condition variable\n    // Sum 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i\n        i++ // Update condition variable\n    }\n    return res\n}\n</code></pre> iteration.rb<pre><code>### while loop ###\ndef while_loop(n)\n  res = 0\n  i = 1 # Initialize condition variable\n\n  # Sum 1, 2, ..., n-1, n\n  while i &lt;= n\n    res += i\n    i += 1 # Update condition variable\n  end\n\n  res\nend\n</code></pre> <p>The <code>while</code> loop has greater flexibility than the <code>for</code> loop. In a <code>while</code> loop, we can freely design the initialization and update steps of the condition variable.</p> <p>For example, in the following code, the condition variable \\(i\\) is updated twice per round, which is not convenient to implement using a <code>for</code> loop:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby iteration.py<pre><code>def while_loop_ii(n: int) -&gt; int:\n    \"\"\"while loop (two updates)\"\"\"\n    res = 0\n    i = 1  # Initialize condition variable\n    # Sum 1, 4, 10, ...\n    while i &lt;= n:\n        res += i\n        # Update condition variable\n        i += 1\n        i *= 2\n    return res\n</code></pre> iteration.cpp<pre><code>/* while loop (two updates) */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // Update condition variable\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* while loop (two updates) */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // Update condition variable\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* while loop (two updates) */\nint WhileLoopII(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // Update condition variable\n        i += 1; \n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* while loop (two updates) */\nfunc whileLoopII(n int) int {\n    res := 0\n    // Initialize condition variable\n    i := 1\n    // Sum 1, 4, 10, ...\n    for i &lt;= n {\n        res += i\n        // Update condition variable\n        i++\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* while loop (two updates) */\nfunc whileLoopII(n: Int) -&gt; Int {\n    var res = 0\n    var i = 1 // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while i &lt;= n {\n        res += i\n        // Update condition variable\n        i += 1\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* while loop (two updates) */\nfunction whileLoopII(n) {\n    let res = 0;\n    let i = 1; // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // Update condition variable\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* while loop (two updates) */\nfunction whileLoopII(n: number): number {\n    let res = 0;\n    let i = 1; // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // Update condition variable\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* while loop (two updates) */\nint whileLoopII(int n) {\n  int res = 0;\n  int i = 1; // Initialize condition variable\n  // Sum 1, 4, 10, ...\n  while (i &lt;= n) {\n    res += i;\n    // Update condition variable\n    i++;\n    i *= 2;\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* while loop (two updates) */\nfn while_loop_ii(n: i32) -&gt; i32 {\n    let mut res = 0;\n    let mut i = 1; // Initialize condition variable\n\n    // Sum 1, 4, 10, ...\n    while i &lt;= n {\n        res += i;\n        // Update condition variable\n        i += 1;\n        i *= 2;\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* while loop (two updates) */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // Update condition variable\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* while loop (two updates) */\nfun whileLoopII(n: Int): Int {\n    var res = 0\n    var i = 1 // Initialize condition variable\n    // Sum 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i\n        // Update condition variable\n        i++\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.rb<pre><code>### while loop (two updates) ###\ndef while_loop_ii(n)\n  res = 0\n  i = 1 # Initialize condition variable\n\n  # Sum 1, 4, 10, ...\n  while i &lt;= n\n    res += i\n    # Update condition variable\n    i += 1\n    i *= 2\n  end\n\n  res\nend\n</code></pre> <p>Overall, <code>for</code> loops have more compact code, while <code>while</code> loops are more flexible; both can implement iterative structures. The choice of which to use should be determined based on the requirements of the specific problem.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#3-nested-loops","title":"3. \u00a0 Nested Loops","text":"<p>We can nest one loop structure inside another. Below is an example using <code>for</code> loops:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby iteration.py<pre><code>def nested_for_loop(n: int) -&gt; str:\n    \"\"\"Nested for loop\"\"\"\n    res = \"\"\n    # Loop i = 1, 2, ..., n-1, n\n    for i in range(1, n + 1):\n        # Loop j = 1, 2, ..., n-1, n\n        for j in range(1, n + 1):\n            res += f\"({i}, {j}), \"\n    return res\n</code></pre> iteration.cpp<pre><code>/* Nested for loop */\nstring nestedForLoop(int n) {\n    ostringstream res;\n    // Loop i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; ++i) {\n        // Loop j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; ++j) {\n            res &lt;&lt; \"(\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \"), \";\n        }\n    }\n    return res.str();\n}\n</code></pre> iteration.java<pre><code>/* Nested for loop */\nString nestedForLoop(int n) {\n    StringBuilder res = new StringBuilder();\n    // Loop i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // Loop j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            res.append(\"(\" + i + \", \" + j + \"), \");\n        }\n    }\n    return res.toString();\n}\n</code></pre> iteration.cs<pre><code>/* Nested for loop */\nstring NestedForLoop(int n) {\n    StringBuilder res = new();\n    // Loop i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // Loop j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            res.Append($\"({i}, {j}), \");\n        }\n    }\n    return res.ToString();\n}\n</code></pre> iteration.go<pre><code>/* Nested for loop */\nfunc nestedForLoop(n int) string {\n    res := \"\"\n    // Loop i = 1, 2, ..., n-1, n\n    for i := 1; i &lt;= n; i++ {\n        for j := 1; j &lt;= n; j++ {\n            // Loop j = 1, 2, ..., n-1, n\n            res += fmt.Sprintf(\"(%d, %d), \", i, j)\n        }\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* Nested for loop */\nfunc nestedForLoop(n: Int) -&gt; String {\n    var res = \"\"\n    // Loop i = 1, 2, ..., n-1, n\n    for i in 1 ... n {\n        // Loop j = 1, 2, ..., n-1, n\n        for j in 1 ... n {\n            res.append(\"(\\(i), \\(j)), \")\n        }\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* Nested for loop */\nfunction nestedForLoop(n) {\n    let res = '';\n    // Loop i = 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        // Loop j = 1, 2, ..., n-1, n\n        for (let j = 1; j &lt;= n; j++) {\n            res += `(${i}, ${j}), `;\n        }\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* Nested for loop */\nfunction nestedForLoop(n: number): string {\n    let res = '';\n    // Loop i = 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        // Loop j = 1, 2, ..., n-1, n\n        for (let j = 1; j &lt;= n; j++) {\n            res += `(${i}, ${j}), `;\n        }\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* Nested for loop */\nString nestedForLoop(int n) {\n  String res = \"\";\n  // Loop i = 1, 2, ..., n-1, n\n  for (int i = 1; i &lt;= n; i++) {\n    // Loop j = 1, 2, ..., n-1, n\n    for (int j = 1; j &lt;= n; j++) {\n      res += \"($i, $j), \";\n    }\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* Nested for loop */\nfn nested_for_loop(n: i32) -&gt; String {\n    let mut res = vec![];\n    // Loop i = 1, 2, ..., n-1, n\n    for i in 1..=n {\n        // Loop j = 1, 2, ..., n-1, n\n        for j in 1..=n {\n            res.push(format!(\"({}, {}), \", i, j));\n        }\n    }\n    res.join(\"\")\n}\n</code></pre> iteration.c<pre><code>/* Nested for loop */\nchar *nestedForLoop(int n) {\n    // n * n is the number of points, \"(i, j), \" string max length is 6+10*2, plus extra space for null character \\0\n    int size = n * n * 26 + 1;\n    char *res = malloc(size * sizeof(char));\n    // Loop i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // Loop j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            char tmp[26];\n            snprintf(tmp, sizeof(tmp), \"(%d, %d), \", i, j);\n            strncat(res, tmp, size - strlen(res) - 1);\n        }\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* Nested for loop */\nfun nestedForLoop(n: Int): String {\n    val res = StringBuilder()\n    // Loop i = 1, 2, ..., n-1, n\n    for (i in 1..n) {\n        // Loop j = 1, 2, ..., n-1, n\n        for (j in 1..n) {\n            res.append(\" ($i, $j), \")\n        }\n    }\n    return res.toString()\n}\n</code></pre> iteration.rb<pre><code>### Nested for loop ###\ndef nested_for_loop(n)\n  res = \"\"\n\n  # Loop i = 1, 2, ..., n-1, n\n  for i in 1..n\n    # Loop j = 1, 2, ..., n-1, n\n    for j in 1..n\n      res += \"(#{i}, #{j}), \"\n    end\n  end\n\n  res\nend\n</code></pre> <p>Figure 2-2 shows the flowchart of this nested loop.</p> <p></p> <p> Figure 2-2 \u00a0 Flowchart of nested loops </p> <p>In this case, the number of operations of the function is proportional to \\(n^2\\), or the algorithm's running time has a \"quadratic relationship\" with the input data size \\(n\\).</p> <p>We can continue adding nested loops, where each nesting is a \"dimension increase\", raising the time complexity to \"cubic relationship\", \"quartic relationship\", and so on.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#222-recursion","title":"2.2.2 \u00a0 Recursion","text":"<p>Recursion is an algorithmic strategy that solves problems by having a function call itself. It mainly consists of two phases.</p> <ol> <li>Descend: The program continuously calls itself deeper, usually passing in smaller or more simplified parameters, until reaching a \"termination condition\".</li> <li>Ascend: After triggering the \"termination condition\", the program returns layer by layer from the deepest recursive function, aggregating the result of each layer.</li> </ol> <p>From an implementation perspective, recursive code mainly consists of three elements.</p> <ol> <li>Termination condition: Used to determine when to switch from \"descending\" to \"ascending\".</li> <li>Recursive call: Corresponds to \"descending\", where the function calls itself, usually with smaller or more simplified parameters.</li> <li>Return result: Corresponds to \"ascending\", returning the result of the current recursion level to the previous layer.</li> </ol> <p>Observe the following code. We only need to call the function <code>recur(n)</code> to complete the calculation of \\(1 + 2 + \\dots + n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby recursion.py<pre><code>def recur(n: int) -&gt; int:\n    \"\"\"Recursion\"\"\"\n    # Termination condition\n    if n == 1:\n        return 1\n    # Recurse: recursive call\n    res = recur(n - 1)\n    # Return: return result\n    return n + res\n</code></pre> recursion.cpp<pre><code>/* Recursion */\nint recur(int n) {\n    // Termination condition\n    if (n == 1)\n        return 1;\n    // Recurse: recursive call\n    int res = recur(n - 1);\n    // Return: return result\n    return n + res;\n}\n</code></pre> recursion.java<pre><code>/* Recursion */\nint recur(int n) {\n    // Termination condition\n    if (n == 1)\n        return 1;\n    // Recurse: recursive call\n    int res = recur(n - 1);\n    // Return: return result\n    return n + res;\n}\n</code></pre> recursion.cs<pre><code>/* Recursion */\nint Recur(int n) {\n    // Termination condition\n    if (n == 1)\n        return 1;\n    // Recurse: recursive call\n    int res = Recur(n - 1);\n    // Return: return result\n    return n + res;\n}\n</code></pre> recursion.go<pre><code>/* Recursion */\nfunc recur(n int) int {\n    // Termination condition\n    if n == 1 {\n        return 1\n    }\n    // Recurse: recursive call\n    res := recur(n - 1)\n    // Return: return result\n    return n + res\n}\n</code></pre> recursion.swift<pre><code>/* Recursion */\nfunc recur(n: Int) -&gt; Int {\n    // Termination condition\n    if n == 1 {\n        return 1\n    }\n    // Recurse: recursive call\n    let res = recur(n: n - 1)\n    // Return: return result\n    return n + res\n}\n</code></pre> recursion.js<pre><code>/* Recursion */\nfunction recur(n) {\n    // Termination condition\n    if (n === 1) return 1;\n    // Recurse: recursive call\n    const res = recur(n - 1);\n    // Return: return result\n    return n + res;\n}\n</code></pre> recursion.ts<pre><code>/* Recursion */\nfunction recur(n: number): number {\n    // Termination condition\n    if (n === 1) return 1;\n    // Recurse: recursive call\n    const res = recur(n - 1);\n    // Return: return result\n    return n + res;\n}\n</code></pre> recursion.dart<pre><code>/* Recursion */\nint recur(int n) {\n  // Termination condition\n  if (n == 1) return 1;\n  // Recurse: recursive call\n  int res = recur(n - 1);\n  // Return: return result\n  return n + res;\n}\n</code></pre> recursion.rs<pre><code>/* Recursion */\nfn recur(n: i32) -&gt; i32 {\n    // Termination condition\n    if n == 1 {\n        return 1;\n    }\n    // Recurse: recursive call\n    let res = recur(n - 1);\n    // Return: return result\n    n + res\n}\n</code></pre> recursion.c<pre><code>/* Recursion */\nint recur(int n) {\n    // Termination condition\n    if (n == 1)\n        return 1;\n    // Recurse: recursive call\n    int res = recur(n - 1);\n    // Return: return result\n    return n + res;\n}\n</code></pre> recursion.kt<pre><code>/* Recursion */\nfun recur(n: Int): Int {\n    // Termination condition\n    if (n == 1)\n        return 1\n    // Descend: recursive call\n    val res = recur(n - 1)\n    // Return: return result\n    return n + res\n}\n</code></pre> recursion.rb<pre><code>### Recursion ###\ndef recur(n)\n  # Termination condition\n  return 1 if n == 1\n  # Recurse: recursive call\n  res = recur(n - 1)\n  # Return: return result\n  n + res\nend\n</code></pre> <p>Figure 2-3 shows the recursive process of this function.</p> <p></p> <p> Figure 2-3 \u00a0 Recursive process of the summation function </p> <p>Although from a computational perspective, iteration and recursion can achieve the same results, they represent two completely different paradigms for thinking about and solving problems.</p> <ul> <li>Iteration: Solves problems \"bottom-up\". Starting from the most basic steps, these steps are then repeatedly executed or accumulated until the task is complete.</li> <li>Recursion: Solves problems \"top-down\". The original problem is decomposed into smaller subproblems that have the same form as the original problem. These subproblems continue to be decomposed into even smaller subproblems until reaching the base case (where the solution is known).</li> </ul> <p>Taking the above summation function as an example, let the problem be \\(f(n) = 1 + 2 + \\dots + n\\).</p> <ul> <li>Iteration: Simulates the summation process in a loop, traversing from \\(1\\) to \\(n\\), performing the summation operation in each round to obtain \\(f(n)\\).</li> <li>Recursion: Decomposes the problem into the subproblem \\(f(n) = n + f(n-1)\\), continuously decomposing (recursively) until terminating at the base case \\(f(1) = 1\\).</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#1-call-stack","title":"1. \u00a0 Call Stack","text":"<p>Each time a recursive function calls itself, the system allocates memory for the newly opened function to store local variables, call addresses, and other information. This leads to two consequences.</p> <ul> <li>The function's context data is stored in a memory area called \"stack frame space\", which is not released until the function returns. Therefore, recursion usually consumes more memory space than iteration.</li> <li>Recursive function calls incur additional overhead. Therefore, recursion is usually less time-efficient than loops.</li> </ul> <p>As shown in Figure 2-4, before the termination condition is triggered, there are \\(n\\) unreturned recursive functions existing simultaneously, with a recursion depth of \\(n\\).</p> <p></p> <p> Figure 2-4 \u00a0 Recursion call depth </p> <p>In practice, the recursion depth allowed by programming languages is usually limited, and excessively deep recursion may lead to stack overflow errors.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#2-tail-recursion","title":"2. \u00a0 Tail Recursion","text":"<p>Interestingly, if a function makes the recursive call as the very last step before returning, the function can be optimized by the compiler or interpreter to have space efficiency comparable to iteration. This case is called tail recursion.</p> <ul> <li>Regular recursion: When a function returns to the previous level, it needs to continue executing code, so the system needs to save the context of the previous layer's call.</li> <li>Tail recursion: The recursive call is the last operation before the function returns, meaning that after returning to the previous level, there is no need to continue executing other operations, so the system does not need to save the context of the previous layer's function.</li> </ul> <p>Taking the calculation of \\(1 + 2 + \\dots + n\\) as an example, we can set the result variable <code>res</code> as a function parameter to implement tail recursion:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby recursion.py<pre><code>def tail_recur(n, res):\n    \"\"\"Tail recursion\"\"\"\n    # Termination condition\n    if n == 0:\n        return res\n    # Tail recursive call\n    return tail_recur(n - 1, res + n)\n</code></pre> recursion.cpp<pre><code>/* Tail recursion */\nint tailRecur(int n, int res) {\n    // Termination condition\n    if (n == 0)\n        return res;\n    // Tail recursive call\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.java<pre><code>/* Tail recursion */\nint tailRecur(int n, int res) {\n    // Termination condition\n    if (n == 0)\n        return res;\n    // Tail recursive call\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.cs<pre><code>/* Tail recursion */\nint TailRecur(int n, int res) {\n    // Termination condition\n    if (n == 0)\n        return res;\n    // Tail recursive call\n    return TailRecur(n - 1, res + n);\n}\n</code></pre> recursion.go<pre><code>/* Tail recursion */\nfunc tailRecur(n int, res int) int {\n    // Termination condition\n    if n == 0 {\n        return res\n    }\n    // Tail recursive call\n    return tailRecur(n-1, res+n)\n}\n</code></pre> recursion.swift<pre><code>/* Tail recursion */\nfunc tailRecur(n: Int, res: Int) -&gt; Int {\n    // Termination condition\n    if n == 0 {\n        return res\n    }\n    // Tail recursive call\n    return tailRecur(n: n - 1, res: res + n)\n}\n</code></pre> recursion.js<pre><code>/* Tail recursion */\nfunction tailRecur(n, res) {\n    // Termination condition\n    if (n === 0) return res;\n    // Tail recursive call\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.ts<pre><code>/* Tail recursion */\nfunction tailRecur(n: number, res: number): number {\n    // Termination condition\n    if (n === 0) return res;\n    // Tail recursive call\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.dart<pre><code>/* Tail recursion */\nint tailRecur(int n, int res) {\n  // Termination condition\n  if (n == 0) return res;\n  // Tail recursive call\n  return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.rs<pre><code>/* Tail recursion */\nfn tail_recur(n: i32, res: i32) -&gt; i32 {\n    // Termination condition\n    if n == 0 {\n        return res;\n    }\n    // Tail recursive call\n    tail_recur(n - 1, res + n)\n}\n</code></pre> recursion.c<pre><code>/* Tail recursion */\nint tailRecur(int n, int res) {\n    // Termination condition\n    if (n == 0)\n        return res;\n    // Tail recursive call\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.kt<pre><code>/* Tail recursion */\ntailrec fun tailRecur(n: Int, res: Int): Int {\n    // Add tailrec keyword to enable tail recursion optimization\n    // Termination condition\n    if (n == 0)\n        return res\n    // Tail recursive call\n    return tailRecur(n - 1, res + n)\n}\n</code></pre> recursion.rb<pre><code>### Tail recursion ###\ndef tail_recur(n, res)\n  # Termination condition\n  return res if n == 0\n  # Tail recursive call\n  tail_recur(n - 1, res + n)\nend\n</code></pre> <p>The execution process of tail recursion is shown in Figure 2-5. Comparing regular recursion and tail recursion, the execution point of the summation operation is different.</p> <ul> <li>Regular recursion: The summation operation is performed during the \"ascending\" process, requiring an additional summation operation after each layer returns.</li> <li>Tail recursion: The summation operation is performed during the \"descending\" process; the \"ascending\" process only needs to return layer by layer.</li> </ul> <p></p> <p> Figure 2-5 \u00a0 Tail recursion process </p> <p>Tip</p> <p>Please note that many compilers or interpreters do not support tail recursion optimization. For example, Python does not support tail recursion optimization by default, so even if a function is in tail recursive form, it may still encounter stack overflow issues.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#3-recursion-tree","title":"3. \u00a0 Recursion Tree","text":"<p>When dealing with algorithmic problems related to \"divide and conquer\", recursion often provides a more intuitive approach and more readable code than iteration. Taking the \"Fibonacci sequence\" as an example.</p> <p>Question</p> <p>Given a Fibonacci sequence \\(0, 1, 1, 2, 3, 5, 8, 13, \\dots\\), find the \\(n\\)-th number in the sequence.</p> <p>Let the \\(n\\)-th number of the Fibonacci sequence be \\(f(n)\\). Two conclusions can be easily obtained.</p> <ul> <li>The first two numbers of the sequence are \\(f(1) = 0\\) and \\(f(2) = 1\\).</li> <li>Each number in the sequence is the sum of the previous two numbers, i.e., \\(f(n) = f(n - 1) + f(n - 2)\\).</li> </ul> <p>Following the recurrence relation to make recursive calls, with the first two numbers as termination conditions, we can write the recursive code. Calling <code>fib(n)</code> will give us the \\(n\\)-th number of the Fibonacci sequence:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby recursion.py<pre><code>def fib(n: int) -&gt; int:\n    \"\"\"Fibonacci sequence: recursion\"\"\"\n    # Termination condition f(1) = 0, f(2) = 1\n    if n == 1 or n == 2:\n        return n - 1\n    # Recursive call f(n) = f(n-1) + f(n-2)\n    res = fib(n - 1) + fib(n - 2)\n    # Return result f(n)\n    return res\n</code></pre> recursion.cpp<pre><code>/* Fibonacci sequence: recursion */\nint fib(int n) {\n    // Termination condition f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // Return result f(n)\n    return res;\n}\n</code></pre> recursion.java<pre><code>/* Fibonacci sequence: recursion */\nint fib(int n) {\n    // Termination condition f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // Return result f(n)\n    return res;\n}\n</code></pre> recursion.cs<pre><code>/* Fibonacci sequence: recursion */\nint Fib(int n) {\n    // Termination condition f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    int res = Fib(n - 1) + Fib(n - 2);\n    // Return result f(n)\n    return res;\n}\n</code></pre> recursion.go<pre><code>/* Fibonacci sequence: recursion */\nfunc fib(n int) int {\n    // Termination condition f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1\n    }\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    res := fib(n-1) + fib(n-2)\n    // Return result f(n)\n    return res\n}\n</code></pre> recursion.swift<pre><code>/* Fibonacci sequence: recursion */\nfunc fib(n: Int) -&gt; Int {\n    // Termination condition f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1\n    }\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    let res = fib(n: n - 1) + fib(n: n - 2)\n    // Return result f(n)\n    return res\n}\n</code></pre> recursion.js<pre><code>/* Fibonacci sequence: recursion */\nfunction fib(n) {\n    // Termination condition f(1) = 0, f(2) = 1\n    if (n === 1 || n === 2) return n - 1;\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    const res = fib(n - 1) + fib(n - 2);\n    // Return result f(n)\n    return res;\n}\n</code></pre> recursion.ts<pre><code>/* Fibonacci sequence: recursion */\nfunction fib(n: number): number {\n    // Termination condition f(1) = 0, f(2) = 1\n    if (n === 1 || n === 2) return n - 1;\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    const res = fib(n - 1) + fib(n - 2);\n    // Return result f(n)\n    return res;\n}\n</code></pre> recursion.dart<pre><code>/* Fibonacci sequence: recursion */\nint fib(int n) {\n  // Termination condition f(1) = 0, f(2) = 1\n  if (n == 1 || n == 2) return n - 1;\n  // Recursive call f(n) = f(n-1) + f(n-2)\n  int res = fib(n - 1) + fib(n - 2);\n  // Return result f(n)\n  return res;\n}\n</code></pre> recursion.rs<pre><code>/* Fibonacci sequence: recursion */\nfn fib(n: i32) -&gt; i32 {\n    // Termination condition f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1;\n    }\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    let res = fib(n - 1) + fib(n - 2);\n    // Return result\n    res\n}\n</code></pre> recursion.c<pre><code>/* Fibonacci sequence: recursion */\nint fib(int n) {\n    // Termination condition f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // Return result f(n)\n    return res;\n}\n</code></pre> recursion.kt<pre><code>/* Fibonacci sequence: recursion */\nfun fib(n: Int): Int {\n    // Termination condition f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1\n    // Recursive call f(n) = f(n-1) + f(n-2)\n    val res = fib(n - 1) + fib(n - 2)\n    // Return result f(n)\n    return res\n}\n</code></pre> recursion.rb<pre><code>### Fibonacci sequence: recursion ###\ndef fib(n)\n  # Termination condition f(1) = 0, f(2) = 1\n  return n - 1 if n == 1 || n == 2\n  # Recursive call f(n) = f(n-1) + f(n-2)\n  res = fib(n - 1) + fib(n - 2)\n  # Return result f(n)\n  res\nend\n</code></pre> <p>Observing the above code, we recursively call two functions within the function, meaning that one call produces two call branches. As shown in Figure 2-6, such continuous recursive calling will eventually produce a recursion tree with \\(n\\) levels.</p> <p></p> <p> Figure 2-6 \u00a0 Recursion tree of the Fibonacci sequence </p> <p>Fundamentally, recursion embodies the paradigm of \"decomposing a problem into smaller subproblems\", and this divide-and-conquer strategy is crucial.</p> <ul> <li>From an algorithmic perspective, many important algorithmic strategies such as searching, sorting, backtracking, divide and conquer, and dynamic programming directly or indirectly apply this way of thinking.</li> <li>From a data structure perspective, recursion is naturally suited for handling problems related to linked lists, trees, and graphs, because they are well-suited for analysis using divide-and-conquer thinking.</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#223-comparison-of-the-two","title":"2.2.3 \u00a0 Comparison of the Two","text":"<p>Summarizing the above content, as shown in Table 2-1, iteration and recursion differ in implementation, performance, and applicability.</p> <p> Table 2-1 \u00a0 Comparison of iteration and recursion characteristics </p> Iteration Recursion Implementation Loop structure Function calls itself Time efficiency Generally more efficient, no function call overhead Each function call incurs overhead Memory usage Usually uses a fixed amount of memory space Accumulated function calls may use a large amount of stack frame space Suitable problems Suitable for simple loop tasks, with intuitive and readable code Suitable for subproblem decomposition, such as trees, graphs, divide and conquer, backtracking, etc., with concise and clear code structure <p>Tip</p> <p>If you find the following content difficult to understand, you can review it after reading the \"Stack\" chapter.</p> <p>What is the intrinsic relationship between iteration and recursion? Taking the above recursive function as an example, the summation operation is performed during the \"ascending\" phase of recursion. This means that the function called first actually completes its summation operation last, and this working mechanism is similar to the \"last-in, first-out\" principle of stacks.</p> <p>In fact, recursive terminology such as \"call stack\" and \"stack frame space\" already hints at the close relationship between recursion and stacks.</p> <ol> <li>Descend: When a function is called, the system allocates a new stack frame on the \"call stack\" for that function to store the function's local variables, parameters, return address, and other data.</li> <li>Ascend: When the function completes execution and returns, the corresponding stack frame is removed from the \"call stack\", restoring the execution environment of the previous function.</li> </ol> <p>Therefore, we can use an explicit stack to simulate the behavior of the call stack, thus transforming recursion into iterative form:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby recursion.py<pre><code>def for_loop_recur(n: int) -&gt; int:\n    \"\"\"Simulate recursion using iteration\"\"\"\n    # Use an explicit stack to simulate the system call stack\n    stack = []\n    res = 0\n    # Recurse: recursive call\n    for i in range(n, 0, -1):\n        # Simulate \"recurse\" with \"push\"\n        stack.append(i)\n    # Return: return result\n    while stack:\n        # Simulate \"return\" with \"pop\"\n        res += stack.pop()\n    # res = 1+2+3+...+n\n    return res\n</code></pre> recursion.cpp<pre><code>/* Simulate recursion using iteration */\nint forLoopRecur(int n) {\n    // Use an explicit stack to simulate the system call stack\n    stack&lt;int&gt; stack;\n    int res = 0;\n    // Recurse: recursive call\n    for (int i = n; i &gt; 0; i--) {\n        // Simulate \"recurse\" with \"push\"\n        stack.push(i);\n    }\n    // Return: return result\n    while (!stack.empty()) {\n        // Simulate \"return\" with \"pop\"\n        res += stack.top();\n        stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.java<pre><code>/* Simulate recursion using iteration */\nint forLoopRecur(int n) {\n    // Use an explicit stack to simulate the system call stack\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    int res = 0;\n    // Recurse: recursive call\n    for (int i = n; i &gt; 0; i--) {\n        // Simulate \"recurse\" with \"push\"\n        stack.push(i);\n    }\n    // Return: return result\n    while (!stack.isEmpty()) {\n        // Simulate \"return\" with \"pop\"\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.cs<pre><code>/* Simulate recursion using iteration */\nint ForLoopRecur(int n) {\n    // Use an explicit stack to simulate the system call stack\n    Stack&lt;int&gt; stack = new();\n    int res = 0;\n    // Recurse: recursive call\n    for (int i = n; i &gt; 0; i--) {\n        // Simulate \"recurse\" with \"push\"\n        stack.Push(i);\n    }\n    // Return: return result\n    while (stack.Count &gt; 0) {\n        // Simulate \"return\" with \"pop\"\n        res += stack.Pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.go<pre><code>/* Simulate recursion using iteration */\nfunc forLoopRecur(n int) int {\n    // Use an explicit stack to simulate the system call stack\n    stack := list.New()\n    res := 0\n    // Recurse: recursive call\n    for i := n; i &gt; 0; i-- {\n        // Simulate \"recurse\" with \"push\"\n        stack.PushBack(i)\n    }\n    // Return: return result\n    for stack.Len() != 0 {\n        // Simulate \"return\" with \"pop\"\n        res += stack.Back().Value.(int)\n        stack.Remove(stack.Back())\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.swift<pre><code>/* Simulate recursion using iteration */\nfunc forLoopRecur(n: Int) -&gt; Int {\n    // Use an explicit stack to simulate the system call stack\n    var stack: [Int] = []\n    var res = 0\n    // Recurse: recursive call\n    for i in (1 ... n).reversed() {\n        // Simulate \"recurse\" with \"push\"\n        stack.append(i)\n    }\n    // Return: return result\n    while !stack.isEmpty {\n        // Simulate \"return\" with \"pop\"\n        res += stack.removeLast()\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.js<pre><code>/* Simulate recursion using iteration */\nfunction forLoopRecur(n) {\n    // Use an explicit stack to simulate the system call stack\n    const stack = [];\n    let res = 0;\n    // Recurse: recursive call\n    for (let i = n; i &gt; 0; i--) {\n        // Simulate \"recurse\" with \"push\"\n        stack.push(i);\n    }\n    // Return: return result\n    while (stack.length) {\n        // Simulate \"return\" with \"pop\"\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.ts<pre><code>/* Simulate recursion using iteration */\nfunction forLoopRecur(n: number): number {\n    // Use an explicit stack to simulate the system call stack\n    const stack: number[] = [];\n    let res: number = 0;\n    // Recurse: recursive call\n    for (let i = n; i &gt; 0; i--) {\n        // Simulate \"recurse\" with \"push\"\n        stack.push(i);\n    }\n    // Return: return result\n    while (stack.length) {\n        // Simulate \"return\" with \"pop\"\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.dart<pre><code>/* Simulate recursion using iteration */\nint forLoopRecur(int n) {\n  // Use an explicit stack to simulate the system call stack\n  List&lt;int&gt; stack = [];\n  int res = 0;\n  // Recurse: recursive call\n  for (int i = n; i &gt; 0; i--) {\n    // Simulate \"recurse\" with \"push\"\n    stack.add(i);\n  }\n  // Return: return result\n  while (!stack.isEmpty) {\n    // Simulate \"return\" with \"pop\"\n    res += stack.removeLast();\n  }\n  // res = 1+2+3+...+n\n  return res;\n}\n</code></pre> recursion.rs<pre><code>/* Simulate recursion using iteration */\nfn for_loop_recur(n: i32) -&gt; i32 {\n    // Use an explicit stack to simulate the system call stack\n    let mut stack = Vec::new();\n    let mut res = 0;\n    // Recurse: recursive call\n    for i in (1..=n).rev() {\n        // Simulate \"recurse\" with \"push\"\n        stack.push(i);\n    }\n    // Return: return result\n    while !stack.is_empty() {\n        // Simulate \"return\" with \"pop\"\n        res += stack.pop().unwrap();\n    }\n    // res = 1+2+3+...+n\n    res\n}\n</code></pre> recursion.c<pre><code>/* Simulate recursion using iteration */\nint forLoopRecur(int n) {\n    int stack[1000]; // Use a large array to simulate stack\n    int top = -1;    // Stack top index\n    int res = 0;\n    // Recurse: recursive call\n    for (int i = n; i &gt; 0; i--) {\n        // Simulate \"recurse\" with \"push\"\n        stack[1 + top++] = i;\n    }\n    // Return: return result\n    while (top &gt;= 0) {\n        // Simulate \"return\" with \"pop\"\n        res += stack[top--];\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.kt<pre><code>/* Simulate recursion using iteration */\nfun forLoopRecur(n: Int): Int {\n    // Use an explicit stack to simulate the system call stack\n    val stack = Stack&lt;Int&gt;()\n    var res = 0\n    // Descend: recursive call\n    for (i in n downTo 0) {\n        // Simulate \"recurse\" with \"push\"\n        stack.push(i)\n    }\n    // Return: return result\n    while (stack.isNotEmpty()) {\n        // Simulate \"return\" with \"pop\"\n        res += stack.pop()\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.rb<pre><code>### Use iteration to simulate recursion ###\ndef for_loop_recur(n)\n  # Use an explicit stack to simulate the system call stack\n  stack = []\n  res = 0\n\n  # Recurse: recursive call\n  for i in n.downto(0)\n    # Simulate \"recurse\" with \"push\"\n    stack &lt;&lt; i\n  end\n  # Return: return result\n  while !stack.empty?\n    res += stack.pop\n  end\n\n  # res = 1+2+3+...+n\n  res\nend\n</code></pre> <p>Observing the above code, when recursion is transformed into iteration, the code becomes more complex. Although iteration and recursion can be converted into each other in many cases, it may not be worthwhile to do so for the following two reasons.</p> <ul> <li>The transformed code may be more difficult to understand and less readable.</li> <li>For some complex problems, simulating the behavior of the system call stack can be very difficult.</li> </ul> <p>In summary, choosing between iteration and recursion depends on the nature of the specific problem. In programming practice, it is crucial to weigh the pros and cons of both and choose the appropriate method based on the context.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/","title":"2.1 \u00a0 Algorithm Efficiency Evaluation","text":"<p>In algorithm design, we pursue the following two levels of objectives sequentially.</p> <ol> <li>Finding a solution to the problem: The algorithm must reliably obtain the correct solution within the specified input range.</li> <li>Seeking the optimal solution: Multiple solutions may exist for the same problem, and we hope to find an algorithm that is as efficient as possible.</li> </ol> <p>In other words, under the premise of being able to solve the problem, algorithm efficiency has become the primary evaluation criterion for measuring the quality of algorithms. It includes the following two dimensions.</p> <ul> <li>Time efficiency: The length of time the algorithm runs.</li> <li>Space efficiency: The size of memory space the algorithm occupies.</li> </ul> <p>In short, our goal is to design data structures and algorithms that are \"both fast and memory-efficient\". Effectively evaluating algorithm efficiency is crucial, because only in this way can we compare various algorithms and guide the algorithm design and optimization process.</p> <p>Efficiency evaluation methods are mainly divided into two types: actual testing and theoretical estimation.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#211-actual-testing","title":"2.1.1 \u00a0 Actual Testing","text":"<p>Suppose we now have algorithm <code>A</code> and algorithm <code>B</code>, both of which can solve the same problem, and we need to compare the efficiency of these two algorithms. The most direct method is to find a computer, run these two algorithms, and monitor and record their running time and memory usage. This evaluation approach can reflect the real situation, but it also has considerable limitations.</p> <p>On one hand, it is difficult to eliminate interference factors from the testing environment. Hardware configuration affects the performance of algorithms. For example, if an algorithm has a high degree of parallelism, it is more suitable for running on multi-core CPUs; if an algorithm has intensive memory operations, it will perform better on high-performance memory. In other words, the test results of an algorithm on different machines may be inconsistent. This means we need to test on various machines and calculate average efficiency, which is impractical.</p> <p>On the other hand, conducting complete testing is very resource-intensive. As the input data volume changes, the algorithm will exhibit different efficiencies. For example, when the input data volume is small, the running time of algorithm <code>A</code> is shorter than algorithm <code>B</code>; but when the input data volume is large, the test results may be exactly the opposite. Therefore, to obtain convincing conclusions, we need to test input data of various scales, which requires a large amount of computational resources.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#212-theoretical-estimation","title":"2.1.2 \u00a0 Theoretical Estimation","text":"<p>Since actual testing has considerable limitations, we can consider evaluating algorithm efficiency through calculations alone. This estimation method is called asymptotic complexity analysis, or complexity analysis for short.</p> <p>Complexity analysis can reflect the relationship between the time and space resources required for algorithm execution and the input data scale. It describes the growth trend of the time and space required for algorithm execution as the input data scale increases. This definition is somewhat convoluted, so we can break it down into three key points to understand.</p> <ul> <li>\"Time and space resources\" correspond to time complexity and space complexity, respectively.</li> <li>\"As the input data scale increases\" means that complexity reflects the relationship between algorithm running efficiency and input data scale.</li> <li>\"Growth trend of time and space\" indicates that complexity analysis focuses not on the specific values of running time or occupied space, but on how \"fast\" time or space grows.</li> </ul> <p>Complexity analysis overcomes the drawbacks of the actual testing method, reflected in the following aspects.</p> <ul> <li>It does not need to actually run the code, making it more environmentally friendly and energy-efficient.</li> <li>It is independent of the testing environment, and the analysis results are applicable to all running platforms.</li> <li>It can reflect algorithm efficiency at different data volumes, especially algorithm performance at large data volumes.</li> </ul> <p>Tip</p> <p>If you are still confused about the concept of complexity, don't worry\u2014we will introduce it in detail in subsequent chapters.</p> <p>Complexity analysis provides us with a \"ruler\" for evaluating algorithm efficiency, allowing us to measure the time and space resources required to execute a certain algorithm and compare the efficiency between different algorithms.</p> <p>Complexity is a mathematical concept that may be relatively abstract for beginners, with a relatively high learning difficulty. From this perspective, complexity analysis may not be very suitable as the first content to be introduced. However, when we discuss the characteristics of a certain data structure or algorithm, it is difficult to avoid analyzing its running speed and space usage.</p> <p>In summary, it is recommended that before diving deep into data structures and algorithms, you first establish a preliminary understanding of complexity analysis so that you can complete complexity analysis of simple algorithms.</p>"},{"location":"chapter_computational_complexity/space_complexity/","title":"2.4 \u00a0 Space Complexity","text":"<p>Space complexity measures the growth trend of memory space occupied by an algorithm as the data size increases. This concept is very similar to time complexity, except that \"running time\" is replaced with \"occupied memory space\".</p>"},{"location":"chapter_computational_complexity/space_complexity/#241-algorithm-related-space","title":"2.4.1 \u00a0 Algorithm-Related Space","text":"<p>The memory space used by an algorithm during execution mainly includes the following types.</p> <ul> <li>Input space: Used to store the input data of the algorithm.</li> <li>Temporary space: Used to store variables, objects, function contexts, and other data during the algorithm's execution.</li> <li>Output space: Used to store the output data of the algorithm.</li> </ul> <p>In general, the scope of space complexity statistics is \"temporary space\" plus \"output space\".</p> <p>Temporary space can be further divided into three parts.</p> <ul> <li>Temporary data: Used to save various constants, variables, objects, etc., during the algorithm's execution.</li> <li>Stack frame space: Used to save the context data of called functions. The system creates a stack frame at the top of the stack each time a function is called, and the stack frame space is released after the function returns.</li> <li>Instruction space: Used to save compiled program instructions, which are usually ignored in actual statistics.</li> </ul> <p>When analyzing the space complexity of a program, we usually count three parts: temporary data, stack frame space, and output data, as shown in the following figure.</p> <p></p> <p> Figure 2-15 \u00a0 Algorithm-related space </p> <p>The related code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>class Node:\n    \"\"\"Class\"\"\"\n    def __init__(self, x: int):\n        self.val: int = x              # Node value\n        self.next: Node | None = None  # Reference to the next node\n\ndef function() -&gt; int:\n    \"\"\"Function\"\"\"\n    # Perform some operations...\n    return 0\n\ndef algorithm(n) -&gt; int:  # Input data\n    A = 0                 # Temporary data (constant, usually represented by uppercase letters)\n    b = 0                 # Temporary data (variable)\n    node = Node(0)        # Temporary data (object)\n    c = function()        # Stack frame space (function call)\n    return A + b + c      # Output data\n</code></pre> <pre><code>/* Structure */\nstruct Node {\n    int val;\n    Node *next;\n    Node(int x) : val(x), next(nullptr) {}\n};\n\n/* Function */\nint func() {\n    // Perform some operations...\n    return 0;\n}\n\nint algorithm(int n) {        // Input data\n    const int a = 0;          // Temporary data (constant)\n    int b = 0;                // Temporary data (variable)\n    Node* node = new Node(0); // Temporary data (object)\n    int c = func();           // Stack frame space (function call)\n    return a + b + c;         // Output data\n}\n</code></pre> <pre><code>/* Class */\nclass Node {\n    int val;\n    Node next;\n    Node(int x) { val = x; }\n}\n\n/* Function */\nint function() {\n    // Perform some operations...\n    return 0;\n}\n\nint algorithm(int n) {        // Input data\n    final int a = 0;          // Temporary data (constant)\n    int b = 0;                // Temporary data (variable)\n    Node node = new Node(0);  // Temporary data (object)\n    int c = function();       // Stack frame space (function call)\n    return a + b + c;         // Output data\n}\n</code></pre> <pre><code>/* Class */\nclass Node(int x) {\n    int val = x;\n    Node next;\n}\n\n/* Function */\nint Function() {\n    // Perform some operations...\n    return 0;\n}\n\nint Algorithm(int n) {        // Input data\n    const int a = 0;          // Temporary data (constant)\n    int b = 0;                // Temporary data (variable)\n    Node node = new(0);       // Temporary data (object)\n    int c = Function();       // Stack frame space (function call)\n    return a + b + c;         // Output data\n}\n</code></pre> <pre><code>/* Structure */\ntype node struct {\n    val  int\n    next *node\n}\n\n/* Create node structure */\nfunc newNode(val int) *node {\n    return &amp;node{val: val}\n}\n\n/* Function */\nfunc function() int {\n    // Perform some operations...\n    return 0\n}\n\nfunc algorithm(n int) int { // Input data\n    const a = 0             // Temporary data (constant)\n    b := 0                  // Temporary data (variable)\n    newNode(0)              // Temporary data (object)\n    c := function()         // Stack frame space (function call)\n    return a + b + c        // Output data\n}\n</code></pre> <pre><code>/* Class */\nclass Node {\n    var val: Int\n    var next: Node?\n\n    init(x: Int) {\n        val = x\n    }\n}\n\n/* Function */\nfunc function() -&gt; Int {\n    // Perform some operations...\n    return 0\n}\n\nfunc algorithm(n: Int) -&gt; Int { // Input data\n    let a = 0             // Temporary data (constant)\n    var b = 0             // Temporary data (variable)\n    let node = Node(x: 0) // Temporary data (object)\n    let c = function()    // Stack frame space (function call)\n    return a + b + c      // Output data\n}\n</code></pre> <pre><code>/* Class */\nclass Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val === undefined ? 0 : val; // Node value\n        this.next = null;                       // Reference to the next node\n    }\n}\n\n/* Function */\nfunction constFunc() {\n    // Perform some operations\n    return 0;\n}\n\nfunction algorithm(n) {       // Input data\n    const a = 0;              // Temporary data (constant)\n    let b = 0;                // Temporary data (variable)\n    const node = new Node(0); // Temporary data (object)\n    const c = constFunc();    // Stack frame space (function call)\n    return a + b + c;         // Output data\n}\n</code></pre> <pre><code>/* Class */\nclass Node {\n    val: number;\n    next: Node | null;\n    constructor(val?: number) {\n        this.val = val === undefined ? 0 : val; // Node value\n        this.next = null;                       // Reference to the next node\n    }\n}\n\n/* Function */\nfunction constFunc(): number {\n    // Perform some operations\n    return 0;\n}\n\nfunction algorithm(n: number): number { // Input data\n    const a = 0;                        // Temporary data (constant)\n    let b = 0;                          // Temporary data (variable)\n    const node = new Node(0);           // Temporary data (object)\n    const c = constFunc();              // Stack frame space (function call)\n    return a + b + c;                   // Output data\n}\n</code></pre> <pre><code>/* Class */\nclass Node {\n  int val;\n  Node next;\n  Node(this.val, [this.next]);\n}\n\n/* Function */\nint function() {\n  // Perform some operations...\n  return 0;\n}\n\nint algorithm(int n) {  // Input data\n  const int a = 0;      // Temporary data (constant)\n  int b = 0;            // Temporary data (variable)\n  Node node = Node(0);  // Temporary data (object)\n  int c = function();   // Stack frame space (function call)\n  return a + b + c;     // Output data\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Structure */\nstruct Node {\n    val: i32,\n    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,\n}\n\n/* Create Node structure */\nimpl Node {\n    fn new(val: i32) -&gt; Self {\n        Self { val: val, next: None }\n    }\n}\n\n/* Function */\nfn function() -&gt; i32 {\n    // Perform some operations...\n    return 0;\n}\n\nfn algorithm(n: i32) -&gt; i32 {       // Input data\n    const a: i32 = 0;               // Temporary data (constant)\n    let mut b = 0;                  // Temporary data (variable)\n    let node = Node::new(0);        // Temporary data (object)\n    let c = function();             // Stack frame space (function call)\n    return a + b + c;               // Output data\n}\n</code></pre> <pre><code>/* Function */\nint func() {\n    // Perform some operations...\n    return 0;\n}\n\nint algorithm(int n) { // Input data\n    const int a = 0;   // Temporary data (constant)\n    int b = 0;         // Temporary data (variable)\n    int c = func();    // Stack frame space (function call)\n    return a + b + c;  // Output data\n}\n</code></pre> <pre><code>/* Class */\nclass Node(var _val: Int) {\n    var next: Node? = null\n}\n\n/* Function */\nfun function(): Int {\n    // Perform some operations...\n    return 0\n}\n\nfun algorithm(n: Int): Int { // Input data\n    val a = 0                // Temporary data (constant)\n    var b = 0                // Temporary data (variable)\n    val node = Node(0)       // Temporary data (object)\n    val c = function()       // Stack frame space (function call)\n    return a + b + c         // Output data\n}\n</code></pre> <pre><code>### Class ###\nclass Node\n    attr_accessor :val      # Node value\n    attr_accessor :next     # Reference to the next node\n\n    def initialize(x)\n        @val = x\n    end\nend\n\n### Function ###\ndef function\n    # Perform some operations...\n    0\nend\n\n### Algorithm ###\ndef algorithm(n)        # Input data\n    a = 0               # Temporary data (constant)\n    b = 0               # Temporary data (variable)\n    node = Node.new(0)  # Temporary data (object)\n    c = function        # Stack frame space (function call)\n    a + b + c           # Output data\nend\n</code></pre>"},{"location":"chapter_computational_complexity/space_complexity/#242-calculation-method","title":"2.4.2 \u00a0 Calculation Method","text":"<p>The calculation method for space complexity is roughly the same as for time complexity, except that the statistical object is changed from \"number of operations\" to \"size of space used\".</p> <p>Unlike time complexity, we usually only focus on the worst-case space complexity. This is because memory space is a hard requirement, and we must ensure that sufficient memory space is reserved for all input data.</p> <p>Observe the following code. The \"worst case\" in worst-case space complexity has two meanings.</p> <ol> <li>Based on the worst input data: When \\(n &lt; 10\\), the space complexity is \\(O(1)\\); but when \\(n &gt; 10\\), the initialized array <code>nums</code> occupies \\(O(n)\\) space, so the worst-case space complexity is \\(O(n)\\).</li> <li>Based on the peak memory during algorithm execution: For example, before executing the last line, the program occupies \\(O(1)\\) space; when initializing the array <code>nums</code>, the program occupies \\(O(n)\\) space, so the worst-case space complexity is \\(O(n)\\).</li> </ol> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>def algorithm(n: int):\n    a = 0               # O(1)\n    b = [0] * 10000     # O(1)\n    if n &gt; 10:\n        nums = [0] * n  # O(n)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    vector&lt;int&gt; b(10000);    // O(1)\n    if (n &gt; 10)\n        vector&lt;int&gt; nums(n); // O(n)\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10)\n        int[] nums = new int[n]; // O(n)\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10) {\n        int[] nums = new int[n]; // O(n)\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 0                      // O(1)\n    b := make([]int, 10000)     // O(1)\n    var nums []int\n    if n &gt; 10 {\n        nums := make([]int, n)  // O(n)\n    }\n    fmt.Println(a, b, nums)\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    let a = 0 // O(1)\n    let b = Array(repeating: 0, count: 10000) // O(1)\n    if n &gt; 10 {\n        let nums = Array(repeating: 0, count: n) // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 0;                            // O(1)\n  List&lt;int&gt; b = List.filled(10000, 0);  // O(1)\n  if (n &gt; 10) {\n    List&lt;int&gt; nums = List.filled(n, 0); // O(n)\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let a = 0;                              // O(1)\n    let b = [0; 10000];                     // O(1)\n    if n &gt; 10 {\n        let nums = vec![0; n as usize];     // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    int b[10000];            // O(1)\n    if (n &gt; 10)\n        int nums[n] = {0};   // O(n)\n}\n</code></pre> <pre><code>fun algorithm(n: Int) {\n    val a = 0                    // O(1)\n    val b = IntArray(10000)      // O(1)\n    if (n &gt; 10) {\n        val nums = IntArray(n)   // O(n)\n    }\n}\n</code></pre> <pre><code>def algorithm(n)\n    a = 0                           # O(1)\n    b = Array.new(10000)            # O(1)\n    nums = Array.new(n) if n &gt; 10   # O(n)\nend\n</code></pre> <p>In recursive functions, it is necessary to count the stack frame space. Observe the following code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>def function() -&gt; int:\n    # Perform some operations\n    return 0\n\ndef loop(n: int):\n    \"\"\"Loop has space complexity of O(1)\"\"\"\n    for _ in range(n):\n        function()\n\ndef recur(n: int):\n    \"\"\"Recursion has space complexity of O(n)\"\"\"\n    if n == 1:\n        return\n    return recur(n - 1)\n</code></pre> <pre><code>int func() {\n    // Perform some operations\n    return 0;\n}\n/* Loop has space complexity of O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* Recursion has space complexity of O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n    // Perform some operations\n    return 0;\n}\n/* Loop has space complexity of O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        function();\n    }\n}\n/* Recursion has space complexity of O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    recur(n - 1);\n}\n</code></pre> <pre><code>int Function() {\n    // Perform some operations\n    return 0;\n}\n/* Loop has space complexity of O(1) */\nvoid Loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Function();\n    }\n}\n/* Recursion has space complexity of O(n) */\nint Recur(int n) {\n    if (n == 1) return 1;\n    return Recur(n - 1);\n}\n</code></pre> <pre><code>func function() int {\n    // Perform some operations\n    return 0\n}\n\n/* Loop has space complexity of O(1) */\nfunc loop(n int) {\n    for i := 0; i &lt; n; i++ {\n        function()\n    }\n}\n\n/* Recursion has space complexity of O(n) */\nfunc recur(n int) {\n    if n == 1 {\n        return\n    }\n    recur(n - 1)\n}\n</code></pre> <pre><code>@discardableResult\nfunc function() -&gt; Int {\n    // Perform some operations\n    return 0\n}\n\n/* Loop has space complexity of O(1) */\nfunc loop(n: Int) {\n    for _ in 0 ..&lt; n {\n        function()\n    }\n}\n\n/* Recursion has space complexity of O(n) */\nfunc recur(n: Int) {\n    if n == 1 {\n        return\n    }\n    recur(n: n - 1)\n}\n</code></pre> <pre><code>function constFunc() {\n    // Perform some operations\n    return 0;\n}\n/* Loop has space complexity of O(1) */\nfunction loop(n) {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* Recursion has space complexity of O(n) */\nfunction recur(n) {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>function constFunc(): number {\n    // Perform some operations\n    return 0;\n}\n/* Loop has space complexity of O(1) */\nfunction loop(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* Recursion has space complexity of O(n) */\nfunction recur(n: number): void {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n  // Perform some operations\n  return 0;\n}\n/* Loop has space complexity of O(1) */\nvoid loop(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    function();\n  }\n}\n/* Recursion has space complexity of O(n) */\nvoid recur(int n) {\n  if (n == 1) return;\n  recur(n - 1);\n}\n</code></pre> <pre><code>fn function() -&gt; i32 {\n    // Perform some operations\n    return 0;\n}\n/* Loop has space complexity of O(1) */\nfn loop(n: i32) {\n    for i in 0..n {\n        function();\n    }\n}\n/* Recursion has space complexity of O(n) */\nfn recur(n: i32) {\n    if n == 1 {\n        return;\n    }\n    recur(n - 1);\n}\n</code></pre> <pre><code>int func() {\n    // Perform some operations\n    return 0;\n}\n/* Loop has space complexity of O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* Recursion has space complexity of O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    recur(n - 1);\n}\n</code></pre> <pre><code>fun function(): Int {\n    // Perform some operations\n    return 0\n}\n/* Loop has space complexity of O(1) */\nfun loop(n: Int) {\n    for (i in 0..&lt;n) {\n        function()\n    }\n}\n/* Recursion has space complexity of O(n) */\nfun recur(n: Int) {\n    if (n == 1) return\n    return recur(n - 1)\n}\n</code></pre> <pre><code>def function\n    # Perform some operations\n    0\nend\n\n### Loop has space complexity of O(1) ###\ndef loop(n)\n    (0...n).each { function }\nend\n\n### Recursion has space complexity of O(n) ###\ndef recur(n)\n    return if n == 1\n    recur(n - 1)\nend\n</code></pre> <p>The time complexity of both functions <code>loop()</code> and <code>recur()</code> is \\(O(n)\\), but their space complexities are different.</p> <ul> <li>The function <code>loop()</code> calls <code>function()</code> \\(n\\) times in a loop. In each iteration, <code>function()</code> returns and releases its stack frame space, so the space complexity remains \\(O(1)\\).</li> <li>The recursive function <code>recur()</code> has \\(n\\) unreturned <code>recur()</code> instances existing simultaneously during execution, thus occupying \\(O(n)\\) stack frame space.</li> </ul>"},{"location":"chapter_computational_complexity/space_complexity/#243-common-types","title":"2.4.3 \u00a0 Common Types","text":"<p>Let the input data size be \\(n\\). The following figure shows common types of space complexity (arranged from low to high).</p> \\[ \\begin{aligned} O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n^2) &lt; O(2^n) \\newline \\text{Constant} &lt; \\text{Logarithmic} &lt; \\text{Linear} &lt; \\text{Quadratic} &lt; \\text{Exponential} \\end{aligned} \\] <p></p> <p> Figure 2-16 \u00a0 Common types of space complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#1-constant-order-o1","title":"1. \u00a0 Constant Order \\(O(1)\\)","text":"<p>Constant order is common in constants, variables, and objects whose quantity is independent of the input data size \\(n\\).</p> <p>It should be noted that memory occupied by initializing variables or calling functions in a loop is released when entering the next iteration, so it does not accumulate space, and the space complexity remains \\(O(1)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby space_complexity.py<pre><code>def function() -&gt; int:\n    \"\"\"Function\"\"\"\n    # Perform some operations\n    return 0\n\ndef constant(n: int):\n    \"\"\"Constant order\"\"\"\n    # Constants, variables, objects occupy O(1) space\n    a = 0\n    nums = [0] * 10000\n    node = ListNode(0)\n    # Variables in the loop occupy O(1) space\n    for _ in range(n):\n        c = 0\n    # Functions in the loop occupy O(1) space\n    for _ in range(n):\n        function()\n</code></pre> space_complexity.cpp<pre><code>/* Function */\nint func() {\n    // Perform some operations\n    return 0;\n}\n\n/* Constant order */\nvoid constant(int n) {\n    // Constants, variables, objects occupy O(1) space\n    const int a = 0;\n    int b = 0;\n    vector&lt;int&gt; nums(10000);\n    ListNode node(0);\n    // Variables in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // Functions in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* Function */\nint function() {\n    // Perform some operations\n    return 0;\n}\n\n/* Constant order */\nvoid constant(int n) {\n    // Constants, variables, objects occupy O(1) space\n    final int a = 0;\n    int b = 0;\n    int[] nums = new int[10000];\n    ListNode node = new ListNode(0);\n    // Variables in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // Functions in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        function();\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* Function */\nint Function() {\n    // Perform some operations\n    return 0;\n}\n\n/* Constant order */\nvoid Constant(int n) {\n    // Constants, variables, objects occupy O(1) space\n    int a = 0;\n    int b = 0;\n    int[] nums = new int[10000];\n    ListNode node = new(0);\n    // Variables in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // Functions in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        Function();\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* Function */\nfunc function() int {\n    // Perform some operations...\n    return 0\n}\n\n/* Constant order */\nfunc spaceConstant(n int) {\n    // Constants, variables, objects occupy O(1) space\n    const a = 0\n    b := 0\n    nums := make([]int, 10000)\n    node := newNode(0)\n    // Variables in the loop occupy O(1) space\n    var c int\n    for i := 0; i &lt; n; i++ {\n        c = 0\n    }\n    // Functions in the loop occupy O(1) space\n    for i := 0; i &lt; n; i++ {\n        function()\n    }\n    b += 0\n    c += 0\n    nums[0] = 0\n    node.val = 0\n}\n</code></pre> space_complexity.swift<pre><code>/* Function */\n@discardableResult\nfunc function() -&gt; Int {\n    // Perform some operations\n    return 0\n}\n\n/* Constant order */\nfunc constant(n: Int) {\n    // Constants, variables, objects occupy O(1) space\n    let a = 0\n    var b = 0\n    let nums = Array(repeating: 0, count: 10000)\n    let node = ListNode(x: 0)\n    // Variables in the loop occupy O(1) space\n    for _ in 0 ..&lt; n {\n        let c = 0\n    }\n    // Functions in the loop occupy O(1) space\n    for _ in 0 ..&lt; n {\n        function()\n    }\n}\n</code></pre> space_complexity.js<pre><code>/* Function */\nfunction constFunc() {\n    // Perform some operations\n    return 0;\n}\n\n/* Constant order */\nfunction constant(n) {\n    // Constants, variables, objects occupy O(1) space\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // Variables in the loop occupy O(1) space\n    for (let i = 0; i &lt; n; i++) {\n        const c = 0;\n    }\n    // Functions in the loop occupy O(1) space\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* Function */\nfunction constFunc(): number {\n    // Perform some operations\n    return 0;\n}\n\n/* Constant order */\nfunction constant(n: number): void {\n    // Constants, variables, objects occupy O(1) space\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // Variables in the loop occupy O(1) space\n    for (let i = 0; i &lt; n; i++) {\n        const c = 0;\n    }\n    // Functions in the loop occupy O(1) space\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* Function */\nint function() {\n  // Perform some operations\n  return 0;\n}\n\n/* Constant order */\nvoid constant(int n) {\n  // Constants, variables, objects occupy O(1) space\n  final int a = 0;\n  int b = 0;\n  List&lt;int&gt; nums = List.filled(10000, 0);\n  ListNode node = ListNode(0);\n  // Variables in the loop occupy O(1) space\n  for (var i = 0; i &lt; n; i++) {\n    int c = 0;\n  }\n  // Functions in the loop occupy O(1) space\n  for (var i = 0; i &lt; n; i++) {\n    function();\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* Function */\nfn function() -&gt; i32 {\n    // Perform some operations\n    return 0;\n}\n\n/* Constant order */\n#[allow(unused)]\nfn constant(n: i32) {\n    // Constants, variables, objects occupy O(1) space\n    const A: i32 = 0;\n    let b = 0;\n    let nums = vec![0; 10000];\n    let node = ListNode::new(0);\n    // Variables in the loop occupy O(1) space\n    for i in 0..n {\n        let c = 0;\n    }\n    // Functions in the loop occupy O(1) space\n    for i in 0..n {\n        function();\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* Function */\nint func() {\n    // Perform some operations\n    return 0;\n}\n\n/* Constant order */\nvoid constant(int n) {\n    // Constants, variables, objects occupy O(1) space\n    const int a = 0;\n    int b = 0;\n    int nums[1000];\n    ListNode *node = newListNode(0);\n    free(node);\n    // Variables in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // Functions in the loop occupy O(1) space\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n</code></pre> space_complexity.kt<pre><code>/* Function */\nfun function(): Int {\n    // Perform some operations\n    return 0\n}\n\n/* Constant order */\nfun constant(n: Int) {\n    // Constants, variables, objects occupy O(1) space\n    val a = 0\n    var b = 0\n    val nums = Array(10000) { 0 }\n    val node = ListNode(0)\n    // Variables in the loop occupy O(1) space\n    for (i in 0..&lt;n) {\n        val c = 0\n    }\n    // Functions in the loop occupy O(1) space\n    for (i in 0..&lt;n) {\n        function()\n    }\n}\n</code></pre> space_complexity.rb<pre><code>### Function ###\ndef function\n  # Perform some operations\n  0\nend\n\n### Constant time ###\ndef constant(n)\n  # Constants, variables, objects occupy O(1) space\n  a = 0\n  nums = [0] * 10000\n  node = ListNode.new\n\n  # Variables in the loop occupy O(1) space\n  (0...n).each { c = 0 }\n  # Functions in the loop occupy O(1) space\n  (0...n).each { function }\nend\n</code></pre>"},{"location":"chapter_computational_complexity/space_complexity/#2-linear-order-on","title":"2. \u00a0 Linear Order \\(O(n)\\)","text":"<p>Linear order is common in arrays, linked lists, stacks, queues, etc., where the number of elements is proportional to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby space_complexity.py<pre><code>def linear(n: int):\n    \"\"\"Linear order\"\"\"\n    # A list of length n occupies O(n) space\n    nums = [0] * n\n    # A hash table of length n occupies O(n) space\n    hmap = dict[int, str]()\n    for i in range(n):\n        hmap[i] = str(i)\n</code></pre> space_complexity.cpp<pre><code>/* Linear order */\nvoid linear(int n) {\n    // Array of length n uses O(n) space\n    vector&lt;int&gt; nums(n);\n    // A list of length n occupies O(n) space\n    vector&lt;ListNode&gt; nodes;\n    for (int i = 0; i &lt; n; i++) {\n        nodes.push_back(ListNode(i));\n    }\n    // A hash table of length n occupies O(n) space\n    unordered_map&lt;int, string&gt; map;\n    for (int i = 0; i &lt; n; i++) {\n        map[i] = to_string(i);\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* Linear order */\nvoid linear(int n) {\n    // Array of length n uses O(n) space\n    int[] nums = new int[n];\n    // A list of length n occupies O(n) space\n    List&lt;ListNode&gt; nodes = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        nodes.add(new ListNode(i));\n    }\n    // A hash table of length n occupies O(n) space\n    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        map.put(i, String.valueOf(i));\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* Linear order */\nvoid Linear(int n) {\n    // Array of length n uses O(n) space\n    int[] nums = new int[n];\n    // A list of length n occupies O(n) space\n    List&lt;ListNode&gt; nodes = [];\n    for (int i = 0; i &lt; n; i++) {\n        nodes.Add(new ListNode(i));\n    }\n    // A hash table of length n occupies O(n) space\n    Dictionary&lt;int, string&gt; map = [];\n    for (int i = 0; i &lt; n; i++) {\n        map.Add(i, i.ToString());\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* Linear order */\nfunc spaceLinear(n int) {\n    // Array of length n uses O(n) space\n    _ = make([]int, n)\n    // A list of length n occupies O(n) space\n    var nodes []*node\n    for i := 0; i &lt; n; i++ {\n        nodes = append(nodes, newNode(i))\n    }\n    // A hash table of length n occupies O(n) space\n    m := make(map[int]string, n)\n    for i := 0; i &lt; n; i++ {\n        m[i] = strconv.Itoa(i)\n    }\n}\n</code></pre> space_complexity.swift<pre><code>/* Linear order */\nfunc linear(n: Int) {\n    // Array of length n uses O(n) space\n    let nums = Array(repeating: 0, count: n)\n    // A list of length n occupies O(n) space\n    let nodes = (0 ..&lt; n).map { ListNode(x: $0) }\n    // A hash table of length n occupies O(n) space\n    let map = Dictionary(uniqueKeysWithValues: (0 ..&lt; n).map { ($0, \"\\($0)\") })\n}\n</code></pre> space_complexity.js<pre><code>/* Linear order */\nfunction linear(n) {\n    // Array of length n uses O(n) space\n    const nums = new Array(n);\n    // A list of length n occupies O(n) space\n    const nodes = [];\n    for (let i = 0; i &lt; n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // A hash table of length n occupies O(n) space\n    const map = new Map();\n    for (let i = 0; i &lt; n; i++) {\n        map.set(i, i.toString());\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* Linear order */\nfunction linear(n: number): void {\n    // Array of length n uses O(n) space\n    const nums = new Array(n);\n    // A list of length n occupies O(n) space\n    const nodes: ListNode[] = [];\n    for (let i = 0; i &lt; n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // A hash table of length n occupies O(n) space\n    const map = new Map();\n    for (let i = 0; i &lt; n; i++) {\n        map.set(i, i.toString());\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* Linear order */\nvoid linear(int n) {\n  // Array of length n uses O(n) space\n  List&lt;int&gt; nums = List.filled(n, 0);\n  // A list of length n occupies O(n) space\n  List&lt;ListNode&gt; nodes = [];\n  for (var i = 0; i &lt; n; i++) {\n    nodes.add(ListNode(i));\n  }\n  // A hash table of length n occupies O(n) space\n  Map&lt;int, String&gt; map = HashMap();\n  for (var i = 0; i &lt; n; i++) {\n    map.putIfAbsent(i, () =&gt; i.toString());\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* Linear order */\n#[allow(unused)]\nfn linear(n: i32) {\n    // Array of length n uses O(n) space\n    let mut nums = vec![0; n as usize];\n    // A list of length n occupies O(n) space\n    let mut nodes = Vec::new();\n    for i in 0..n {\n        nodes.push(ListNode::new(i))\n    }\n    // A hash table of length n occupies O(n) space\n    let mut map = HashMap::new();\n    for i in 0..n {\n        map.insert(i, i.to_string());\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* Hash table */\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh; // Implemented using uthash.h\n} HashTable;\n\n/* Linear order */\nvoid linear(int n) {\n    // Array of length n uses O(n) space\n    int *nums = malloc(sizeof(int) * n);\n    free(nums);\n\n    // A list of length n occupies O(n) space\n    ListNode **nodes = malloc(sizeof(ListNode *) * n);\n    for (int i = 0; i &lt; n; i++) {\n        nodes[i] = newListNode(i);\n    }\n    // Memory release\n    for (int i = 0; i &lt; n; i++) {\n        free(nodes[i]);\n    }\n    free(nodes);\n\n    // A hash table of length n occupies O(n) space\n    HashTable *h = NULL;\n    for (int i = 0; i &lt; n; i++) {\n        HashTable *tmp = malloc(sizeof(HashTable));\n        tmp-&gt;key = i;\n        tmp-&gt;val = i;\n        HASH_ADD_INT(h, key, tmp);\n    }\n\n    // Memory release\n    HashTable *curr, *tmp;\n    HASH_ITER(hh, h, curr, tmp) {\n        HASH_DEL(h, curr);\n        free(curr);\n    }\n}\n</code></pre> space_complexity.kt<pre><code>/* Linear order */\nfun linear(n: Int) {\n    // Array of length n uses O(n) space\n    val nums = Array(n) { 0 }\n    // A list of length n occupies O(n) space\n    val nodes = mutableListOf&lt;ListNode&gt;()\n    for (i in 0..&lt;n) {\n        nodes.add(ListNode(i))\n    }\n    // A hash table of length n occupies O(n) space\n    val map = mutableMapOf&lt;Int, String&gt;()\n    for (i in 0..&lt;n) {\n        map[i] = i.toString()\n    }\n}\n</code></pre> space_complexity.rb<pre><code>### Linear time ###\ndef linear(n)\n  # A list of length n occupies O(n) space\n  nums = Array.new(n, 0)\n\n  # A hash table of length n occupies O(n) space\n  hmap = {}\n  for i in 0...n\n    hmap[i] = i.to_s\n  end\nend\n</code></pre> <p>As shown in the following figure, the recursion depth of this function is \\(n\\), meaning that there are \\(n\\) unreturned <code>linear_recur()</code> functions existing simultaneously, using \\(O(n)\\) stack frame space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby space_complexity.py<pre><code>def linear_recur(n: int):\n    \"\"\"Linear order (recursive implementation)\"\"\"\n    print(\"Recursion n =\", n)\n    if n == 1:\n        return\n    linear_recur(n - 1)\n</code></pre> space_complexity.cpp<pre><code>/* Linear order (recursive implementation) */\nvoid linearRecur(int n) {\n    cout &lt;&lt; \"Recursion n = \" &lt;&lt; n &lt;&lt; endl;\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.java<pre><code>/* Linear order (recursive implementation) */\nvoid linearRecur(int n) {\n    System.out.println(\"Recursion n = \" + n);\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.cs<pre><code>/* Linear order (recursive implementation) */\nvoid LinearRecur(int n) {\n    Console.WriteLine(\"Recursion n = \" + n);\n    if (n == 1) return;\n    LinearRecur(n - 1);\n}\n</code></pre> space_complexity.go<pre><code>/* Linear order (recursive implementation) */\nfunc spaceLinearRecur(n int) {\n    fmt.Println(\"Recursion n =\", n)\n    if n == 1 {\n        return\n    }\n    spaceLinearRecur(n - 1)\n}\n</code></pre> space_complexity.swift<pre><code>/* Linear order (recursive implementation) */\nfunc linearRecur(n: Int) {\n    print(\"Recursion n = \\(n)\")\n    if n == 1 {\n        return\n    }\n    linearRecur(n: n - 1)\n}\n</code></pre> space_complexity.js<pre><code>/* Linear order (recursive implementation) */\nfunction linearRecur(n) {\n    console.log(`Recursion n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.ts<pre><code>/* Linear order (recursive implementation) */\nfunction linearRecur(n: number): void {\n    console.log(`Recursion n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.dart<pre><code>/* Linear order (recursive implementation) */\nvoid linearRecur(int n) {\n  print('Recursion n = $n');\n  if (n == 1) return;\n  linearRecur(n - 1);\n}\n</code></pre> space_complexity.rs<pre><code>/* Linear order (recursive implementation) */\nfn linear_recur(n: i32) {\n    println!(\"Recursion n = {}\", n);\n    if n == 1 {\n        return;\n    };\n    linear_recur(n - 1);\n}\n</code></pre> space_complexity.c<pre><code>/* Linear order (recursive implementation) */\nvoid linearRecur(int n) {\n    printf(\"Recursion n = %d\\r\\n\", n);\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.kt<pre><code>/* Linear order (recursive implementation) */\nfun linearRecur(n: Int) {\n    println(\"Recursion n = $n\")\n    if (n == 1)\n        return\n    linearRecur(n - 1)\n}\n</code></pre> space_complexity.rb<pre><code>### Linear space (recursive) ###\ndef linear_recur(n)\n  puts \"Recursion n = #{n}\"\n  return if n == 1\n  linear_recur(n - 1)\nend\n</code></pre> <p></p> <p> Figure 2-17 \u00a0 Linear order space complexity generated by recursive function </p>"},{"location":"chapter_computational_complexity/space_complexity/#3-quadratic-order-on2","title":"3. \u00a0 Quadratic Order \\(O(n^2)\\)","text":"<p>Quadratic order is common in matrices and graphs, where the number of elements is quadratically related to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby space_complexity.py<pre><code>def quadratic(n: int):\n    \"\"\"Quadratic order\"\"\"\n    # A 2D list occupies O(n^2) space\n    num_matrix = [[0] * n for _ in range(n)]\n</code></pre> space_complexity.cpp<pre><code>/* Exponential order */\nvoid quadratic(int n) {\n    // 2D list uses O(n^2) space\n    vector&lt;vector&lt;int&gt;&gt; numMatrix;\n    for (int i = 0; i &lt; n; i++) {\n        vector&lt;int&gt; tmp;\n        for (int j = 0; j &lt; n; j++) {\n            tmp.push_back(0);\n        }\n        numMatrix.push_back(tmp);\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* Exponential order */\nvoid quadratic(int n) {\n    // Matrix uses O(n^2) space\n    int[][] numMatrix = new int[n][n];\n    // 2D list uses O(n^2) space\n    List&lt;List&lt;Integer&gt;&gt; numList = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n        for (int j = 0; j &lt; n; j++) {\n            tmp.add(0);\n        }\n        numList.add(tmp);\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* Exponential order */\nvoid Quadratic(int n) {\n    // Matrix uses O(n^2) space\n    int[,] numMatrix = new int[n, n];\n    // 2D list uses O(n^2) space\n    List&lt;List&lt;int&gt;&gt; numList = [];\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;int&gt; tmp = [];\n        for (int j = 0; j &lt; n; j++) {\n            tmp.Add(0);\n        }\n        numList.Add(tmp);\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* Exponential order */\nfunc spaceQuadratic(n int) {\n    // Matrix uses O(n^2) space\n    numMatrix := make([][]int, n)\n    for i := 0; i &lt; n; i++ {\n        numMatrix[i] = make([]int, n)\n    }\n}\n</code></pre> space_complexity.swift<pre><code>/* Exponential order */\nfunc quadratic(n: Int) {\n    // 2D list uses O(n^2) space\n    let numList = Array(repeating: Array(repeating: 0, count: n), count: n)\n}\n</code></pre> space_complexity.js<pre><code>/* Exponential order */\nfunction quadratic(n) {\n    // Matrix uses O(n^2) space\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() =&gt; Array(n).fill(null));\n    // 2D list uses O(n^2) space\n    const numList = [];\n    for (let i = 0; i &lt; n; i++) {\n        const tmp = [];\n        for (let j = 0; j &lt; n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* Exponential order */\nfunction quadratic(n: number): void {\n    // Matrix uses O(n^2) space\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() =&gt; Array(n).fill(null));\n    // 2D list uses O(n^2) space\n    const numList = [];\n    for (let i = 0; i &lt; n; i++) {\n        const tmp = [];\n        for (let j = 0; j &lt; n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* Exponential order */\nvoid quadratic(int n) {\n  // Matrix uses O(n^2) space\n  List&lt;List&lt;int&gt;&gt; numMatrix = List.generate(n, (_) =&gt; List.filled(n, 0));\n  // 2D list uses O(n^2) space\n  List&lt;List&lt;int&gt;&gt; numList = [];\n  for (var i = 0; i &lt; n; i++) {\n    List&lt;int&gt; tmp = [];\n    for (int j = 0; j &lt; n; j++) {\n      tmp.add(0);\n    }\n    numList.add(tmp);\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* Exponential order */\n#[allow(unused)]\nfn quadratic(n: i32) {\n    // Matrix uses O(n^2) space\n    let num_matrix = vec![vec![0; n as usize]; n as usize];\n    // 2D list uses O(n^2) space\n    let mut num_list = Vec::new();\n    for i in 0..n {\n        let mut tmp = Vec::new();\n        for j in 0..n {\n            tmp.push(0);\n        }\n        num_list.push(tmp);\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* Exponential order */\nvoid quadratic(int n) {\n    // 2D list uses O(n^2) space\n    int **numMatrix = malloc(sizeof(int *) * n);\n    for (int i = 0; i &lt; n; i++) {\n        int *tmp = malloc(sizeof(int) * n);\n        for (int j = 0; j &lt; n; j++) {\n            tmp[j] = 0;\n        }\n        numMatrix[i] = tmp;\n    }\n\n    // Memory release\n    for (int i = 0; i &lt; n; i++) {\n        free(numMatrix[i]);\n    }\n    free(numMatrix);\n}\n</code></pre> space_complexity.kt<pre><code>/* Exponential order */\nfun quadratic(n: Int) {\n    // Matrix uses O(n^2) space\n    val numMatrix = arrayOfNulls&lt;Array&lt;Int&gt;?&gt;(n)\n    // 2D list uses O(n^2) space\n    val numList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;()\n    for (i in 0..&lt;n) {\n        val tmp = mutableListOf&lt;Int&gt;()\n        for (j in 0..&lt;n) {\n            tmp.add(0)\n        }\n        numList.add(tmp)\n    }\n}\n</code></pre> space_complexity.rb<pre><code>### Quadratic time ###\ndef quadratic(n)\n  # 2D list uses O(n^2) space\n  Array.new(n) { Array.new(n, 0) }\nend\n</code></pre> <p>As shown in the following figure, the recursion depth of this function is \\(n\\), and an array is initialized in each recursive function with lengths of \\(n\\), \\(n-1\\), \\(\\dots\\), \\(2\\), \\(1\\), with an average length of \\(n / 2\\), thus occupying \\(O(n^2)\\) space overall:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby space_complexity.py<pre><code>def quadratic_recur(n: int) -&gt; int:\n    \"\"\"Quadratic order (recursive implementation)\"\"\"\n    if n &lt;= 0:\n        return 0\n    # Array nums length is n, n-1, ..., 2, 1\n    nums = [0] * n\n    return quadratic_recur(n - 1)\n</code></pre> space_complexity.cpp<pre><code>/* Quadratic order (recursive implementation) */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    vector&lt;int&gt; nums(n);\n    cout &lt;&lt; \"In recursion n = \" &lt;&lt; n &lt;&lt; \", nums length = \" &lt;&lt; nums.size() &lt;&lt; endl;\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.java<pre><code>/* Quadratic order (recursive implementation) */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    // Array nums has length n, n-1, ..., 2, 1\n    int[] nums = new int[n];\n    System.out.println(\"In recursion n = \" + n + \", nums length = \" + nums.length);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.cs<pre><code>/* Quadratic order (recursive implementation) */\nint QuadraticRecur(int n) {\n    if (n &lt;= 0) return 0;\n    int[] nums = new int[n];\n    Console.WriteLine(\"Recursion n = \" + n + \", nums length = \" + nums.Length);\n    return QuadraticRecur(n - 1);\n}\n</code></pre> space_complexity.go<pre><code>/* Quadratic order (recursive implementation) */\nfunc spaceQuadraticRecur(n int) int {\n    if n &lt;= 0 {\n        return 0\n    }\n    nums := make([]int, n)\n    fmt.Printf(\"In recursion n = %d, nums length = %d \\n\", n, len(nums))\n    return spaceQuadraticRecur(n - 1)\n}\n</code></pre> space_complexity.swift<pre><code>/* Quadratic order (recursive implementation) */\n@discardableResult\nfunc quadraticRecur(n: Int) -&gt; Int {\n    if n &lt;= 0 {\n        return 0\n    }\n    // Array nums has length n, n-1, ..., 2, 1\n    let nums = Array(repeating: 0, count: n)\n    print(\"In recursion n = \\(n), nums length = \\(nums.count)\")\n    return quadraticRecur(n: n - 1)\n}\n</code></pre> space_complexity.js<pre><code>/* Quadratic order (recursive implementation) */\nfunction quadraticRecur(n) {\n    if (n &lt;= 0) return 0;\n    const nums = new Array(n);\n    console.log(`In recursion n = ${n}, nums length = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.ts<pre><code>/* Quadratic order (recursive implementation) */\nfunction quadraticRecur(n: number): number {\n    if (n &lt;= 0) return 0;\n    const nums = new Array(n);\n    console.log(`In recursion n = ${n}, nums length = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.dart<pre><code>/* Quadratic order (recursive implementation) */\nint quadraticRecur(int n) {\n  if (n &lt;= 0) return 0;\n  List&lt;int&gt; nums = List.filled(n, 0);\n  print('In recursion n = $n, nums length = ${nums.length}');\n  return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.rs<pre><code>/* Quadratic order (recursive implementation) */\nfn quadratic_recur(n: i32) -&gt; i32 {\n    if n &lt;= 0 {\n        return 0;\n    };\n    // Array nums has length n, n-1, ..., 2, 1\n    let nums = vec![0; n as usize];\n    println!(\"In recursion n = {}, nums length = {}\", n, nums.len());\n    return quadratic_recur(n - 1);\n}\n</code></pre> space_complexity.c<pre><code>/* Quadratic order (recursive implementation) */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    int *nums = malloc(sizeof(int) * n);\n    printf(\"In recursion n = %d, nums length = %d\\r\\n\", n, n);\n    int res = quadraticRecur(n - 1);\n    free(nums);\n    return res;\n}\n</code></pre> space_complexity.kt<pre><code>/* Quadratic order (recursive implementation) */\ntailrec fun quadraticRecur(n: Int): Int {\n    if (n &lt;= 0)\n        return 0\n    // Array nums has length n, n-1, ..., 2, 1\n    val nums = Array(n) { 0 }\n    println(\"In recursion n = $n, nums length = ${nums.size}\")\n    return quadraticRecur(n - 1)\n}\n</code></pre> space_complexity.rb<pre><code>### Quadratic space (recursive) ###\ndef quadratic_recur(n)\n  return 0 unless n &gt; 0\n\n  # Array nums has length n, n-1, ..., 2, 1\n  nums = Array.new(n, 0)\n  quadratic_recur(n - 1)\nend\n</code></pre> <p></p> <p> Figure 2-18 \u00a0 Quadratic order space complexity generated by recursive function </p>"},{"location":"chapter_computational_complexity/space_complexity/#4-exponential-order-o2n","title":"4. \u00a0 Exponential Order \\(O(2^n)\\)","text":"<p>Exponential order is common in binary trees. Observe the following figure: a \"full binary tree\" with \\(n\\) levels has \\(2^n - 1\\) nodes, occupying \\(O(2^n)\\) space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby space_complexity.py<pre><code>def build_tree(n: int) -&gt; TreeNode | None:\n    \"\"\"Exponential order (build full binary tree)\"\"\"\n    if n == 0:\n        return None\n    root = TreeNode(0)\n    root.left = build_tree(n - 1)\n    root.right = build_tree(n - 1)\n    return root\n</code></pre> space_complexity.cpp<pre><code>/* Driver Code */\nTreeNode *buildTree(int n) {\n    if (n == 0)\n        return nullptr;\n    TreeNode *root = new TreeNode(0);\n    root-&gt;left = buildTree(n - 1);\n    root-&gt;right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.java<pre><code>/* Driver Code */\nTreeNode buildTree(int n) {\n    if (n == 0)\n        return null;\n    TreeNode root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.cs<pre><code>/* Driver Code */\nTreeNode? BuildTree(int n) {\n    if (n == 0) return null;\n    TreeNode root = new(0) {\n        left = BuildTree(n - 1),\n        right = BuildTree(n - 1)\n    };\n    return root;\n}\n</code></pre> space_complexity.go<pre><code>/* Driver Code */\nfunc buildTree(n int) *TreeNode {\n    if n == 0 {\n        return nil\n    }\n    root := NewTreeNode(0)\n    root.Left = buildTree(n - 1)\n    root.Right = buildTree(n - 1)\n    return root\n}\n</code></pre> space_complexity.swift<pre><code>/* Driver Code */\nfunc buildTree(n: Int) -&gt; TreeNode? {\n    if n == 0 {\n        return nil\n    }\n    let root = TreeNode(x: 0)\n    root.left = buildTree(n: n - 1)\n    root.right = buildTree(n: n - 1)\n    return root\n}\n</code></pre> space_complexity.js<pre><code>/* Driver Code */\nfunction buildTree(n) {\n    if (n === 0) return null;\n    const root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.ts<pre><code>/* Driver Code */\nfunction buildTree(n: number): TreeNode | null {\n    if (n === 0) return null;\n    const root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.dart<pre><code>/* Driver Code */\nTreeNode? buildTree(int n) {\n  if (n == 0) return null;\n  TreeNode root = TreeNode(0);\n  root.left = buildTree(n - 1);\n  root.right = buildTree(n - 1);\n  return root;\n}\n</code></pre> space_complexity.rs<pre><code>/* Driver Code */\nfn build_tree(n: i32) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n    if n == 0 {\n        return None;\n    };\n    let root = TreeNode::new(0);\n    root.borrow_mut().left = build_tree(n - 1);\n    root.borrow_mut().right = build_tree(n - 1);\n    return Some(root);\n}\n</code></pre> space_complexity.c<pre><code>/* Driver Code */\nTreeNode *buildTree(int n) {\n    if (n == 0)\n        return NULL;\n    TreeNode *root = newTreeNode(0);\n    root-&gt;left = buildTree(n - 1);\n    root-&gt;right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.kt<pre><code>/* Driver Code */\nfun buildTree(n: Int): TreeNode? {\n    if (n == 0)\n        return null\n    val root = TreeNode(0)\n    root.left = buildTree(n - 1)\n    root.right = buildTree(n - 1)\n    return root\n}\n</code></pre> space_complexity.rb<pre><code>### Exponential space (build full binary tree) ###\ndef build_tree(n)\n  return if n == 0\n\n  TreeNode.new.tap do |root|\n    root.left = build_tree(n - 1)\n    root.right = build_tree(n - 1)\n  end\nend\n</code></pre> <p></p> <p> Figure 2-19 \u00a0 Exponential order space complexity generated by full binary tree </p>"},{"location":"chapter_computational_complexity/space_complexity/#5-logarithmic-order-olog-n","title":"5. \u00a0 Logarithmic Order \\(O(\\log n)\\)","text":"<p>Logarithmic order is common in divide-and-conquer algorithms. For example, merge sort: given an input array of length \\(n\\), each recursion divides the array in half from the midpoint, forming a recursion tree of height \\(\\log n\\), using \\(O(\\log n)\\) stack frame space.</p> <p>Another example is converting a number to a string. Given a positive integer \\(n\\), it has \\(\\lfloor \\log_{10} n \\rfloor + 1\\) digits, i.e., the corresponding string length is \\(\\lfloor \\log_{10} n \\rfloor + 1\\), so the space complexity is \\(O(\\log_{10} n + 1) = O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/space_complexity/#244-trading-time-for-space","title":"2.4.4 \u00a0 Trading Time for Space","text":"<p>Ideally, we hope that both the time complexity and space complexity of an algorithm can reach optimal. However, in practice, optimizing both time complexity and space complexity simultaneously is usually very difficult.</p> <p>Reducing time complexity usually comes at the cost of increasing space complexity, and vice versa. The approach of sacrificing memory space to improve algorithm execution speed is called \"trading space for time\"; conversely, it is called \"trading time for space\".</p> <p>The choice of which approach depends on which aspect we value more. In most cases, time is more precious than space, so \"trading space for time\" is usually the more common strategy. Of course, when the data volume is very large, controlling space complexity is also very important.</p>"},{"location":"chapter_computational_complexity/summary/","title":"2.5 \u00a0 Summary","text":""},{"location":"chapter_computational_complexity/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<p>Algorithm Efficiency Assessment</p> <ul> <li>Time efficiency and space efficiency are the two primary evaluation metrics for measuring algorithm performance.</li> <li>We can evaluate algorithm efficiency through actual testing, but it is difficult to eliminate the influence of the testing environment, and it consumes substantial computational resources.</li> <li>Complexity analysis can eliminate the drawbacks of actual testing, with results applicable to all running platforms, and it can reveal algorithm efficiency under different data scales.</li> </ul> <p>Time Complexity</p> <ul> <li>Time complexity is used to measure the trend of algorithm runtime as data volume increases. It can effectively evaluate algorithm efficiency, but may fail in certain situations, such as when the input data volume is small or when time complexities are identical, making it impossible to precisely compare algorithm efficiency.</li> <li>Worst-case time complexity is represented using Big \\(O\\) notation, corresponding to the asymptotic upper bound of a function, reflecting the growth level of the number of operations \\(T(n)\\) as \\(n\\) approaches positive infinity.</li> <li>Deriving time complexity involves two steps: first, counting the number of operations, then determining the asymptotic upper bound.</li> <li>Common time complexities arranged from low to high include \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n \\log n)\\), \\(O(n^2)\\), \\(O(2^n)\\), and \\(O(n!)\\).</li> <li>The time complexity of some algorithms is not fixed, but rather depends on the distribution of input data. Time complexity is divided into worst-case, best-case, and average-case time complexity. Best-case time complexity is rarely used because input data generally needs to satisfy strict conditions to achieve the best case.</li> <li>Average time complexity reflects the algorithm's runtime efficiency under random data input, and is closest to the algorithm's performance in practical applications. Calculating average time complexity requires statistical analysis of input data distribution and the combined mathematical expectation.</li> </ul> <p>Space Complexity</p> <ul> <li>Space complexity serves a similar purpose to time complexity, used to measure the trend of algorithm memory usage as data volume increases.</li> <li>The memory space related to algorithm execution can be divided into input space, temporary space, and output space. Typically, input space is not included in space complexity calculations. Temporary space can be divided into temporary data, stack frame space, and instruction space, where stack frame space usually affects space complexity only in recursive functions.</li> <li>We typically only focus on worst-case space complexity, which is the space complexity of an algorithm under worst-case input data and worst-case runtime.</li> <li>Common space complexities arranged from low to high include \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n^2)\\), and \\(O(2^n)\\).</li> </ul>"},{"location":"chapter_computational_complexity/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Is the space complexity of tail recursion \\(O(1)\\)?</p> <p>Theoretically, the space complexity of tail recursive functions can be optimized to \\(O(1)\\). However, most programming languages (such as Java, Python, C++, Go, C#, etc.) do not support automatic tail recursion optimization, so the space complexity is generally considered to be \\(O(n)\\).</p> <p>Q: What is the difference between the terms function and method?</p> <p>A function can be executed independently, with all parameters passed explicitly. A method is associated with an object, is implicitly passed to the object that invokes it, and can operate on data contained in class instances.</p> <p>The following examples use several common programming languages for illustration.</p> <ul> <li>C is a procedural programming language without object-oriented concepts, so it only has functions. However, we can simulate object-oriented programming by creating structures (struct), and functions associated with structures are equivalent to methods in other programming languages.</li> <li>Java and C# are object-oriented programming languages where code blocks (methods) are typically part of a class. Static methods behave like functions because they are bound to the class and cannot access specific instance variables.</li> <li>C++ and Python support both procedural programming (functions) and object-oriented programming (methods).</li> </ul> <p>Q: Does the diagram for \"common space complexity types\" reflect the absolute size of occupied space?</p> <p>No, the diagram shows space complexity, which reflects growth trends rather than the absolute size of occupied space.</p> <p>Assuming \\(n = 8\\), you might find that the values of each curve do not correspond to the functions. This is because each curve contains a constant term used to compress the value range into a visually comfortable range.</p> <p>In practice, because we generally do not know what the \"constant term\" complexity of each method is, we usually cannot select the optimal solution for \\(n = 8\\) based on complexity alone. But for \\(n = 8^5\\), the choice is straightforward, as the growth trend already dominates.</p> <p>Q: Are there situations where algorithms are designed to sacrifice time (or space) based on actual use cases?</p> <p>In practical applications, most situations choose to sacrifice space for time. For example, with database indexes, we typically choose to build B+ trees or hash indexes, occupying substantial memory space in exchange for efficient queries of \\(O(\\log n)\\) or even \\(O(1)\\).</p> <p>In scenarios where space resources are precious, time may be sacrificed for space. For example, in embedded development, device memory is precious, and engineers may forgo using hash tables and choose to use array sequential search to save memory usage, at the cost of slower searches.</p>"},{"location":"chapter_computational_complexity/time_complexity/","title":"2.3 \u00a0 Time Complexity","text":"<p>Runtime can intuitively and accurately reflect the efficiency of an algorithm. If we want to accurately estimate the runtime of a piece of code, how should we proceed?</p> <ol> <li>Determine the running platform, including hardware configuration, programming language, system environment, etc., as these factors all affect code execution efficiency.</li> <li>Evaluate the runtime required for various computational operations, for example, an addition operation <code>+</code> requires 1 ns, a multiplication operation <code>*</code> requires 10 ns, a print operation <code>print()</code> requires 5 ns, etc.</li> <li>Count all computational operations in the code, and sum the execution times of all operations to obtain the runtime.</li> </ol> <p>For example, in the following code, the input data size is \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code># On a certain running platform\ndef algorithm(n: int):\n    a = 2      # 1 ns\n    a = a + 1  # 1 ns\n    a = a * 2  # 10 ns\n    # Loop n times\n    for _ in range(n):  # 1 ns\n        print(0)        # 5 ns\n</code></pre> <pre><code>// On a certain running platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns\n        cout &lt;&lt; 0 &lt;&lt; endl;         // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns\n        System.out.println(0);     // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nvoid Algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns\n        Console.WriteLine(0);      // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nfunc algorithm(n int) {\n    a := 2     // 1 ns\n    a = a + 1  // 1 ns\n    a = a * 2  // 10 ns\n    // Loop n times\n    for i := 0; i &lt; n; i++ {  // 1 ns\n        fmt.Println(a)        // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nfunc algorithm(n: Int) {\n    var a = 2 // 1 ns\n    a = a + 1 // 1 ns\n    a = a * 2 // 10 ns\n    // Loop n times\n    for _ in 0 ..&lt; n { // 1 ns\n        print(0) // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nfunction algorithm(n) {\n    var a = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // Loop n times\n    for(let i = 0; i &lt; n; i++) { // 1 ns\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nfunction algorithm(n: number): void {\n    var a: number = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // Loop n times\n    for(let i = 0; i &lt; n; i++) { // 1 ns\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nvoid algorithm(int n) {\n  int a = 2; // 1 ns\n  a = a + 1; // 1 ns\n  a = a * 2; // 10 ns\n  // Loop n times\n  for (int i = 0; i &lt; n; i++) { // 1 ns\n    print(0); // 5 ns\n  }\n}\n</code></pre> <pre><code>// On a certain running platform\nfn algorithm(n: i32) {\n    let mut a = 2;      // 1 ns\n    a = a + 1;          // 1 ns\n    a = a * 2;          // 10 ns\n    // Loop n times\n    for _ in 0..n {     // 1 ns\n        println!(\"{}\", 0);  // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // 1 ns\n        printf(\"%d\", 0);            // 5 ns\n    }\n}\n</code></pre> <pre><code>// On a certain running platform\nfun algorithm(n: Int) {\n    var a = 2 // 1 ns\n    a = a + 1 // 1 ns\n    a = a * 2 // 10 ns\n    // Loop n times\n    for (i in 0..&lt;n) {  // 1 ns\n        println(0)      // 5 ns\n    }\n}\n</code></pre> <pre><code># On a certain running platform\ndef algorithm(n)\n    a = 2       # 1 ns\n    a = a + 1   # 1 ns\n    a = a * 2   # 10 ns\n    # Loop n times\n    (0...n).each do # 1 ns\n        puts 0      # 5 ns\n    end\nend\n</code></pre> <p>According to the above method, the algorithm's runtime can be obtained as \\((6n + 12)\\) ns:</p> \\[ 1 + 1 + 10 + (1 + 5) \\times n = 6n + 12 \\] <p>In reality, however, counting an algorithm's runtime is neither reasonable nor realistic. First, we do not want to tie the estimated time to the running platform, because algorithms need to run on various different platforms. Second, it is difficult to know the runtime of each type of operation, which brings great difficulty to the estimation process.</p>"},{"location":"chapter_computational_complexity/time_complexity/#231-counting-time-growth-trends","title":"2.3.1 \u00a0 Counting Time Growth Trends","text":"<p>Time complexity analysis does not count the algorithm's runtime, but rather counts the growth trend of the algorithm's runtime as the data volume increases.</p> <p>The concept of \"time growth trend\" is rather abstract; let us understand it through an example. Suppose the input data size is \\(n\\), and given three algorithms <code>A</code>, <code>B</code>, and <code>C</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code># Time complexity of algorithm A: constant order\ndef algorithm_A(n: int):\n    print(0)\n# Time complexity of algorithm B: linear order\ndef algorithm_B(n: int):\n    for _ in range(n):\n        print(0)\n# Time complexity of algorithm C: constant order\ndef algorithm_C(n: int):\n    for _ in range(1000000):\n        print(0)\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    cout &lt;&lt; 0 &lt;&lt; endl;\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    System.out.println(0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        System.out.println(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        System.out.println(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid AlgorithmA(int n) {\n    Console.WriteLine(0);\n}\n// Time complexity of algorithm B: linear order\nvoid AlgorithmB(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Console.WriteLine(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid AlgorithmC(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        Console.WriteLine(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunc algorithm_A(n int) {\n    fmt.Println(0)\n}\n// Time complexity of algorithm B: linear order\nfunc algorithm_B(n int) {\n    for i := 0; i &lt; n; i++ {\n        fmt.Println(0)\n    }\n}\n// Time complexity of algorithm C: constant order\nfunc algorithm_C(n int) {\n    for i := 0; i &lt; 1000000; i++ {\n        fmt.Println(0)\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunc algorithmA(n: Int) {\n    print(0)\n}\n\n// Time complexity of algorithm B: linear order\nfunc algorithmB(n: Int) {\n    for _ in 0 ..&lt; n {\n        print(0)\n    }\n}\n\n// Time complexity of algorithm C: constant order\nfunc algorithmC(n: Int) {\n    for _ in 0 ..&lt; 1_000_000 {\n        print(0)\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunction algorithm_A(n) {\n    console.log(0);\n}\n// Time complexity of algorithm B: linear order\nfunction algorithm_B(n) {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfunction algorithm_C(n) {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunction algorithm_A(n: number): void {\n    console.log(0);\n}\n// Time complexity of algorithm B: linear order\nfunction algorithm_B(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfunction algorithm_C(n: number): void {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithmA(int n) {\n  print(0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithmB(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    print(0);\n  }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithmC(int n) {\n  for (int i = 0; i &lt; 1000000; i++) {\n    print(0);\n  }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfn algorithm_A(n: i32) {\n    println!(\"{}\", 0);\n}\n// Time complexity of algorithm B: linear order\nfn algorithm_B(n: i32) {\n    for _ in 0..n {\n        println!(\"{}\", 0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfn algorithm_C(n: i32) {\n    for _ in 0..1000000 {\n        println!(\"{}\", 0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    printf(\"%d\", 0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        printf(\"%d\", 0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        printf(\"%d\", 0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfun algoritm_A(n: Int) {\n    println(0)\n}\n// Time complexity of algorithm B: linear order\nfun algorithm_B(n: Int) {\n    for (i in 0..&lt;n){\n        println(0)\n    }\n}\n// Time complexity of algorithm C: constant order\nfun algorithm_C(n: Int) {\n    for (i in 0..&lt;1000000) {\n        println(0)\n    }\n}\n</code></pre> <pre><code># Time complexity of algorithm A: constant order\ndef algorithm_A(n)\n    puts 0\nend\n\n# Time complexity of algorithm B: linear order\ndef algorithm_B(n)\n    (0...n).each { puts 0 }\nend\n\n# Time complexity of algorithm C: constant order\ndef algorithm_C(n)\n    (0...1_000_000).each { puts 0 }\nend\n</code></pre> <p>Figure 2-7 shows the time complexity of the above three algorithm functions.</p> <ul> <li>Algorithm <code>A</code> has only \\(1\\) print operation, and the algorithm's runtime does not grow as \\(n\\) increases. We call the time complexity of this algorithm \"constant order\".</li> <li>In algorithm <code>B</code>, the print operation needs to loop \\(n\\) times, and the algorithm's runtime grows linearly as \\(n\\) increases. The time complexity of this algorithm is called \"linear order\".</li> <li>In algorithm <code>C</code>, the print operation needs to loop \\(1000000\\) times. Although the runtime is very long, it is independent of the input data size \\(n\\). Therefore, the time complexity of <code>C</code> is the same as <code>A</code>, still \"constant order\".</li> </ul> <p></p> <p> Figure 2-7 \u00a0 Time growth trends of algorithms A, B, and C </p> <p>Compared to directly counting the algorithm's runtime, what are the characteristics of time complexity analysis?</p> <ul> <li>Time complexity can effectively evaluate algorithm efficiency. For example, the runtime of algorithm <code>B</code> grows linearly; when \\(n &gt; 1\\) it is slower than algorithm <code>A</code>, and when \\(n &gt; 1000000\\) it is slower than algorithm <code>C</code>. In fact, as long as the input data size \\(n\\) is sufficiently large, an algorithm with \"constant order\" complexity will always be superior to one with \"linear order\" complexity, which is precisely the meaning of time growth trend.</li> <li>The derivation method for time complexity is simpler. Obviously, the running platform and the types of computational operations are both unrelated to the growth trend of the algorithm's runtime. Therefore, in time complexity analysis, we can simply treat the execution time of all computational operations as the same \"unit time\", thus simplifying \"counting computational operation runtime\" to \"counting the number of computational operations\", which greatly reduces the difficulty of estimation.</li> <li>Time complexity also has certain limitations. For example, although algorithms <code>A</code> and <code>C</code> have the same time complexity, their actual runtimes differ significantly. Similarly, although algorithm <code>B</code> has a higher time complexity than <code>C</code>, when the input data size \\(n\\) is small, algorithm <code>B</code> is clearly superior to algorithm <code>C</code>. In such cases, it is often difficult to judge the efficiency of algorithms based solely on time complexity. Of course, despite the above issues, complexity analysis remains the most effective and commonly used method for evaluating algorithm efficiency.</li> </ul>"},{"location":"chapter_computational_complexity/time_complexity/#232-asymptotic-upper-bound-of-functions","title":"2.3.2 \u00a0 Asymptotic Upper Bound of Functions","text":"<p>Given a function with input size \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>def algorithm(n: int):\n    a = 1      # +1\n    a = a + 1  # +1\n    a = a * 2  # +1\n    # Loop n times\n    for i in range(n):  # +1\n        print(0)        # +1\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) { // +1 (i++ is executed each round)\n        cout &lt;&lt; 0 &lt;&lt; endl;    // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) { // +1 (i++ is executed each round)\n        System.out.println(0);    // +1\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // +1 (i++ is executed each round)\n        Console.WriteLine(0);   // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1      // +1\n    a = a + 1   // +1\n    a = a * 2   // +1\n    // Loop n times\n    for i := 0; i &lt; n; i++ {   // +1\n        fmt.Println(a)         // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +1\n    a = a + 1 // +1\n    a = a * 2 // +1\n    // Loop n times\n    for _ in 0 ..&lt; n { // +1\n        print(0) // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    var a = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for(let i = 0; i &lt; n; i++){ // +1 (i++ is executed each round)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void{\n    var a: number = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for(let i = 0; i &lt; n; i++){ // +1 (i++ is executed each round)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +1\n  a = a + 1; // +1\n  a = a * 2; // +1\n  // Loop n times\n  for (int i = 0; i &lt; n; i++) { // +1 (i++ is executed each round)\n    print(0); // +1\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;   // +1\n    a = a + 1;      // +1\n    a = a * 2;      // +1\n\n    // Loop n times\n    for _ in 0..n { // +1 (i++ is executed each round)\n        println!(\"{}\", 0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // +1 (i++ is executed each round)\n        printf(\"%d\", 0);            // +1\n    }\n}\n</code></pre> <pre><code>fun algorithm(n: Int) {\n    var a = 1 // +1\n    a = a + 1 // +1\n    a = a * 2 // +1\n    // Loop n times\n    for (i in 0..&lt;n) { // +1 (i++ is executed each round)\n        println(0) // +1\n    }\n}\n</code></pre> <pre><code>def algorithm(n)\n    a = 1       # +1\n    a = a + 1   # +1\n    a = a * 2   # +1\n    # Loop n times\n    (0...n).each do # +1\n        puts 0      # +1\n    end\nend\n</code></pre> <p>Let the number of operations of the algorithm be a function of the input data size \\(n\\), denoted as \\(T(n)\\). Then the number of operations of the above function is:</p> \\[ T(n) = 3 + 2n \\] <p>\\(T(n)\\) is a linear function, indicating that its runtime growth trend is linear, and therefore its time complexity is linear order.</p> <p>We denote the time complexity of linear order as \\(O(n)\\). This mathematical symbol is called big-\\(O\\) notation, representing the asymptotic upper bound of the function \\(T(n)\\).</p> <p>Time complexity analysis essentially calculates the asymptotic upper bound of \"the number of operations \\(T(n)\\)\", which has a clear mathematical definition.</p> <p>Asymptotic upper bound of functions</p> <p>If there exist positive real numbers \\(c\\) and \\(n_0\\) such that for all \\(n &gt; n_0\\), we have \\(T(n) \\leq c \\cdot f(n)\\), then \\(f(n)\\) can be considered as an asymptotic upper bound of \\(T(n)\\), denoted as \\(T(n) = O(f(n))\\).</p> <p>As shown in Figure 2-8, calculating the asymptotic upper bound is to find a function \\(f(n)\\) such that when \\(n\\) tends to infinity, \\(T(n)\\) and \\(f(n)\\) are at the same growth level, differing only by a constant coefficient \\(c\\).</p> <p></p> <p> Figure 2-8 \u00a0 Asymptotic upper bound of a function </p>"},{"location":"chapter_computational_complexity/time_complexity/#233-derivation-method","title":"2.3.3 \u00a0 Derivation Method","text":"<p>The asymptotic upper bound has a bit of mathematical flavor. If you feel you haven't fully understood it, don't worry. We can first master the derivation method, and gradually grasp its mathematical meaning through continuous practice.</p> <p>According to the definition, after determining \\(f(n)\\), we can obtain the time complexity \\(O(f(n))\\). So how do we determine the asymptotic upper bound \\(f(n)\\)? Overall, it is divided into two steps: first count the number of operations, then determine the asymptotic upper bound.</p>"},{"location":"chapter_computational_complexity/time_complexity/#1-step-1-count-the-number-of-operations","title":"1. \u00a0 Step 1: Count the Number of Operations","text":"<p>For code, count from top to bottom line by line. However, since the constant coefficient \\(c\\) in \\(c \\cdot f(n)\\) above can be of any size, coefficients and constant terms in the number of operations \\(T(n)\\) can all be ignored. According to this principle, the following counting simplification techniques can be summarized.</p> <ol> <li>Ignore constants in \\(T(n)\\). Because they are all independent of \\(n\\), they do not affect time complexity.</li> <li>Omit all coefficients. For example, looping \\(2n\\) times, \\(5n + 1\\) times, etc., can all be simplified as \\(n\\) times, because the coefficient before \\(n\\) does not affect time complexity.</li> <li>Use multiplication for nested loops. The total number of operations equals the product of the number of operations in the outer and inner loops, with each layer of loop still able to apply techniques <code>1.</code> and <code>2.</code> separately.</li> </ol> <p>Given a function, we can use the above techniques to count the number of operations:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>def algorithm(n: int):\n    a = 1      # +0 (Technique 1)\n    a = a + n  # +0 (Technique 1)\n    # +n (Technique 2)\n    for i in range(5 * n + 1):\n        print(0)\n    # +n*n (Technique 3)\n    for i in range(2 * n):\n        for j in range(n + 1):\n            print(0)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (Technique 1)\n    a = a + n;  // +0 (Technique 1)\n    // +n (Technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n    // +n*n (Technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            cout &lt;&lt; 0 &lt;&lt; endl;\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (Technique 1)\n    a = a + n;  // +0 (Technique 1)\n    // +n (Technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        System.out.println(0);\n    }\n    // +n*n (Technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            System.out.println(0);\n        }\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +0 (Technique 1)\n    a = a + n;  // +0 (Technique 1)\n    // +n (Technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        Console.WriteLine(0);\n    }\n    // +n*n (Technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            Console.WriteLine(0);\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1     // +0 (Technique 1)\n    a = a + n  // +0 (Technique 1)\n    // +n (Technique 2)\n    for i := 0; i &lt; 5 * n + 1; i++ {\n        fmt.Println(0)\n    }\n    // +n*n (Technique 3)\n    for i := 0; i &lt; 2 * n; i++ {\n        for j := 0; j &lt; n + 1; j++ {\n            fmt.Println(0)\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +0 (Technique 1)\n    a = a + n // +0 (Technique 1)\n    // +n (Technique 2)\n    for _ in 0 ..&lt; (5 * n + 1) {\n        print(0)\n    }\n    // +n*n (Technique 3)\n    for _ in 0 ..&lt; (2 * n) {\n        for _ in 0 ..&lt; (n + 1) {\n            print(0)\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    let a = 1;  // +0 (Technique 1)\n    a = a + n;  // +0 (Technique 1)\n    // +n (Technique 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (Technique 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    let a = 1;  // +0 (Technique 1)\n    a = a + n;  // +0 (Technique 1)\n    // +n (Technique 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (Technique 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +0 (Technique 1)\n  a = a + n; // +0 (Technique 1)\n  // +n (Technique 2)\n  for (int i = 0; i &lt; 5 * n + 1; i++) {\n    print(0);\n  }\n  // +n*n (Technique 3)\n  for (int i = 0; i &lt; 2 * n; i++) {\n    for (int j = 0; j &lt; n + 1; j++) {\n      print(0);\n    }\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;     // +0 (Technique 1)\n    a = a + n;        // +0 (Technique 1)\n\n    // +n (Technique 2)\n    for i in 0..(5 * n + 1) {\n        println!(\"{}\", 0);\n    }\n\n    // +n*n (Technique 3)\n    for i in 0..(2 * n) {\n        for j in 0..(n + 1) {\n            println!(\"{}\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (Technique 1)\n    a = a + n;  // +0 (Technique 1)\n    // +n (Technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        printf(\"%d\", 0);\n    }\n    // +n*n (Technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            printf(\"%d\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>fun algorithm(n: Int) {\n    var a = 1   // +0 (Technique 1)\n    a = a + n   // +0 (Technique 1)\n    // +n (Technique 2)\n    for (i in 0..&lt;5 * n + 1) {\n        println(0)\n    }\n    // +n*n (Technique 3)\n    for (i in 0..&lt;2 * n) {\n        for (j in 0..&lt;n + 1) {\n            println(0)\n        }\n    }\n}\n</code></pre> <pre><code>def algorithm(n)\n    a = 1       # +0 (Technique 1)\n    a = a + n   # +0 (Technique 1)\n    # +n (Technique 2)\n    (0...(5 * n + 1)).each do { puts 0 }\n    # +n*n (Technique 3)\n    (0...(2 * n)).each do\n        (0...(n + 1)).each do { puts 0 }\n    end\nend\n</code></pre> <p>The following formula shows the counting results before and after using the above techniques; both derive a time complexity of \\(O(n^2)\\).</p> \\[ \\begin{aligned} T(n) &amp; = 2n(n + 1) + (5n + 1) + 2 &amp; \\text{Complete count (-.-|||)} \\newline &amp; = 2n^2 + 7n + 3 \\newline T(n) &amp; = n^2 + n &amp; \\text{Simplified count (o.O)} \\end{aligned} \\]"},{"location":"chapter_computational_complexity/time_complexity/#2-step-2-determine-the-asymptotic-upper-bound","title":"2. \u00a0 Step 2: Determine the Asymptotic Upper Bound","text":"<p>Time complexity is determined by the highest-order term in \\(T(n)\\). This is because as \\(n\\) tends to infinity, the highest-order term will play a dominant role, and the influence of other terms can be ignored.</p> <p>Table 2-2 shows some examples, where some exaggerated values are used to emphasize the conclusion that \"coefficients cannot shake the order\". When \\(n\\) tends to infinity, these constants become insignificant.</p> <p> Table 2-2 \u00a0 Time complexities corresponding to different numbers of operations </p> Number of Operations \\(T(n)\\) Time Complexity \\(O(f(n))\\) \\(100000\\) \\(O(1)\\) \\(3n + 2\\) \\(O(n)\\) \\(2n^2 + 3n + 2\\) \\(O(n^2)\\) \\(n^3 + 10000n^2\\) \\(O(n^3)\\) \\(2^n + 10000n^{10000}\\) \\(O(2^n)\\)"},{"location":"chapter_computational_complexity/time_complexity/#234-common-types","title":"2.3.4 \u00a0 Common Types","text":"<p>Let the input data size be \\(n\\). Common time complexity types are shown in Figure 2-9 (arranged in order from low to high).</p> \\[ \\begin{aligned} O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!) \\newline \\text{Constant order} &lt; \\text{Logarithmic order} &lt; \\text{Linear order} &lt; \\text{Linearithmic order} &lt; \\text{Quadratic order} &lt; \\text{Exponential order} &lt; \\text{Factorial order} \\end{aligned} \\] <p></p> <p> Figure 2-9 \u00a0 Common time complexity types </p>"},{"location":"chapter_computational_complexity/time_complexity/#1-constant-order-o1","title":"1. \u00a0 Constant Order \\(O(1)\\)","text":"<p>The number of operations in constant order is independent of the input data size \\(n\\), meaning it does not change as \\(n\\) changes.</p> <p>In the following function, although the number of operations <code>size</code> may be large, since it is independent of the input data size \\(n\\), the time complexity remains \\(O(1)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def constant(n: int) -&gt; int:\n    \"\"\"Constant order\"\"\"\n    count = 0\n    size = 100000\n    for _ in range(size):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Constant order */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Constant order */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Constant order */\nint Constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Constant order */\nfunc constant(n int) int {\n    count := 0\n    size := 100000\n    for i := 0; i &lt; size; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Constant order */\nfunc constant(n: Int) -&gt; Int {\n    var count = 0\n    let size = 100_000\n    for _ in 0 ..&lt; size {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Constant order */\nfunction constant(n) {\n    let count = 0;\n    const size = 100000;\n    for (let i = 0; i &lt; size; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Constant order */\nfunction constant(n: number): number {\n    let count = 0;\n    const size = 100000;\n    for (let i = 0; i &lt; size; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Constant order */\nint constant(int n) {\n  int count = 0;\n  int size = 100000;\n  for (var i = 0; i &lt; size; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Constant order */\nfn constant(n: i32) -&gt; i32 {\n    _ = n;\n    let mut count = 0;\n    let size = 100_000;\n    for _ in 0..size {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Constant order */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    int i = 0;\n    for (int i = 0; i &lt; size; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Constant order */\nfun constant(n: Int): Int {\n    var count = 0\n    val size = 100000\n    for (i in 0..&lt;size)\n        count++\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Constant time ###\ndef constant(n)\n  count = 0\n  size = 100000\n\n  (0...size).each { count += 1 }\n\n  count\nend\n</code></pre>"},{"location":"chapter_computational_complexity/time_complexity/#2-linear-order-on","title":"2. \u00a0 Linear Order \\(O(n)\\)","text":"<p>The number of operations in linear order grows linearly relative to the input data size \\(n\\). Linear order typically appears in single-layer loops:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def linear(n: int) -&gt; int:\n    \"\"\"Linear order\"\"\"\n    count = 0\n    for _ in range(n):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Linear order */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Linear order */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Linear order */\nint Linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Linear order */\nfunc linear(n int) int {\n    count := 0\n    for i := 0; i &lt; n; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Linear order */\nfunc linear(n: Int) -&gt; Int {\n    var count = 0\n    for _ in 0 ..&lt; n {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Linear order */\nfunction linear(n) {\n    let count = 0;\n    for (let i = 0; i &lt; n; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Linear order */\nfunction linear(n: number): number {\n    let count = 0;\n    for (let i = 0; i &lt; n; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Linear order */\nint linear(int n) {\n  int count = 0;\n  for (var i = 0; i &lt; n; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Linear order */\nfn linear(n: i32) -&gt; i32 {\n    let mut count = 0;\n    for _ in 0..n {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Linear order */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Linear order */\nfun linear(n: Int): Int {\n    var count = 0\n    for (i in 0..&lt;n)\n        count++\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Linear time ###\ndef linear(n)\n  count = 0\n  (0...n).each { count += 1 }\n  count\nend\n</code></pre> <p>Operations such as traversing arrays and traversing linked lists have a time complexity of \\(O(n)\\), where \\(n\\) is the length of the array or linked list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def array_traversal(nums: list[int]) -&gt; int:\n    \"\"\"Linear order (traversing array)\"\"\"\n    count = 0\n    # Number of iterations is proportional to the array length\n    for num in nums:\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Linear order (traversing array) */\nint arrayTraversal(vector&lt;int&gt; &amp;nums) {\n    int count = 0;\n    // Number of iterations is proportional to the array length\n    for (int num : nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Linear order (traversing array) */\nint arrayTraversal(int[] nums) {\n    int count = 0;\n    // Number of iterations is proportional to the array length\n    for (int num : nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Linear order (traversing array) */\nint ArrayTraversal(int[] nums) {\n    int count = 0;\n    // Number of iterations is proportional to the array length\n    foreach (int num in nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Linear order (traversing array) */\nfunc arrayTraversal(nums []int) int {\n    count := 0\n    // Number of iterations is proportional to the array length\n    for range nums {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Linear order (traversing array) */\nfunc arrayTraversal(nums: [Int]) -&gt; Int {\n    var count = 0\n    // Number of iterations is proportional to the array length\n    for _ in nums {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Linear order (traversing array) */\nfunction arrayTraversal(nums) {\n    let count = 0;\n    // Number of iterations is proportional to the array length\n    for (let i = 0; i &lt; nums.length; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Linear order (traversing array) */\nfunction arrayTraversal(nums: number[]): number {\n    let count = 0;\n    // Number of iterations is proportional to the array length\n    for (let i = 0; i &lt; nums.length; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Linear order (traversing array) */\nint arrayTraversal(List&lt;int&gt; nums) {\n  int count = 0;\n  // Number of iterations is proportional to the array length\n  for (var _num in nums) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Linear order (traversing array) */\nfn array_traversal(nums: &amp;[i32]) -&gt; i32 {\n    let mut count = 0;\n    // Number of iterations is proportional to the array length\n    for _ in nums {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Linear order (traversing array) */\nint arrayTraversal(int *nums, int n) {\n    int count = 0;\n    // Number of iterations is proportional to the array length\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Linear order (traversing array) */\nfun arrayTraversal(nums: IntArray): Int {\n    var count = 0\n    // Number of iterations is proportional to the array length\n    for (num in nums) {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Linear time (array traversal) ###\ndef array_traversal(nums)\n  count = 0\n\n  # Number of iterations is proportional to the array length\n  for num in nums\n    count += 1\n  end\n\n  count\nend\n</code></pre> <p>It is worth noting that the input data size \\(n\\) should be determined according to the type of input data. For example, in the first example, the variable \\(n\\) is the input data size; in the second example, the array length \\(n\\) is the data size.</p>"},{"location":"chapter_computational_complexity/time_complexity/#3-quadratic-order-on2","title":"3. \u00a0 Quadratic Order \\(O(n^2)\\)","text":"<p>The number of operations in quadratic order grows quadratically relative to the input data size \\(n\\). Quadratic order typically appears in nested loops, where both the outer and inner loops have a time complexity of \\(O(n)\\), resulting in an overall time complexity of \\(O(n^2)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def quadratic(n: int) -&gt; int:\n    \"\"\"Quadratic order\"\"\"\n    count = 0\n    # Number of iterations is quadratically related to the data size n\n    for i in range(n):\n        for j in range(n):\n            count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Exponential order */\nint quadratic(int n) {\n    int count = 0;\n    // Number of iterations is quadratically related to the data size n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Exponential order */\nint quadratic(int n) {\n    int count = 0;\n    // Number of iterations is quadratically related to the data size n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Exponential order */\nint Quadratic(int n) {\n    int count = 0;\n    // Number of iterations is quadratically related to the data size n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Exponential order */\nfunc quadratic(n int) int {\n    count := 0\n    // Number of iterations is quadratically related to the data size n\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; n; j++ {\n            count++\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Exponential order */\nfunc quadratic(n: Int) -&gt; Int {\n    var count = 0\n    // Number of iterations is quadratically related to the data size n\n    for _ in 0 ..&lt; n {\n        for _ in 0 ..&lt; n {\n            count += 1\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Exponential order */\nfunction quadratic(n) {\n    let count = 0;\n    // Number of iterations is quadratically related to the data size n\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Exponential order */\nfunction quadratic(n: number): number {\n    let count = 0;\n    // Number of iterations is quadratically related to the data size n\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Exponential order */\nint quadratic(int n) {\n  int count = 0;\n  // Number of iterations is quadratically related to the data size n\n  for (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n      count++;\n    }\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Exponential order */\nfn quadratic(n: i32) -&gt; i32 {\n    let mut count = 0;\n    // Number of iterations is quadratically related to the data size n\n    for _ in 0..n {\n        for _ in 0..n {\n            count += 1;\n        }\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Exponential order */\nint quadratic(int n) {\n    int count = 0;\n    // Number of iterations is quadratically related to the data size n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Exponential order */\nfun quadratic(n: Int): Int {\n    var count = 0\n    // Number of iterations is quadratically related to the data size n\n    for (i in 0..&lt;n) {\n        for (j in 0..&lt;n) {\n            count++\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Quadratic time ###\ndef quadratic(n)\n  count = 0\n\n  # Number of iterations is quadratically related to the data size n\n  for i in 0...n\n    for j in 0...n\n      count += 1\n    end\n  end\n\n  count\nend\n</code></pre> <p>Figure 2-10 compares constant order, linear order, and quadratic order time complexities.</p> <p></p> <p> Figure 2-10 \u00a0 Time complexities of constant, linear, and quadratic orders </p> <p>Taking bubble sort as an example, the outer loop executes \\(n - 1\\) times, and the inner loop executes \\(n-1\\), \\(n-2\\), \\(\\dots\\), \\(2\\), \\(1\\) times, averaging \\(n / 2\\) times, resulting in a time complexity of \\(O((n - 1) n / 2) = O(n^2)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def bubble_sort(nums: list[int]) -&gt; int:\n    \"\"\"Quadratic order (bubble sort)\"\"\"\n    count = 0  # Counter\n    # Outer loop: unsorted range is [0, i]\n    for i in range(len(nums) - 1, 0, -1):\n        # Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j in range(i):\n            if nums[j] &gt; nums[j + 1]:\n                # Swap nums[j] and nums[j + 1]\n                tmp: int = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = tmp\n                count += 3  # Element swap includes 3 unit operations\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Quadratic order (bubble sort) */\nint bubbleSort(vector&lt;int&gt; &amp;nums) {\n    int count = 0; // Counter\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.size() - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Quadratic order (bubble sort) */\nint bubbleSort(int[] nums) {\n    int count = 0; // Counter\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Quadratic order (bubble sort) */\nint BubbleSort(int[] nums) {\n    int count = 0;  // Counter\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                (nums[j + 1], nums[j]) = (nums[j], nums[j + 1]);\n                count += 3;  // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Quadratic order (bubble sort) */\nfunc bubbleSort(nums []int) int {\n    count := 0 // Counter\n    // Outer loop: unsorted range is [0, i]\n    for i := len(nums) - 1; i &gt; 0; i-- {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j := 0; j &lt; i; j++ {\n            if nums[j] &gt; nums[j+1] {\n                // Swap nums[j] and nums[j + 1]\n                tmp := nums[j]\n                nums[j] = nums[j+1]\n                nums[j+1] = tmp\n                count += 3 // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Quadratic order (bubble sort) */\nfunc bubbleSort(nums: inout [Int]) -&gt; Int {\n    var count = 0 // Counter\n    // Outer loop: unsorted range is [0, i]\n    for i in nums.indices.dropFirst().reversed() {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j in 0 ..&lt; i {\n            if nums[j] &gt; nums[j + 1] {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = tmp\n                count += 3 // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Quadratic order (bubble sort) */\nfunction bubbleSort(nums) {\n    let count = 0; // Counter\n    // Outer loop: unsorted range is [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Quadratic order (bubble sort) */\nfunction bubbleSort(nums: number[]): number {\n    let count = 0; // Counter\n    // Outer loop: unsorted range is [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Quadratic order (bubble sort) */\nint bubbleSort(List&lt;int&gt; nums) {\n  int count = 0; // Counter\n  // Outer loop: unsorted range is [0, i]\n  for (var i = nums.length - 1; i &gt; 0; i--) {\n    // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n    for (var j = 0; j &lt; i; j++) {\n      if (nums[j] &gt; nums[j + 1]) {\n        // Swap nums[j] and nums[j + 1]\n        int tmp = nums[j];\n        nums[j] = nums[j + 1];\n        nums[j + 1] = tmp;\n        count += 3; // Element swap includes 3 unit operations\n      }\n    }\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Quadratic order (bubble sort) */\nfn bubble_sort(nums: &amp;mut [i32]) -&gt; i32 {\n    let mut count = 0; // Counter\n\n    // Outer loop: unsorted range is [0, i]\n    for i in (1..nums.len()).rev() {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j in 0..i {\n            if nums[j] &gt; nums[j + 1] {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // Element swap includes 3 unit operations\n            }\n        }\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Quadratic order (bubble sort) */\nint bubbleSort(int *nums, int n) {\n    int count = 0; // Counter\n    // Outer loop: unsorted range is [0, i]\n    for (int i = n - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Quadratic order (bubble sort) */\nfun bubbleSort(nums: IntArray): Int {\n    var count = 0 // Counter\n    // Outer loop: unsorted range is [0, i]\n    for (i in nums.size - 1 downTo 1) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (j in 0..&lt;i) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                val temp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = temp\n                count += 3 // Element swap includes 3 unit operations\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Quadratic time (bubble sort) ###\ndef bubble_sort(nums)\n  count = 0  # Counter\n\n  # Outer loop: unsorted range is [0, i]\n  for i in (nums.length - 1).downto(0)\n    # Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n    for j in 0...i\n      if nums[j] &gt; nums[j + 1]\n        # Swap nums[j] and nums[j + 1]\n        tmp = nums[j]\n        nums[j] = nums[j + 1]\n        nums[j + 1] = tmp\n        count += 3 # Element swap includes 3 unit operations\n      end\n    end\n  end\n\n  count\nend\n</code></pre>"},{"location":"chapter_computational_complexity/time_complexity/#4-exponential-order-o2n","title":"4. \u00a0 Exponential Order \\(O(2^n)\\)","text":"<p>Biological \"cell division\" is a typical example of exponential order growth: the initial state is \\(1\\) cell, after one round of division it becomes \\(2\\), after two rounds it becomes \\(4\\), and so on; after \\(n\\) rounds of division there are \\(2^n\\) cells.</p> <p>Figure 2-11 and the following code simulate the cell division process, with a time complexity of \\(O(2^n)\\). Note that the input \\(n\\) represents the number of division rounds, and the return value <code>count</code> represents the total number of divisions.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def exponential(n: int) -&gt; int:\n    \"\"\"Exponential order (loop implementation)\"\"\"\n    count = 0\n    base = 1\n    # Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in range(n):\n        for _ in range(base):\n            count += 1\n        base *= 2\n    # count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Exponential order (loop implementation) */\nint exponential(int n) {\n    int count = 0, base = 1;\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Exponential order (loop implementation) */\nint exponential(int n) {\n    int count = 0, base = 1;\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Exponential order (loop implementation) */\nint Exponential(int n) {\n    int count = 0, bas = 1;\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; bas; j++) {\n            count++;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Exponential order (loop implementation) */\nfunc exponential(n int) int {\n    count, base := 0, 1\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; base; j++ {\n            count++\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Exponential order (loop implementation) */\nfunc exponential(n: Int) -&gt; Int {\n    var count = 0\n    var base = 1\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in 0 ..&lt; n {\n        for _ in 0 ..&lt; base {\n            count += 1\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Exponential order (loop implementation) */\nfunction exponential(n) {\n    let count = 0,\n        base = 1;\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Exponential order (loop implementation) */\nfunction exponential(n: number): number {\n    let count = 0,\n        base = 1;\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Exponential order (loop implementation) */\nint exponential(int n) {\n  int count = 0, base = 1;\n  // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n  for (var i = 0; i &lt; n; i++) {\n    for (var j = 0; j &lt; base; j++) {\n      count++;\n    }\n    base *= 2;\n  }\n  // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Exponential order (loop implementation) */\nfn exponential(n: i32) -&gt; i32 {\n    let mut count = 0;\n    let mut base = 1;\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in 0..n {\n        for _ in 0..base {\n            count += 1\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Exponential order (loop implementation) */\nint exponential(int n) {\n    int count = 0;\n    int bas = 1;\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; bas; j++) {\n            count++;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Exponential order (loop implementation) */\nfun exponential(n: Int): Int {\n    var count = 0\n    var base = 1\n    // Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n    for (i in 0..&lt;n) {\n        for (j in 0..&lt;base) {\n            count++\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Exponential time (iterative) ###\ndef exponential(n)\n  count, base = 0, 1\n\n  # Cells divide into two every round, forming sequence 1, 2, 4, 8, ..., 2^(n-1)\n  (0...n).each do\n    (0...base).each { count += 1 }\n    base *= 2\n  end\n\n  # count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n  count\nend\n</code></pre> <p></p> <p> Figure 2-11 \u00a0 Time complexity of exponential order </p> <p>In actual algorithms, exponential order often appears in recursive functions. For example, in the following code, it recursively splits in two, stopping after \\(n\\) splits:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def exp_recur(n: int) -&gt; int:\n    \"\"\"Exponential order (recursive implementation)\"\"\"\n    if n == 1:\n        return 1\n    return exp_recur(n - 1) + exp_recur(n - 1) + 1\n</code></pre> time_complexity.cpp<pre><code>/* Exponential order (recursive implementation) */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.java<pre><code>/* Exponential order (recursive implementation) */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.cs<pre><code>/* Exponential order (recursive implementation) */\nint ExpRecur(int n) {\n    if (n == 1) return 1;\n    return ExpRecur(n - 1) + ExpRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.go<pre><code>/* Exponential order (recursive implementation) */\nfunc expRecur(n int) int {\n    if n == 1 {\n        return 1\n    }\n    return expRecur(n-1) + expRecur(n-1) + 1\n}\n</code></pre> time_complexity.swift<pre><code>/* Exponential order (recursive implementation) */\nfunc expRecur(n: Int) -&gt; Int {\n    if n == 1 {\n        return 1\n    }\n    return expRecur(n: n - 1) + expRecur(n: n - 1) + 1\n}\n</code></pre> time_complexity.js<pre><code>/* Exponential order (recursive implementation) */\nfunction expRecur(n) {\n    if (n === 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.ts<pre><code>/* Exponential order (recursive implementation) */\nfunction expRecur(n: number): number {\n    if (n === 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.dart<pre><code>/* Exponential order (recursive implementation) */\nint expRecur(int n) {\n  if (n == 1) return 1;\n  return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.rs<pre><code>/* Exponential order (recursive implementation) */\nfn exp_recur(n: i32) -&gt; i32 {\n    if n == 1 {\n        return 1;\n    }\n    exp_recur(n - 1) + exp_recur(n - 1) + 1\n}\n</code></pre> time_complexity.c<pre><code>/* Exponential order (recursive implementation) */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.kt<pre><code>/* Exponential order (recursive implementation) */\nfun expRecur(n: Int): Int {\n    if (n == 1) {\n        return 1\n    }\n    return expRecur(n - 1) + expRecur(n - 1) + 1\n}\n</code></pre> time_complexity.rb<pre><code>### Exponential time (recursive) ###\ndef exp_recur(n)\n  return 1 if n == 1\n  exp_recur(n - 1) + exp_recur(n - 1) + 1\nend\n</code></pre> <p>Exponential order growth is very rapid and is common in exhaustive methods (brute force search, backtracking, etc.). For problems with large data scales, exponential order is unacceptable and typically requires dynamic programming or greedy algorithms to solve.</p>"},{"location":"chapter_computational_complexity/time_complexity/#5-logarithmic-order-olog-n","title":"5. \u00a0 Logarithmic Order \\(O(\\log n)\\)","text":"<p>In contrast to exponential order, logarithmic order reflects the situation of \"reducing to half each round\". Let the input data size be \\(n\\). Since it is reduced to half each round, the number of loops is \\(\\log_2 n\\), which is the inverse function of \\(2^n\\).</p> <p>Figure 2-12 and the following code simulate the process of \"reducing to half each round\", with a time complexity of \\(O(\\log_2 n)\\), abbreviated as \\(O(\\log n)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def logarithmic(n: int) -&gt; int:\n    \"\"\"Logarithmic order (loop implementation)\"\"\"\n    count = 0\n    while n &gt; 1:\n        n = n / 2\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Logarithmic order (loop implementation) */\nint logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Logarithmic order (loop implementation) */\nint logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Logarithmic order (loop implementation) */\nint Logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n /= 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Logarithmic order (loop implementation) */\nfunc logarithmic(n int) int {\n    count := 0\n    for n &gt; 1 {\n        n = n / 2\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Logarithmic order (loop implementation) */\nfunc logarithmic(n: Int) -&gt; Int {\n    var count = 0\n    var n = n\n    while n &gt; 1 {\n        n = n / 2\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Logarithmic order (loop implementation) */\nfunction logarithmic(n) {\n    let count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Logarithmic order (loop implementation) */\nfunction logarithmic(n: number): number {\n    let count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Logarithmic order (loop implementation) */\nint logarithmic(int n) {\n  int count = 0;\n  while (n &gt; 1) {\n    n = n ~/ 2;\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Logarithmic order (loop implementation) */\nfn logarithmic(mut n: i32) -&gt; i32 {\n    let mut count = 0;\n    while n &gt; 1 {\n        n = n / 2;\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Logarithmic order (loop implementation) */\nint logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Logarithmic order (loop implementation) */\nfun logarithmic(n: Int): Int {\n    var n1 = n\n    var count = 0\n    while (n1 &gt; 1) {\n        n1 /= 2\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Logarithmic time (iterative) ###\ndef logarithmic(n)\n  count = 0\n\n  while n &gt; 1\n    n /= 2\n    count += 1\n  end\n\n  count\nend\n</code></pre> <p></p> <p> Figure 2-12 \u00a0 Time complexity of logarithmic order </p> <p>Like exponential order, logarithmic order also commonly appears in recursive functions. The following code forms a recursion tree of height \\(\\log_2 n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def log_recur(n: int) -&gt; int:\n    \"\"\"Logarithmic order (recursive implementation)\"\"\"\n    if n &lt;= 1:\n        return 0\n    return log_recur(n / 2) + 1\n</code></pre> time_complexity.cpp<pre><code>/* Logarithmic order (recursive implementation) */\nint logRecur(int n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.java<pre><code>/* Logarithmic order (recursive implementation) */\nint logRecur(int n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.cs<pre><code>/* Logarithmic order (recursive implementation) */\nint LogRecur(int n) {\n    if (n &lt;= 1) return 0;\n    return LogRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.go<pre><code>/* Logarithmic order (recursive implementation) */\nfunc logRecur(n int) int {\n    if n &lt;= 1 {\n        return 0\n    }\n    return logRecur(n/2) + 1\n}\n</code></pre> time_complexity.swift<pre><code>/* Logarithmic order (recursive implementation) */\nfunc logRecur(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return 0\n    }\n    return logRecur(n: n / 2) + 1\n}\n</code></pre> time_complexity.js<pre><code>/* Logarithmic order (recursive implementation) */\nfunction logRecur(n) {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.ts<pre><code>/* Logarithmic order (recursive implementation) */\nfunction logRecur(n: number): number {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.dart<pre><code>/* Logarithmic order (recursive implementation) */\nint logRecur(int n) {\n  if (n &lt;= 1) return 0;\n  return logRecur(n ~/ 2) + 1;\n}\n</code></pre> time_complexity.rs<pre><code>/* Logarithmic order (recursive implementation) */\nfn log_recur(n: i32) -&gt; i32 {\n    if n &lt;= 1 {\n        return 0;\n    }\n    log_recur(n / 2) + 1\n}\n</code></pre> time_complexity.c<pre><code>/* Logarithmic order (recursive implementation) */\nint logRecur(int n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.kt<pre><code>/* Logarithmic order (recursive implementation) */\nfun logRecur(n: Int): Int {\n    if (n &lt;= 1)\n        return 0\n    return logRecur(n / 2) + 1\n}\n</code></pre> time_complexity.rb<pre><code>### Logarithmic time (recursive) ###\ndef log_recur(n)\n  return 0 unless n &gt; 1\n  log_recur(n / 2) + 1\nend\n</code></pre> <p>Logarithmic order commonly appears in algorithms based on the divide-and-conquer strategy, embodying the algorithmic thinking of \"dividing into many\" and \"simplifying complexity\". It grows slowly and is the ideal time complexity second only to constant order.</p> <p>What is the base of \\(O(\\log n)\\)?</p> <p>To be precise, \"dividing into \\(m\\)\" corresponds to a time complexity of \\(O(\\log_m n)\\). And through the logarithmic base change formula, we can obtain time complexities with different bases that are equal:</p> \\[ O(\\log_m n) = O(\\log_k n / \\log_k m) = O(\\log_k n) \\] <p>That is to say, the base \\(m\\) can be converted without affecting the complexity. Therefore, we usually omit the base \\(m\\) and denote logarithmic order simply as \\(O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/time_complexity/#6-linearithmic-order-on-log-n","title":"6. \u00a0 Linearithmic Order \\(O(n \\log n)\\)","text":"<p>Linearithmic order commonly appears in nested loops, where the time complexities of the two layers of loops are \\(O(\\log n)\\) and \\(O(n)\\) respectively. The relevant code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def linear_log_recur(n: int) -&gt; int:\n    \"\"\"Linearithmic order\"\"\"\n    if n &lt;= 1:\n        return 1\n    # Divide into two, the scale of subproblems is reduced by half\n    count = linear_log_recur(n // 2) + linear_log_recur(n // 2)\n    # Current subproblem contains n operations\n    for _ in range(n):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Linearithmic order */\nint linearLogRecur(int n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Linearithmic order */\nint linearLogRecur(int n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Linearithmic order */\nint LinearLogRecur(int n) {\n    if (n &lt;= 1) return 1;\n    int count = LinearLogRecur(n / 2) + LinearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Linearithmic order */\nfunc linearLogRecur(n int) int {\n    if n &lt;= 1 {\n        return 1\n    }\n    count := linearLogRecur(n/2) + linearLogRecur(n/2)\n    for i := 0; i &lt; n; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Linearithmic order */\nfunc linearLogRecur(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return 1\n    }\n    var count = linearLogRecur(n: n / 2) + linearLogRecur(n: n / 2)\n    for _ in stride(from: 0, to: n, by: 1) {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Linearithmic order */\nfunction linearLogRecur(n) {\n    if (n &lt;= 1) return 1;\n    let count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (let i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Linearithmic order */\nfunction linearLogRecur(n: number): number {\n    if (n &lt;= 1) return 1;\n    let count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (let i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Linearithmic order */\nint linearLogRecur(int n) {\n  if (n &lt;= 1) return 1;\n  int count = linearLogRecur(n ~/ 2) + linearLogRecur(n ~/ 2);\n  for (var i = 0; i &lt; n; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Linearithmic order */\nfn linear_log_recur(n: i32) -&gt; i32 {\n    if n &lt;= 1 {\n        return 1;\n    }\n    let mut count = linear_log_recur(n / 2) + linear_log_recur(n / 2);\n    for _ in 0..n {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> time_complexity.c<pre><code>/* Linearithmic order */\nint linearLogRecur(int n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Linearithmic order */\nfun linearLogRecur(n: Int): Int {\n    if (n &lt;= 1)\n        return 1\n    var count = linearLogRecur(n / 2) + linearLogRecur(n / 2)\n    for (i in 0..&lt;n) {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Linearithmic time ###\ndef linear_log_recur(n)\n  return 1 unless n &gt; 1\n\n  count = linear_log_recur(n / 2) + linear_log_recur(n / 2)\n  (0...n).each { count += 1 }\n\n  count\nend\n</code></pre> <p>Figure 2-13 shows how linearithmic order is generated. Each level of the binary tree has a total of \\(n\\) operations, and the tree has \\(\\log_2 n + 1\\) levels, resulting in a time complexity of \\(O(n \\log n)\\).</p> <p></p> <p> Figure 2-13 \u00a0 Time complexity of linearithmic order </p> <p>Mainstream sorting algorithms typically have a time complexity of \\(O(n \\log n)\\), such as quicksort, merge sort, and heap sort.</p>"},{"location":"chapter_computational_complexity/time_complexity/#7-factorial-order-on","title":"7. \u00a0 Factorial Order \\(O(n!)\\)","text":"<p>Factorial order corresponds to the mathematical \"permutation\" problem. Given \\(n\\) distinct elements, find all possible permutation schemes; the number of schemes is:</p> \\[ n! = n \\times (n - 1) \\times (n - 2) \\times \\dots \\times 2 \\times 1 \\] <p>Factorials are typically implemented using recursion. As shown in Figure 2-14 and the following code, the first level splits into \\(n\\) branches, the second level splits into \\(n - 1\\) branches, and so on, until the \\(n\\)-th level when splitting stops:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby time_complexity.py<pre><code>def factorial_recur(n: int) -&gt; int:\n    \"\"\"Factorial order (recursive implementation)\"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    # Split from 1 into n\n    for _ in range(n):\n        count += factorial_recur(n - 1)\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* Factorial order (recursive implementation) */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    // Split from 1 into n\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* Factorial order (recursive implementation) */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    // Split from 1 into n\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* Factorial order (recursive implementation) */\nint FactorialRecur(int n) {\n    if (n == 0) return 1;\n    int count = 0;\n    // Split from 1 into n\n    for (int i = 0; i &lt; n; i++) {\n        count += FactorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* Factorial order (recursive implementation) */\nfunc factorialRecur(n int) int {\n    if n == 0 {\n        return 1\n    }\n    count := 0\n    // Split from 1 into n\n    for i := 0; i &lt; n; i++ {\n        count += factorialRecur(n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* Factorial order (recursive implementation) */\nfunc factorialRecur(n: Int) -&gt; Int {\n    if n == 0 {\n        return 1\n    }\n    var count = 0\n    // Split from 1 into n\n    for _ in 0 ..&lt; n {\n        count += factorialRecur(n: n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* Factorial order (recursive implementation) */\nfunction factorialRecur(n) {\n    if (n === 0) return 1;\n    let count = 0;\n    // Split from 1 into n\n    for (let i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* Factorial order (recursive implementation) */\nfunction factorialRecur(n: number): number {\n    if (n === 0) return 1;\n    let count = 0;\n    // Split from 1 into n\n    for (let i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* Factorial order (recursive implementation) */\nint factorialRecur(int n) {\n  if (n == 0) return 1;\n  int count = 0;\n  // Split from 1 into n\n  for (var i = 0; i &lt; n; i++) {\n    count += factorialRecur(n - 1);\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* Factorial order (recursive implementation) */\nfn factorial_recur(n: i32) -&gt; i32 {\n    if n == 0 {\n        return 1;\n    }\n    let mut count = 0;\n    // Split from 1 into n\n    for _ in 0..n {\n        count += factorial_recur(n - 1);\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* Factorial order (recursive implementation) */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* Factorial order (recursive implementation) */\nfun factorialRecur(n: Int): Int {\n    if (n == 0)\n        return 1\n    var count = 0\n    // Split from 1 into n\n    for (i in 0..&lt;n) {\n        count += factorialRecur(n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### Factorial time (recursive) ###\ndef factorial_recur(n)\n  return 1 if n == 0\n\n  count = 0\n  # Split from 1 into n\n  (0...n).each { count += factorial_recur(n - 1) }\n\n  count\nend\n</code></pre> <p></p> <p> Figure 2-14 \u00a0 Time complexity of factorial order </p> <p>Note that because when \\(n \\geq 4\\) we always have \\(n! &gt; 2^n\\), factorial order grows faster than exponential order, and is also unacceptable for large \\(n\\).</p>"},{"location":"chapter_computational_complexity/time_complexity/#235-worst-best-and-average-time-complexities","title":"2.3.5 \u00a0 Worst, Best, and Average Time Complexities","text":"<p>The time efficiency of an algorithm is often not fixed, but is related to the distribution of the input data. Suppose we input an array <code>nums</code> of length \\(n\\), where <code>nums</code> consists of numbers from \\(1\\) to \\(n\\), with each number appearing only once, but the element order is randomly shuffled. The task is to return the index of element \\(1\\). We can draw the following conclusions.</p> <ul> <li>When <code>nums = [?, ?, ..., 1]</code>, i.e., when the last element is \\(1\\), it requires a complete traversal of the array, reaching worst-case time complexity \\(O(n)\\).</li> <li>When <code>nums = [1, ?, ?, ...]</code>, i.e., when the first element is \\(1\\), no matter how long the array is, there is no need to continue traversing, reaching best-case time complexity \\(\\Omega(1)\\).</li> </ul> <p>The \"worst-case time complexity\" corresponds to the function's asymptotic upper bound, denoted using big-\\(O\\) notation. Correspondingly, the \"best-case time complexity\" corresponds to the function's asymptotic lower bound, denoted using \\(\\Omega\\) notation:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby worst_best_time_complexity.py<pre><code>def random_numbers(n: int) -&gt; list[int]:\n    \"\"\"Generate an array with elements: 1, 2, ..., n, shuffled in order\"\"\"\n    # Generate array nums =: 1, 2, 3, ..., n\n    nums = [i for i in range(1, n + 1)]\n    # Randomly shuffle array elements\n    random.shuffle(nums)\n    return nums\n\ndef find_one(nums: list[int]) -&gt; int:\n    \"\"\"Find the index of number 1 in array nums\"\"\"\n    for i in range(len(nums)):\n        # When element 1 is at the head of the array, best time complexity O(1) is achieved\n        # When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if nums[i] == 1:\n            return i\n    return -1\n</code></pre> worst_best_time_complexity.cpp<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nvector&lt;int&gt; randomNumbers(int n) {\n    vector&lt;int&gt; nums(n);\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // Use system time to generate random seed\n    unsigned seed = chrono::system_clock::now().time_since_epoch().count();\n    // Randomly shuffle array elements\n    shuffle(nums.begin(), nums.end(), default_random_engine(seed));\n    return nums;\n}\n\n/* Find the index of number 1 in array nums */\nint findOne(vector&lt;int&gt; &amp;nums) {\n    for (int i = 0; i &lt; nums.size(); i++) {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.java<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nint[] randomNumbers(int n) {\n    Integer[] nums = new Integer[n];\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // Randomly shuffle array elements\n    Collections.shuffle(Arrays.asList(nums));\n    // Integer[] -&gt; int[]\n    int[] res = new int[n];\n    for (int i = 0; i &lt; n; i++) {\n        res[i] = nums[i];\n    }\n    return res;\n}\n\n/* Find the index of number 1 in array nums */\nint findOne(int[] nums) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.cs<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nint[] RandomNumbers(int n) {\n    int[] nums = new int[n];\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n\n    // Randomly shuffle array elements\n    for (int i = 0; i &lt; nums.Length; i++) {\n        int index = new Random().Next(i, nums.Length);\n        (nums[i], nums[index]) = (nums[index], nums[i]);\n    }\n    return nums;\n}\n\n/* Find the index of number 1 in array nums */\nint FindOne(int[] nums) {\n    for (int i = 0; i &lt; nums.Length; i++) {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.go<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nfunc randomNumbers(n int) []int {\n    nums := make([]int, n)\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for i := 0; i &lt; n; i++ {\n        nums[i] = i + 1\n    }\n    // Randomly shuffle array elements\n    rand.Shuffle(len(nums), func(i, j int) {\n        nums[i], nums[j] = nums[j], nums[i]\n    })\n    return nums\n}\n\n/* Find the index of number 1 in array nums */\nfunc findOne(nums []int) int {\n    for i := 0; i &lt; len(nums); i++ {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if nums[i] == 1 {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.swift<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nfunc randomNumbers(n: Int) -&gt; [Int] {\n    // Generate array nums = { 1, 2, 3, ..., n }\n    var nums = Array(1 ... n)\n    // Randomly shuffle array elements\n    nums.shuffle()\n    return nums\n}\n\n/* Find the index of number 1 in array nums */\nfunc findOne(nums: [Int]) -&gt; Int {\n    for i in nums.indices {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if nums[i] == 1 {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.js<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nfunction randomNumbers(n) {\n    const nums = Array(n);\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // Randomly shuffle array elements\n    for (let i = 0; i &lt; n; i++) {\n        const r = Math.floor(Math.random() * (i + 1));\n        const temp = nums[i];\n        nums[i] = nums[r];\n        nums[r] = temp;\n    }\n    return nums;\n}\n\n/* Find the index of number 1 in array nums */\nfunction findOne(nums) {\n    for (let i = 0; i &lt; nums.length; i++) {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if (nums[i] === 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.ts<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nfunction randomNumbers(n: number): number[] {\n    const nums = Array(n);\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // Randomly shuffle array elements\n    for (let i = 0; i &lt; n; i++) {\n        const r = Math.floor(Math.random() * (i + 1));\n        const temp = nums[i];\n        nums[i] = nums[r];\n        nums[r] = temp;\n    }\n    return nums;\n}\n\n/* Find the index of number 1 in array nums */\nfunction findOne(nums: number[]): number {\n    for (let i = 0; i &lt; nums.length; i++) {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if (nums[i] === 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.dart<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nList&lt;int&gt; randomNumbers(int n) {\n  final nums = List.filled(n, 0);\n  // Generate array nums = { 1, 2, 3, ..., n }\n  for (var i = 0; i &lt; n; i++) {\n    nums[i] = i + 1;\n  }\n  // Randomly shuffle array elements\n  nums.shuffle();\n\n  return nums;\n}\n\n/* Find the index of number 1 in array nums */\nint findOne(List&lt;int&gt; nums) {\n  for (var i = 0; i &lt; nums.length; i++) {\n    // When element 1 is at the head of the array, best time complexity O(1) is achieved\n    // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n    if (nums[i] == 1) return i;\n  }\n\n  return -1;\n}\n</code></pre> worst_best_time_complexity.rs<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nfn random_numbers(n: i32) -&gt; Vec&lt;i32&gt; {\n    // Generate array nums = { 1, 2, 3, ..., n }\n    let mut nums = (1..=n).collect::&lt;Vec&lt;i32&gt;&gt;();\n    // Randomly shuffle array elements\n    nums.shuffle(&amp;mut thread_rng());\n    nums\n}\n\n/* Find the index of number 1 in array nums */\nfn find_one(nums: &amp;[i32]) -&gt; Option&lt;usize&gt; {\n    for i in 0..nums.len() {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if nums[i] == 1 {\n            return Some(i);\n        }\n    }\n    None\n}\n</code></pre> worst_best_time_complexity.c<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nint *randomNumbers(int n) {\n    // Allocate heap memory (create 1D variable-length array: n elements of type int)\n    int *nums = (int *)malloc(n * sizeof(int));\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // Randomly shuffle array elements\n    for (int i = n - 1; i &gt; 0; i--) {\n        int j = rand() % (i + 1);\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    return nums;\n}\n\n/* Find the index of number 1 in array nums */\nint findOne(int *nums, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.kt<pre><code>/* Generate an array with elements { 1, 2, ..., n }, order shuffled */\nfun randomNumbers(n: Int): Array&lt;Int?&gt; {\n    val nums = IntArray(n)\n    // Generate array nums = { 1, 2, 3, ..., n }\n    for (i in 0..&lt;n) {\n        nums[i] = i + 1\n    }\n    // Randomly shuffle array elements\n    nums.shuffle()\n    val res = arrayOfNulls&lt;Int&gt;(n)\n    for (i in 0..&lt;n) {\n        res[i] = nums[i]\n    }\n    return res\n}\n\n/* Find the index of number 1 in array nums */\nfun findOne(nums: Array&lt;Int?&gt;): Int {\n    for (i in nums.indices) {\n        // When element 1 is at the head of the array, best time complexity O(1) is achieved\n        // When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n        if (nums[i] == 1)\n            return i\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.rb<pre><code>### Generate array with elements: 1, 2, ..., n, shuffled ###\ndef random_numbers(n)\n  # Generate array nums =: 1, 2, 3, ..., n\n  nums = Array.new(n) { |i| i + 1 }\n  # Randomly shuffle array elements\n  nums.shuffle!\nend\n\n### Find index of number 1 in array nums ###\ndef find_one(nums)\n  for i in 0...nums.length\n    # When element 1 is at the head of the array, best time complexity O(1) is achieved\n    # When element 1 is at the tail of the array, worst time complexity O(n) is achieved\n    return i if nums[i] == 1\n  end\n\n  -1\nend\n</code></pre> <p>It is worth noting that we rarely use best-case time complexity in practice, because it can usually only be achieved with a very small probability and may be somewhat misleading. The worst-case time complexity is more practical because it gives a safety value for efficiency, allowing us to use the algorithm with confidence.</p> <p>From the above example, we can see that both worst-case and best-case time complexities only occur under \"special data distributions\", which may have a very small probability of occurrence and may not truly reflect the algorithm's running efficiency. In contrast, average time complexity can reflect the algorithm's running efficiency under random input data, denoted using the \\(\\Theta\\) notation.</p> <p>For some algorithms, we can simply derive the average case under random data distribution. For example, in the above example, since the input array is shuffled, the probability of element \\(1\\) appearing at any index is equal, so the algorithm's average number of loops is half the array length \\(n / 2\\), giving an average time complexity of \\(\\Theta(n / 2) = \\Theta(n)\\).</p> <p>But for more complex algorithms, calculating average time complexity is often quite difficult, because it is hard to analyze the overall mathematical expectation under data distribution. In this case, we usually use worst-case time complexity as the criterion for judging algorithm efficiency.</p> <p>Why is the \\(\\Theta\\) symbol rarely seen?</p> <p>This may be because the \\(O\\) symbol is too catchy, so we often use it to represent average time complexity. But strictly speaking, this practice is not standard. In this book and other materials, if you encounter expressions like \"average time complexity \\(O(n)\\)\", please understand it directly as \\(\\Theta(n)\\).</p>"},{"location":"chapter_data_structure/","title":"Chapter 3. \u00a0 Data Structures","text":"<p>Abstract</p> <p>Data structure is like a sturdy and diverse framework.</p> <p>It provides a blueprint for the orderly organization of data, upon which algorithms come to life.</p>"},{"location":"chapter_data_structure/#chapter-contents","title":"Chapter contents","text":"<ul> <li>3.1 \u00a0 Classification of Data Structures</li> <li>3.2 \u00a0 Basic Data Types</li> <li>3.3 \u00a0 Number Encoding *</li> <li>3.4 \u00a0 Character Encoding *</li> <li>3.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_data_structure/basic_data_types/","title":"3.2 \u00a0 Basic Data Types","text":"<p>When we talk about data in computers, we think of various forms such as text, images, videos, audio, 3D models, and more. Although these data are organized in different ways, they are all composed of various basic data types.</p> <p>Basic data types are types that the CPU can directly operate on, and they are directly used in algorithms, mainly including the following.</p> <ul> <li>Integer types <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>.</li> <li>Floating-point types <code>float</code>, <code>double</code>, used to represent decimal numbers.</li> <li>Character type <code>char</code>, used to represent letters, punctuation marks, and even emojis in various languages.</li> <li>Boolean type <code>bool</code>, used to represent \"yes\" and \"no\" judgments.</li> </ul> <p>Basic data types are stored in binary form in computers. One binary bit is \\(1\\) bit. In most modern operating systems, \\(1\\) byte consists of \\(8\\) bits.</p> <p>The range of values for basic data types depends on the size of the space they occupy. Below is an example using Java.</p> <ul> <li>Integer type <code>byte</code> occupies \\(1\\) byte = \\(8\\) bits, and can represent \\(2^{8}\\) numbers.</li> <li>Integer type <code>int</code> occupies \\(4\\) bytes = \\(32\\) bits, and can represent \\(2^{32}\\) numbers.</li> </ul> <p>The following table lists the space occupied, value ranges, and default values of various basic data types in Java. You don't need to memorize this table; a general understanding is sufficient, and you can refer to it when needed.</p> <p> Table 3-1 \u00a0 Space occupied and value ranges of basic data types </p> Type Symbol Space Occupied Minimum Value Maximum Value Default Value Integer <code>byte</code> 1 byte \\(-2^7\\) (\\(-128\\)) \\(2^7 - 1\\) (\\(127\\)) \\(0\\) <code>short</code> 2 bytes \\(-2^{15}\\) \\(2^{15} - 1\\) \\(0\\) <code>int</code> 4 bytes \\(-2^{31}\\) \\(2^{31} - 1\\) \\(0\\) <code>long</code> 8 bytes \\(-2^{63}\\) \\(2^{63} - 1\\) \\(0\\) Float <code>float</code> 4 bytes \\(1.175 \\times 10^{-38}\\) \\(3.403 \\times 10^{38}\\) \\(0.0\\text{f}\\) <code>double</code> 8 bytes \\(2.225 \\times 10^{-308}\\) \\(1.798 \\times 10^{308}\\) \\(0.0\\) Character <code>char</code> 2 bytes \\(0\\) \\(2^{16} - 1\\) \\(0\\) Boolean <code>bool</code> 1 byte \\(\\text{false}\\) \\(\\text{true}\\) \\(\\text{false}\\) <p>Please note that the above table is specific to Java's basic data types. Each programming language has its own data type definitions, and their space occupied, value ranges, and default values may vary.</p> <ul> <li>In Python, the integer type <code>int</code> can be of any size, limited only by available memory; the floating-point type <code>float</code> is double-precision 64-bit; there is no <code>char</code> type, a single character is actually a string <code>str</code> of length 1.</li> <li>C and C++ do not explicitly specify the size of basic data types, which varies by implementation and platform. The above table follows the LP64 data model, which is used in Unix 64-bit operating systems including Linux and macOS.</li> <li>The size of character <code>char</code> is 1 byte in C and C++, and in most programming languages it depends on the specific character encoding method, as detailed in the \"Character Encoding\" section.</li> <li>Even though representing a boolean value requires only 1 bit (\\(0\\) or \\(1\\)), it is usually stored as 1 byte in memory. This is because modern computer CPUs typically use 1 byte as the minimum addressable memory unit.</li> </ul> <p>So, what is the relationship between basic data types and data structures? We know that data structures are ways of organizing and storing data in computers. The subject of this statement is \"structure\", not \"data\".</p> <p>If we want to represent \"a row of numbers\", we naturally think of using an array. This is because the linear structure of an array can represent the adjacency and order relationships of numbers, but the content stored\u2014whether integer <code>int</code>, floating-point <code>float</code>, or character <code>char</code>\u2014is unrelated to the \"data structure\".</p> <p>In other words, basic data types provide the \"content type\" of data, while data structures provide the \"organization method\" of data. For example, in the following code, we use the same data structure (array) to store and represent different basic data types, including <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code>, etc.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code># Initialize arrays using various basic data types\nnumbers: list[int] = [0] * 5\ndecimals: list[float] = [0.0] * 5\n# In Python, characters are actually strings of length 1\ncharacters: list[str] = ['0'] * 5\nbools: list[bool] = [False] * 5\n# Python lists can freely store various basic data types and object references\ndata = [0, 0.0, 'a', False, ListNode(0)]\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nint numbers[5];\nfloat decimals[5];\nchar characters[5];\nbool bools[5];\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nint[] numbers = new int[5];\nfloat[] decimals = new float[5];\nchar[] characters = new char[5];\nboolean[] bools = new boolean[5];\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nint[] numbers = new int[5];\nfloat[] decimals = new float[5];\nchar[] characters = new char[5];\nbool[] bools = new bool[5];\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nvar numbers = [5]int{}\nvar decimals = [5]float64{}\nvar characters = [5]byte{}\nvar bools = [5]bool{}\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nlet numbers = Array(repeating: 0, count: 5)\nlet decimals = Array(repeating: 0.0, count: 5)\nlet characters: [Character] = Array(repeating: \"a\", count: 5)\nlet bools = Array(repeating: false, count: 5)\n</code></pre> <pre><code>// JavaScript arrays can freely store various basic data types and objects\nconst array = [0, 0.0, 'a', false];\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nconst numbers: number[] = [];\nconst characters: string[] = [];\nconst bools: boolean[] = [];\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nList&lt;int&gt; numbers = List.filled(5, 0);\nList&lt;double&gt; decimals = List.filled(5, 0.0);\nList&lt;String&gt; characters = List.filled(5, 'a');\nList&lt;bool&gt; bools = List.filled(5, false);\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nlet numbers: Vec&lt;i32&gt; = vec![0; 5];\nlet decimals: Vec&lt;f32&gt; = vec![0.0; 5];\nlet characters: Vec&lt;char&gt; = vec!['0'; 5];\nlet bools: Vec&lt;bool&gt; = vec![false; 5];\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nint numbers[10];\nfloat decimals[10];\nchar characters[10];\nbool bools[10];\n</code></pre> <pre><code>// Initialize arrays using various basic data types\nval numbers = IntArray(5)\nval decinals = FloatArray(5)\nval characters = CharArray(5)\nval bools = BooleanArray(5)\n</code></pre> <pre><code># Ruby lists can freely store various basic data types and object references\ndata = [0, 0.0, 'a', false, ListNode(0)]\n</code></pre> Visualized Execution <p>https://pythontutor.com/render.html#code=class%20ListNode%3A%0A%20%20%20%20%22%22%22%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%B1%BB%22%22%22%0A%20%20%20%20def%20__init__%28self,%20val%3A%20int%29%3A%0A%20%20%20%20%20%20%20%20self.val%3A%20int%20%3D%20val%20%20%23%20%E8%8A%82%E7%82%B9%E5%80%BC%0A%20%20%20%20%20%20%20%20self.next%3A%20ListNode%20%7C%20None%20%3D%20None%20%20%23%20%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%0A%20%20%20%20numbers%20%3D%20%5B0%5D%20*%205%0A%20%20%20%20decimals%20%3D%20%5B0.0%5D%20*%205%0A%20%20%20%20%23%20Python%20%E7%9A%84%E5%AD%97%E7%AC%A6%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E9%95%BF%E5%BA%A6%E4%B8%BA%201%20%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%0A%20%20%20%20characters%20%3D%20%5B'0'%5D%20*%205%0A%20%20%20%20bools%20%3D%20%5BFalse%5D%20*%205%0A%20%20%20%20%23%20Python%20%E7%9A%84%E5%88%97%E8%A1%A8%E5%8F%AF%E4%BB%A5%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E5%90%84%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%0A%20%20%20%20data%20%3D%20%5B0,%200.0,%20'a',%20False,%20ListNode%280%29%5D&amp;cumulative=false&amp;curInstr=12&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_data_structure/character_encoding/","title":"3.4 \u00a0 Character Encoding *","text":"<p>In computers, all data is stored in binary form, and character <code>char</code> is no exception. To represent characters, we need to establish a \"character set\" that defines a one-to-one correspondence between each character and binary numbers. With a character set, computers can convert binary numbers to characters by looking up the table.</p>"},{"location":"chapter_data_structure/character_encoding/#341-ascii-character-set","title":"3.4.1 \u00a0 Ascii Character Set","text":"<p>ASCII code is the earliest character set, with the full name American Standard Code for Information Interchange. It uses 7 binary bits (the lower 7 bits of one byte) to represent a character, and can represent a maximum of 128 different characters. As shown in Figure 3-6, ASCII code includes uppercase and lowercase English letters, numbers 0 ~ 9, some punctuation marks, and some control characters (such as newline and tab).</p> <p></p> <p> Figure 3-6 \u00a0 ASCII code </p> <p>However, ASCII code can only represent English. With the globalization of computers, a character set called EASCII that can represent more languages emerged. It expands from the 7-bit basis of ASCII to 8 bits, and can represent 256 different characters.</p> <p>Worldwide, a batch of EASCII character sets suitable for different regions have appeared successively. The first 128 characters of these character sets are unified as ASCII code, and the last 128 characters are defined differently to adapt to the needs of different languages.</p>"},{"location":"chapter_data_structure/character_encoding/#342-gbk-character-set","title":"3.4.2 \u00a0 Gbk Character Set","text":"<p>Later, people found that EASCII code still cannot meet the character quantity requirements of many languages. For example, there are nearly one hundred thousand Chinese characters, and several thousand are used daily. In 1980, the China National Standardization Administration released the GB2312 character set, which included 6,763 Chinese characters, basically meeting the needs for computer processing of Chinese characters.</p> <p>However, GB2312 cannot handle some rare characters and traditional Chinese characters. The GBK character set is an extension based on GB2312, which includes a total of 21,886 Chinese characters. In the GBK encoding scheme, ASCII characters are represented using one byte, and Chinese characters are represented using two bytes.</p>"},{"location":"chapter_data_structure/character_encoding/#343-unicode-character-set","title":"3.4.3 \u00a0 Unicode Character Set","text":"<p>With the vigorous development of computer technology, character sets and encoding standards flourished, which brought many problems. On the one hand, these character sets generally only define characters for specific languages and cannot work normally in multilingual environments. On the other hand, multiple character set standards exist for the same language, and if two computers use different encoding standards, garbled characters will appear during information transmission.</p> <p>Researchers of that era thought: If a sufficiently complete character set is released that includes all languages and symbols in the world, wouldn't it be possible to solve cross-language environment and garbled character problems? Driven by this idea, a large and comprehensive character set, Unicode, was born.</p> <p>Unicode is called \"\u7edf\u4e00\u7801\" (Unified Code) in Chinese and can theoretically accommodate over one million characters. It is committed to including characters from around the world into a unified character set, providing a universal character set to handle and display various language texts, reducing garbled character problems caused by different encoding standards.</p> <p>Since its release in 1991, Unicode has continuously expanded to include new languages and characters. As of September 2022, Unicode has included 149,186 characters, including characters, symbols, and even emojis from various languages. In the vast Unicode character set, commonly used characters occupy 2 bytes, and some rare characters occupy 3 bytes or even 4 bytes.</p> <p>Unicode is a universal character set that essentially assigns a number (called a \"code point\") to each character, but it does not specify how to store these character code points in computers. We can't help but ask: when Unicode code points of multiple lengths appear simultaneously in a text, how does the system parse the characters? For example, given an encoding with a length of 2 bytes, how does the system determine whether it is one 2-byte character or two 1-byte characters?</p> <p>For the above problem, a straightforward solution is to store all characters as equal-length encodings. As shown in Figure 3-7, each character in \"Hello\" occupies 1 byte, and each character in \"\u7b97\u6cd5\" (algorithm) occupies 2 bytes. We can encode all characters in \"Hello \u7b97\u6cd5\" as 2 bytes in length by padding the high bits with 0. In this way, the system can parse one character every 2 bytes and restore the content of this phrase.</p> <p></p> <p> Figure 3-7 \u00a0 Unicode encoding example </p> <p>However, ASCII code has already proven to us that encoding English only requires 1 byte. If the above scheme is adopted, the size of English text will be twice that under ASCII encoding, which is very wasteful of memory space. Therefore, we need a more efficient Unicode encoding method.</p>"},{"location":"chapter_data_structure/character_encoding/#344-utf-8-encoding","title":"3.4.4 \u00a0 Utf-8 Encoding","text":"<p>Currently, UTF-8 has become the most widely used Unicode encoding method internationally. It is a variable-length encoding that uses 1 to 4 bytes to represent a character, depending on the complexity of the character. ASCII characters only require 1 byte, Latin and Greek letters require 2 bytes, commonly used Chinese characters require 3 bytes, and some other rare characters require 4 bytes.</p> <p>The encoding rules of UTF-8 are not complicated and can be divided into the following two cases.</p> <ul> <li>For 1-byte characters, set the highest bit to \\(0\\), and set the remaining 7 bits to the Unicode code point. It is worth noting that ASCII characters occupy the first 128 code points in the Unicode character set. That is to say, UTF-8 encoding is backward compatible with ASCII code. This means we can use UTF-8 to parse very old ASCII code text.</li> <li>For characters with a length of \\(n\\) bytes (where \\(n &gt; 1\\)), set the highest \\(n\\) bits of the first byte to \\(1\\), and set the \\((n + 1)\\)-th bit to \\(0\\); starting from the second byte, set the highest 2 bits of each byte to \\(10\\); use all remaining bits to fill in the Unicode code point of the character.</li> </ul> <p>Figure 3-8 shows the UTF-8 encoding corresponding to \"Hello\u7b97\u6cd5\". It can be observed that since the highest \\(n\\) bits are all set to \\(1\\), the system can parse the length of the character as \\(n\\) by reading the number of highest bits that are \\(1\\).</p> <p>But why set the highest 2 bits of all other bytes to \\(10\\)? In fact, this \\(10\\) can serve as a check symbol. Assuming the system starts parsing text from an incorrect byte, the \\(10\\) at the beginning of the byte can help the system quickly determine an anomaly.</p> <p>The reason for using \\(10\\) as a check symbol is that under UTF-8 encoding rules, it is impossible for a character's highest two bits to be \\(10\\). This conclusion can be proven by contradiction: assuming the highest two bits of a character are \\(10\\), it means the length of the character is \\(1\\), corresponding to ASCII code. However, the highest bit of ASCII code should be \\(0\\), which contradicts the assumption.</p> <p></p> <p> Figure 3-8 \u00a0 UTF-8 encoding example </p> <p>In addition to UTF-8, common encoding methods also include the following two.</p> <ul> <li>UTF-16 encoding: Uses 2 or 4 bytes to represent a character. All ASCII characters and commonly used non-English characters are represented with 2 bytes; a few characters need to use 4 bytes. For 2-byte characters, UTF-16 encoding is equal to the Unicode code point.</li> <li>UTF-32 encoding: Every character uses 4 bytes. This means that UTF-32 takes up more space than UTF-8 and UTF-16, especially for text with a high proportion of ASCII characters.</li> </ul> <p>From the perspective of storage space occupation, using UTF-8 to represent English characters is very efficient because it only requires 1 byte; using UTF-16 encoding for some non-English characters (such as Chinese) will be more efficient because it only requires 2 bytes, while UTF-8 may require 3 bytes.</p> <p>From a compatibility perspective, UTF-8 has the best universality, and many tools and libraries support UTF-8 first.</p>"},{"location":"chapter_data_structure/character_encoding/#345-character-encoding-in-programming-languages","title":"3.4.5 \u00a0 Character Encoding in Programming Languages","text":"<p>For most past programming languages, strings during program execution use fixed-length encodings such as UTF-16 or UTF-32. Under fixed-length encoding, we can treat strings as arrays for processing, and this approach has the following advantages.</p> <ul> <li>Random access: UTF-16 encoded strings can be easily accessed randomly. UTF-8 is a variable-length encoding. To find the \\(i\\)-th character, we need to traverse from the beginning of the string to the \\(i\\)-th character, which requires \\(O(n)\\) time.</li> <li>Character counting: Similar to random access, calculating the length of a UTF-16 encoded string is also an \\(O(1)\\) operation. However, calculating the length of a UTF-8 encoded string requires traversing the entire string.</li> <li>String operations: Many string operations (such as splitting, joining, inserting, deleting, etc.) on UTF-16 encoded strings are easier to perform. Performing these operations on UTF-8 encoded strings usually requires additional calculations to ensure that invalid UTF-8 encoding is not generated.</li> </ul> <p>In fact, the design of character encoding schemes for programming languages is a very interesting topic involving many factors.</p> <ul> <li>Java's <code>String</code> type uses UTF-16 encoding, with each character occupying 2 bytes. This is because at the beginning of Java language design, people believed that 16 bits were sufficient to represent all possible characters. However, this was an incorrect judgment. Later, the Unicode specification expanded beyond 16 bits, so characters in Java may now be represented by a pair of 16-bit values (called \"surrogate pairs\").</li> <li>The strings of JavaScript and TypeScript use UTF-16 encoding for reasons similar to Java. When Netscape first introduced the JavaScript language in 1995, Unicode was still in its early stages of development, and at that time, using 16-bit encoding was sufficient to represent all Unicode characters.</li> <li>C# uses UTF-16 encoding mainly because the .NET platform was designed by Microsoft, and many of Microsoft's technologies (including the Windows operating system) extensively use UTF-16 encoding.</li> </ul> <p>Due to the underestimation of character quantities by the above programming languages, they had to adopt the \"surrogate pair\" method to represent Unicode characters with lengths exceeding 16 bits. This is a reluctant compromise. On the one hand, in strings containing surrogate pairs, one character may occupy 2 bytes or 4 bytes, thus losing the advantage of fixed-length encoding. On the other hand, handling surrogate pairs requires additional code, which increases the complexity and difficulty of debugging in programming.</p> <p>For the above reasons, some programming languages have proposed different encoding schemes.</p> <ul> <li>Python's <code>str</code> uses Unicode encoding and adopts a flexible string representation where the stored character length depends on the largest Unicode code point in the string. If all characters in the string are ASCII characters, each character occupies 1 byte; if there are characters exceeding the ASCII range but all within the Basic Multilingual Plane (BMP), each character occupies 2 bytes; if there are characters exceeding the BMP, each character occupies 4 bytes.</li> <li>Go language's <code>string</code> type uses UTF-8 encoding internally. Go language also provides the <code>rune</code> type, which is used to represent a single Unicode code point.</li> <li>Rust language's <code>str</code> and <code>String</code> types use UTF-8 encoding internally. Rust also provides the <code>char</code> type for representing a single Unicode code point.</li> </ul> <p>It should be noted that the above discussion is about how strings are stored in programming languages, which is different from how strings are stored in files or transmitted over networks. In file storage or network transmission, we usually encode strings into UTF-8 format to achieve optimal compatibility and space efficiency.</p>"},{"location":"chapter_data_structure/classification_of_data_structure/","title":"3.1 \u00a0 Classification of Data Structures","text":"<p>Common data structures include arrays, linked lists, stacks, queues, hash tables, trees, heaps, and graphs. They can be classified from two dimensions: \"logical structure\" and \"physical structure\".</p>"},{"location":"chapter_data_structure/classification_of_data_structure/#311-logical-structure-linear-and-non-linear","title":"3.1.1 \u00a0 Logical Structure: Linear and Non-Linear","text":"<p>Logical structure reveals the logical relationships between data elements. In arrays and linked lists, data is arranged in a certain order, embodying the linear relationship between data; while in trees, data is arranged hierarchically from top to bottom, showing the derived relationship between \"ancestors\" and \"descendants\"; graphs are composed of nodes and edges, reflecting complex network relationships.</p> <p>As shown in Figure 3-1, logical structures can be divided into two major categories: \"linear\" and \"non-linear\". Linear structures are more intuitive, indicating that data is linearly arranged in logical relationships; non-linear structures are the opposite, arranged non-linearly.</p> <ul> <li>Linear data structures: Arrays, linked lists, stacks, queues, hash tables, where elements have a one-to-one sequential relationship.</li> <li>Non-linear data structures: Trees, heaps, graphs, hash tables.</li> </ul> <p>Non-linear data structures can be further divided into tree structures and network structures.</p> <ul> <li>Tree structures: Trees, heaps, hash tables, where elements have a one-to-many relationship.</li> <li>Network structures: Graphs, where elements have a many-to-many relationship.</li> </ul> <p></p> <p> Figure 3-1 \u00a0 Linear and non-linear data structures </p>"},{"location":"chapter_data_structure/classification_of_data_structure/#312-physical-structure-contiguous-and-dispersed","title":"3.1.2 \u00a0 Physical Structure: Contiguous and Dispersed","text":"<p>When an algorithm program runs, the data being processed is mainly stored in memory. Figure 3-2 shows a computer memory stick, where each black square contains a memory space. We can imagine memory as a huge Excel spreadsheet, where each cell can store a certain amount of data.</p> <p>The system accesses data at the target location through memory addresses. As shown in Figure 3-2, the computer assigns a number to each cell in the spreadsheet according to specific rules, ensuring that each memory space has a unique memory address. With these addresses, the program can access data in memory.</p> <p></p> <p> Figure 3-2 \u00a0 Memory stick, memory space, memory address </p> <p>Tip</p> <p>It is worth noting that comparing memory to an Excel spreadsheet is a simplified analogy. The actual working mechanism of memory is quite complex, involving concepts such as address space, memory management, cache mechanisms, virtual memory, and physical memory.</p> <p>Memory is a shared resource for all programs. When a block of memory is occupied by a program, it usually cannot be used by other programs at the same time. Therefore, in the design of data structures and algorithms, memory resources are an important consideration. For example, the peak memory occupied by an algorithm should not exceed the remaining free memory of the system; if there is a lack of contiguous large memory blocks, then the data structure chosen must be able to be stored in dispersed memory spaces.</p> <p>As shown in Figure 3-3, physical structure reflects the way data is stored in computer memory, and can be divided into contiguous space storage (arrays) and dispersed space storage (linked lists). The two physical structures exhibit complementary characteristics in terms of time efficiency and space efficiency.</p> <p></p> <p> Figure 3-3 \u00a0 Contiguous space storage and dispersed space storage </p> <p>It is worth noting that all data structures are implemented based on arrays, linked lists, or a combination of both. For example, stacks and queues can be implemented using either arrays or linked lists; while the implementation of hash tables may include both arrays and linked lists.</p> <ul> <li>Can be implemented based on arrays: Stacks, queues, hash tables, trees, heaps, graphs, matrices, tensors (arrays with dimensions \\(\\geq 3\\)), etc.</li> <li>Can be implemented based on linked lists: Stacks, queues, hash tables, trees, heaps, graphs, etc.</li> </ul> <p>After initialization, linked lists can still adjust their length during program execution, so they are also called \"dynamic data structures\". After initialization, the length of arrays cannot be changed, so they are also called \"static data structures\". It is worth noting that arrays can achieve length changes by reallocating memory, thus possessing a certain degree of \"dynamism\".</p> <p>Tip</p> <p>If you find it difficult to understand physical structure, it is recommended to read the next chapter first, and then review this section.</p>"},{"location":"chapter_data_structure/number_encoding/","title":"3.3 \u00a0 Number Encoding *","text":"<p>Tip</p> <p>In this book, chapters marked with an asterisk * are optional readings. If you are short on time or find them challenging, you may skip these initially and return to them after completing the essential chapters.</p>"},{"location":"chapter_data_structure/number_encoding/#331-sign-magnitude-1s-complement-and-2s-complement","title":"3.3.1 \u00a0 Sign-Magnitude, 1's Complement, and 2's Complement","text":"<p>In the table from the previous section, we found that all integer types can represent one more negative number than positive numbers. For example, the <code>byte</code> range is \\([-128, 127]\\). This phenomenon is counterintuitive, and its underlying reason involves knowledge of sign-magnitude, 1's complement, and 2's complement.</p> <p>First, it should be noted that numbers are stored in computers in the form of \"2's complement\". Before analyzing the reasons for this, let's first define these three concepts.</p> <ul> <li>Sign-magnitude: We treat the highest bit of the binary representation of a number as the sign bit, where \\(0\\) represents a positive number and \\(1\\) represents a negative number, and the remaining bits represent the value of the number.</li> <li>1's complement: The 1's complement of a positive number is the same as its sign-magnitude. For a negative number, the 1's complement is obtained by inverting all bits except the sign bit of its sign-magnitude.</li> <li>2's complement: The 2's complement of a positive number is the same as its sign-magnitude. For a negative number, the 2's complement is obtained by adding \\(1\\) to its 1's complement.</li> </ul> <p>Figure 3-4 shows the conversion methods among sign-magnitude, 1's complement, and 2's complement.</p> <p></p> <p> Figure 3-4 \u00a0 Conversions among sign-magnitude, 1's complement, and 2's complement </p> <p>Sign-magnitude, although the most intuitive, has some limitations. On one hand, the sign-magnitude of negative numbers cannot be directly used in operations. For example, calculating \\(1 + (-2)\\) in sign-magnitude yields \\(-3\\), which is clearly incorrect.</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 + 1000 \\; 0010 \\newline &amp; = 1000 \\; 0011 \\newline &amp; \\rightarrow -3 \\end{aligned} \\] <p>To solve this problem, computers introduced 1's complement. If we first convert sign-magnitude to 1's complement and calculate \\(1 + (-2)\\) in 1's complement, then convert the result back to sign-magnitude, we can obtain the correct result of \\(-1\\).</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 \\; \\text{(Sign-magnitude)} + 1000 \\; 0010 \\; \\text{(Sign-magnitude)} \\newline &amp; = 0000 \\; 0001 \\; \\text{(1's complement)} + 1111  \\; 1101 \\; \\text{(1's complement)} \\newline &amp; = 1111 \\; 1110 \\; \\text{(1's complement)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(Sign-magnitude)} \\newline &amp; \\rightarrow -1 \\end{aligned} \\] <p>On the other hand, the sign-magnitude of the number zero has two representations, \\(+0\\) and \\(-0\\). This means that the number zero corresponds to two different binary encodings, which may cause ambiguity. For example, in conditional judgments, if we don't distinguish between positive zero and negative zero, it may lead to incorrect judgment results. If we want to handle the ambiguity of positive and negative zero, we need to introduce additional judgment operations, which may reduce the computational efficiency of the computer.</p> \\[ \\begin{aligned} +0 &amp; \\rightarrow 0000 \\; 0000 \\newline -0 &amp; \\rightarrow 1000 \\; 0000 \\end{aligned} \\] <p>Like sign-magnitude, 1's complement also has the problem of positive and negative zero ambiguity. Therefore, computers further introduced 2's complement. Let's first observe the conversion process of negative zero from sign-magnitude to 1's complement to 2's complement:</p> \\[ \\begin{aligned} -0 \\rightarrow \\; &amp; 1000 \\; 0000 \\; \\text{(Sign-magnitude)} \\newline = \\; &amp; 1111 \\; 1111 \\; \\text{(1's complement)} \\newline = 1 \\; &amp; 0000 \\; 0000 \\; \\text{(2's complement)} \\newline \\end{aligned} \\] <p>Adding \\(1\\) to the 1's complement of negative zero produces a carry, but since the <code>byte</code> type has a length of only 8 bits, the \\(1\\) that overflows to the 9<sup>th</sup> bit is discarded. That is to say, the 2's complement of negative zero is \\(0000 \\; 0000\\), which is the same as the 2's complement of positive zero. This means that in 2's complement representation, there is only one zero, and the positive and negative zero ambiguity is thus resolved.</p> <p>One last question remains: the range of the <code>byte</code> type is \\([-128, 127]\\), and how is the extra negative number \\(-128\\) obtained? We notice that all integers in the interval \\([-127, +127]\\) have corresponding sign-magnitude, 1's complement, and 2's complement, and sign-magnitude and 2's complement can be converted to each other.</p> <p>However, the 2's complement \\(1000 \\; 0000\\) is an exception, and it does not have a corresponding sign-magnitude. According to the conversion method, we get that the sign-magnitude of this 2's complement is \\(0000 \\; 0000\\). This is clearly contradictory because this sign-magnitude represents the number \\(0\\), and its 2's complement should be itself. The computer specifies that this special 2's complement \\(1000 \\; 0000\\) represents \\(-128\\). In fact, the result of calculating \\((-1) + (-127)\\) in 2's complement is \\(-128\\).</p> \\[ \\begin{aligned} &amp; (-127) + (-1) \\newline &amp; \\rightarrow 1111 \\; 1111 \\; \\text{(Sign-magnitude)} + 1000 \\; 0001 \\; \\text{(Sign-magnitude)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(1's complement)} + 1111  \\; 1110 \\; \\text{(1's complement)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(2's complement)} + 1111  \\; 1111 \\; \\text{(2's complement)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(2's complement)} \\newline &amp; \\rightarrow -128 \\end{aligned} \\] <p>You may have noticed that all the above calculations are addition operations. This hints at an important fact: the hardware circuits inside computers are mainly designed based on addition operations. This is because addition operations are simpler to implement in hardware compared to other operations (such as multiplication, division, and subtraction), easier to parallelize, and have faster operation speeds.</p> <p>Please note that this does not mean that computers can only perform addition. By combining addition with some basic logical operations, computers can implement various other mathematical operations. For example, calculating the subtraction \\(a - b\\) can be converted to calculating the addition \\(a + (-b)\\); calculating multiplication and division can be converted to calculating multiple additions or subtractions.</p> <p>Now we can summarize the reasons why computers use 2's complement: based on 2's complement representation, computers can use the same circuits and operations to handle the addition of positive and negative numbers, without the need to design special hardware circuits to handle subtraction, and without the need to specially handle the ambiguity problem of positive and negative zero. This greatly simplifies hardware design and improves operational efficiency.</p> <p>The design of 2's complement is very ingenious. Due to space limitations, we will stop here. Interested readers are encouraged to explore further.</p>"},{"location":"chapter_data_structure/number_encoding/#332-floating-point-number-encoding","title":"3.3.2 \u00a0 Floating-Point Number Encoding","text":"<p>Careful readers may have noticed: <code>int</code> and <code>float</code> have the same length, both are 4 bytes, but why does <code>float</code> have a much larger range than <code>int</code>? This is very counterintuitive because it stands to reason that <code>float</code> needs to represent decimals, so the range should be smaller.</p> <p>In fact, this is because floating-point number <code>float</code> uses a different representation method. Let's denote a 32-bit binary number as:</p> \\[ b_{31} b_{30} b_{29} \\ldots b_2 b_1 b_0 \\] <p>According to the IEEE 754 standard, a 32-bit <code>float</code> consists of the following three parts.</p> <ul> <li>Sign bit \\(\\mathrm{S}\\): occupies 1 bit, corresponding to \\(b_{31}\\).</li> <li>Exponent bit \\(\\mathrm{E}\\): occupies 8 bits, corresponding to \\(b_{30} b_{29} \\ldots b_{23}\\).</li> <li>Fraction bit \\(\\mathrm{N}\\): occupies 23 bits, corresponding to \\(b_{22} b_{21} \\ldots b_0\\).</li> </ul> <p>The calculation method for the value corresponding to the binary <code>float</code> is:</p> \\[ \\text {val} = (-1)^{b_{31}} \\times 2^{\\left(b_{30} b_{29} \\ldots b_{23}\\right)_2-127} \\times\\left(1 . b_{22} b_{21} \\ldots b_0\\right)_2 \\] <p>Converted to decimal, the calculation formula is:</p> \\[ \\text {val}=(-1)^{\\mathrm{S}} \\times 2^{\\mathrm{E} -127} \\times (1 + \\mathrm{N}) \\] <p>The range of each component is:</p> \\[ \\begin{aligned} \\mathrm{S} \\in &amp; \\{ 0, 1\\}, \\quad \\mathrm{E} \\in \\{ 1, 2, \\dots, 254 \\} \\newline (1 + \\mathrm{N}) = &amp; (1 + \\sum_{i=1}^{23} b_{23-i} 2^{-i}) \\subset [1, 2 - 2^{-23}] \\end{aligned} \\] <p></p> <p> Figure 3-5 \u00a0 Calculation example of float under IEEE 754 standard </p> <p>Observing Figure 3-5, given example data \\(\\mathrm{S} = 0\\), \\(\\mathrm{E} = 124\\), \\(\\mathrm{N} = 2^{-2} + 2^{-3} = 0.375\\), we have:</p> \\[ \\text { val } = (-1)^0 \\times 2^{124 - 127} \\times (1 + 0.375) = 0.171875 \\] <p>Now we can answer the initial question: the representation of <code>float</code> includes an exponent bit, resulting in a range far greater than <code>int</code>. According to the above calculation, the maximum positive number that <code>float</code> can represent is \\(2^{254 - 127} \\times (2 - 2^{-23}) \\approx 3.4 \\times 10^{38}\\), and the minimum negative number can be obtained by switching the sign bit.</p> <p>Although floating-point number <code>float</code> expands the range, its side effect is sacrificing precision. The integer type <code>int</code> uses all 32 bits to represent numbers, and the numbers are evenly distributed; however, due to the existence of the exponent bit, the larger the value of floating-point number <code>float</code>, the larger the difference between two adjacent numbers tends to be.</p> <p>As shown in Table 3-2, exponent bits \\(\\mathrm{E} = 0\\) and \\(\\mathrm{E} = 255\\) have special meanings, used to represent zero, infinity, \\(\\mathrm{NaN}\\), etc.</p> <p> Table 3-2 \u00a0 Meaning of exponent bits </p> Exponent Bit E Fraction Bit \\(\\mathrm{N} = 0\\) Fraction Bit \\(\\mathrm{N} \\ne 0\\) Calculation Formula \\(0\\) \\(\\pm 0\\) Subnormal Number \\((-1)^{\\mathrm{S}} \\times 2^{-126} \\times (0.\\mathrm{N})\\) \\(1, 2, \\dots, 254\\) Normal Number Normal Number \\((-1)^{\\mathrm{S}} \\times 2^{(\\mathrm{E} -127)} \\times (1.\\mathrm{N})\\) \\(255\\) \\(\\pm \\infty\\) \\(\\mathrm{NaN}\\) <p>It is worth noting that subnormal numbers significantly improve the precision of floating-point numbers. The smallest positive normal number is \\(2^{-126}\\), and the smallest positive subnormal number is \\(2^{-126} \\times 2^{-23}\\).</p> <p>Double-precision <code>double</code> also uses a representation method similar to <code>float</code>, which will not be elaborated here.</p>"},{"location":"chapter_data_structure/summary/","title":"3.5 \u00a0 Summary","text":""},{"location":"chapter_data_structure/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Data structures can be classified from two perspectives: logical structure and physical structure. Logical structure describes the logical relationships between data elements, while physical structure describes how data is stored in computer memory.</li> <li>Common logical structures include linear, tree, and network structures. We typically classify data structures as linear (arrays, linked lists, stacks, queues) and non-linear (trees, graphs, heaps) based on their logical structure. The implementation of hash tables may involve both linear and non-linear data structures.</li> <li>When a program runs, data is stored in computer memory. Each memory space has a corresponding memory address, and the program accesses data through these memory addresses.</li> <li>Physical structures are primarily divided into contiguous space storage (arrays) and dispersed space storage (linked lists). All data structures are implemented using arrays, linked lists, or a combination of both.</li> <li>Basic data types in computers include integers <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, floating-point numbers <code>float</code>, <code>double</code>, characters <code>char</code>, and booleans <code>bool</code>. Their value ranges depend on the size of space they occupy and their representation method.</li> <li>Sign-magnitude, 1's complement, and 2's complement are three methods for encoding numbers in computers, and they can be converted into each other. The most significant bit of sign-magnitude is the sign bit, and the remaining bits represent the value of the number.</li> <li>Integers are stored in computers in 2's complement form. Under 2's complement representation, computers can treat the addition of positive and negative numbers uniformly, without needing to design special hardware circuits for subtraction, and there is no ambiguity of positive and negative zero.</li> <li>The encoding of floating-point numbers consists of 1 sign bit, 8 exponent bits, and 23 fraction bits. Due to the exponent bits, the range of floating-point numbers is much larger than that of integers, at the cost of sacrificing precision.</li> <li>ASCII is the earliest English character set, with a length of 1 byte, containing a total of 127 characters. GBK is a commonly used Chinese character set, containing over 20,000 Chinese characters. Unicode is committed to providing a complete character set standard, collecting characters from various languages around the world, thereby solving the garbled text problem caused by inconsistent character encoding methods.</li> <li>UTF-8 is the most popular Unicode encoding method, with excellent universality. It is a variable-length encoding method with good scalability, effectively improving storage space efficiency. UTF-16 and UTF-32 are fixed-length encoding methods. When encoding Chinese characters, UTF-16 occupies less space than UTF-8. Programming languages such as Java and C# use UTF-16 encoding by default.</li> </ul>"},{"location":"chapter_data_structure/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Why do hash tables contain both linear and non-linear data structures?</p> <p>The underlying structure of a hash table is an array. To resolve hash collisions, we may use \"chaining\" (discussed in the subsequent \"Hash Collision\" section): each bucket in the array points to a linked list, which may be converted to a tree (usually a red-black tree) when the list length exceeds a certain threshold.</p> <p>From a storage perspective, the underlying structure of a hash table is an array, where each bucket slot may contain a value, a linked list, or a tree. Therefore, hash tables may contain both linear data structures (arrays, linked lists) and non-linear data structures (trees).</p> <p>Q: Is the length of the <code>char</code> type 1 byte?</p> <p>The length of the <code>char</code> type is determined by the encoding method used by the programming language. For example, Java, JavaScript, TypeScript, and C# all use UTF-16 encoding (to store Unicode code points), so the <code>char</code> type has a length of 2 bytes.</p> <p>Q: Is there ambiguity in referring to array-based data structures as \"static data structures\"? Stacks can also perform \"dynamic\" operations such as push and pop.</p> <p>Stacks can indeed implement dynamic data operations, but the data structure is still \"static\" (fixed length). Although array-based data structures can dynamically add or remove elements, their capacity is fixed. If the data volume exceeds the pre-allocated size, a new larger array needs to be created, and the contents of the old array must be copied to the new array.</p> <p>Q: When constructing a stack (queue), its size is not specified. Why are they \"static data structures\"?</p> <p>In high-level programming languages, we do not need to manually specify the initial capacity of a stack (queue); this work is automatically completed within the class. For example, the initial capacity of Java's <code>ArrayList</code> is typically 10. Additionally, the expansion operation is also automatically implemented. See the subsequent \"List\" section for details.</p> <p>Q: The method of converting sign-magnitude to 2's complement is \"first negate then add 1\". So converting 2's complement to sign-magnitude should be the inverse operation \"first subtract 1 then negate\". However, 2's complement can also be converted to sign-magnitude through \"first negate then add 1\". Why is this?</p> <p>This is because the mutual conversion between sign-magnitude and 2's complement is actually the process of computing the \"complement\". Let us first define the complement: assuming \\(a + b = c\\), then we say that \\(a\\) is the complement of \\(b\\) to \\(c\\), and conversely, \\(b\\) is the complement of \\(a\\) to \\(c\\).</p> <p>Given an \\(n = 4\\) bit binary number \\(0010\\), if we treat this number as sign-magnitude (ignoring the sign bit), then its 2's complement can be obtained through \"first negate then add 1\":</p> \\[ 0010 \\rightarrow 1101 \\rightarrow 1110 \\] <p>We find that the sum of sign-magnitude and 2's complement is \\(0010 + 1110 = 10000\\), which means the 2's complement \\(1110\\) is the \"complement\" of sign-magnitude \\(0010\\) to \\(10000\\). This means the above \"first negate then add 1\" is actually the process of computing the complement to \\(10000\\).</p> <p>So, what is the \"complement\" of 2's complement \\(1110\\) to \\(10000\\)? We can still use \"first negate then add 1\" to obtain it:</p> \\[ 1110 \\rightarrow 0001 \\rightarrow 0010 \\] <p>In other words, sign-magnitude and 2's complement are each other's \"complement\" to \\(10000\\), so \"sign-magnitude to 2's complement\" and \"2's complement to sign-magnitude\" can be implemented using the same operation (first negate then add 1).</p> <p>Of course, we can also use the inverse operation to find the sign-magnitude of 2's complement \\(1110\\), that is, \"first subtract 1 then negate\":</p> \\[ 1110 \\rightarrow 1101 \\rightarrow 0010 \\] <p>In summary, both \"first negate then add 1\" and \"first subtract 1 then negate\" are computing the complement to \\(10000\\), and they are equivalent.</p> <p>Essentially, the \"negate\" operation is actually finding the complement to \\(1111\\) (because <code>sign-magnitude + 1's complement = 1111</code> always holds); and adding 1 to the 1's complement yields the 2's complement, which is the complement to \\(10000\\).</p> <p>The above uses \\(n = 4\\) as an example, and it can be generalized to binary numbers of any number of bits.</p>"},{"location":"chapter_divide_and_conquer/","title":"Chapter 12. \u00a0 Divide and Conquer","text":"<p>Abstract</p> <p>Difficult problems are decomposed layer by layer, with each decomposition making them simpler.</p> <p>Divide and conquer reveals an important truth: start with simplicity, and nothing remains complex.</p>"},{"location":"chapter_divide_and_conquer/#chapter-contents","title":"Chapter contents","text":"<ul> <li>12.1 \u00a0 Divide and Conquer Algorithms</li> <li>12.2 \u00a0 Divide and Conquer Search Strategy</li> <li>12.3 \u00a0 Building a Binary Tree Problem</li> <li>12.4 \u00a0 Hanoi Tower Problem</li> <li>12.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_divide_and_conquer/binary_search_recur/","title":"12.2 \u00a0 Divide and Conquer Search Strategy","text":"<p>We have already learned that search algorithms are divided into two major categories.</p> <ul> <li>Brute-force search: Implemented by traversing the data structure, with a time complexity of \\(O(n)\\).</li> <li>Adaptive search: Utilizes unique data organization forms or prior information, with time complexity reaching \\(O(\\log n)\\) or even \\(O(1)\\).</li> </ul> <p>In fact, search algorithms with time complexity of \\(O(\\log n)\\) are typically implemented based on the divide and conquer strategy, such as binary search and trees.</p> <ul> <li>Each step of binary search divides the problem (searching for a target element in an array) into a smaller problem (searching for the target element in half of the array), continuing until the array is empty or the target element is found.</li> <li>Trees are representative of the divide and conquer idea. In data structures such as binary search trees, AVL trees, and heaps, the time complexity of various operations is \\(O(\\log n)\\).</li> </ul> <p>The divide and conquer strategy of binary search is as follows.</p> <ul> <li>The problem can be decomposed: Binary search recursively decomposes the original problem (searching in an array) into subproblems (searching in half of the array), achieved by comparing the middle element with the target element.</li> <li>Subproblems are independent: In binary search, each round only processes one subproblem, which is not affected by other subproblems.</li> <li>Solutions of subproblems do not need to be merged: Binary search aims to find a specific element, so there is no need to merge the solutions of subproblems. When a subproblem is solved, the original problem is also solved.</li> </ul> <p>Divide and conquer can improve search efficiency because brute-force search can only eliminate one option per round, while divide and conquer search can eliminate half of the options per round.</p>"},{"location":"chapter_divide_and_conquer/binary_search_recur/#1-implementing-binary-search-based-on-divide-and-conquer","title":"1. \u00a0 Implementing Binary Search Based on Divide and Conquer","text":"<p>In previous sections, binary search was implemented based on iteration. Now we implement it based on divide and conquer (recursion).</p> <p>Question</p> <p>Given a sorted array <code>nums</code> of length \\(n\\), where all elements are unique, find the element <code>target</code>.</p> <p>From a divide and conquer perspective, we denote the subproblem corresponding to the search interval \\([i, j]\\) as \\(f(i, j)\\).</p> <p>Starting from the original problem \\(f(0, n-1)\\), perform binary search through the following steps.</p> <ol> <li>Calculate the midpoint \\(m\\) of the search interval \\([i, j]\\), and use it to eliminate half of the search interval.</li> <li>Recursively solve the subproblem reduced by half in size, which could be \\(f(i, m-1)\\) or \\(f(m+1, j)\\).</li> <li>Repeat steps <code>1.</code> and <code>2.</code> until <code>target</code> is found or the interval is empty and return.</li> </ol> <p>Figure 12-4 shows the divide and conquer process of binary search for element \\(6\\) in an array.</p> <p></p> <p> Figure 12-4 \u00a0 Divide and conquer process of binary search </p> <p>In the implementation code, we declare a recursive function <code>dfs()</code> to solve the problem \\(f(i, j)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_recur.py<pre><code>def dfs(nums: list[int], target: int, i: int, j: int) -&gt; int:\n    \"\"\"Binary search: problem f(i, j)\"\"\"\n    # If the interval is empty, it means there is no target element, return -1\n    if i &gt; j:\n        return -1\n    # Calculate the midpoint index m\n    m = (i + j) // 2\n    if nums[m] &lt; target:\n        # Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m + 1, j)\n    elif nums[m] &gt; target:\n        # Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m - 1)\n    else:\n        # Found the target element, return its index\n        return m\n\ndef binary_search(nums: list[int], target: int) -&gt; int:\n    \"\"\"Binary search\"\"\"\n    n = len(nums)\n    # Solve the problem f(0, n-1)\n    return dfs(nums, target, 0, n - 1)\n</code></pre> binary_search_recur.cpp<pre><code>/* Binary search: problem f(i, j) */\nint dfs(vector&lt;int&gt; &amp;nums, int target, int i, int j) {\n    // If the interval is empty, it means there is no target element, return -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // Calculate the midpoint index m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // Found the target element, return its index\n        return m;\n    }\n}\n\n/* Binary search */\nint binarySearch(vector&lt;int&gt; &amp;nums, int target) {\n    int n = nums.size();\n    // Solve the problem f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.java<pre><code>/* Binary search: problem f(i, j) */\nint dfs(int[] nums, int target, int i, int j) {\n    // If the interval is empty, it means there is no target element, return -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // Calculate the midpoint index m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // Found the target element, return its index\n        return m;\n    }\n}\n\n/* Binary search */\nint binarySearch(int[] nums, int target) {\n    int n = nums.length;\n    // Solve the problem f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.cs<pre><code>/* Binary search: problem f(i, j) */\nint DFS(int[] nums, int target, int i, int j) {\n    // If the interval is empty, it means there is no target element, return -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // Calculate the midpoint index m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // Recursion subproblem f(m+1, j)\n        return DFS(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // Recursion subproblem f(i, m-1)\n        return DFS(nums, target, i, m - 1);\n    } else {\n        // Found the target element, return its index\n        return m;\n    }\n}\n\n/* Binary search */\nint BinarySearch(int[] nums, int target) {\n    int n = nums.Length;\n    // Solve the problem f(0, n-1)\n    return DFS(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.go<pre><code>/* Binary search: problem f(i, j) */\nfunc dfs(nums []int, target, i, j int) int {\n    // If interval is empty, indicating no target element, return -1\n    if i &gt; j {\n        return -1\n    }\n    // Calculate midpoint index\n    m := i + ((j - i) &gt;&gt; 1)\n    // Compare midpoint with target element\n    if nums[m] &lt; target {\n        // If smaller, recurse on right half of array\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m+1, j)\n    } else if nums[m] &gt; target {\n        // If larger, recurse on left half of array\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m-1)\n    } else {\n        // Found the target element, return its index\n        return m\n    }\n}\n\n/* Binary search */\nfunc binarySearch(nums []int, target int) int {\n    n := len(nums)\n    return dfs(nums, target, 0, n-1)\n}\n</code></pre> binary_search_recur.swift<pre><code>/* Binary search: problem f(i, j) */\nfunc dfs(nums: [Int], target: Int, i: Int, j: Int) -&gt; Int {\n    // If the interval is empty, it means there is no target element, return -1\n    if i &gt; j {\n        return -1\n    }\n    // Calculate the midpoint index m\n    let m = (i + j) / 2\n    if nums[m] &lt; target {\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums: nums, target: target, i: m + 1, j: j)\n    } else if nums[m] &gt; target {\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums: nums, target: target, i: i, j: m - 1)\n    } else {\n        // Found the target element, return its index\n        return m\n    }\n}\n\n/* Binary search */\nfunc binarySearch(nums: [Int], target: Int) -&gt; Int {\n    // Solve the problem f(0, n-1)\n    dfs(nums: nums, target: target, i: nums.startIndex, j: nums.endIndex - 1)\n}\n</code></pre> binary_search_recur.js<pre><code>/* Binary search: problem f(i, j) */\nfunction dfs(nums, target, i, j) {\n    // If the interval is empty, it means there is no target element, return -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // Calculate the midpoint index m\n    const m = i + ((j - i) &gt;&gt; 1);\n    if (nums[m] &lt; target) {\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // Found the target element, return its index\n        return m;\n    }\n}\n\n/* Binary search */\nfunction binarySearch(nums, target) {\n    const n = nums.length;\n    // Solve the problem f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.ts<pre><code>/* Binary search: problem f(i, j) */\nfunction dfs(nums: number[], target: number, i: number, j: number): number {\n    // If the interval is empty, it means there is no target element, return -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // Calculate the midpoint index m\n    const m = i + ((j - i) &gt;&gt; 1);\n    if (nums[m] &lt; target) {\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // Found the target element, return its index\n        return m;\n    }\n}\n\n/* Binary search */\nfunction binarySearch(nums: number[], target: number): number {\n    const n = nums.length;\n    // Solve the problem f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.dart<pre><code>/* Binary search: problem f(i, j) */\nint dfs(List&lt;int&gt; nums, int target, int i, int j) {\n  // If the interval is empty, it means there is no target element, return -1\n  if (i &gt; j) {\n    return -1;\n  }\n  // Calculate the midpoint index m\n  int m = (i + j) ~/ 2;\n  if (nums[m] &lt; target) {\n    // Recursion subproblem f(m+1, j)\n    return dfs(nums, target, m + 1, j);\n  } else if (nums[m] &gt; target) {\n    // Recursion subproblem f(i, m-1)\n    return dfs(nums, target, i, m - 1);\n  } else {\n    // Found the target element, return its index\n    return m;\n  }\n}\n\n/* Binary search */\nint binarySearch(List&lt;int&gt; nums, int target) {\n  int n = nums.length;\n  // Solve the problem f(0, n-1)\n  return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.rs<pre><code>/* Binary search: problem f(i, j) */\nfn dfs(nums: &amp;[i32], target: i32, i: i32, j: i32) -&gt; i32 {\n    // If the interval is empty, it means there is no target element, return -1\n    if i &gt; j {\n        return -1;\n    }\n    let m: i32 = i + (j - i) / 2;\n    if nums[m as usize] &lt; target {\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if nums[m as usize] &gt; target {\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // Found the target element, return its index\n        return m;\n    }\n}\n\n/* Binary search */\nfn binary_search(nums: &amp;[i32], target: i32) -&gt; i32 {\n    let n = nums.len() as i32;\n    // Solve the problem f(0, n-1)\n    dfs(nums, target, 0, n - 1)\n}\n</code></pre> binary_search_recur.c<pre><code>/* Binary search: problem f(i, j) */\nint dfs(int nums[], int target, int i, int j) {\n    // If the interval is empty, it means there is no target element, return -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // Calculate the midpoint index m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // Recursion subproblem f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // Recursion subproblem f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // Found the target element, return its index\n        return m;\n    }\n}\n\n/* Binary search */\nint binarySearch(int nums[], int target, int numsSize) {\n    int n = numsSize;\n    // Solve the problem f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.kt<pre><code>/* Binary search: problem f(i, j) */\nfun dfs(\n    nums: IntArray,\n    target: Int,\n    i: Int,\n    j: Int\n): Int {\n    // If the interval is empty, it means there is no target element, return -1\n    if (i &gt; j) {\n        return -1\n    }\n    // Calculate the midpoint index m\n    val m = (i + j) / 2\n    return if (nums[m] &lt; target) {\n        // Recursion subproblem f(m+1, j)\n        dfs(nums, target, m + 1, j)\n    } else if (nums[m] &gt; target) {\n        // Recursion subproblem f(i, m-1)\n        dfs(nums, target, i, m - 1)\n    } else {\n        // Found the target element, return its index\n        m\n    }\n}\n\n/* Binary search */\nfun binarySearch(nums: IntArray, target: Int): Int {\n    val n = nums.size\n    // Solve the problem f(0, n-1)\n    return dfs(nums, target, 0, n - 1)\n}\n</code></pre> binary_search_recur.rb<pre><code>### Binary search: problem f(i, j) ###\ndef dfs(nums, target, i, j)\n  # If the interval is empty, it means there is no target element, return -1\n  return -1 if i &gt; j\n\n  # Calculate the midpoint index m\n  m = (i + j) / 2\n\n  if nums[m] &lt; target\n    # Recursion subproblem f(m+1, j)\n    return dfs(nums, target, m + 1, j)\n  elsif nums[m] &gt; target\n    # Recursion subproblem f(i, m-1)\n    return dfs(nums, target, i, m - 1)\n  else\n    # Found the target element, return its index\n    return m\n  end\nend\n\n### Binary search ###\ndef binary_search(nums, target)\n  n = nums.length\n  # Solve the problem f(0, n-1)\n  dfs(nums, target, 0, n - 1)\nend\n</code></pre>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/","title":"12.3 \u00a0 Building a Binary Tree Problem","text":"<p>Question</p> <p>Given the preorder traversal <code>preorder</code> and inorder traversal <code>inorder</code> of a binary tree, construct the binary tree and return the root node of the binary tree. Assume there are no duplicate node values in the binary tree (as shown in Figure 12-5).</p> <p></p> <p> Figure 12-5 \u00a0 Example data for building a binary tree </p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#1-determining-if-it-is-a-divide-and-conquer-problem","title":"1. \u00a0 Determining If It Is a Divide and Conquer Problem","text":"<p>The original problem is defined as constructing a binary tree from <code>preorder</code> and <code>inorder</code>, which is a typical divide and conquer problem.</p> <ul> <li>The problem can be decomposed: From a divide and conquer perspective, we can divide the original problem into two subproblems: constructing the left subtree and constructing the right subtree, plus one operation: initializing the root node. For each subtree (subproblem), we can still reuse the above division method, dividing it into smaller subtrees (subproblems) until the smallest subproblem (empty subtree) is reached.</li> <li>Subproblems are independent: The left and right subtrees are independent of each other; there is no overlap between them. When constructing the left subtree, we only need to focus on the parts of the inorder and preorder traversals corresponding to the left subtree. The same applies to the right subtree.</li> <li>Solutions of subproblems can be merged: Once we have the left and right subtrees (solutions of subproblems), we can link them to the root node to obtain the solution to the original problem.</li> </ul>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#2-how-to-divide-subtrees","title":"2. \u00a0 How to Divide Subtrees","text":"<p>Based on the above analysis, this problem can be solved using divide and conquer, but how do we divide the left and right subtrees through the preorder traversal <code>preorder</code> and inorder traversal <code>inorder</code>?</p> <p>According to the definition, both <code>preorder</code> and <code>inorder</code> can be divided into three parts.</p> <ul> <li>Preorder traversal: <code>[ Root Node | Left Subtree | Right Subtree ]</code>, for example, the tree in Figure 12-5 corresponds to <code>[ 3 | 9 | 2 1 7 ]</code>.</li> <li>Inorder traversal: <code>[ Left Subtree | Root Node \uff5c Right Subtree ]</code>, for example, the tree in Figure 12-5 corresponds to <code>[ 9 | 3 | 1 2 7 ]</code>.</li> </ul> <p>Using the data from the figure above as an example, we can obtain the division results through the steps shown in Figure 12-6.</p> <ol> <li>The first element 3 in the preorder traversal is the value of the root node.</li> <li>Find the index of root node 3 in <code>inorder</code>, and use this index to divide <code>inorder</code> into <code>[ 9 | 3 \uff5c 1 2 7 ]</code>.</li> <li>Based on the division result of <code>inorder</code>, it is easy to determine that the left and right subtrees have 1 and 3 nodes respectively, allowing us to divide <code>preorder</code> into <code>[ 3 | 9 | 2 1 7 ]</code>.</li> </ol> <p></p> <p> Figure 12-6 \u00a0 Dividing subtrees in preorder and inorder traversals </p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#3-describing-subtree-intervals-based-on-variables","title":"3. \u00a0 Describing Subtree Intervals Based on Variables","text":"<p>Based on the above division method, we have obtained the index intervals of the root node, left subtree, and right subtree in <code>preorder</code> and <code>inorder</code>. To describe these index intervals, we need to use several pointer variables.</p> <ul> <li>Denote the index of the current tree's root node in <code>preorder</code> as \\(i\\).</li> <li>Denote the index of the current tree's root node in <code>inorder</code> as \\(m\\).</li> <li>Denote the index interval of the current tree in <code>inorder</code> as \\([l, r]\\).</li> </ul> <p>As shown in Table 12-1, through these variables we can represent the index of the root node in <code>preorder</code> and the index intervals of the subtrees in <code>inorder</code>.</p> <p> Table 12-1 \u00a0 Indices of root node and subtrees in preorder and inorder traversals </p> Root node index in <code>preorder</code> Subtree index interval in <code>inorder</code> Current tree \\(i\\) \\([l, r]\\) Left subtree \\(i + 1\\) \\([l, m-1]\\) Right subtree \\(i + 1 + (m - l)\\) \\([m+1, r]\\) <p>Please note that \\((m-l)\\) in the right subtree root node index means \"the number of nodes in the left subtree\". It is recommended to understand this in conjunction with Figure 12-7.</p> <p></p> <p> Figure 12-7 \u00a0 Index interval representation of root node and left and right subtrees </p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#4-code-implementation","title":"4. \u00a0 Code Implementation","text":"<p>To improve the efficiency of querying \\(m\\), we use a hash table <code>hmap</code> to store the mapping from elements in the <code>inorder</code> array to their indices:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby build_tree.py<pre><code>def dfs(\n    preorder: list[int],\n    inorder_map: dict[int, int],\n    i: int,\n    l: int,\n    r: int,\n) -&gt; TreeNode | None:\n    \"\"\"Build binary tree: divide and conquer\"\"\"\n    # Terminate when the subtree interval is empty\n    if r - l &lt; 0:\n        return None\n    # Initialize the root node\n    root = TreeNode(preorder[i])\n    # Query m to divide the left and right subtrees\n    m = inorder_map[preorder[i]]\n    # Subproblem: build the left subtree\n    root.left = dfs(preorder, inorder_map, i + 1, l, m - 1)\n    # Subproblem: build the right subtree\n    root.right = dfs(preorder, inorder_map, i + 1 + m - l, m + 1, r)\n    # Return the root node\n    return root\n\ndef build_tree(preorder: list[int], inorder: list[int]) -&gt; TreeNode | None:\n    \"\"\"Build binary tree\"\"\"\n    # Initialize hash map, storing the mapping from inorder elements to indices\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    root = dfs(preorder, inorder_map, 0, 0, len(inorder) - 1)\n    return root\n</code></pre> build_tree.cpp<pre><code>/* Build binary tree: divide and conquer */\nTreeNode *dfs(vector&lt;int&gt; &amp;preorder, unordered_map&lt;int, int&gt; &amp;inorderMap, int i, int l, int r) {\n    // Terminate when the subtree interval is empty\n    if (r - l &lt; 0)\n        return NULL;\n    // Initialize the root node\n    TreeNode *root = new TreeNode(preorder[i]);\n    // Query m to divide the left and right subtrees\n    int m = inorderMap[preorder[i]];\n    // Subproblem: build the left subtree\n    root-&gt;left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // Subproblem: build the right subtree\n    root-&gt;right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // Return the root node\n    return root;\n}\n\n/* Build binary tree */\nTreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    unordered_map&lt;int, int&gt; inorderMap;\n    for (int i = 0; i &lt; inorder.size(); i++) {\n        inorderMap[inorder[i]] = i;\n    }\n    TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorder.size() - 1);\n    return root;\n}\n</code></pre> build_tree.java<pre><code>/* Build binary tree: divide and conquer */\nTreeNode dfs(int[] preorder, Map&lt;Integer, Integer&gt; inorderMap, int i, int l, int r) {\n    // Terminate when the subtree interval is empty\n    if (r - l &lt; 0)\n        return null;\n    // Initialize the root node\n    TreeNode root = new TreeNode(preorder[i]);\n    // Query m to divide the left and right subtrees\n    int m = inorderMap.get(preorder[i]);\n    // Subproblem: build the left subtree\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // Subproblem: build the right subtree\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // Return the root node\n    return root;\n}\n\n/* Build binary tree */\nTreeNode buildTree(int[] preorder, int[] inorder) {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; inorder.length; i++) {\n        inorderMap.put(inorder[i], i);\n    }\n    TreeNode root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n    return root;\n}\n</code></pre> build_tree.cs<pre><code>/* Build binary tree: divide and conquer */\nTreeNode? DFS(int[] preorder, Dictionary&lt;int, int&gt; inorderMap, int i, int l, int r) {\n    // Terminate when the subtree interval is empty\n    if (r - l &lt; 0)\n        return null;\n    // Initialize the root node\n    TreeNode root = new(preorder[i]);\n    // Query m to divide the left and right subtrees\n    int m = inorderMap[preorder[i]];\n    // Subproblem: build the left subtree\n    root.left = DFS(preorder, inorderMap, i + 1, l, m - 1);\n    // Subproblem: build the right subtree\n    root.right = DFS(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // Return the root node\n    return root;\n}\n\n/* Build binary tree */\nTreeNode? BuildTree(int[] preorder, int[] inorder) {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    Dictionary&lt;int, int&gt; inorderMap = [];\n    for (int i = 0; i &lt; inorder.Length; i++) {\n        inorderMap.TryAdd(inorder[i], i);\n    }\n    TreeNode? root = DFS(preorder, inorderMap, 0, 0, inorder.Length - 1);\n    return root;\n}\n</code></pre> build_tree.go<pre><code>/* Build binary tree: divide and conquer */\nfunc dfsBuildTree(preorder []int, inorderMap map[int]int, i, l, r int) *TreeNode {\n    // Terminate when the subtree interval is empty\n    if r-l &lt; 0 {\n        return nil\n    }\n    // Initialize the root node\n    root := NewTreeNode(preorder[i])\n    // Query m to divide the left and right subtrees\n    m := inorderMap[preorder[i]]\n    // Subproblem: build the left subtree\n    root.Left = dfsBuildTree(preorder, inorderMap, i+1, l, m-1)\n    // Subproblem: build the right subtree\n    root.Right = dfsBuildTree(preorder, inorderMap, i+1+m-l, m+1, r)\n    // Return the root node\n    return root\n}\n\n/* Build binary tree */\nfunc buildTree(preorder, inorder []int) *TreeNode {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    inorderMap := make(map[int]int, len(inorder))\n    for i := 0; i &lt; len(inorder); i++ {\n        inorderMap[inorder[i]] = i\n    }\n\n    root := dfsBuildTree(preorder, inorderMap, 0, 0, len(inorder)-1)\n    return root\n}\n</code></pre> build_tree.swift<pre><code>/* Build binary tree: divide and conquer */\nfunc dfs(preorder: [Int], inorderMap: [Int: Int], i: Int, l: Int, r: Int) -&gt; TreeNode? {\n    // Terminate when the subtree interval is empty\n    if r - l &lt; 0 {\n        return nil\n    }\n    // Initialize the root node\n    let root = TreeNode(x: preorder[i])\n    // Query m to divide the left and right subtrees\n    let m = inorderMap[preorder[i]]!\n    // Subproblem: build the left subtree\n    root.left = dfs(preorder: preorder, inorderMap: inorderMap, i: i + 1, l: l, r: m - 1)\n    // Subproblem: build the right subtree\n    root.right = dfs(preorder: preorder, inorderMap: inorderMap, i: i + 1 + m - l, l: m + 1, r: r)\n    // Return the root node\n    return root\n}\n\n/* Build binary tree */\nfunc buildTree(preorder: [Int], inorder: [Int]) -&gt; TreeNode? {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    let inorderMap = inorder.enumerated().reduce(into: [:]) { $0[$1.element] = $1.offset }\n    return dfs(preorder: preorder, inorderMap: inorderMap, i: inorder.startIndex, l: inorder.startIndex, r: inorder.endIndex - 1)\n}\n</code></pre> build_tree.js<pre><code>/* Build binary tree: divide and conquer */\nfunction dfs(preorder, inorderMap, i, l, r) {\n    // Terminate when the subtree interval is empty\n    if (r - l &lt; 0) return null;\n    // Initialize the root node\n    const root = new TreeNode(preorder[i]);\n    // Query m to divide the left and right subtrees\n    const m = inorderMap.get(preorder[i]);\n    // Subproblem: build the left subtree\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // Subproblem: build the right subtree\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // Return the root node\n    return root;\n}\n\n/* Build binary tree */\nfunction buildTree(preorder, inorder) {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    let inorderMap = new Map();\n    for (let i = 0; i &lt; inorder.length; i++) {\n        inorderMap.set(inorder[i], i);\n    }\n    const root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n    return root;\n}\n</code></pre> build_tree.ts<pre><code>/* Build binary tree: divide and conquer */\nfunction dfs(\n    preorder: number[],\n    inorderMap: Map&lt;number, number&gt;,\n    i: number,\n    l: number,\n    r: number\n): TreeNode | null {\n    // Terminate when the subtree interval is empty\n    if (r - l &lt; 0) return null;\n    // Initialize the root node\n    const root: TreeNode = new TreeNode(preorder[i]);\n    // Query m to divide the left and right subtrees\n    const m = inorderMap.get(preorder[i]);\n    // Subproblem: build the left subtree\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // Subproblem: build the right subtree\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // Return the root node\n    return root;\n}\n\n/* Build binary tree */\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    let inorderMap = new Map&lt;number, number&gt;();\n    for (let i = 0; i &lt; inorder.length; i++) {\n        inorderMap.set(inorder[i], i);\n    }\n    const root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n    return root;\n}\n</code></pre> build_tree.dart<pre><code>/* Build binary tree: divide and conquer */\nTreeNode? dfs(\n  List&lt;int&gt; preorder,\n  Map&lt;int, int&gt; inorderMap,\n  int i,\n  int l,\n  int r,\n) {\n  // Terminate when the subtree interval is empty\n  if (r - l &lt; 0) {\n    return null;\n  }\n  // Initialize the root node\n  TreeNode? root = TreeNode(preorder[i]);\n  // Query m to divide the left and right subtrees\n  int m = inorderMap[preorder[i]]!;\n  // Subproblem: build the left subtree\n  root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n  // Subproblem: build the right subtree\n  root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n  // Return the root node\n  return root;\n}\n\n/* Build binary tree */\nTreeNode? buildTree(List&lt;int&gt; preorder, List&lt;int&gt; inorder) {\n  // Initialize hash map, storing the mapping from inorder elements to indices\n  Map&lt;int, int&gt; inorderMap = {};\n  for (int i = 0; i &lt; inorder.length; i++) {\n    inorderMap[inorder[i]] = i;\n  }\n  TreeNode? root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n  return root;\n}\n</code></pre> build_tree.rs<pre><code>/* Build binary tree: divide and conquer */\nfn dfs(\n    preorder: &amp;[i32],\n    inorder_map: &amp;HashMap&lt;i32, i32&gt;,\n    i: i32,\n    l: i32,\n    r: i32,\n) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n    // Terminate when the subtree interval is empty\n    if r - l &lt; 0 {\n        return None;\n    }\n    // Initialize the root node\n    let root = TreeNode::new(preorder[i as usize]);\n    // Query m to divide the left and right subtrees\n    let m = inorder_map.get(&amp;preorder[i as usize]).unwrap();\n    // Subproblem: build the left subtree\n    root.borrow_mut().left = dfs(preorder, inorder_map, i + 1, l, m - 1);\n    // Subproblem: build the right subtree\n    root.borrow_mut().right = dfs(preorder, inorder_map, i + 1 + m - l, m + 1, r);\n    // Return the root node\n    Some(root)\n}\n\n/* Build binary tree */\nfn build_tree(preorder: &amp;[i32], inorder: &amp;[i32]) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    let mut inorder_map: HashMap&lt;i32, i32&gt; = HashMap::new();\n    for i in 0..inorder.len() {\n        inorder_map.insert(inorder[i], i as i32);\n    }\n    let root = dfs(preorder, &amp;inorder_map, 0, 0, inorder.len() as i32 - 1);\n    root\n}\n</code></pre> build_tree.c<pre><code>/* Build binary tree: divide and conquer */\nTreeNode *dfs(int *preorder, int *inorderMap, int i, int l, int r, int size) {\n    // Terminate when the subtree interval is empty\n    if (r - l &lt; 0)\n        return NULL;\n    // Initialize the root node\n    TreeNode *root = (TreeNode *)malloc(sizeof(TreeNode));\n    root-&gt;val = preorder[i];\n    root-&gt;left = NULL;\n    root-&gt;right = NULL;\n    // Query m to divide the left and right subtrees\n    int m = inorderMap[preorder[i]];\n    // Subproblem: build the left subtree\n    root-&gt;left = dfs(preorder, inorderMap, i + 1, l, m - 1, size);\n    // Subproblem: build the right subtree\n    root-&gt;right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r, size);\n    // Return the root node\n    return root;\n}\n\n/* Build binary tree */\nTreeNode *buildTree(int *preorder, int preorderSize, int *inorder, int inorderSize) {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    int *inorderMap = (int *)malloc(sizeof(int) * MAX_SIZE);\n    for (int i = 0; i &lt; inorderSize; i++) {\n        inorderMap[inorder[i]] = i;\n    }\n    TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorderSize - 1, inorderSize);\n    free(inorderMap);\n    return root;\n}\n</code></pre> build_tree.kt<pre><code>/* Build binary tree: divide and conquer */\nfun dfs(\n    preorder: IntArray,\n    inorderMap: Map&lt;Int?, Int?&gt;,\n    i: Int,\n    l: Int,\n    r: Int\n): TreeNode? {\n    // Terminate when the subtree interval is empty\n    if (r - l &lt; 0) return null\n    // Initialize the root node\n    val root = TreeNode(preorder[i])\n    // Query m to divide the left and right subtrees\n    val m = inorderMap[preorder[i]]!!\n    // Subproblem: build the left subtree\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1)\n    // Subproblem: build the right subtree\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r)\n    // Return the root node\n    return root\n}\n\n/* Build binary tree */\nfun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? {\n    // Initialize hash map, storing the mapping from inorder elements to indices\n    val inorderMap = HashMap&lt;Int?, Int?&gt;()\n    for (i in inorder.indices) {\n        inorderMap[inorder[i]] = i\n    }\n    val root = dfs(preorder, inorderMap, 0, 0, inorder.size - 1)\n    return root\n}\n</code></pre> build_tree.rb<pre><code>### Build binary tree: divide and conquer ###\ndef dfs(preorder, inorder_map, i, l, r)\n  # Terminate when the subtree interval is empty\n  return if r - l &lt; 0\n\n  # Initialize the root node\n  root = TreeNode.new(preorder[i])\n  # Query m to divide the left and right subtrees\n  m = inorder_map[preorder[i]]\n  # Subproblem: build the left subtree\n  root.left = dfs(preorder, inorder_map, i + 1, l, m - 1)\n  # Subproblem: build the right subtree\n  root.right = dfs(preorder, inorder_map, i + 1 + m - l, m + 1, r)\n\n  # Return the root node\n  root\nend\n\n### Build binary tree ###\ndef build_tree(preorder, inorder)\n  # Initialize hash map, storing the mapping from inorder elements to indices\n  inorder_map = {}\n  inorder.each_with_index { |val, i| inorder_map[val] = i }\n  dfs(preorder, inorder_map, 0, 0, inorder.length - 1)\nend\n</code></pre> <p>Figure 12-8 shows the recursive process of building the binary tree. Each node is established during the downward \"recursion\" process, while each edge (reference) is established during the upward \"return\" process.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 12-8 \u00a0 Recursive process of building a binary tree </p> <p>The division results of the preorder traversal <code>preorder</code> and inorder traversal <code>inorder</code> within each recursive function are shown in Figure 12-9.</p> <p></p> <p> Figure 12-9 \u00a0 Division results in each recursive function </p> <p>Let the number of nodes in the tree be \\(n\\). Initializing each node (executing one recursive function <code>dfs()</code>) takes \\(O(1)\\) time. Therefore, the overall time complexity is \\(O(n)\\).</p> <p>The hash table stores the mapping from <code>inorder</code> elements to their indices, with a space complexity of \\(O(n)\\). In the worst case, when the binary tree degenerates into a linked list, the recursion depth reaches \\(n\\), using \\(O(n)\\) stack frame space. Therefore, the overall space complexity is \\(O(n)\\).</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/","title":"12.1 \u00a0 Divide and Conquer Algorithms","text":"<p>Divide and conquer is a very important and common algorithm strategy. Divide and conquer is typically implemented based on recursion, consisting of two steps: \"divide\" and \"conquer\".</p> <ol> <li>Divide (partition phase): Recursively divide the original problem into two or more subproblems until the smallest subproblem is reached.</li> <li>Conquer (merge phase): Starting from the smallest subproblems with known solutions, merge the solutions of subproblems from bottom to top to construct the solution to the original problem.</li> </ol> <p>As shown in Figure 12-1, \"merge sort\" is one of the typical applications of the divide and conquer strategy.</p> <ol> <li>Divide: Recursively divide the original array (original problem) into two subarrays (subproblems) until the subarray has only one element (smallest subproblem).</li> <li>Conquer: Merge the sorted subarrays (solutions to subproblems) from bottom to top to obtain a sorted original array (solution to the original problem).</li> </ol> <p></p> <p> Figure 12-1 \u00a0 Divide and conquer strategy of merge sort </p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1211-how-to-determine-divide-and-conquer-problems","title":"12.1.1 \u00a0 How to Determine Divide and Conquer Problems","text":"<p>Whether a problem is suitable for solving with divide and conquer can usually be determined based on the following criteria.</p> <ol> <li>The problem can be decomposed: The original problem can be divided into smaller, similar subproblems, and can be recursively divided in the same way.</li> <li>Subproblems are independent: There is no overlap between subproblems, they are independent of each other and can be solved independently.</li> <li>Solutions of subproblems can be merged: The solution to the original problem is obtained by merging the solutions of subproblems.</li> </ol> <p>Clearly, merge sort satisfies these three criteria.</p> <ol> <li>The problem can be decomposed: Recursively divide the array (original problem) into two subarrays (subproblems).</li> <li>Subproblems are independent: Each subarray can be sorted independently (subproblems can be solved independently).</li> <li>Solutions of subproblems can be merged: Two sorted subarrays (solutions of subproblems) can be merged into one sorted array (solution of the original problem).</li> </ol>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1212-improving-efficiency-through-divide-and-conquer","title":"12.1.2 \u00a0 Improving Efficiency Through Divide and Conquer","text":"<p>Divide and conquer can not only effectively solve algorithmic problems but often also improve algorithm efficiency. In sorting algorithms, quick sort, merge sort, and heap sort are faster than selection, bubble, and insertion sort because they apply the divide and conquer strategy.</p> <p>This raises the question: Why can divide and conquer improve algorithm efficiency, and what is the underlying logic? In other words, why is dividing a large problem into multiple subproblems, solving the subproblems, and merging their solutions more efficient than directly solving the original problem? This question can be discussed from two aspects: operation count and parallel computation.</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1-operation-count-optimization","title":"1. \u00a0 Operation Count Optimization","text":"<p>Taking \"bubble sort\" as an example, processing an array of length \\(n\\) requires \\(O(n^2)\\) time. Suppose we divide the array into two subarrays from the midpoint as shown in Figure 12-2, the division requires \\(O(n)\\) time, sorting each subarray requires \\(O((n / 2)^2)\\) time, and merging the two subarrays requires \\(O(n)\\) time, resulting in an overall time complexity of:</p> \\[ O(n + (\\frac{n}{2})^2 \\times 2 + n) = O(\\frac{n^2}{2} + 2n) \\] <p></p> <p> Figure 12-2 \u00a0 Bubble sort before and after array division </p> <p>Next, we compute the following inequality, where the left and right sides represent the total number of operations before and after division, respectively:</p> \\[ \\begin{aligned} n^2 &amp; &gt; \\frac{n^2}{2} + 2n \\newline n^2 - \\frac{n^2}{2} - 2n &amp; &gt; 0 \\newline n(n - 4) &amp; &gt; 0 \\end{aligned} \\] <p>This means that when \\(n &gt; 4\\), the number of operations after division is smaller, and sorting efficiency should be higher. Note that the time complexity after division is still quadratic \\(O(n^2)\\), but the constant term in the complexity has become smaller.</p> <p>Going further, what if we continuously divide the subarrays from their midpoints into two subarrays until the subarrays have only one element? This approach is actually \"merge sort\", with a time complexity of \\(O(n \\log n)\\).</p> <p>Thinking further, what if we set multiple division points and evenly divide the original array into \\(k\\) subarrays? This situation is very similar to \"bucket sort\", which is well-suited for sorting massive amounts of data, with a theoretical time complexity of \\(O(n + k)\\).</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#2-parallel-computation-optimization","title":"2. \u00a0 Parallel Computation Optimization","text":"<p>We know that the subproblems generated by divide and conquer are independent of each other, so they can typically be solved in parallel. This means divide and conquer can not only reduce the time complexity of algorithms, but also benefits from parallel optimization by operating systems.</p> <p>Parallel optimization is particularly effective in multi-core or multi-processor environments, as the system can simultaneously handle multiple subproblems, making fuller use of computing resources and significantly reducing overall runtime.</p> <p>For example, in the \"bucket sort\" shown in Figure 12-3, we evenly distribute massive data into various buckets, and the sorting tasks for all buckets can be distributed to various computing units. After completion, the results are merged.</p> <p></p> <p> Figure 12-3 \u00a0 Parallel computation in bucket sort </p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1213-common-applications-of-divide-and-conquer","title":"12.1.3 \u00a0 Common Applications of Divide and Conquer","text":"<p>On one hand, divide and conquer can be used to solve many classic algorithmic problems.</p> <ul> <li>Finding the closest pair of points: This algorithm first divides the point set into two parts, then finds the closest pair of points in each part separately, and finally finds the closest pair of points that spans both parts.</li> <li>Large integer multiplication: For example, the Karatsuba algorithm, which decomposes large integer multiplication into several smaller integer multiplications and additions.</li> <li>Matrix multiplication: For example, the Strassen algorithm, which decomposes large matrix multiplication into multiple small matrix multiplications and additions.</li> <li>Hanota problem: The hanota problem can be solved through recursion, which is a typical application of the divide and conquer strategy.</li> <li>Solving inversion pairs: In a sequence, if a preceding number is greater than a following number, these two numbers form an inversion pair. Solving the inversion pair problem can utilize the divide and conquer approach with the help of merge sort.</li> </ul> <p>On the other hand, divide and conquer is widely applied in the design of algorithms and data structures.</p> <ul> <li>Binary search: Binary search divides a sorted array into two parts from the midpoint index, then decides which half to eliminate based on the comparison result between the target value and the middle element value, and performs the same binary operation on the remaining interval.</li> <li>Merge sort: Already introduced at the beginning of this section, no further elaboration needed.</li> <li>Quick sort: Quick sort selects a pivot value, then divides the array into two subarrays, one with elements smaller than the pivot and the other with elements larger than the pivot, then performs the same division operation on these two parts until the subarrays have only one element.</li> <li>Bucket sort: The basic idea of bucket sort is to scatter data into multiple buckets, then sort the elements within each bucket, and finally extract the elements from each bucket in sequence to obtain a sorted array.</li> <li>Trees: For example, binary search trees, AVL trees, red-black trees, B-trees, B+ trees, etc. Their search, insertion, and deletion operations can all be viewed as applications of the divide and conquer strategy.</li> <li>Heaps: A heap is a special complete binary tree, and its various operations, such as insertion, deletion, and heapify, actually imply the divide and conquer idea.</li> <li>Hash tables: Although hash tables do not directly apply divide and conquer, some hash collision resolution solutions indirectly apply the divide and conquer strategy. For example, long linked lists in chaining may be converted to red-black trees to improve query efficiency.</li> </ul> <p>It can be seen that divide and conquer is a \"subtly pervasive\" algorithmic idea, embedded in various algorithms and data structures.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/","title":"12.4 \u00a0 Hanota Problem","text":"<p>In merge sort and building binary trees, we decompose the original problem into two subproblems, each half the size of the original problem. However, for the hanota problem, we adopt a different decomposition strategy.</p> <p>Question</p> <p>Given three pillars, denoted as <code>A</code>, <code>B</code>, and <code>C</code>. Initially, pillar <code>A</code> has \\(n\\) discs stacked on it, arranged from top to bottom in ascending order of size. Our task is to move these \\(n\\) discs to pillar <code>C</code> while maintaining their original order (as shown in Figure 12-10). The following rules must be followed when moving the discs.</p> <ol> <li>A disc can only be taken from the top of one pillar and placed on top of another pillar.</li> <li>Only one disc can be moved at a time.</li> <li>A smaller disc must always be on top of a larger disc.</li> </ol> <p></p> <p> Figure 12-10 \u00a0 Example of the hanota problem </p> <p>We denote the hanota problem of size \\(i\\) as \\(f(i)\\). For example, \\(f(3)\\) represents moving \\(3\\) discs from <code>A</code> to <code>C</code>.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#1-considering-the-base-cases","title":"1. \u00a0 Considering the Base Cases","text":"<p>As shown in Figure 12-11, for problem \\(f(1)\\), when there is only one disc, we can move it directly from <code>A</code> to <code>C</code>.</p> &lt;1&gt;&lt;2&gt; <p></p> <p></p> <p> Figure 12-11 \u00a0 Solution for a problem of size 1 </p> <p>As shown in Figure 12-12, for problem \\(f(2)\\), when there are two discs, since we must always keep the smaller disc on top of the larger disc, we need to use <code>B</code> to assist in the move.</p> <ol> <li>First, move the smaller disc from <code>A</code> to <code>B</code>.</li> <li>Then move the larger disc from <code>A</code> to <code>C</code>.</li> <li>Finally, move the smaller disc from <code>B</code> to <code>C</code>.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 12-12 \u00a0 Solution for a problem of size 2 </p> <p>The process of solving problem \\(f(2)\\) can be summarized as: moving two discs from <code>A</code> to <code>C</code> with the help of <code>B</code>. Here, <code>C</code> is called the target pillar, and <code>B</code> is called the buffer pillar.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#2-subproblem-decomposition","title":"2. \u00a0 Subproblem Decomposition","text":"<p>For problem \\(f(3)\\), when there are three discs, the situation becomes slightly more complex.</p> <p>Since we already know the solutions to \\(f(1)\\) and \\(f(2)\\), we can think from a divide and conquer perspective, treating the top two discs on <code>A</code> as a whole, and execute the steps shown in Figure 12-13. This successfully moves the three discs from <code>A</code> to <code>C</code>.</p> <ol> <li>Let <code>B</code> be the target pillar and <code>C</code> be the buffer pillar, and move two discs from <code>A</code> to <code>B</code>.</li> <li>Move the remaining disc from <code>A</code> directly to <code>C</code>.</li> <li>Let <code>C</code> be the target pillar and <code>A</code> be the buffer pillar, and move two discs from <code>B</code> to <code>C</code>.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 12-13 \u00a0 Solution for a problem of size 3 </p> <p>Essentially, we divide problem \\(f(3)\\) into two subproblems \\(f(2)\\) and one subproblem \\(f(1)\\). By solving these three subproblems in order, the original problem is solved. This shows that the subproblems are independent and their solutions can be merged.</p> <p>From this, we can summarize the divide and conquer strategy for solving the hanota problem shown in Figure 12-14: divide the original problem \\(f(n)\\) into two subproblems \\(f(n-1)\\) and one subproblem \\(f(1)\\), and solve these three subproblems in the following order.</p> <ol> <li>Move \\(n-1\\) discs from <code>A</code> to <code>B</code> with the help of <code>C</code>.</li> <li>Move the remaining \\(1\\) disc directly from <code>A</code> to <code>C</code>.</li> <li>Move \\(n-1\\) discs from <code>B</code> to <code>C</code> with the help of <code>A</code>.</li> </ol> <p>For these two subproblems \\(f(n-1)\\), we can recursively divide them in the same way until reaching the smallest subproblem \\(f(1)\\). The solution to \\(f(1)\\) is known and requires only one move operation.</p> <p></p> <p> Figure 12-14 \u00a0 Divide and conquer strategy for solving the hanota problem </p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#3-code-implementation","title":"3. \u00a0 Code Implementation","text":"<p>In the code, we declare a recursive function <code>dfs(i, src, buf, tar)</code>, whose purpose is to move the top \\(i\\) discs from pillar <code>src</code> to target pillar <code>tar</code> with the help of buffer pillar <code>buf</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby hanota.py<pre><code>def move(src: list[int], tar: list[int]):\n    \"\"\"Move a disk\"\"\"\n    # Take out a disk from the top of src\n    pan = src.pop()\n    # Place the disk on top of tar\n    tar.append(pan)\n\ndef dfs(i: int, src: list[int], buf: list[int], tar: list[int]):\n    \"\"\"Solve the Tower of Hanoi problem f(i)\"\"\"\n    # If there is only one disk left in src, move it directly to tar\n    if i == 1:\n        move(src, tar)\n        return\n    # Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, tar, buf)\n    # Subproblem f(1): move the remaining disk from src to tar\n    move(src, tar)\n    # Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, src, tar)\n\ndef solve_hanota(A: list[int], B: list[int], C: list[int]):\n    \"\"\"Solve the Tower of Hanoi problem\"\"\"\n    n = len(A)\n    # Move the top n disks from A to C using B\n    dfs(n, A, B, C)\n</code></pre> hanota.cpp<pre><code>/* Move a disk */\nvoid move(vector&lt;int&gt; &amp;src, vector&lt;int&gt; &amp;tar) {\n    // Take out a disk from the top of src\n    int pan = src.back();\n    src.pop_back();\n    // Place the disk on top of tar\n    tar.push_back(pan);\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nvoid dfs(int i, vector&lt;int&gt; &amp;src, vector&lt;int&gt; &amp;buf, vector&lt;int&gt; &amp;tar) {\n    // If there is only one disk left in src, move it directly to tar\n    if (i == 1) {\n        move(src, tar);\n        return;\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, tar, buf);\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src, tar);\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, src, tar);\n}\n\n/* Solve the Tower of Hanoi problem */\nvoid solveHanota(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B, vector&lt;int&gt; &amp;C) {\n    int n = A.size();\n    // Move the top n disks from A to C using B\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.java<pre><code>/* Move a disk */\nvoid move(List&lt;Integer&gt; src, List&lt;Integer&gt; tar) {\n    // Take out a disk from the top of src\n    Integer pan = src.remove(src.size() - 1);\n    // Place the disk on top of tar\n    tar.add(pan);\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nvoid dfs(int i, List&lt;Integer&gt; src, List&lt;Integer&gt; buf, List&lt;Integer&gt; tar) {\n    // If there is only one disk left in src, move it directly to tar\n    if (i == 1) {\n        move(src, tar);\n        return;\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, tar, buf);\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src, tar);\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, src, tar);\n}\n\n/* Solve the Tower of Hanoi problem */\nvoid solveHanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) {\n    int n = A.size();\n    // Move the top n disks from A to C using B\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.cs<pre><code>/* Move a disk */\nvoid Move(List&lt;int&gt; src, List&lt;int&gt; tar) {\n    // Take out a disk from the top of src\n    int pan = src[^1];\n    src.RemoveAt(src.Count - 1);\n    // Place the disk on top of tar\n    tar.Add(pan);\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nvoid DFS(int i, List&lt;int&gt; src, List&lt;int&gt; buf, List&lt;int&gt; tar) {\n    // If there is only one disk left in src, move it directly to tar\n    if (i == 1) {\n        Move(src, tar);\n        return;\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    DFS(i - 1, src, tar, buf);\n    // Subproblem f(1): move the remaining disk from src to tar\n    Move(src, tar);\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    DFS(i - 1, buf, src, tar);\n}\n\n/* Solve the Tower of Hanoi problem */\nvoid SolveHanota(List&lt;int&gt; A, List&lt;int&gt; B, List&lt;int&gt; C) {\n    int n = A.Count;\n    // Move the top n disks from A to C using B\n    DFS(n, A, B, C);\n}\n</code></pre> hanota.go<pre><code>/* Move a disk */\nfunc move(src, tar *list.List) {\n    // Take out a disk from the top of src\n    pan := src.Back()\n    // Place the disk on top of tar\n    tar.PushBack(pan.Value)\n    // Remove top disk from src\n    src.Remove(pan)\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nfunc dfsHanota(i int, src, buf, tar *list.List) {\n    // If there is only one disk left in src, move it directly to tar\n    if i == 1 {\n        move(src, tar)\n        return\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfsHanota(i-1, src, tar, buf)\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src, tar)\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfsHanota(i-1, buf, src, tar)\n}\n\n/* Solve the Tower of Hanoi problem */\nfunc solveHanota(A, B, C *list.List) {\n    n := A.Len()\n    // Move the top n disks from A to C using B\n    dfsHanota(n, A, B, C)\n}\n</code></pre> hanota.swift<pre><code>/* Move a disk */\nfunc move(src: inout [Int], tar: inout [Int]) {\n    // Take out a disk from the top of src\n    let pan = src.popLast()!\n    // Place the disk on top of tar\n    tar.append(pan)\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nfunc dfs(i: Int, src: inout [Int], buf: inout [Int], tar: inout [Int]) {\n    // If there is only one disk left in src, move it directly to tar\n    if i == 1 {\n        move(src: &amp;src, tar: &amp;tar)\n        return\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i: i - 1, src: &amp;src, buf: &amp;tar, tar: &amp;buf)\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src: &amp;src, tar: &amp;tar)\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i: i - 1, src: &amp;buf, buf: &amp;src, tar: &amp;tar)\n}\n\n/* Solve the Tower of Hanoi problem */\nfunc solveHanota(A: inout [Int], B: inout [Int], C: inout [Int]) {\n    let n = A.count\n    // The tail of the list is the top of the rod\n    // Move top n disks from src to C using B\n    dfs(i: n, src: &amp;A, buf: &amp;B, tar: &amp;C)\n}\n</code></pre> hanota.js<pre><code>/* Move a disk */\nfunction move(src, tar) {\n    // Take out a disk from the top of src\n    const pan = src.pop();\n    // Place the disk on top of tar\n    tar.push(pan);\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nfunction dfs(i, src, buf, tar) {\n    // If there is only one disk left in src, move it directly to tar\n    if (i === 1) {\n        move(src, tar);\n        return;\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, tar, buf);\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src, tar);\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, src, tar);\n}\n\n/* Solve the Tower of Hanoi problem */\nfunction solveHanota(A, B, C) {\n    const n = A.length;\n    // Move the top n disks from A to C using B\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.ts<pre><code>/* Move a disk */\nfunction move(src: number[], tar: number[]): void {\n    // Take out a disk from the top of src\n    const pan = src.pop();\n    // Place the disk on top of tar\n    tar.push(pan);\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nfunction dfs(i: number, src: number[], buf: number[], tar: number[]): void {\n    // If there is only one disk left in src, move it directly to tar\n    if (i === 1) {\n        move(src, tar);\n        return;\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, tar, buf);\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src, tar);\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, src, tar);\n}\n\n/* Solve the Tower of Hanoi problem */\nfunction solveHanota(A: number[], B: number[], C: number[]): void {\n    const n = A.length;\n    // Move the top n disks from A to C using B\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.dart<pre><code>/* Move a disk */\nvoid move(List&lt;int&gt; src, List&lt;int&gt; tar) {\n  // Take out a disk from the top of src\n  int pan = src.removeLast();\n  // Place the disk on top of tar\n  tar.add(pan);\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nvoid dfs(int i, List&lt;int&gt; src, List&lt;int&gt; buf, List&lt;int&gt; tar) {\n  // If there is only one disk left in src, move it directly to tar\n  if (i == 1) {\n    move(src, tar);\n    return;\n  }\n  // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n  dfs(i - 1, src, tar, buf);\n  // Subproblem f(1): move the remaining disk from src to tar\n  move(src, tar);\n  // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n  dfs(i - 1, buf, src, tar);\n}\n\n/* Solve the Tower of Hanoi problem */\nvoid solveHanota(List&lt;int&gt; A, List&lt;int&gt; B, List&lt;int&gt; C) {\n  int n = A.length;\n  // Move the top n disks from A to C using B\n  dfs(n, A, B, C);\n}\n</code></pre> hanota.rs<pre><code>/* Move a disk */\nfn move_pan(src: &amp;mut Vec&lt;i32&gt;, tar: &amp;mut Vec&lt;i32&gt;) {\n    // Take out a disk from the top of src\n    let pan = src.pop().unwrap();\n    // Place the disk on top of tar\n    tar.push(pan);\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nfn dfs(i: i32, src: &amp;mut Vec&lt;i32&gt;, buf: &amp;mut Vec&lt;i32&gt;, tar: &amp;mut Vec&lt;i32&gt;) {\n    // If there is only one disk left in src, move it directly to tar\n    if i == 1 {\n        move_pan(src, tar);\n        return;\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, tar, buf);\n    // Subproblem f(1): move the remaining disk from src to tar\n    move_pan(src, tar);\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, src, tar);\n}\n\n/* Solve the Tower of Hanoi problem */\nfn solve_hanota(A: &amp;mut Vec&lt;i32&gt;, B: &amp;mut Vec&lt;i32&gt;, C: &amp;mut Vec&lt;i32&gt;) {\n    let n = A.len() as i32;\n    // Move the top n disks from A to C using B\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.c<pre><code>/* Move a disk */\nvoid move(int *src, int *srcSize, int *tar, int *tarSize) {\n    // Take out a disk from the top of src\n    int pan = src[*srcSize - 1];\n    src[*srcSize - 1] = 0;\n    (*srcSize)--;\n    // Place the disk on top of tar\n    tar[*tarSize] = pan;\n    (*tarSize)++;\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nvoid dfs(int i, int *src, int *srcSize, int *buf, int *bufSize, int *tar, int *tarSize) {\n    // If there is only one disk left in src, move it directly to tar\n    if (i == 1) {\n        move(src, srcSize, tar, tarSize);\n        return;\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, srcSize, tar, tarSize, buf, bufSize);\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src, srcSize, tar, tarSize);\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, bufSize, src, srcSize, tar, tarSize);\n}\n\n/* Solve the Tower of Hanoi problem */\nvoid solveHanota(int *A, int *ASize, int *B, int *BSize, int *C, int *CSize) {\n    // Move the top n disks from A to C using B\n    dfs(*ASize, A, ASize, B, BSize, C, CSize);\n}\n</code></pre> hanota.kt<pre><code>/* Move a disk */\nfun move(src: MutableList&lt;Int&gt;, tar: MutableList&lt;Int&gt;) {\n    // Take out a disk from the top of src\n    val pan = src.removeAt(src.size - 1)\n    // Place the disk on top of tar\n    tar.add(pan)\n}\n\n/* Solve the Tower of Hanoi problem f(i) */\nfun dfs(i: Int, src: MutableList&lt;Int&gt;, buf: MutableList&lt;Int&gt;, tar: MutableList&lt;Int&gt;) {\n    // If there is only one disk left in src, move it directly to tar\n    if (i == 1) {\n        move(src, tar)\n        return\n    }\n    // Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n    dfs(i - 1, src, tar, buf)\n    // Subproblem f(1): move the remaining disk from src to tar\n    move(src, tar)\n    // Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n    dfs(i - 1, buf, src, tar)\n}\n\n/* Solve the Tower of Hanoi problem */\nfun solveHanota(A: MutableList&lt;Int&gt;, B: MutableList&lt;Int&gt;, C: MutableList&lt;Int&gt;) {\n    val n = A.size\n    // Move the top n disks from A to C using B\n    dfs(n, A, B, C)\n}\n</code></pre> hanota.rb<pre><code>### Move one disk ###\ndef move(src, tar)\n  # Take out a disk from the top of src\n  pan = src.pop\n  # Place the disk on top of tar\n  tar &lt;&lt; pan\nend\n\n### Solve Tower of Hanoi f(i) ###\ndef dfs(i, src, buf, tar)\n  # If there is only one disk left in src, move it directly to tar\n  if i == 1\n    move(src, tar)\n    return\n  end\n\n  # Subproblem f(i-1): move the top i-1 disks from src to buf using tar\n  dfs(i - 1, src, tar, buf)\n  # Subproblem f(1): move the remaining disk from src to tar\n  move(src, tar)\n  # Subproblem f(i-1): move the top i-1 disks from buf to tar using src\n  dfs(i - 1, buf, src, tar)\nend\n\n### Solve Tower of Hanoi ###\ndef solve_hanota(_A, _B, _C)\n  n = _A.length\n  # Move the top n disks from A to C using B\n  dfs(n, _A, _B, _C)\nend\n</code></pre> <p>As shown in Figure 12-15, the hanota problem forms a recursion tree of height \\(n\\), where each node represents a subproblem corresponding to an invocation of the <code>dfs()</code> function, therefore the time complexity is \\(O(2^n)\\) and the space complexity is \\(O(n)\\).</p> <p></p> <p> Figure 12-15 \u00a0 Recursion tree of the hanota problem </p> <p>Quote</p> <p>The hanota problem originates from an ancient legend. In a temple in ancient India, monks had three tall diamond pillars and \\(64\\) golden discs of different sizes. The monks continuously moved the discs, believing that when the last disc was correctly placed, the world would come to an end.</p> <p>However, even if the monks moved one disc per second, it would take approximately \\(2^{64} \\approx 1.84\u00d710^{19}\\) seconds, which is about \\(5850\\) billion years, far exceeding current estimates of the age of the universe. Therefore, if this legend is true, we should not need to worry about the end of the world.</p>"},{"location":"chapter_divide_and_conquer/summary/","title":"12.5 \u00a0 Summary","text":""},{"location":"chapter_divide_and_conquer/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Divide and conquer is a common algorithm design strategy, consisting of two phases: divide (partition) and conquer (merge), typically implemented based on recursion.</li> <li>The criteria for determining whether a problem is a divide and conquer problem include: whether the problem can be decomposed, whether subproblems are independent, and whether subproblems can be merged.</li> <li>Merge sort is a typical application of the divide and conquer strategy. It recursively divides an array into two equal-length subarrays until only one element remains, then merges them layer by layer to complete the sorting.</li> <li>Introducing the divide and conquer strategy can often improve algorithm efficiency. On one hand, the divide and conquer strategy reduces the number of operations; on the other hand, it facilitates parallel optimization of the system after division.</li> <li>Divide and conquer can both solve many algorithmic problems and is widely applied in data structure and algorithm design, appearing everywhere.</li> <li>Compared to brute-force search, adaptive search is more efficient. Search algorithms with time complexity of \\(O(\\log n)\\) are typically implemented based on the divide and conquer strategy.</li> <li>Binary search is another typical application of divide and conquer. It does not include the step of merging solutions of subproblems. We can implement binary search through recursive divide and conquer.</li> <li>In the problem of building a binary tree, building the tree (original problem) can be divided into building the left subtree and right subtree (subproblems), which can be achieved by dividing the index intervals of the preorder and inorder traversals.</li> <li>In the hanota problem, a problem of size \\(n\\) can be divided into two subproblems of size \\(n-1\\) and one subproblem of size \\(1\\). After solving these three subproblems in order, the original problem is solved.</li> </ul>"},{"location":"chapter_dynamic_programming/","title":"Chapter 14. \u00a0 Dynamic Programming","text":"<p>Abstract</p> <p>Streams converge into rivers, rivers converge into the sea.</p> <p>Dynamic programming gathers solutions to small problems into answers to large problems, step by step guiding us to the shore of problem-solving.</p>"},{"location":"chapter_dynamic_programming/#chapter-contents","title":"Chapter contents","text":"<ul> <li>14.1 \u00a0 Introduction to Dynamic Programming</li> <li>14.2 \u00a0 Characteristics of Dynamic Programming Problems</li> <li>14.3 \u00a0 Dynamic Programming Problem-Solving Approach</li> <li>14.4 \u00a0 0-1 Knapsack Problem</li> <li>14.5 \u00a0 Unbounded Knapsack Problem</li> <li>14.6 \u00a0 Edit Distance Problem</li> <li>14.7 \u00a0 Summary</li> </ul>"},{"location":"chapter_dynamic_programming/dp_problem_features/","title":"14.2 \u00a0 Characteristics of Dynamic Programming Problems","text":"<p>In the previous section, we learned how dynamic programming solves the original problem by decomposing it into subproblems. In fact, subproblem decomposition is a general algorithmic approach, with different emphases in divide and conquer, dynamic programming, and backtracking.</p> <ul> <li>Divide and conquer algorithms recursively divide the original problem into multiple independent subproblems until the smallest subproblems are reached, and merge the solutions to the subproblems during backtracking to ultimately obtain the solution to the original problem.</li> <li>Dynamic programming also recursively decomposes problems, but the main difference from divide and conquer algorithms is that subproblems in dynamic programming are interdependent, and many overlapping subproblems appear during the decomposition process.</li> <li>Backtracking algorithms enumerate all possible solutions through trial and error, and avoid unnecessary search branches through pruning. The solution to the original problem consists of a series of decision steps, and we can regard the subsequence before each decision step as a subproblem.</li> </ul> <p>In fact, dynamic programming is commonly used to solve optimization problems, which not only contain overlapping subproblems but also have two other major characteristics: optimal substructure and no aftereffects.</p>"},{"location":"chapter_dynamic_programming/dp_problem_features/#1421-optimal-substructure","title":"14.2.1 \u00a0 Optimal Substructure","text":"<p>We make a slight modification to the stair climbing problem to make it more suitable for demonstrating the concept of optimal substructure.</p> <p>Climbing stairs with minimum cost</p> <p>Given a staircase, where you can climb \\(1\\) or \\(2\\) steps at a time, and each step has a non-negative integer representing the cost you need to pay at that step. Given a non-negative integer array \\(cost\\), where \\(cost[i]\\) represents the cost at the \\(i\\)-th step, and \\(cost[0]\\) is the ground (starting point). What is the minimum cost required to reach the top?</p> <p>As shown in Figure 14-6, if the costs of the \\(1\\)st, \\(2\\)nd, and \\(3\\)rd steps are \\(1\\), \\(10\\), and \\(1\\) respectively, then climbing from the ground to the \\(3\\)rd step requires a minimum cost of \\(2\\).</p> <p></p> <p> Figure 14-6 \u00a0 Minimum cost to climb to the 3rd step </p> <p>Let \\(dp[i]\\) be the accumulated cost of climbing to the \\(i\\)-th step. Since the \\(i\\)-th step can only come from the \\(i-1\\)-th or \\(i-2\\)-th step, \\(dp[i]\\) can only equal \\(dp[i-1] + cost[i]\\) or \\(dp[i-2] + cost[i]\\). To minimize the cost, we should choose the smaller of the two:</p> \\[ dp[i] = \\min(dp[i-1], dp[i-2]) + cost[i] \\] <p>This leads us to the meaning of optimal substructure: the optimal solution to the original problem is constructed from the optimal solutions to the subproblems.</p> <p>This problem clearly has optimal substructure: we select the better one from the optimal solutions to the two subproblems \\(dp[i-1]\\) and \\(dp[i-2]\\), and use it to construct the optimal solution to the original problem \\(dp[i]\\).</p> <p>So, does the stair climbing problem from the previous section have optimal substructure? Its goal is to find the number of ways, which seems to be a counting problem, but if we change the question: \"Find the maximum number of ways\". We surprisingly discover that although the problem before and after modification are equivalent, the optimal substructure has emerged: the maximum number of ways for the \\(n\\)-th step equals the sum of the maximum number of ways for the \\(n-1\\)-th and \\(n-2\\)-th steps. Therefore, the interpretation of optimal substructure is quite flexible and will have different meanings in different problems.</p> <p>According to the state transition equation and the initial states \\(dp[1] = cost[1]\\) and \\(dp[2] = cost[2]\\), we can obtain the dynamic programming code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby min_cost_climbing_stairs_dp.py<pre><code>def min_cost_climbing_stairs_dp(cost: list[int]) -&gt; int:\n    \"\"\"Minimum cost climbing stairs: Dynamic programming\"\"\"\n    n = len(cost) - 1\n    if n == 1 or n == 2:\n        return cost[n]\n    # Initialize dp table, used to store solutions to subproblems\n    dp = [0] * (n + 1)\n    # Initial state: preset the solution to the smallest subproblem\n    dp[1], dp[2] = cost[1], cost[2]\n    # State transition: gradually solve larger subproblems from smaller ones\n    for i in range(3, n + 1):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    return dp[n]\n</code></pre> min_cost_climbing_stairs_dp.cpp<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nint minCostClimbingStairsDP(vector&lt;int&gt; &amp;cost) {\n    int n = cost.size() - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // Initialize dp table, used to store solutions to subproblems\n    vector&lt;int&gt; dp(n + 1);\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.java<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nint minCostClimbingStairsDP(int[] cost) {\n    int n = cost.length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // Initialize dp table, used to store solutions to subproblems\n    int[] dp = new int[n + 1];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.cs<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nint MinCostClimbingStairsDP(int[] cost) {\n    int n = cost.Length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // Initialize dp table, used to store solutions to subproblems\n    int[] dp = new int[n + 1];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = Math.Min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.go<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nfunc minCostClimbingStairsDP(cost []int) int {\n    n := len(cost) - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    min := func(a, b int) int {\n        if a &lt; b {\n            return a\n        }\n        return b\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    dp := make([]int, n+1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1]\n    dp[2] = cost[2]\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i := 3; i &lt;= n; i++ {\n        dp[i] = min(dp[i-1], dp[i-2]) + cost[i]\n    }\n    return dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.swift<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nfunc minCostClimbingStairsDP(cost: [Int]) -&gt; Int {\n    let n = cost.count - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    var dp = Array(repeating: 0, count: n + 1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1]\n    dp[2] = cost[2]\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i in 3 ... n {\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    }\n    return dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.js<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nfunction minCostClimbingStairsDP(cost) {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    const dp = new Array(n + 1);\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.ts<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nfunction minCostClimbingStairsDP(cost: Array&lt;number&gt;): number {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    const dp = new Array(n + 1);\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.dart<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nint minCostClimbingStairsDP(List&lt;int&gt; cost) {\n  int n = cost.length - 1;\n  if (n == 1 || n == 2) return cost[n];\n  // Initialize dp table, used to store solutions to subproblems\n  List&lt;int&gt; dp = List.filled(n + 1, 0);\n  // Initial state: preset the solution to the smallest subproblem\n  dp[1] = cost[1];\n  dp[2] = cost[2];\n  // State transition: gradually solve larger subproblems from smaller ones\n  for (int i = 3; i &lt;= n; i++) {\n    dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n  }\n  return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.rs<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nfn min_cost_climbing_stairs_dp(cost: &amp;[i32]) -&gt; i32 {\n    let n = cost.len() - 1;\n    if n == 1 || n == 2 {\n        return cost[n];\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    let mut dp = vec![-1; n + 1];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i in 3..=n {\n        dp[i] = cmp::min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.c<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nint minCostClimbingStairsDP(int cost[], int costSize) {\n    int n = costSize - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // Initialize dp table, used to store solutions to subproblems\n    int *dp = calloc(n + 1, sizeof(int));\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = myMin(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    int res = dp[n];\n    // Free memory\n    free(dp);\n    return res;\n}\n</code></pre> min_cost_climbing_stairs_dp.kt<pre><code>/* Minimum cost climbing stairs: Dynamic programming */\nfun minCostClimbingStairsDP(cost: IntArray): Int {\n    val n = cost.size - 1\n    if (n == 1 || n == 2) return cost[n]\n    // Initialize dp table, used to store solutions to subproblems\n    val dp = IntArray(n + 1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = cost[1]\n    dp[2] = cost[2]\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (i in 3..n) {\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    }\n    return dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.rb<pre><code>### Minimum cost climbing stairs: DP ###\ndef min_cost_climbing_stairs_dp(cost)\n  n = cost.length - 1\n  return cost[n] if n == 1 || n == 2\n  # Initialize dp table, used to store solutions to subproblems\n  dp = Array.new(n + 1, 0)\n  # Initial state: preset the solution to the smallest subproblem\n  dp[1], dp[2] = cost[1], cost[2]\n  # State transition: gradually solve larger subproblems from smaller ones\n  (3...(n + 1)).each { |i| dp[i] = [dp[i - 1], dp[i - 2]].min + cost[i] }\n  dp[n]\nend\n</code></pre> <p>Figure 14-7 shows the dynamic programming process for the above code.</p> <p></p> <p> Figure 14-7 \u00a0 Dynamic programming process for climbing stairs with minimum cost </p> <p>This problem can also be space-optimized, compressing from one dimension to zero, reducing the space complexity from \\(O(n)\\) to \\(O(1)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby min_cost_climbing_stairs_dp.py<pre><code>def min_cost_climbing_stairs_dp_comp(cost: list[int]) -&gt; int:\n    \"\"\"Minimum cost climbing stairs: Space-optimized dynamic programming\"\"\"\n    n = len(cost) - 1\n    if n == 1 or n == 2:\n        return cost[n]\n    a, b = cost[1], cost[2]\n    for i in range(3, n + 1):\n        a, b = b, min(a, b) + cost[i]\n    return b\n</code></pre> min_cost_climbing_stairs_dp.cpp<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nint minCostClimbingStairsDPComp(vector&lt;int&gt; &amp;cost) {\n    int n = cost.size() - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.java<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nint minCostClimbingStairsDPComp(int[] cost) {\n    int n = cost.length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = Math.min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.cs<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nint MinCostClimbingStairsDPComp(int[] cost) {\n    int n = cost.Length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = Math.Min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.go<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nfunc minCostClimbingStairsDPComp(cost []int) int {\n    n := len(cost) - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    min := func(a, b int) int {\n        if a &lt; b {\n            return a\n        }\n        return b\n    }\n    // Initial state: preset the solution to the smallest subproblem\n    a, b := cost[1], cost[2]\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i := 3; i &lt;= n; i++ {\n        tmp := b\n        b = min(a, tmp) + cost[i]\n        a = tmp\n    }\n    return b\n}\n</code></pre> min_cost_climbing_stairs_dp.swift<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nfunc minCostClimbingStairsDPComp(cost: [Int]) -&gt; Int {\n    let n = cost.count - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    var (a, b) = (cost[1], cost[2])\n    for i in 3 ... n {\n        (a, b) = (b, min(a, b) + cost[i])\n    }\n    return b\n}\n</code></pre> min_cost_climbing_stairs_dp.js<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nfunction minCostClimbingStairsDPComp(cost) {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    let a = cost[1],\n        b = cost[2];\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = Math.min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.ts<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nfunction minCostClimbingStairsDPComp(cost: Array&lt;number&gt;): number {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    let a = cost[1],\n        b = cost[2];\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = Math.min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.dart<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nint minCostClimbingStairsDPComp(List&lt;int&gt; cost) {\n  int n = cost.length - 1;\n  if (n == 1 || n == 2) return cost[n];\n  int a = cost[1], b = cost[2];\n  for (int i = 3; i &lt;= n; i++) {\n    int tmp = b;\n    b = min(a, tmp) + cost[i];\n    a = tmp;\n  }\n  return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.rs<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nfn min_cost_climbing_stairs_dp_comp(cost: &amp;[i32]) -&gt; i32 {\n    let n = cost.len() - 1;\n    if n == 1 || n == 2 {\n        return cost[n];\n    };\n    let (mut a, mut b) = (cost[1], cost[2]);\n    for i in 3..=n {\n        let tmp = b;\n        b = cmp::min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    b\n}\n</code></pre> min_cost_climbing_stairs_dp.c<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nint minCostClimbingStairsDPComp(int cost[], int costSize) {\n    int n = costSize - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = myMin(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.kt<pre><code>/* Minimum cost climbing stairs: Space-optimized dynamic programming */\nfun minCostClimbingStairsDPComp(cost: IntArray): Int {\n    val n = cost.size - 1\n    if (n == 1 || n == 2) return cost[n]\n    var a = cost[1]\n    var b = cost[2]\n    for (i in 3..n) {\n        val tmp = b\n        b = min(a, tmp) + cost[i]\n        a = tmp\n    }\n    return b\n}\n</code></pre> min_cost_climbing_stairs_dp.rb<pre><code>### Minimum cost climbing stairs: DP ###\ndef min_cost_climbing_stairs_dp(cost)\n  n = cost.length - 1\n  return cost[n] if n == 1 || n == 2\n  # Initialize dp table, used to store solutions to subproblems\n  dp = Array.new(n + 1, 0)\n  # Initial state: preset the solution to the smallest subproblem\n  dp[1], dp[2] = cost[1], cost[2]\n  # State transition: gradually solve larger subproblems from smaller ones\n  (3...(n + 1)).each { |i| dp[i] = [dp[i - 1], dp[i - 2]].min + cost[i] }\n  dp[n]\nend\n\n# Minimum cost climbing stairs: Space-optimized dynamic programming\ndef min_cost_climbing_stairs_dp_comp(cost)\n  n = cost.length - 1\n  return cost[n] if n == 1 || n == 2\n  a, b = cost[1], cost[2]\n  (3...(n + 1)).each { |i| a, b = b, [a, b].min + cost[i] }\n  b\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/dp_problem_features/#1422-no-aftereffects","title":"14.2.2 \u00a0 No Aftereffects","text":"<p>No aftereffects is one of the important characteristics that enable dynamic programming to solve problems effectively. Its definition is: given a certain state, its future development is only related to the current state and has nothing to do with all past states.</p> <p>Taking the stair climbing problem as an example, given state \\(i\\), it will develop into states \\(i+1\\) and \\(i+2\\), corresponding to jumping \\(1\\) step and jumping \\(2\\) steps, respectively. When making these two choices, we do not need to consider the states before state \\(i\\), as they have no effect on the future of state \\(i\\).</p> <p>However, if we add a constraint to the stair climbing problem, the situation changes.</p> <p>Climbing stairs with constraint</p> <p>Given a staircase with \\(n\\) steps, where you can climb \\(1\\) or \\(2\\) steps at a time, but you cannot jump \\(1\\) step in two consecutive rounds. How many ways are there to climb to the top?</p> <p>As shown in Figure 14-8, there are only \\(2\\) feasible ways to climb to the \\(3\\)rd step. The way of jumping \\(1\\) step three consecutive times does not satisfy the constraint and is therefore discarded.</p> <p></p> <p> Figure 14-8 \u00a0 Number of ways to climb to the 3rd step with constraint </p> <p>In this problem, if the previous round was a jump of \\(1\\) step, then the next round must jump \\(2\\) steps. This means that the next choice cannot be determined solely by the current state (current stair step number), but also depends on the previous state (the stair step number from the previous round).</p> <p>It is not difficult to see that this problem no longer satisfies no aftereffects, and the state transition equation \\(dp[i] = dp[i-1] + dp[i-2]\\) also fails, because \\(dp[i-1]\\) represents jumping \\(1\\) step in this round, but it includes many solutions where \"the previous round was a jump of \\(1\\) step\", which cannot be directly counted in \\(dp[i]\\) to satisfy the constraint.</p> <p>For this reason, we need to expand the state definition: state \\([i, j]\\) represents being on the \\(i\\)-th step with the previous round having jumped \\(j\\) steps, where \\(j \\in \\{1, 2\\}\\). This state definition effectively distinguishes whether the previous round was a jump of \\(1\\) step or \\(2\\) steps, allowing us to determine where the current state came from.</p> <ul> <li>When the previous round jumped \\(1\\) step, the round before that could only choose to jump \\(2\\) steps, i.e., \\(dp[i, 1]\\) can only be transferred from \\(dp[i-1, 2]\\).</li> <li>When the previous round jumped \\(2\\) steps, the round before that could choose to jump \\(1\\) step or \\(2\\) steps, i.e., \\(dp[i, 2]\\) can be transferred from \\(dp[i-2, 1]\\) or \\(dp[i-2, 2]\\).</li> </ul> <p>As shown in Figure 14-9, under this definition, \\(dp[i, j]\\) represents the number of ways for state \\([i, j]\\). The state transition equation is then:</p> \\[ \\begin{cases} dp[i, 1] = dp[i-1, 2] \\\\ dp[i, 2] = dp[i-2, 1] + dp[i-2, 2] \\end{cases} \\] <p></p> <p> Figure 14-9 \u00a0 Recurrence relation considering constraints </p> <p>Finally, return \\(dp[n, 1] + dp[n, 2]\\), where the sum of the two represents the total number of ways to climb to the \\(n\\)-th step:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby climbing_stairs_constraint_dp.py<pre><code>def climbing_stairs_constraint_dp(n: int) -&gt; int:\n    \"\"\"Climbing stairs with constraint: Dynamic programming\"\"\"\n    if n == 1 or n == 2:\n        return 1\n    # Initialize dp table, used to store solutions to subproblems\n    dp = [[0] * 3 for _ in range(n + 1)]\n    # Initial state: preset the solution to the smallest subproblem\n    dp[1][1], dp[1][2] = 1, 0\n    dp[2][1], dp[2][2] = 0, 1\n    # State transition: gradually solve larger subproblems from smaller ones\n    for i in range(3, n + 1):\n        dp[i][1] = dp[i - 1][2]\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2]\n    return dp[n][1] + dp[n][2]\n</code></pre> climbing_stairs_constraint_dp.cpp<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nint climbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(3, 0));\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.java<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nint climbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    int[][] dp = new int[n + 1][3];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.cs<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nint ClimbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    int[,] dp = new int[n + 1, 3];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1, 1] = 1;\n    dp[1, 2] = 0;\n    dp[2, 1] = 0;\n    dp[2, 2] = 1;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i, 1] = dp[i - 1, 2];\n        dp[i, 2] = dp[i - 2, 1] + dp[i - 2, 2];\n    }\n    return dp[n, 1] + dp[n, 2];\n}\n</code></pre> climbing_stairs_constraint_dp.go<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nfunc climbingStairsConstraintDP(n int) int {\n    if n == 1 || n == 2 {\n        return 1\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    dp := make([][3]int, n+1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1\n    dp[1][2] = 0\n    dp[2][1] = 0\n    dp[2][2] = 1\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i := 3; i &lt;= n; i++ {\n        dp[i][1] = dp[i-1][2]\n        dp[i][2] = dp[i-2][1] + dp[i-2][2]\n    }\n    return dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.swift<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nfunc climbingStairsConstraintDP(n: Int) -&gt; Int {\n    if n == 1 || n == 2 {\n        return 1\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    var dp = Array(repeating: Array(repeating: 0, count: 3), count: n + 1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1\n    dp[1][2] = 0\n    dp[2][1] = 0\n    dp[2][2] = 1\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i in 3 ... n {\n        dp[i][1] = dp[i - 1][2]\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2]\n    }\n    return dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.js<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nfunction climbingStairsConstraintDP(n) {\n    if (n === 1 || n === 2) {\n        return 1;\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    const dp = Array.from(new Array(n + 1), () =&gt; new Array(3));\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.ts<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nfunction climbingStairsConstraintDP(n: number): number {\n    if (n === 1 || n === 2) {\n        return 1;\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    const dp = Array.from({ length: n + 1 }, () =&gt; new Array(3));\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.dart<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nint climbingStairsConstraintDP(int n) {\n  if (n == 1 || n == 2) {\n    return 1;\n  }\n  // Initialize dp table, used to store solutions to subproblems\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(3, 0));\n  // Initial state: preset the solution to the smallest subproblem\n  dp[1][1] = 1;\n  dp[1][2] = 0;\n  dp[2][1] = 0;\n  dp[2][2] = 1;\n  // State transition: gradually solve larger subproblems from smaller ones\n  for (int i = 3; i &lt;= n; i++) {\n    dp[i][1] = dp[i - 1][2];\n    dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n  }\n  return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.rs<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nfn climbing_stairs_constraint_dp(n: usize) -&gt; i32 {\n    if n == 1 || n == 2 {\n        return 1;\n    };\n    // Initialize dp table, used to store solutions to subproblems\n    let mut dp = vec![vec![-1; 3]; n + 1];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i in 3..=n {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.c<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nint climbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(3, sizeof(int));\n    }\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    int res = dp[n][1] + dp[n][2];\n    // Free memory\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return res;\n}\n</code></pre> climbing_stairs_constraint_dp.kt<pre><code>/* Climbing stairs with constraint: Dynamic programming */\nfun climbingStairsConstraintDP(n: Int): Int {\n    if (n == 1 || n == 2) {\n        return 1\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    val dp = Array(n + 1) { IntArray(3) }\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1][1] = 1\n    dp[1][2] = 0\n    dp[2][1] = 0\n    dp[2][2] = 1\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (i in 3..n) {\n        dp[i][1] = dp[i - 1][2]\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2]\n    }\n    return dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.rb<pre><code>### Climbing stairs with constraint: DP ###\ndef climbing_stairs_constraint_dp(n)\n  return 1 if n == 1 || n == 2\n\n  # Initialize dp table, used to store solutions to subproblems\n  dp = Array.new(n + 1) { Array.new(3, 0) }\n  # Initial state: preset the solution to the smallest subproblem\n  dp[1][1], dp[1][2] = 1, 0\n  dp[2][1], dp[2][2] = 0, 1\n  # State transition: gradually solve larger subproblems from smaller ones\n  for i in 3...(n + 1)\n    dp[i][1] = dp[i - 1][2]\n    dp[i][2] = dp[i - 2][1] + dp[i - 2][2]\n  end\n\n  dp[n][1] + dp[n][2]\nend\n</code></pre> <p>In the above case, since we only need to consider one more preceding state, we can still make the problem satisfy no aftereffects by expanding the state definition. However, some problems have very severe \"aftereffects\".</p> <p>Climbing stairs with obstacle generation</p> <p>Given a staircase with \\(n\\) steps, where you can climb \\(1\\) or \\(2\\) steps at a time. It is stipulated that when climbing to the \\(i\\)-th step, the system will automatically place an obstacle on the \\(2i\\)-th step, and thereafter no round is allowed to jump to the \\(2i\\)-th step. For example, if the first two rounds jump to the \\(2\\)nd and \\(3\\)rd steps, then afterwards you cannot jump to the \\(4\\)th and \\(6\\)th steps. How many ways are there to climb to the top?</p> <p>In this problem, the next jump depends on all past states, because each jump places obstacles on higher steps, affecting future jumps. For such problems, dynamic programming is often difficult to solve.</p> <p>In fact, many complex combinatorial optimization problems (such as the traveling salesman problem) do not satisfy no aftereffects. For such problems, we usually choose to use other methods, such as heuristic search, genetic algorithms, reinforcement learning, etc., to obtain usable local optimal solutions within a limited time.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/","title":"14.3 \u00a0 Dynamic Programming Problem-Solving Approach","text":"<p>The previous two sections introduced the main characteristics of dynamic programming problems. Next, let us explore two more practical issues together.</p> <ol> <li>How to determine whether a problem is a dynamic programming problem?</li> <li>What is the complete process for solving a dynamic programming problem, and where should we start?</li> </ol>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#1431-problem-determination","title":"14.3.1 \u00a0 Problem Determination","text":"<p>Generally speaking, if a problem contains overlapping subproblems, optimal substructure, and satisfies no aftereffects, then it is usually suitable for solving with dynamic programming. However, it is difficult to directly extract these characteristics from the problem description. Therefore, we usually relax the conditions and first observe whether the problem is suitable for solving with backtracking (exhaustive search).</p> <p>Problems suitable for solving with backtracking usually satisfy the \"decision tree model\", which means the problem can be described using a tree structure, where each node represents a decision and each path represents a sequence of decisions.</p> <p>In other words, if a problem contains an explicit concept of decisions, and the solution is generated through a series of decisions, then it satisfies the decision tree model and can usually be solved using backtracking.</p> <p>On this basis, dynamic programming problems also have some \"bonus points\" for determination.</p> <ul> <li>The problem contains descriptions such as maximum (minimum) or most (least), indicating optimization.</li> <li>The problem's state can be represented using a list, multi-dimensional matrix, or tree, and a state has a recurrence relation with its surrounding states.</li> </ul> <p>Correspondingly, there are also some \"penalty points\".</p> <ul> <li>The goal of the problem is to find all possible solutions, rather than finding the optimal solution.</li> <li>The problem description has obvious permutation and combination characteristics, requiring the return of specific multiple solutions.</li> </ul> <p>If a problem satisfies the decision tree model and has relatively obvious \"bonus points\", we can assume it is a dynamic programming problem and verify it during the solving process.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#1432-problem-solving-steps","title":"14.3.2 \u00a0 Problem-Solving Steps","text":"<p>The problem-solving process for dynamic programming varies depending on the nature and difficulty of the problem, but generally follows these steps: describe decisions, define states, establish the \\(dp\\) table, derive state transition equations, determine boundary conditions, etc.</p> <p>To illustrate the problem-solving steps more vividly, we use a classic problem \"minimum path sum\" as an example.</p> <p>Question</p> <p>Given an \\(n \\times m\\) two-dimensional grid <code>grid</code>, where each cell in the grid contains a non-negative integer representing the cost of that cell. A robot starts from the top-left cell and can only move down or right at each step until reaching the bottom-right cell. Return the minimum path sum from the top-left to the bottom-right.</p> <p>Figure 14-10 shows an example where the minimum path sum for the given grid is \\(13\\).</p> <p></p> <p> Figure 14-10 \u00a0 Minimum path sum example data </p> <p>Step 1: Think about the decisions in each round, define the state, and thus obtain the \\(dp\\) table</p> <p>The decision in each round of this problem is to move one step down or right from the current cell. Let the row and column indices of the current cell be \\([i, j]\\). After moving down or right, the indices become \\([i+1, j]\\) or \\([i, j+1]\\). Therefore, the state should include two variables, the row index and column index, denoted as \\([i, j]\\).</p> <p>State \\([i, j]\\) corresponds to the subproblem: the minimum path sum from the starting point \\([0, 0]\\) to \\([i, j]\\), denoted as \\(dp[i, j]\\).</p> <p>From this, we obtain the two-dimensional \\(dp\\) matrix shown in Figure 14-11, whose size is the same as the input grid \\(grid\\).</p> <p></p> <p> Figure 14-11 \u00a0 State definition and dp table </p> <p>Note</p> <p>The dynamic programming and backtracking processes can be described as a sequence of decisions, and the state consists of all decision variables. It should contain all variables describing the progress of problem-solving, and should contain sufficient information to derive the next state.</p> <p>Each state corresponds to a subproblem, and we define a \\(dp\\) table to store the solutions to all subproblems. Each independent variable of the state is a dimension of the \\(dp\\) table. Essentially, the \\(dp\\) table is a mapping between states and solutions to subproblems.</p> <p>Step 2: Identify the optimal substructure, and then derive the state transition equation</p> <p>For state \\([i, j]\\), it can only be transferred from the cell above \\([i-1, j]\\) or the cell to the left \\([i, j-1]\\). Therefore, the optimal substructure is: the minimum path sum to reach \\([i, j]\\) is determined by the smaller of the minimum path sums of \\([i, j-1]\\) and \\([i-1, j]\\).</p> <p>Based on the above analysis, the state transition equation shown in Figure 14-12 can be derived:</p> \\[ dp[i, j] = \\min(dp[i-1, j], dp[i, j-1]) + grid[i, j] \\] <p></p> <p> Figure 14-12 \u00a0 Optimal substructure and state transition equation </p> <p>Note</p> <p>Based on the defined \\(dp\\) table, think about the relationship between the original problem and subproblems, and find the method to construct the optimal solution to the original problem from the optimal solutions to the subproblems, which is the optimal substructure.</p> <p>Once we identify the optimal substructure, we can use it to construct the state transition equation.</p> <p>Step 3: Determine boundary conditions and state transition order</p> <p>In this problem, states in the first row can only come from the state to their left, and states in the first column can only come from the state above them. Therefore, the first row \\(i = 0\\) and first column \\(j = 0\\) are boundary conditions.</p> <p>As shown in Figure 14-13, since each cell is transferred from the cell to its left and the cell above it, we use loops to traverse the matrix, with the outer loop traversing rows and the inner loop traversing columns.</p> <p></p> <p> Figure 14-13 \u00a0 Boundary conditions and state transition order </p> <p>Note</p> <p>Boundary conditions in dynamic programming are used to initialize the \\(dp\\) table, and in search are used for pruning.</p> <p>The core of state transition order is to ensure that when computing the solution to the current problem, all the smaller subproblems it depends on have already been computed correctly.</p> <p>Based on the above analysis, we can directly write the dynamic programming code. However, subproblem decomposition is a top-down approach, so implementing in the order \"brute force search \\(\\rightarrow\\) memoization \\(\\rightarrow\\) dynamic programming\" is more aligned with thinking habits.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#1-method-1-brute-force-search","title":"1. \u00a0 Method 1: Brute Force Search","text":"<p>Starting from state \\([i, j]\\), continuously decompose into smaller states \\([i-1, j]\\) and \\([i, j-1]\\). The recursive function includes the following elements.</p> <ul> <li>Recursive parameters: state \\([i, j]\\).</li> <li>Return value: minimum path sum from \\([0, 0]\\) to \\([i, j]\\), which is \\(dp[i, j]\\).</li> <li>Termination condition: when \\(i = 0\\) and \\(j = 0\\), return cost \\(grid[0, 0]\\).</li> <li>Pruning: when \\(i &lt; 0\\) or \\(j &lt; 0\\), the index is out of bounds, return cost \\(+\\infty\\), representing infeasibility.</li> </ul> <p>The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby min_path_sum.py<pre><code>def min_path_sum_dfs(grid: list[list[int]], i: int, j: int) -&gt; int:\n    \"\"\"Minimum path sum: Brute-force search\"\"\"\n    # If it's the top-left cell, terminate the search\n    if i == 0 and j == 0:\n        return grid[0][0]\n    # If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 or j &lt; 0:\n        return inf\n    # Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    up = min_path_sum_dfs(grid, i - 1, j)\n    left = min_path_sum_dfs(grid, i, j - 1)\n    # Return the minimum path cost from top-left to (i, j)\n    return min(left, up) + grid[i][j]\n</code></pre> min_path_sum.cpp<pre><code>/* Minimum path sum: Brute-force search */\nint minPathSumDFS(vector&lt;vector&lt;int&gt;&gt; &amp;grid, int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    int up = minPathSumDFS(grid, i - 1, j);\n    int left = minPathSumDFS(grid, i, j - 1);\n    // Return the minimum path cost from top-left to (i, j)\n    return min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;\n}\n</code></pre> min_path_sum.java<pre><code>/* Minimum path sum: Brute-force search */\nint minPathSumDFS(int[][] grid, int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Integer.MAX_VALUE;\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    int up = minPathSumDFS(grid, i - 1, j);\n    int left = minPathSumDFS(grid, i, j - 1);\n    // Return the minimum path cost from top-left to (i, j)\n    return Math.min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.cs<pre><code>/* Minimum path sum: Brute-force search */\nint MinPathSumDFS(int[][] grid, int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return int.MaxValue;\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    int up = MinPathSumDFS(grid, i - 1, j);\n    int left = MinPathSumDFS(grid, i, j - 1);\n    // Return the minimum path cost from top-left to (i, j)\n    return Math.Min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.go<pre><code>/* Minimum path sum: Brute-force search */\nfunc minPathSumDFS(grid [][]int, i, j int) int {\n    // If it's the top-left cell, terminate the search\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0]\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 || j &lt; 0 {\n        return math.MaxInt\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    up := minPathSumDFS(grid, i-1, j)\n    left := minPathSumDFS(grid, i, j-1)\n    // Return the minimum path cost from top-left to (i, j)\n    return int(math.Min(float64(left), float64(up))) + grid[i][j]\n}\n</code></pre> min_path_sum.swift<pre><code>/* Minimum path sum: Brute-force search */\nfunc minPathSumDFS(grid: [[Int]], i: Int, j: Int) -&gt; Int {\n    // If it's the top-left cell, terminate the search\n    if i == 0, j == 0 {\n        return grid[0][0]\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 || j &lt; 0 {\n        return .max\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    let up = minPathSumDFS(grid: grid, i: i - 1, j: j)\n    let left = minPathSumDFS(grid: grid, i: i, j: j - 1)\n    // Return the minimum path cost from top-left to (i, j)\n    return min(left, up) + grid[i][j]\n}\n</code></pre> min_path_sum.js<pre><code>/* Minimum path sum: Brute-force search */\nfunction minPathSumDFS(grid, i, j) {\n    // If it's the top-left cell, terminate the search\n    if (i === 0 &amp;&amp; j === 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    const up = minPathSumDFS(grid, i - 1, j);\n    const left = minPathSumDFS(grid, i, j - 1);\n    // Return the minimum path cost from top-left to (i, j)\n    return Math.min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.ts<pre><code>/* Minimum path sum: Brute-force search */\nfunction minPathSumDFS(\n    grid: Array&lt;Array&lt;number&gt;&gt;,\n    i: number,\n    j: number\n): number {\n    // If it's the top-left cell, terminate the search\n    if (i === 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    const up = minPathSumDFS(grid, i - 1, j);\n    const left = minPathSumDFS(grid, i, j - 1);\n    // Return the minimum path cost from top-left to (i, j)\n    return Math.min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.dart<pre><code>/* Minimum path sum: Brute-force search */\nint minPathSumDFS(List&lt;List&lt;int&gt;&gt; grid, int i, int j) {\n  // If it's the top-left cell, terminate the search\n  if (i == 0 &amp;&amp; j == 0) {\n    return grid[0][0];\n  }\n  // If row or column index is out of bounds, return +\u221e cost\n  if (i &lt; 0 || j &lt; 0) {\n    // In Dart, int type is fixed-range integer, no value representing \"infinity\"\n    return BigInt.from(2).pow(31).toInt();\n  }\n  // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n  int up = minPathSumDFS(grid, i - 1, j);\n  int left = minPathSumDFS(grid, i, j - 1);\n  // Return the minimum path cost from top-left to (i, j)\n  return min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.rs<pre><code>/* Minimum path sum: Brute-force search */\nfn min_path_sum_dfs(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, i: i32, j: i32) -&gt; i32 {\n    // If it's the top-left cell, terminate the search\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 || j &lt; 0 {\n        return i32::MAX;\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    let up = min_path_sum_dfs(grid, i - 1, j);\n    let left = min_path_sum_dfs(grid, i, j - 1);\n    // Return the minimum path cost from top-left to (i, j)\n    std::cmp::min(left, up) + grid[i as usize][j as usize]\n}\n</code></pre> min_path_sum.c<pre><code>/* Minimum path sum: Brute-force search */\nint minPathSumDFS(int grid[MAX_SIZE][MAX_SIZE], int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    int up = minPathSumDFS(grid, i - 1, j);\n    int left = minPathSumDFS(grid, i, j - 1);\n    // Return the minimum path cost from top-left to (i, j)\n    return myMin(left, up) != INT_MAX ? myMin(left, up) + grid[i][j] : INT_MAX;\n}\n</code></pre> min_path_sum.kt<pre><code>/* Minimum path sum: Brute-force search */\nfun minPathSumDFS(grid: Array&lt;IntArray&gt;, i: Int, j: Int): Int {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0]\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Int.MAX_VALUE\n    }\n    // Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n    val up = minPathSumDFS(grid, i - 1, j)\n    val left = minPathSumDFS(grid, i, j - 1)\n    // Return the minimum path cost from top-left to (i, j)\n    return min(left, up) + grid[i][j]\n}\n</code></pre> min_path_sum.rb<pre><code>### Minimum path sum: brute force search ###\ndef min_path_sum_dfs(grid, i, j)\n  # If it's the top-left cell, terminate the search\n  return grid[i][j] if i == 0 &amp;&amp; j == 0\n  # If row or column index is out of bounds, return +\u221e cost\n  return Float::INFINITY if i &lt; 0 || j &lt; 0\n  # Calculate the minimum path cost from top-left to (i-1, j) and (i, j-1)\n  up = min_path_sum_dfs(grid, i - 1, j)\n  left = min_path_sum_dfs(grid, i, j - 1)\n  # Return the minimum path cost from top-left to (i, j)\n  [left, up].min + grid[i][j]\nend\n</code></pre> <p>Figure 14-14 shows the recursion tree rooted at \\(dp[2, 1]\\), which includes some overlapping subproblems whose number will increase sharply as the size of grid <code>grid</code> grows.</p> <p>Essentially, the reason for overlapping subproblems is: there are multiple paths from the top-left corner to reach a certain cell.</p> <p></p> <p> Figure 14-14 \u00a0 Brute force search recursion tree </p> <p>Each state has two choices, down and right, so the total number of steps from the top-left corner to the bottom-right corner is \\(m + n - 2\\), giving a worst-case time complexity of \\(O(2^{m + n})\\), where \\(n\\) and \\(m\\) are the number of rows and columns of the grid, respectively. Note that this calculation does not account for situations near the grid boundaries, where only one choice remains when reaching the grid boundary, so the actual number of paths will be somewhat less.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#2-method-2-memoization","title":"2. \u00a0 Method 2: Memoization","text":"<p>We introduce a memo list <code>mem</code> of the same size as grid <code>grid</code> to record the solutions to subproblems and prune overlapping subproblems:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby min_path_sum.py<pre><code>def min_path_sum_dfs_mem(\n    grid: list[list[int]], mem: list[list[int]], i: int, j: int\n) -&gt; int:\n    \"\"\"Minimum path sum: Memoization search\"\"\"\n    # If it's the top-left cell, terminate the search\n    if i == 0 and j == 0:\n        return grid[0][0]\n    # If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 or j &lt; 0:\n        return inf\n    # If there's a record, return it directly\n    if mem[i][j] != -1:\n        return mem[i][j]\n    # Minimum path cost for left and upper cells\n    up = min_path_sum_dfs_mem(grid, mem, i - 1, j)\n    left = min_path_sum_dfs_mem(grid, mem, i, j - 1)\n    # Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = min(left, up) + grid[i][j]\n    return mem[i][j]\n</code></pre> min_path_sum.cpp<pre><code>/* Minimum path sum: Memoization search */\nint minPathSumDFSMem(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;int&gt;&gt; &amp;mem, int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // If there's a record, return it directly\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // Minimum path cost for left and upper cells\n    int up = minPathSumDFSMem(grid, mem, i - 1, j);\n    int left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;\n    return mem[i][j];\n}\n</code></pre> min_path_sum.java<pre><code>/* Minimum path sum: Memoization search */\nint minPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Integer.MAX_VALUE;\n    }\n    // If there's a record, return it directly\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // Minimum path cost for left and upper cells\n    int up = minPathSumDFSMem(grid, mem, i - 1, j);\n    int left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = Math.min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.cs<pre><code>/* Minimum path sum: Memoization search */\nint MinPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return int.MaxValue;\n    }\n    // If there's a record, return it directly\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // Minimum path cost for left and upper cells\n    int up = MinPathSumDFSMem(grid, mem, i - 1, j);\n    int left = MinPathSumDFSMem(grid, mem, i, j - 1);\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = Math.Min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.go<pre><code>/* Minimum path sum: Memoization search */\nfunc minPathSumDFSMem(grid, mem [][]int, i, j int) int {\n    // If it's the top-left cell, terminate the search\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0]\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 || j &lt; 0 {\n        return math.MaxInt\n    }\n    // If there's a record, return it directly\n    if mem[i][j] != -1 {\n        return mem[i][j]\n    }\n    // Minimum path cost for left and upper cells\n    up := minPathSumDFSMem(grid, mem, i-1, j)\n    left := minPathSumDFSMem(grid, mem, i, j-1)\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = int(math.Min(float64(left), float64(up))) + grid[i][j]\n    return mem[i][j]\n}\n</code></pre> min_path_sum.swift<pre><code>/* Minimum path sum: Memoization search */\nfunc minPathSumDFSMem(grid: [[Int]], mem: inout [[Int]], i: Int, j: Int) -&gt; Int {\n    // If it's the top-left cell, terminate the search\n    if i == 0, j == 0 {\n        return grid[0][0]\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 || j &lt; 0 {\n        return .max\n    }\n    // If there's a record, return it directly\n    if mem[i][j] != -1 {\n        return mem[i][j]\n    }\n    // Minimum path cost for left and upper cells\n    let up = minPathSumDFSMem(grid: grid, mem: &amp;mem, i: i - 1, j: j)\n    let left = minPathSumDFSMem(grid: grid, mem: &amp;mem, i: i, j: j - 1)\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = min(left, up) + grid[i][j]\n    return mem[i][j]\n}\n</code></pre> min_path_sum.js<pre><code>/* Minimum path sum: Memoization search */\nfunction minPathSumDFSMem(grid, mem, i, j) {\n    // If it's the top-left cell, terminate the search\n    if (i === 0 &amp;&amp; j === 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // If there's a record, return it directly\n    if (mem[i][j] !== -1) {\n        return mem[i][j];\n    }\n    // Minimum path cost for left and upper cells\n    const up = minPathSumDFSMem(grid, mem, i - 1, j);\n    const left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = Math.min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.ts<pre><code>/* Minimum path sum: Memoization search */\nfunction minPathSumDFSMem(\n    grid: Array&lt;Array&lt;number&gt;&gt;,\n    mem: Array&lt;Array&lt;number&gt;&gt;,\n    i: number,\n    j: number\n): number {\n    // If it's the top-left cell, terminate the search\n    if (i === 0 &amp;&amp; j === 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // If there's a record, return it directly\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // Minimum path cost for left and upper cells\n    const up = minPathSumDFSMem(grid, mem, i - 1, j);\n    const left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = Math.min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.dart<pre><code>/* Minimum path sum: Memoization search */\nint minPathSumDFSMem(List&lt;List&lt;int&gt;&gt; grid, List&lt;List&lt;int&gt;&gt; mem, int i, int j) {\n  // If it's the top-left cell, terminate the search\n  if (i == 0 &amp;&amp; j == 0) {\n    return grid[0][0];\n  }\n  // If row or column index is out of bounds, return +\u221e cost\n  if (i &lt; 0 || j &lt; 0) {\n    // In Dart, int type is fixed-range integer, no value representing \"infinity\"\n    return BigInt.from(2).pow(31).toInt();\n  }\n  // If there's a record, return it directly\n  if (mem[i][j] != -1) {\n    return mem[i][j];\n  }\n  // Minimum path cost for left and upper cells\n  int up = minPathSumDFSMem(grid, mem, i - 1, j);\n  int left = minPathSumDFSMem(grid, mem, i, j - 1);\n  // Record and return the minimum path cost from top-left to (i, j)\n  mem[i][j] = min(left, up) + grid[i][j];\n  return mem[i][j];\n}\n</code></pre> min_path_sum.rs<pre><code>/* Minimum path sum: Memoization search */\nfn min_path_sum_dfs_mem(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, mem: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, i: i32, j: i32) -&gt; i32 {\n    // If it's the top-left cell, terminate the search\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if i &lt; 0 || j &lt; 0 {\n        return i32::MAX;\n    }\n    // If there's a record, return it directly\n    if mem[i as usize][j as usize] != -1 {\n        return mem[i as usize][j as usize];\n    }\n    // Minimum path cost for left and upper cells\n    let up = min_path_sum_dfs_mem(grid, mem, i - 1, j);\n    let left = min_path_sum_dfs_mem(grid, mem, i, j - 1);\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i as usize][j as usize] = std::cmp::min(left, up) + grid[i as usize][j as usize];\n    mem[i as usize][j as usize]\n}\n</code></pre> min_path_sum.c<pre><code>/* Minimum path sum: Memoization search */\nint minPathSumDFSMem(int grid[MAX_SIZE][MAX_SIZE], int mem[MAX_SIZE][MAX_SIZE], int i, int j) {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // If there's a record, return it directly\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // Minimum path cost for left and upper cells\n    int up = minPathSumDFSMem(grid, mem, i - 1, j);\n    int left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = myMin(left, up) != INT_MAX ? myMin(left, up) + grid[i][j] : INT_MAX;\n    return mem[i][j];\n}\n</code></pre> min_path_sum.kt<pre><code>/* Minimum path sum: Memoization search */\nfun minPathSumDFSMem(\n    grid: Array&lt;IntArray&gt;,\n    mem: Array&lt;IntArray&gt;,\n    i: Int,\n    j: Int\n): Int {\n    // If it's the top-left cell, terminate the search\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0]\n    }\n    // If row or column index is out of bounds, return +\u221e cost\n    if (i &lt; 0 || j &lt; 0) {\n        return Int.MAX_VALUE\n    }\n    // If there's a record, return it directly\n    if (mem[i][j] != -1) {\n        return mem[i][j]\n    }\n    // Minimum path cost for left and upper cells\n    val up = minPathSumDFSMem(grid, mem, i - 1, j)\n    val left = minPathSumDFSMem(grid, mem, i, j - 1)\n    // Record and return the minimum path cost from top-left to (i, j)\n    mem[i][j] = min(left, up) + grid[i][j]\n    return mem[i][j]\n}\n</code></pre> min_path_sum.rb<pre><code>### Minimum path sum: memoization search ###\ndef min_path_sum_dfs_mem(grid, mem, i, j)\n  # If it's the top-left cell, terminate the search\n  return grid[0][0] if i == 0 &amp;&amp; j == 0\n  # If row or column index is out of bounds, return +\u221e cost\n  return Float::INFINITY if i &lt; 0 || j &lt; 0\n  # If there's a record, return it directly\n  return mem[i][j] if mem[i][j] != -1\n  # Minimum path cost for left and upper cells\n  up = min_path_sum_dfs_mem(grid, mem, i - 1, j)\n  left = min_path_sum_dfs_mem(grid, mem, i, j - 1)\n  # Record and return the minimum path cost from top-left to (i, j)\n  mem[i][j] = [left, up].min + grid[i][j]\nend\n</code></pre> <p>As shown in Figure 14-15, after introducing memoization, all subproblem solutions only need to be computed once, so the time complexity depends on the total number of states, which is the grid size \\(O(nm)\\).</p> <p></p> <p> Figure 14-15 \u00a0 Memoization recursion tree </p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#3-method-3-dynamic-programming","title":"3. \u00a0 Method 3: Dynamic Programming","text":"<p>Implement the dynamic programming solution based on iteration, as shown in the code below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby min_path_sum.py<pre><code>def min_path_sum_dp(grid: list[list[int]]) -&gt; int:\n    \"\"\"Minimum path sum: Dynamic programming\"\"\"\n    n, m = len(grid), len(grid[0])\n    # Initialize dp table\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    # State transition: first row\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    # State transition: first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    # State transition: rest of the rows and columns\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]\n    return dp[n - 1][m - 1]\n</code></pre> min_path_sum.cpp<pre><code>/* Minimum path sum: Dynamic programming */\nint minPathSumDP(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size(), m = grid[0].size();\n    // Initialize dp table\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m));\n    dp[0][0] = grid[0][0];\n    // State transition: first row\n    for (int j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // State transition: first column\n    for (int i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.java<pre><code>/* Minimum path sum: Dynamic programming */\nint minPathSumDP(int[][] grid) {\n    int n = grid.length, m = grid[0].length;\n    // Initialize dp table\n    int[][] dp = new int[n][m];\n    dp[0][0] = grid[0][0];\n    // State transition: first row\n    for (int j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // State transition: first column\n    for (int i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.cs<pre><code>/* Minimum path sum: Dynamic programming */\nint MinPathSumDP(int[][] grid) {\n    int n = grid.Length, m = grid[0].Length;\n    // Initialize dp table\n    int[,] dp = new int[n, m];\n    dp[0, 0] = grid[0][0];\n    // State transition: first row\n    for (int j = 1; j &lt; m; j++) {\n        dp[0, j] = dp[0, j - 1] + grid[0][j];\n    }\n    // State transition: first column\n    for (int i = 1; i &lt; n; i++) {\n        dp[i, 0] = dp[i - 1, 0] + grid[i][0];\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i, j] = Math.Min(dp[i, j - 1], dp[i - 1, j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1, m - 1];\n}\n</code></pre> min_path_sum.go<pre><code>/* Minimum path sum: Dynamic programming */\nfunc minPathSumDP(grid [][]int) int {\n    n, m := len(grid), len(grid[0])\n    // Initialize dp table\n    dp := make([][]int, n)\n    for i := 0; i &lt; n; i++ {\n        dp[i] = make([]int, m)\n    }\n    dp[0][0] = grid[0][0]\n    // State transition: first row\n    for j := 1; j &lt; m; j++ {\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    }\n    // State transition: first column\n    for i := 1; i &lt; n; i++ {\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    // State transition: rest of the rows and columns\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            dp[i][j] = int(math.Min(float64(dp[i][j-1]), float64(dp[i-1][j]))) + grid[i][j]\n        }\n    }\n    return dp[n-1][m-1]\n}\n</code></pre> min_path_sum.swift<pre><code>/* Minimum path sum: Dynamic programming */\nfunc minPathSumDP(grid: [[Int]]) -&gt; Int {\n    let n = grid.count\n    let m = grid[0].count\n    // Initialize dp table\n    var dp = Array(repeating: Array(repeating: 0, count: m), count: n)\n    dp[0][0] = grid[0][0]\n    // State transition: first row\n    for j in 1 ..&lt; m {\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    }\n    // State transition: first column\n    for i in 1 ..&lt; n {\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    }\n    // State transition: rest of the rows and columns\n    for i in 1 ..&lt; n {\n        for j in 1 ..&lt; m {\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]\n        }\n    }\n    return dp[n - 1][m - 1]\n}\n</code></pre> min_path_sum.js<pre><code>/* Minimum path sum: Dynamic programming */\nfunction minPathSumDP(grid) {\n    const n = grid.length,\n        m = grid[0].length;\n    // Initialize dp table\n    const dp = Array.from({ length: n }, () =&gt;\n        Array.from({ length: m }, () =&gt; 0)\n    );\n    dp[0][0] = grid[0][0];\n    // State transition: first row\n    for (let j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // State transition: first column\n    for (let i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // State transition: rest of the rows and columns\n    for (let i = 1; i &lt; n; i++) {\n        for (let j = 1; j &lt; m; j++) {\n            dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.ts<pre><code>/* Minimum path sum: Dynamic programming */\nfunction minPathSumDP(grid: Array&lt;Array&lt;number&gt;&gt;): number {\n    const n = grid.length,\n        m = grid[0].length;\n    // Initialize dp table\n    const dp = Array.from({ length: n }, () =&gt;\n        Array.from({ length: m }, () =&gt; 0)\n    );\n    dp[0][0] = grid[0][0];\n    // State transition: first row\n    for (let j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // State transition: first column\n    for (let i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // State transition: rest of the rows and columns\n    for (let i = 1; i &lt; n; i++) {\n        for (let j: number = 1; j &lt; m; j++) {\n            dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.dart<pre><code>/* Minimum path sum: Dynamic programming */\nint minPathSumDP(List&lt;List&lt;int&gt;&gt; grid) {\n  int n = grid.length, m = grid[0].length;\n  // Initialize dp table\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n, (i) =&gt; List.filled(m, 0));\n  dp[0][0] = grid[0][0];\n  // State transition: first row\n  for (int j = 1; j &lt; m; j++) {\n    dp[0][j] = dp[0][j - 1] + grid[0][j];\n  }\n  // State transition: first column\n  for (int i = 1; i &lt; n; i++) {\n    dp[i][0] = dp[i - 1][0] + grid[i][0];\n  }\n  // State transition: rest of the rows and columns\n  for (int i = 1; i &lt; n; i++) {\n    for (int j = 1; j &lt; m; j++) {\n      dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n    }\n  }\n  return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.rs<pre><code>/* Minimum path sum: Dynamic programming */\nfn min_path_sum_dp(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\n    let (n, m) = (grid.len(), grid[0].len());\n    // Initialize dp table\n    let mut dp = vec![vec![0; m]; n];\n    dp[0][0] = grid[0][0];\n    // State transition: first row\n    for j in 1..m {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // State transition: first column\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // State transition: rest of the rows and columns\n    for i in 1..n {\n        for j in 1..m {\n            dp[i][j] = std::cmp::min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    dp[n - 1][m - 1]\n}\n</code></pre> min_path_sum.c<pre><code>/* Minimum path sum: Dynamic programming */\nint minPathSumDP(int grid[MAX_SIZE][MAX_SIZE], int n, int m) {\n    // Initialize dp table\n    int **dp = malloc(n * sizeof(int *));\n    for (int i = 0; i &lt; n; i++) {\n        dp[i] = calloc(m, sizeof(int));\n    }\n    dp[0][0] = grid[0][0];\n    // State transition: first row\n    for (int j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // State transition: first column\n    for (int i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i][j] = myMin(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    int res = dp[n - 1][m - 1];\n    // Free memory\n    for (int i = 0; i &lt; n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> min_path_sum.kt<pre><code>/* Minimum path sum: Dynamic programming */\nfun minPathSumDP(grid: Array&lt;IntArray&gt;): Int {\n    val n = grid.size\n    val m = grid[0].size\n    // Initialize dp table\n    val dp = Array(n) { IntArray(m) }\n    dp[0][0] = grid[0][0]\n    // State transition: first row\n    for (j in 1..&lt;m) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    }\n    // State transition: first column\n    for (i in 1..&lt;n) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    }\n    // State transition: rest of the rows and columns\n    for (i in 1..&lt;n) {\n        for (j in 1..&lt;m) {\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]\n        }\n    }\n    return dp[n - 1][m - 1]\n}\n</code></pre> min_path_sum.rb<pre><code>### Minimum path sum: dynamic programming ###\ndef min_path_sum_dp(grid)\n  n, m = grid.length, grid.first.length\n  # Initialize dp table\n  dp = Array.new(n) { Array.new(m, 0) }\n  dp[0][0] = grid[0][0]\n  # State transition: first row\n  (1...m).each { |j| dp[0][j] = dp[0][j - 1] + grid[0][j] }\n  # State transition: first column\n  (1...n).each { |i| dp[i][0] = dp[i - 1][0] + grid[i][0] }\n  # State transition: rest of the rows and columns\n  for i in 1...n\n    for j in 1...m\n      dp[i][j] = [dp[i][j - 1], dp[i - 1][j]].min + grid[i][j]\n    end\n  end\n  dp[n -1][m -1]\nend\n</code></pre> <p>Figure 14-16 shows the state transition process for minimum path sum, which traverses the entire grid, thus the time complexity is \\(O(nm)\\).</p> <p>The array <code>dp</code> has size \\(n \\times m\\), thus the space complexity is \\(O(nm)\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-16 \u00a0 Dynamic programming process for minimum path sum </p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#4-space-optimization","title":"4. \u00a0 Space Optimization","text":"<p>Since each cell is only related to the cell to its left and the cell above it, we can use a single-row array to implement the \\(dp\\) table.</p> <p>Note that since the array <code>dp</code> can only represent the state of one row, we cannot initialize the first column state in advance, but rather update it when traversing each row:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby min_path_sum.py<pre><code>def min_path_sum_dp_comp(grid: list[list[int]]) -&gt; int:\n    \"\"\"Minimum path sum: Space-optimized dynamic programming\"\"\"\n    n, m = len(grid), len(grid[0])\n    # Initialize dp table\n    dp = [0] * m\n    # State transition: first row\n    dp[0] = grid[0][0]\n    for j in range(1, m):\n        dp[j] = dp[j - 1] + grid[0][j]\n    # State transition: rest of the rows\n    for i in range(1, n):\n        # State transition: first column\n        dp[0] = dp[0] + grid[i][0]\n        # State transition: rest of the columns\n        for j in range(1, m):\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]\n    return dp[m - 1]\n</code></pre> min_path_sum.cpp<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nint minPathSumDPComp(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size(), m = grid[0].size();\n    // Initialize dp table\n    vector&lt;int&gt; dp(m);\n    // State transition: first row\n    dp[0] = grid[0][0];\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt; n; i++) {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0];\n        // State transition: rest of the columns\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.java<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nint minPathSumDPComp(int[][] grid) {\n    int n = grid.length, m = grid[0].length;\n    // Initialize dp table\n    int[] dp = new int[m];\n    // State transition: first row\n    dp[0] = grid[0][0];\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt; n; i++) {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0];\n        // State transition: rest of the columns\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.cs<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nint MinPathSumDPComp(int[][] grid) {\n    int n = grid.Length, m = grid[0].Length;\n    // Initialize dp table\n    int[] dp = new int[m];\n    dp[0] = grid[0][0];\n    // State transition: first row\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt; n; i++) {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0];\n        // State transition: rest of the columns\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = Math.Min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.go<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nfunc minPathSumDPComp(grid [][]int) int {\n    n, m := len(grid), len(grid[0])\n    // Initialize dp table\n    dp := make([]int, m)\n    // State transition: first row\n    dp[0] = grid[0][0]\n    for j := 1; j &lt; m; j++ {\n        dp[j] = dp[j-1] + grid[0][j]\n    }\n    // State transition: rest of the rows and columns\n    for i := 1; i &lt; n; i++ {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0]\n        // State transition: rest of the columns\n        for j := 1; j &lt; m; j++ {\n            dp[j] = int(math.Min(float64(dp[j-1]), float64(dp[j]))) + grid[i][j]\n        }\n    }\n    return dp[m-1]\n}\n</code></pre> min_path_sum.swift<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nfunc minPathSumDPComp(grid: [[Int]]) -&gt; Int {\n    let n = grid.count\n    let m = grid[0].count\n    // Initialize dp table\n    var dp = Array(repeating: 0, count: m)\n    // State transition: first row\n    dp[0] = grid[0][0]\n    for j in 1 ..&lt; m {\n        dp[j] = dp[j - 1] + grid[0][j]\n    }\n    // State transition: rest of the rows\n    for i in 1 ..&lt; n {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0]\n        // State transition: rest of the columns\n        for j in 1 ..&lt; m {\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]\n        }\n    }\n    return dp[m - 1]\n}\n</code></pre> min_path_sum.js<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nfunction minPathSumDPComp(grid) {\n    const n = grid.length,\n        m = grid[0].length;\n    // Initialize dp table\n    const dp = new Array(m);\n    // State transition: first row\n    dp[0] = grid[0][0];\n    for (let j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // State transition: rest of the rows\n    for (let i = 1; i &lt; n; i++) {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0];\n        // State transition: rest of the columns\n        for (let j = 1; j &lt; m; j++) {\n            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.ts<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nfunction minPathSumDPComp(grid: Array&lt;Array&lt;number&gt;&gt;): number {\n    const n = grid.length,\n        m = grid[0].length;\n    // Initialize dp table\n    const dp = new Array(m);\n    // State transition: first row\n    dp[0] = grid[0][0];\n    for (let j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // State transition: rest of the rows\n    for (let i = 1; i &lt; n; i++) {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0];\n        // State transition: rest of the columns\n        for (let j = 1; j &lt; m; j++) {\n            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.dart<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nint minPathSumDPComp(List&lt;List&lt;int&gt;&gt; grid) {\n  int n = grid.length, m = grid[0].length;\n  // Initialize dp table\n  List&lt;int&gt; dp = List.filled(m, 0);\n  dp[0] = grid[0][0];\n  for (int j = 1; j &lt; m; j++) {\n    dp[j] = dp[j - 1] + grid[0][j];\n  }\n  // State transition: rest of the rows\n  for (int i = 1; i &lt; n; i++) {\n    // State transition: first column\n    dp[0] = dp[0] + grid[i][0];\n    // State transition: rest of the columns\n    for (int j = 1; j &lt; m; j++) {\n      dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];\n    }\n  }\n  return dp[m - 1];\n}\n</code></pre> min_path_sum.rs<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nfn min_path_sum_dp_comp(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\n    let (n, m) = (grid.len(), grid[0].len());\n    // Initialize dp table\n    let mut dp = vec![0; m];\n    // State transition: first row\n    dp[0] = grid[0][0];\n    for j in 1..m {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // State transition: rest of the rows\n    for i in 1..n {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0];\n        // State transition: rest of the columns\n        for j in 1..m {\n            dp[j] = std::cmp::min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    dp[m - 1]\n}\n</code></pre> min_path_sum.c<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nint minPathSumDPComp(int grid[MAX_SIZE][MAX_SIZE], int n, int m) {\n    // Initialize dp table\n    int *dp = calloc(m, sizeof(int));\n    // State transition: first row\n    dp[0] = grid[0][0];\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt; n; i++) {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0];\n        // State transition: rest of the columns\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = myMin(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    int res = dp[m - 1];\n    // Free memory\n    free(dp);\n    return res;\n}\n</code></pre> min_path_sum.kt<pre><code>/* Minimum path sum: Space-optimized dynamic programming */\nfun minPathSumDPComp(grid: Array&lt;IntArray&gt;): Int {\n    val n = grid.size\n    val m = grid[0].size\n    // Initialize dp table\n    val dp = IntArray(m)\n    // State transition: first row\n    dp[0] = grid[0][0]\n    for (j in 1..&lt;m) {\n        dp[j] = dp[j - 1] + grid[0][j]\n    }\n    // State transition: rest of the rows\n    for (i in 1..&lt;n) {\n        // State transition: first column\n        dp[0] = dp[0] + grid[i][0]\n        // State transition: rest of the columns\n        for (j in 1..&lt;m) {\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]\n        }\n    }\n    return dp[m - 1]\n}\n</code></pre> min_path_sum.rb<pre><code>### Minimum path sum: space-optimized DP ###\ndef min_path_sum_dp_comp(grid)\n  n, m = grid.length, grid.first.length\n  # Initialize dp table\n  dp = Array.new(m, 0)\n  # State transition: first row\n  dp[0] = grid[0][0]\n  (1...m).each { |j| dp[j] = dp[j - 1] + grid[0][j] }\n  # State transition: rest of the rows\n  for i in 1...n\n    # State transition: first column\n    dp[0] = dp[0] + grid[i][0]\n    # State transition: rest of the columns\n    (1...m).each { |j| dp[j] = [dp[j - 1], dp[j]].min + grid[i][j] }\n  end\n  dp[m - 1]\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/edit_distance_problem/","title":"14.6 \u00a0 Edit Distance Problem","text":"<p>Edit distance, also known as Levenshtein distance, refers to the minimum number of edits required to transform one string into another, commonly used in information retrieval and natural language processing to measure the similarity between two sequences.</p> <p>Question</p> <p>Given two strings \\(s\\) and \\(t\\), return the minimum number of edits required to transform \\(s\\) into \\(t\\).</p> <p>You can perform three types of edit operations on a string: insert a character, delete a character, or replace a character with any other character.</p> <p>As shown in Figure 14-27, transforming <code>kitten</code> into <code>sitting</code> requires 3 edits, including 2 replacements and 1 insertion; transforming <code>hello</code> into <code>algo</code> requires 3 steps, including 2 replacements and 1 deletion.</p> <p></p> <p> Figure 14-27 \u00a0 Example data for edit distance </p> <p>The edit distance problem can be naturally explained using the decision tree model. Strings correspond to tree nodes, and a round of decision (one edit operation) corresponds to an edge of the tree.</p> <p>As shown in Figure 14-28, without restricting operations, each node can branch into many edges, with each edge corresponding to one operation, meaning there are many possible paths to transform <code>hello</code> into <code>algo</code>.</p> <p>From the perspective of the decision tree, the goal of this problem is to find the shortest path between node <code>hello</code> and node <code>algo</code>.</p> <p></p> <p> Figure 14-28 \u00a0 Representing edit distance problem based on decision tree model </p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#1-dynamic-programming-approach","title":"1. \u00a0 Dynamic Programming Approach","text":"<p>Step 1: Think about the decisions in each round, define the state, and thus obtain the \\(dp\\) table</p> <p>Each round of decision involves performing one edit operation on string \\(s\\).</p> <p>We want the problem scale to gradually decrease during the editing process, which allows us to construct subproblems. Let the lengths of strings \\(s\\) and \\(t\\) be \\(n\\) and \\(m\\) respectively. We first consider the tail characters of the two strings, \\(s[n-1]\\) and \\(t[m-1]\\).</p> <ul> <li>If \\(s[n-1]\\) and \\(t[m-1]\\) are the same, we can skip them and directly consider \\(s[n-2]\\) and \\(t[m-2]\\).</li> <li>If \\(s[n-1]\\) and \\(t[m-1]\\) are different, we need to perform one edit on \\(s\\) (insert, delete, or replace) to make the tail characters of the two strings the same, allowing us to skip them and consider a smaller-scale problem.</li> </ul> <p>In other words, each round of decision (edit operation) we make on string \\(s\\) will change the remaining characters to be matched in \\(s\\) and \\(t\\). Therefore, the state is the \\(i\\)-th and \\(j\\)-th characters currently being considered in \\(s\\) and \\(t\\), denoted as \\([i, j]\\).</p> <p>State \\([i, j]\\) corresponds to the subproblem: the minimum number of edits required to change the first \\(i\\) characters of \\(s\\) into the first \\(j\\) characters of \\(t\\).</p> <p>From this, we obtain a two-dimensional \\(dp\\) table of size \\((i+1) \\times (j+1)\\).</p> <p>Step 2: Identify the optimal substructure, and then derive the state transition equation</p> <p>Consider subproblem \\(dp[i, j]\\), where the tail characters of the corresponding two strings are \\(s[i-1]\\) and \\(t[j-1]\\), which can be divided into the three cases shown in Figure 14-29 based on different edit operations.</p> <ol> <li>Insert \\(t[j-1]\\) after \\(s[i-1]\\), then the remaining subproblem is \\(dp[i, j-1]\\).</li> <li>Delete \\(s[i-1]\\), then the remaining subproblem is \\(dp[i-1, j]\\).</li> <li>Replace \\(s[i-1]\\) with \\(t[j-1]\\), then the remaining subproblem is \\(dp[i-1, j-1]\\).</li> </ol> <p></p> <p> Figure 14-29 \u00a0 State transition for edit distance </p> <p>Based on the above analysis, the optimal substructure can be obtained: the minimum number of edits for \\(dp[i, j]\\) equals the minimum among the minimum edit steps of \\(dp[i, j-1]\\), \\(dp[i-1, j]\\), and \\(dp[i-1, j-1]\\), plus the edit step \\(1\\) for this time. The corresponding state transition equation is:</p> \\[ dp[i, j] = \\min(dp[i, j-1], dp[i-1, j], dp[i-1, j-1]) + 1 \\] <p>Please note that when \\(s[i-1]\\) and \\(t[j-1]\\) are the same, no edit is required for the current character, in which case the state transition equation is:</p> \\[ dp[i, j] = dp[i-1, j-1] \\] <p>Step 3: Determine boundary conditions and state transition order</p> <p>When both strings are empty, the number of edit steps is \\(0\\), i.e., \\(dp[0, 0] = 0\\). When \\(s\\) is empty but \\(t\\) is not, the minimum number of edit steps equals the length of \\(t\\), i.e., the first row \\(dp[0, j] = j\\). When \\(s\\) is not empty but \\(t\\) is empty, the minimum number of edit steps equals the length of \\(s\\), i.e., the first column \\(dp[i, 0] = i\\).</p> <p>Observing the state transition equation, the solution \\(dp[i, j]\\) depends on solutions to the left, above, and upper-left, so the entire \\(dp\\) table can be traversed in order through two nested loops.</p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#2-code-implementation","title":"2. \u00a0 Code Implementation","text":"PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby edit_distance.py<pre><code>def edit_distance_dp(s: str, t: str) -&gt; int:\n    \"\"\"Edit distance: Dynamic programming\"\"\"\n    n, m = len(s), len(t)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    # State transition: first row and first column\n    for i in range(1, n + 1):\n        dp[i][0] = i\n    for j in range(1, m + 1):\n        dp[0][j] = j\n    # State transition: rest of the rows and columns\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == t[j - 1]:\n                # If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                # Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1\n    return dp[n][m]\n</code></pre> edit_distance.cpp<pre><code>/* Edit distance: Dynamic programming */\nint editDistanceDP(string s, string t) {\n    int n = s.length(), m = t.length();\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));\n    // State transition: first row and first column\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.java<pre><code>/* Edit distance: Dynamic programming */\nint editDistanceDP(String s, String t) {\n    int n = s.length(), m = t.length();\n    int[][] dp = new int[n + 1][m + 1];\n    // State transition: first row and first column\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.cs<pre><code>/* Edit distance: Dynamic programming */\nint EditDistanceDP(string s, string t) {\n    int n = s.Length, m = t.Length;\n    int[,] dp = new int[n + 1, m + 1];\n    // State transition: first row and first column\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i, 0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0, j] = j;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[i, j] = dp[i - 1, j - 1];\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i, j] = Math.Min(Math.Min(dp[i, j - 1], dp[i - 1, j]), dp[i - 1, j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n, m];\n}\n</code></pre> edit_distance.go<pre><code>/* Edit distance: Dynamic programming */\nfunc editDistanceDP(s string, t string) int {\n    n := len(s)\n    m := len(t)\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, m+1)\n    }\n    // State transition: first row and first column\n    for i := 1; i &lt;= n; i++ {\n        dp[i][0] = i\n    }\n    for j := 1; j &lt;= m; j++ {\n        dp[0][j] = j\n    }\n    // State transition: rest of the rows and columns\n    for i := 1; i &lt;= n; i++ {\n        for j := 1; j &lt;= m; j++ {\n            if s[i-1] == t[j-1] {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] = MinInt(MinInt(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1\n            }\n        }\n    }\n    return dp[n][m]\n}\n</code></pre> edit_distance.swift<pre><code>/* Edit distance: Dynamic programming */\nfunc editDistanceDP(s: String, t: String) -&gt; Int {\n    let n = s.utf8CString.count\n    let m = t.utf8CString.count\n    var dp = Array(repeating: Array(repeating: 0, count: m + 1), count: n + 1)\n    // State transition: first row and first column\n    for i in 1 ... n {\n        dp[i][0] = i\n    }\n    for j in 1 ... m {\n        dp[0][j] = j\n    }\n    // State transition: rest of the rows and columns\n    for i in 1 ... n {\n        for j in 1 ... m {\n            if s.utf8CString[i - 1] == t.utf8CString[j - 1] {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1]\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1\n            }\n        }\n    }\n    return dp[n][m]\n}\n</code></pre> edit_distance.js<pre><code>/* Edit distance: Dynamic programming */\nfunction editDistanceDP(s, t) {\n    const n = s.length,\n        m = t.length;\n    const dp = Array.from({ length: n + 1 }, () =&gt; new Array(m + 1).fill(0));\n    // State transition: first row and first column\n    for (let i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // State transition: rest of the rows and columns\n    for (let i = 1; i &lt;= n; i++) {\n        for (let j = 1; j &lt;= m; j++) {\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] =\n                    Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.ts<pre><code>/* Edit distance: Dynamic programming */\nfunction editDistanceDP(s: string, t: string): number {\n    const n = s.length,\n        m = t.length;\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: m + 1 }, () =&gt; 0)\n    );\n    // State transition: first row and first column\n    for (let i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // State transition: rest of the rows and columns\n    for (let i = 1; i &lt;= n; i++) {\n        for (let j = 1; j &lt;= m; j++) {\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] =\n                    Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.dart<pre><code>/* Edit distance: Dynamic programming */\nint editDistanceDP(String s, String t) {\n  int n = s.length, m = t.length;\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (_) =&gt; List.filled(m + 1, 0));\n  // State transition: first row and first column\n  for (int i = 1; i &lt;= n; i++) {\n    dp[i][0] = i;\n  }\n  for (int j = 1; j &lt;= m; j++) {\n    dp[0][j] = j;\n  }\n  // State transition: rest of the rows and columns\n  for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n      if (s[i - 1] == t[j - 1]) {\n        // If two characters are equal, skip both characters\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n        dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n      }\n    }\n  }\n  return dp[n][m];\n}\n</code></pre> edit_distance.rs<pre><code>/* Edit distance: Dynamic programming */\nfn edit_distance_dp(s: &amp;str, t: &amp;str) -&gt; i32 {\n    let (n, m) = (s.len(), t.len());\n    let mut dp = vec![vec![0; m + 1]; n + 1];\n    // State transition: first row and first column\n    for i in 1..=n {\n        dp[i][0] = i as i32;\n    }\n    for j in 1..m {\n        dp[0][j] = j as i32;\n    }\n    // State transition: rest of the rows and columns\n    for i in 1..=n {\n        for j in 1..=m {\n            if s.chars().nth(i - 1) == t.chars().nth(j - 1) {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] =\n                    std::cmp::min(std::cmp::min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    dp[n][m]\n}\n</code></pre> edit_distance.c<pre><code>/* Edit distance: Dynamic programming */\nint editDistanceDP(char *s, char *t, int n, int m) {\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(m + 1, sizeof(int));\n    }\n    // State transition: first row and first column\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] = myMin(myMin(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    int res = dp[n][m];\n    // Free memory\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> edit_distance.kt<pre><code>/* Edit distance: Dynamic programming */\nfun editDistanceDP(s: String, t: String): Int {\n    val n = s.length\n    val m = t.length\n    val dp = Array(n + 1) { IntArray(m + 1) }\n    // State transition: first row and first column\n    for (i in 1..n) {\n        dp[i][0] = i\n    }\n    for (j in 1..m) {\n        dp[0][j] = j\n    }\n    // State transition: rest of the rows and columns\n    for (i in 1..n) {\n        for (j in 1..m) {\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[i][j] = dp[i - 1][j - 1]\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1\n            }\n        }\n    }\n    return dp[n][m]\n}\n</code></pre> edit_distance.rb<pre><code>### Edit distance: dynamic programming ###\ndef edit_distance_dp(s, t)\n  n, m = s.length, t.length\n  dp = Array.new(n + 1) { Array.new(m + 1, 0) }\n  # State transition: first row and first column\n  (1...(n + 1)).each { |i| dp[i][0] = i }\n  (1...(m + 1)).each { |j| dp[0][j] = j }\n  # State transition: rest of the rows and columns\n  for i in 1...(n + 1)\n    for j in 1...(m +1)\n      if s[i - 1] == t[j - 1]\n        # If two characters are equal, skip both characters\n        dp[i][j] = dp[i - 1][j - 1]\n      else\n        # Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n        dp[i][j] = [dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]].min + 1\n      end\n    end\n  end\n  dp[n][m]\nend\n</code></pre> <p>As shown in Figure 14-30, the state transition process for the edit distance problem is very similar to the knapsack problem and can both be viewed as the process of filling a two-dimensional grid.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt;&lt;15&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-30 \u00a0 Dynamic programming process for edit distance </p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#3-space-optimization","title":"3. \u00a0 Space Optimization","text":"<p>Since \\(dp[i, j]\\) is transferred from the solutions above \\(dp[i-1, j]\\), to the left \\(dp[i, j-1]\\), and to the upper-left \\(dp[i-1, j-1]\\), forward traversal will lose the upper-left solution \\(dp[i-1, j-1]\\), and reverse traversal cannot build \\(dp[i, j-1]\\) in advance, so neither traversal order is feasible.</p> <p>For this reason, we can use a variable <code>leftup</code> to temporarily store the upper-left solution \\(dp[i-1, j-1]\\), so we only need to consider the solutions to the left and above. This situation is the same as the unbounded knapsack problem, allowing for forward traversal. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby edit_distance.py<pre><code>def edit_distance_dp_comp(s: str, t: str) -&gt; int:\n    \"\"\"Edit distance: Space-optimized dynamic programming\"\"\"\n    n, m = len(s), len(t)\n    dp = [0] * (m + 1)\n    # State transition: first row\n    for j in range(1, m + 1):\n        dp[j] = j\n    # State transition: rest of the rows\n    for i in range(1, n + 1):\n        # State transition: first column\n        leftup = dp[0]  # Temporarily store dp[i-1, j-1]\n        dp[0] += 1\n        # State transition: rest of the columns\n        for j in range(1, m + 1):\n            temp = dp[j]\n            if s[i - 1] == t[j - 1]:\n                # If two characters are equal, skip both characters\n                dp[j] = leftup\n            else:\n                # Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = min(dp[j - 1], dp[j], leftup) + 1\n            leftup = temp  # Update for next round's dp[i-1, j-1]\n    return dp[m]\n</code></pre> edit_distance.cpp<pre><code>/* Edit distance: Space-optimized dynamic programming */\nint editDistanceDPComp(string s, string t) {\n    int n = s.length(), m = t.length();\n    vector&lt;int&gt; dp(m + 1, 0);\n    // State transition: first row\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt;= n; i++) {\n        // State transition: first column\n        int leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n        dp[0] = i;\n        // State transition: rest of the columns\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup;\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.java<pre><code>/* Edit distance: Space-optimized dynamic programming */\nint editDistanceDPComp(String s, String t) {\n    int n = s.length(), m = t.length();\n    int[] dp = new int[m + 1];\n    // State transition: first row\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt;= n; i++) {\n        // State transition: first column\n        int leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n        dp[0] = i;\n        // State transition: rest of the columns\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup;\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = Math.min(Math.min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.cs<pre><code>/* Edit distance: Space-optimized dynamic programming */\nint EditDistanceDPComp(string s, string t) {\n    int n = s.Length, m = t.Length;\n    int[] dp = new int[m + 1];\n    // State transition: first row\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt;= n; i++) {\n        // State transition: first column\n        int leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n        dp[0] = i;\n        // State transition: rest of the columns\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup;\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = Math.Min(Math.Min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.go<pre><code>/* Edit distance: Space-optimized dynamic programming */\nfunc editDistanceDPComp(s string, t string) int {\n    n := len(s)\n    m := len(t)\n    dp := make([]int, m+1)\n    // State transition: first row\n    for j := 1; j &lt;= m; j++ {\n        dp[j] = j\n    }\n    // State transition: rest of the rows\n    for i := 1; i &lt;= n; i++ {\n        // State transition: first column\n        leftUp := dp[0] // Temporarily store dp[i-1, j-1]\n        dp[0] = i\n        // State transition: rest of the columns\n        for j := 1; j &lt;= m; j++ {\n            temp := dp[j]\n            if s[i-1] == t[j-1] {\n                // If two characters are equal, skip both characters\n                dp[j] = leftUp\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = MinInt(MinInt(dp[j-1], dp[j]), leftUp) + 1\n            }\n            leftUp = temp // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m]\n}\n</code></pre> edit_distance.swift<pre><code>/* Edit distance: Space-optimized dynamic programming */\nfunc editDistanceDPComp(s: String, t: String) -&gt; Int {\n    let n = s.utf8CString.count\n    let m = t.utf8CString.count\n    var dp = Array(repeating: 0, count: m + 1)\n    // State transition: first row\n    for j in 1 ... m {\n        dp[j] = j\n    }\n    // State transition: rest of the rows\n    for i in 1 ... n {\n        // State transition: first column\n        var leftup = dp[0] // Temporarily store dp[i-1, j-1]\n        dp[0] = i\n        // State transition: rest of the columns\n        for j in 1 ... m {\n            let temp = dp[j]\n            if s.utf8CString[i - 1] == t.utf8CString[j - 1] {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1\n            }\n            leftup = temp // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m]\n}\n</code></pre> edit_distance.js<pre><code>/* Edit distance: Space-optimized dynamic programming */\nfunction editDistanceDPComp(s, t) {\n    const n = s.length,\n        m = t.length;\n    const dp = new Array(m + 1).fill(0);\n    // State transition: first row\n    for (let j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // State transition: rest of the rows\n    for (let i = 1; i &lt;= n; i++) {\n        // State transition: first column\n        let leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n        dp[0] = i;\n        // State transition: rest of the columns\n        for (let j = 1; j &lt;= m; j++) {\n            const temp = dp[j];\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup;\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = Math.min(dp[j - 1], dp[j], leftup) + 1;\n            }\n            leftup = temp; // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.ts<pre><code>/* Edit distance: Space-optimized dynamic programming */\nfunction editDistanceDPComp(s: string, t: string): number {\n    const n = s.length,\n        m = t.length;\n    const dp = new Array(m + 1).fill(0);\n    // State transition: first row\n    for (let j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // State transition: rest of the rows\n    for (let i = 1; i &lt;= n; i++) {\n        // State transition: first column\n        let leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n        dp[0] = i;\n        // State transition: rest of the columns\n        for (let j = 1; j &lt;= m; j++) {\n            const temp = dp[j];\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup;\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = Math.min(dp[j - 1], dp[j], leftup) + 1;\n            }\n            leftup = temp; // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.dart<pre><code>/* Edit distance: Space-optimized dynamic programming */\nint editDistanceDPComp(String s, String t) {\n  int n = s.length, m = t.length;\n  List&lt;int&gt; dp = List.filled(m + 1, 0);\n  // State transition: first row\n  for (int j = 1; j &lt;= m; j++) {\n    dp[j] = j;\n  }\n  // State transition: rest of the rows\n  for (int i = 1; i &lt;= n; i++) {\n    // State transition: first column\n    int leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n    dp[0] = i;\n    // State transition: rest of the columns\n    for (int j = 1; j &lt;= m; j++) {\n      int temp = dp[j];\n      if (s[i - 1] == t[j - 1]) {\n        // If two characters are equal, skip both characters\n        dp[j] = leftup;\n      } else {\n        // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n        dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1;\n      }\n      leftup = temp; // Update for next round's dp[i-1, j-1]\n    }\n  }\n  return dp[m];\n}\n</code></pre> edit_distance.rs<pre><code>/* Edit distance: Space-optimized dynamic programming */\nfn edit_distance_dp_comp(s: &amp;str, t: &amp;str) -&gt; i32 {\n    let (n, m) = (s.len(), t.len());\n    let mut dp = vec![0; m + 1];\n    // State transition: first row\n    for j in 1..m {\n        dp[j] = j as i32;\n    }\n    // State transition: rest of the rows\n    for i in 1..=n {\n        // State transition: first column\n        let mut leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n        dp[0] = i as i32;\n        // State transition: rest of the columns\n        for j in 1..=m {\n            let temp = dp[j];\n            if s.chars().nth(i - 1) == t.chars().nth(j - 1) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup;\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = std::cmp::min(std::cmp::min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // Update for next round's dp[i-1, j-1]\n        }\n    }\n    dp[m]\n}\n</code></pre> edit_distance.c<pre><code>/* Edit distance: Space-optimized dynamic programming */\nint editDistanceDPComp(char *s, char *t, int n, int m) {\n    int *dp = calloc(m + 1, sizeof(int));\n    // State transition: first row\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // State transition: rest of the rows\n    for (int i = 1; i &lt;= n; i++) {\n        // State transition: first column\n        int leftup = dp[0]; // Temporarily store dp[i-1, j-1]\n        dp[0] = i;\n        // State transition: rest of the columns\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup;\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = myMin(myMin(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // Update for next round's dp[i-1, j-1]\n        }\n    }\n    int res = dp[m];\n    // Free memory\n    free(dp);\n    return res;\n}\n</code></pre> edit_distance.kt<pre><code>/* Edit distance: Space-optimized dynamic programming */\nfun editDistanceDPComp(s: String, t: String): Int {\n    val n = s.length\n    val m = t.length\n    val dp = IntArray(m + 1)\n    // State transition: first row\n    for (j in 1..m) {\n        dp[j] = j\n    }\n    // State transition: rest of the rows\n    for (i in 1..n) {\n        // State transition: first column\n        var leftup = dp[0] // Temporarily store dp[i-1, j-1]\n        dp[0] = i\n        // State transition: rest of the columns\n        for (j in 1..m) {\n            val temp = dp[j]\n            if (s[i - 1] == t[j - 1]) {\n                // If two characters are equal, skip both characters\n                dp[j] = leftup\n            } else {\n                // Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n                dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1\n            }\n            leftup = temp // Update for next round's dp[i-1, j-1]\n        }\n    }\n    return dp[m]\n}\n</code></pre> edit_distance.rb<pre><code>### Edit distance: space-optimized DP ###\ndef edit_distance_dp_comp(s, t)\n  n, m = s.length, t.length\n  dp = Array.new(m + 1, 0)\n  # State transition: first row\n  (1...(m + 1)).each { |j| dp[j] = j }\n  # State transition: rest of the rows\n  for i in 1...(n + 1)\n    # State transition: first column\n    leftup = dp.first # Temporarily store dp[i-1, j-1]\n    dp[0] += 1\n    # State transition: rest of the columns\n    for j in 1...(m + 1)\n      temp = dp[j]\n      if s[i - 1] == t[j - 1]\n        # If two characters are equal, skip both characters\n        dp[j] = leftup\n      else\n        # Minimum edit steps = minimum edit steps of insert, delete, replace + 1\n        dp[j] = [dp[j - 1], dp[j], leftup].min + 1\n      end\n      leftup = temp # Update for next round's dp[i-1, j-1]\n    end\n  end\n  dp[m]\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/","title":"14.1 \u00a0 Introduction to Dynamic Programming","text":"<p>Dynamic programming is an important algorithmic paradigm that decomposes a problem into a series of smaller subproblems and avoids redundant computation by storing the solutions to subproblems, thereby significantly improving time efficiency.</p> <p>In this section, we start with a classic example, first presenting its brute force backtracking solution, observing the overlapping subproblems within it, and then gradually deriving a more efficient dynamic programming solution.</p> <p>Climbing stairs</p> <p>Given a staircase with \\(n\\) steps, where you can climb \\(1\\) or \\(2\\) steps at a time, how many different ways are there to reach the top?</p> <p>As shown in Figure 14-1, for a \\(3\\)-step staircase, there are \\(3\\) different ways to reach the top.</p> <p></p> <p> Figure 14-1 \u00a0 Number of ways to reach the 3rd step </p> <p>The goal of this problem is to find the number of ways, we can consider using backtracking to enumerate all possibilities. Specifically, imagine climbing stairs as a multi-round selection process: starting from the ground, choosing to go up \\(1\\) or \\(2\\) steps in each round, incrementing the count by \\(1\\) whenever the top of the stairs is reached, and pruning when exceeding the top. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby climbing_stairs_backtrack.py<pre><code>def backtrack(choices: list[int], state: int, n: int, res: list[int]) -&gt; int:\n    \"\"\"Backtracking\"\"\"\n    # When climbing to the n-th stair, add 1 to the solution count\n    if state == n:\n        res[0] += 1\n    # Traverse all choices\n    for choice in choices:\n        # Pruning: not allowed to go beyond the n-th stair\n        if state + choice &gt; n:\n            continue\n        # Attempt: make a choice, update state\n        backtrack(choices, state + choice, n, res)\n        # Backtrack\n\ndef climbing_stairs_backtrack(n: int) -&gt; int:\n    \"\"\"Climbing stairs: Backtracking\"\"\"\n    choices = [1, 2]  # Can choose to climb up 1 or 2 stairs\n    state = 0  # Start climbing from the 0-th stair\n    res = [0]  # Use res[0] to record the solution count\n    backtrack(choices, state, n, res)\n    return res[0]\n</code></pre> climbing_stairs_backtrack.cpp<pre><code>/* Backtracking */\nvoid backtrack(vector&lt;int&gt; &amp;choices, int state, int n, vector&lt;int&gt; &amp;res) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if (state == n)\n        res[0]++;\n    // Traverse all choices\n    for (auto &amp;choice : choices) {\n        // Pruning: not allowed to go beyond the n-th stair\n        if (state + choice &gt; n)\n            continue;\n        // Attempt: make choice, update state\n        backtrack(choices, state + choice, n, res);\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nint climbingStairsBacktrack(int n) {\n    vector&lt;int&gt; choices = {1, 2}; // Can choose to climb up 1 or 2 stairs\n    int state = 0;                // Start climbing from the 0-th stair\n    vector&lt;int&gt; res = {0};        // Use res[0] to record the solution count\n    backtrack(choices, state, n, res);\n    return res[0];\n}\n</code></pre> climbing_stairs_backtrack.java<pre><code>/* Backtracking */\nvoid backtrack(List&lt;Integer&gt; choices, int state, int n, List&lt;Integer&gt; res) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if (state == n)\n        res.set(0, res.get(0) + 1);\n    // Traverse all choices\n    for (Integer choice : choices) {\n        // Pruning: not allowed to go beyond the n-th stair\n        if (state + choice &gt; n)\n            continue;\n        // Attempt: make choice, update state\n        backtrack(choices, state + choice, n, res);\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nint climbingStairsBacktrack(int n) {\n    List&lt;Integer&gt; choices = Arrays.asList(1, 2); // Can choose to climb up 1 or 2 stairs\n    int state = 0; // Start climbing from the 0-th stair\n    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n    res.add(0); // Use res[0] to record the solution count\n    backtrack(choices, state, n, res);\n    return res.get(0);\n}\n</code></pre> climbing_stairs_backtrack.cs<pre><code>/* Backtracking */\nvoid Backtrack(List&lt;int&gt; choices, int state, int n, List&lt;int&gt; res) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if (state == n)\n        res[0]++;\n    // Traverse all choices\n    foreach (int choice in choices) {\n        // Pruning: not allowed to go beyond the n-th stair\n        if (state + choice &gt; n)\n            continue;\n        // Attempt: make choice, update state\n        Backtrack(choices, state + choice, n, res);\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nint ClimbingStairsBacktrack(int n) {\n    List&lt;int&gt; choices = [1, 2]; // Can choose to climb up 1 or 2 stairs\n    int state = 0; // Start climbing from the 0-th stair\n    List&lt;int&gt; res = [0]; // Use res[0] to record the solution count\n    Backtrack(choices, state, n, res);\n    return res[0];\n}\n</code></pre> climbing_stairs_backtrack.go<pre><code>/* Backtracking */\nfunc backtrack(choices []int, state, n int, res []int) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if state == n {\n        res[0] = res[0] + 1\n    }\n    // Traverse all choices\n    for _, choice := range choices {\n        // Pruning: not allowed to go beyond the n-th stair\n        if state+choice &gt; n {\n            continue\n        }\n        // Attempt: make choice, update state\n        backtrack(choices, state+choice, n, res)\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nfunc climbingStairsBacktrack(n int) int {\n    // Can choose to climb up 1 or 2 stairs\n    choices := []int{1, 2}\n    // Start climbing from the 0-th stair\n    state := 0\n    res := make([]int, 1)\n    // Use res[0] to record the solution count\n    res[0] = 0\n    backtrack(choices, state, n, res)\n    return res[0]\n}\n</code></pre> climbing_stairs_backtrack.swift<pre><code>/* Backtracking */\nfunc backtrack(choices: [Int], state: Int, n: Int, res: inout [Int]) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if state == n {\n        res[0] += 1\n    }\n    // Traverse all choices\n    for choice in choices {\n        // Pruning: not allowed to go beyond the n-th stair\n        if state + choice &gt; n {\n            continue\n        }\n        // Attempt: make choice, update state\n        backtrack(choices: choices, state: state + choice, n: n, res: &amp;res)\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nfunc climbingStairsBacktrack(n: Int) -&gt; Int {\n    let choices = [1, 2] // Can choose to climb up 1 or 2 stairs\n    let state = 0 // Start climbing from the 0-th stair\n    var res: [Int] = []\n    res.append(0) // Use res[0] to record the solution count\n    backtrack(choices: choices, state: state, n: n, res: &amp;res)\n    return res[0]\n}\n</code></pre> climbing_stairs_backtrack.js<pre><code>/* Backtracking */\nfunction backtrack(choices, state, n, res) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if (state === n) res.set(0, res.get(0) + 1);\n    // Traverse all choices\n    for (const choice of choices) {\n        // Pruning: not allowed to go beyond the n-th stair\n        if (state + choice &gt; n) continue;\n        // Attempt: make choice, update state\n        backtrack(choices, state + choice, n, res);\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nfunction climbingStairsBacktrack(n) {\n    const choices = [1, 2]; // Can choose to climb up 1 or 2 stairs\n    const state = 0; // Start climbing from the 0-th stair\n    const res = new Map();\n    res.set(0, 0); // Use res[0] to record the solution count\n    backtrack(choices, state, n, res);\n    return res.get(0);\n}\n</code></pre> climbing_stairs_backtrack.ts<pre><code>/* Backtracking */\nfunction backtrack(\n    choices: number[],\n    state: number,\n    n: number,\n    res: Map&lt;0, any&gt;\n): void {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if (state === n) res.set(0, res.get(0) + 1);\n    // Traverse all choices\n    for (const choice of choices) {\n        // Pruning: not allowed to go beyond the n-th stair\n        if (state + choice &gt; n) continue;\n        // Attempt: make choice, update state\n        backtrack(choices, state + choice, n, res);\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nfunction climbingStairsBacktrack(n: number): number {\n    const choices = [1, 2]; // Can choose to climb up 1 or 2 stairs\n    const state = 0; // Start climbing from the 0-th stair\n    const res = new Map();\n    res.set(0, 0); // Use res[0] to record the solution count\n    backtrack(choices, state, n, res);\n    return res.get(0);\n}\n</code></pre> climbing_stairs_backtrack.dart<pre><code>/* Backtracking */\nvoid backtrack(List&lt;int&gt; choices, int state, int n, List&lt;int&gt; res) {\n  // When climbing to the n-th stair, add 1 to the solution count\n  if (state == n) {\n    res[0]++;\n  }\n  // Traverse all choices\n  for (int choice in choices) {\n    // Pruning: not allowed to go beyond the n-th stair\n    if (state + choice &gt; n) continue;\n    // Attempt: make choice, update state\n    backtrack(choices, state + choice, n, res);\n    // Backtrack\n  }\n}\n\n/* Climbing stairs: Backtracking */\nint climbingStairsBacktrack(int n) {\n  List&lt;int&gt; choices = [1, 2]; // Can choose to climb up 1 or 2 stairs\n  int state = 0; // Start climbing from the 0-th stair\n  List&lt;int&gt; res = [];\n  res.add(0); // Use res[0] to record the solution count\n  backtrack(choices, state, n, res);\n  return res[0];\n}\n</code></pre> climbing_stairs_backtrack.rs<pre><code>/* Backtracking */\nfn backtrack(choices: &amp;[i32], state: i32, n: i32, res: &amp;mut [i32]) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if state == n {\n        res[0] = res[0] + 1;\n    }\n    // Traverse all choices\n    for &amp;choice in choices {\n        // Pruning: not allowed to go beyond the n-th stair\n        if state + choice &gt; n {\n            continue;\n        }\n        // Attempt: make choice, update state\n        backtrack(choices, state + choice, n, res);\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nfn climbing_stairs_backtrack(n: usize) -&gt; i32 {\n    let choices = vec![1, 2]; // Can choose to climb up 1 or 2 stairs\n    let state = 0; // Start climbing from the 0-th stair\n    let mut res = Vec::new();\n    res.push(0); // Use res[0] to record the solution count\n    backtrack(&amp;choices, state, n as i32, &amp;mut res);\n    res[0]\n}\n</code></pre> climbing_stairs_backtrack.c<pre><code>/* Backtracking */\nvoid backtrack(int *choices, int state, int n, int *res, int len) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if (state == n)\n        res[0]++;\n    // Traverse all choices\n    for (int i = 0; i &lt; len; i++) {\n        int choice = choices[i];\n        // Pruning: not allowed to go beyond the n-th stair\n        if (state + choice &gt; n)\n            continue;\n        // Attempt: make choice, update state\n        backtrack(choices, state + choice, n, res, len);\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nint climbingStairsBacktrack(int n) {\n    int choices[2] = {1, 2}; // Can choose to climb up 1 or 2 stairs\n    int state = 0;           // Start climbing from the 0-th stair\n    int *res = (int *)malloc(sizeof(int));\n    *res = 0; // Use res[0] to record the solution count\n    int len = sizeof(choices) / sizeof(int);\n    backtrack(choices, state, n, res, len);\n    int result = *res;\n    free(res);\n    return result;\n}\n</code></pre> climbing_stairs_backtrack.kt<pre><code>/* Backtracking */\nfun backtrack(\n    choices: MutableList&lt;Int&gt;,\n    state: Int,\n    n: Int,\n    res: MutableList&lt;Int&gt;\n) {\n    // When climbing to the n-th stair, add 1 to the solution count\n    if (state == n)\n        res[0] = res[0] + 1\n    // Traverse all choices\n    for (choice in choices) {\n        // Pruning: not allowed to go beyond the n-th stair\n        if (state + choice &gt; n) continue\n        // Attempt: make choice, update state\n        backtrack(choices, state + choice, n, res)\n        // Backtrack\n    }\n}\n\n/* Climbing stairs: Backtracking */\nfun climbingStairsBacktrack(n: Int): Int {\n    val choices = mutableListOf(1, 2) // Can choose to climb up 1 or 2 stairs\n    val state = 0 // Start climbing from the 0-th stair\n    val res = mutableListOf&lt;Int&gt;()\n    res.add(0) // Use res[0] to record the solution count\n    backtrack(choices, state, n, res)\n    return res[0]\n}\n</code></pre> climbing_stairs_backtrack.rb<pre><code>### Backtracking ###\ndef backtrack(choices, state, n, res)\n  # When climbing to the n-th stair, add 1 to the solution count\n  res[0] += 1 if state == n\n  # Traverse all choices\n  for choice in choices\n    # Pruning: not allowed to go beyond the n-th stair\n    next if state + choice &gt; n\n\n    # Attempt: make choice, update state\n    backtrack(choices, state + choice, n, res)\n  end\n  # Backtrack\nend\n\n### Climbing stairs: backtracking ###\ndef climbing_stairs_backtrack(n)\n  choices = [1, 2] # Can choose to climb up 1 or 2 stairs\n  state = 0 # Start climbing from the 0-th stair\n  res = [0] # Use res[0] to record the solution count\n  backtrack(choices, state, n, res)\n  res.first\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1411-method-1-brute-force-search","title":"14.1.1 \u00a0 Method 1: Brute Force Search","text":"<p>Backtracking algorithms typically do not explicitly decompose problems, but rather treat solving the problem as a series of decision steps, searching for all possible solutions through trial and pruning.</p> <p>We can try to analyze this problem from the perspective of problem decomposition. Let the number of ways to climb to the \\(i\\)-th step be \\(dp[i]\\), then \\(dp[i]\\) is the original problem, and its subproblems include:</p> \\[ dp[i-1], dp[i-2], \\dots, dp[2], dp[1] \\] <p>Since we can only go up \\(1\\) or \\(2\\) steps in each round, when we stand on the \\(i\\)-th step, we could only have been on the \\(i-1\\)-th or \\(i-2\\)-th step in the previous round. In other words, we can only reach the \\(i\\)-th step from the \\(i-1\\)-th or \\(i-2\\)-th step.</p> <p>This leads to an important conclusion: the number of ways to climb to the \\(i-1\\)-th step plus the number of ways to climb to the \\(i-2\\)-th step equals the number of ways to climb to the \\(i\\)-th step. The formula is as follows:</p> \\[ dp[i] = dp[i-1] + dp[i-2] \\] <p>This means that in the stair climbing problem, there exists a recurrence relation among the subproblems, the solution to the original problem can be constructed from the solutions to the subproblems. Figure 14-2 illustrates this recurrence relation.</p> <p></p> <p> Figure 14-2 \u00a0 Recurrence relation for the number of ways </p> <p>We can obtain a brute force search solution based on the recurrence formula. Starting from \\(dp[n]\\), recursively decompose a larger problem into the sum of two smaller problems, until reaching the smallest subproblems \\(dp[1]\\) and \\(dp[2]\\) and returning. Among them, the solutions to the smallest subproblems are known, namely \\(dp[1] = 1\\) and \\(dp[2] = 2\\), representing \\(1\\) and \\(2\\) ways to climb to the \\(1\\)st and \\(2\\)nd steps, respectively.</p> <p>Observe the following code, which, like standard backtracking code, belongs to depth-first search but is more concise:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby climbing_stairs_dfs.py<pre><code>def dfs(i: int) -&gt; int:\n    \"\"\"Search\"\"\"\n    # Known dp[1] and dp[2], return them\n    if i == 1 or i == 2:\n        return i\n    # dp[i] = dp[i-1] + dp[i-2]\n    count = dfs(i - 1) + dfs(i - 2)\n    return count\n\ndef climbing_stairs_dfs(n: int) -&gt; int:\n    \"\"\"Climbing stairs: Search\"\"\"\n    return dfs(n)\n</code></pre> climbing_stairs_dfs.cpp<pre><code>/* Search */\nint dfs(int i) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* Climbing stairs: Search */\nint climbingStairsDFS(int n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.java<pre><code>/* Search */\nint dfs(int i) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* Climbing stairs: Search */\nint climbingStairsDFS(int n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.cs<pre><code>/* Search */\nint DFS(int i) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = DFS(i - 1) + DFS(i - 2);\n    return count;\n}\n\n/* Climbing stairs: Search */\nint ClimbingStairsDFS(int n) {\n    return DFS(n);\n}\n</code></pre> climbing_stairs_dfs.go<pre><code>/* Search */\nfunc dfs(i int) int {\n    // Known dp[1] and dp[2], return them\n    if i == 1 || i == 2 {\n        return i\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    count := dfs(i-1) + dfs(i-2)\n    return count\n}\n\n/* Climbing stairs: Search */\nfunc climbingStairsDFS(n int) int {\n    return dfs(n)\n}\n</code></pre> climbing_stairs_dfs.swift<pre><code>/* Search */\nfunc dfs(i: Int) -&gt; Int {\n    // Known dp[1] and dp[2], return them\n    if i == 1 || i == 2 {\n        return i\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i: i - 1) + dfs(i: i - 2)\n    return count\n}\n\n/* Climbing stairs: Search */\nfunc climbingStairsDFS(n: Int) -&gt; Int {\n    dfs(i: n)\n}\n</code></pre> climbing_stairs_dfs.js<pre><code>/* Search */\nfunction dfs(i) {\n    // Known dp[1] and dp[2], return them\n    if (i === 1 || i === 2) return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* Climbing stairs: Search */\nfunction climbingStairsDFS(n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.ts<pre><code>/* Search */\nfunction dfs(i: number): number {\n    // Known dp[1] and dp[2], return them\n    if (i === 1 || i === 2) return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* Climbing stairs: Search */\nfunction climbingStairsDFS(n: number): number {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.dart<pre><code>/* Search */\nint dfs(int i) {\n  // Known dp[1] and dp[2], return them\n  if (i == 1 || i == 2) return i;\n  // dp[i] = dp[i-1] + dp[i-2]\n  int count = dfs(i - 1) + dfs(i - 2);\n  return count;\n}\n\n/* Climbing stairs: Search */\nint climbingStairsDFS(int n) {\n  return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.rs<pre><code>/* Search */\nfn dfs(i: usize) -&gt; i32 {\n    // Known dp[1] and dp[2], return them\n    if i == 1 || i == 2 {\n        return i as i32;\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i - 1) + dfs(i - 2);\n    count\n}\n\n/* Climbing stairs: Search */\nfn climbing_stairs_dfs(n: usize) -&gt; i32 {\n    dfs(n)\n}\n</code></pre> climbing_stairs_dfs.c<pre><code>/* Search */\nint dfs(int i) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* Climbing stairs: Search */\nint climbingStairsDFS(int n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.kt<pre><code>/* Search */\nfun dfs(i: Int): Int {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2) return i\n    // dp[i] = dp[i-1] + dp[i-2]\n    val count = dfs(i - 1) + dfs(i - 2)\n    return count\n}\n\n/* Climbing stairs: Search */\nfun climbingStairsDFS(n: Int): Int {\n    return dfs(n)\n}\n</code></pre> climbing_stairs_dfs.rb<pre><code>### Search ###\ndef dfs(i)\n  # Known dp[1] and dp[2], return them\n  return i if i == 1 || i == 2\n  # dp[i] = dp[i-1] + dp[i-2]\n  dfs(i - 1) + dfs(i - 2)\nend\n\n### Climbing stairs: search ###\ndef climbing_stairs_dfs(n)\n  dfs(n)\nend\n</code></pre> <p>Figure 14-3 shows the recursion tree formed by brute force search. For the problem \\(dp[n]\\), the depth of its recursion tree is \\(n\\), with a time complexity of \\(O(2^n)\\). Exponential order represents explosive growth; if we input a relatively large \\(n\\), we will fall into a long wait.</p> <p></p> <p> Figure 14-3 \u00a0 Recursion tree for climbing stairs </p> <p>Observing the above figure, the exponential time complexity is caused by \"overlapping subproblems\". For example, \\(dp[9]\\) is decomposed into \\(dp[8]\\) and \\(dp[7]\\), and \\(dp[8]\\) is decomposed into \\(dp[7]\\) and \\(dp[6]\\), both of which contain the subproblem \\(dp[7]\\).</p> <p>And so on, subproblems contain smaller overlapping subproblems, ad infinitum. The vast majority of computational resources are wasted on these overlapping subproblems.</p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1412-method-2-memoization","title":"14.1.2 \u00a0 Method 2: Memoization","text":"<p>To improve algorithm efficiency, we want all overlapping subproblems to be computed only once. For this purpose, we declare an array <code>mem</code> to record the solution to each subproblem and prune overlapping subproblems during the search process.</p> <ol> <li>When computing \\(dp[i]\\) for the first time, we record it in <code>mem[i]</code> for later use.</li> <li>When we need to compute \\(dp[i]\\) again, we can directly retrieve the result from <code>mem[i]</code>, thereby avoiding redundant computation of that subproblem.</li> </ol> <p>The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby climbing_stairs_dfs_mem.py<pre><code>def dfs(i: int, mem: list[int]) -&gt; int:\n    \"\"\"Memoization search\"\"\"\n    # Known dp[1] and dp[2], return them\n    if i == 1 or i == 2:\n        return i\n    # If record dp[i] exists, return it directly\n    if mem[i] != -1:\n        return mem[i]\n    # dp[i] = dp[i-1] + dp[i-2]\n    count = dfs(i - 1, mem) + dfs(i - 2, mem)\n    # Record dp[i]\n    mem[i] = count\n    return count\n\ndef climbing_stairs_dfs_mem(n: int) -&gt; int:\n    \"\"\"Climbing stairs: Memoization search\"\"\"\n    # mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    mem = [-1] * (n + 1)\n    return dfs(n, mem)\n</code></pre> climbing_stairs_dfs_mem.cpp<pre><code>/* Memoization search */\nint dfs(int i, vector&lt;int&gt; &amp;mem) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // If record dp[i] exists, return it directly\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // Record dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* Climbing stairs: Memoization search */\nint climbingStairsDFSMem(int n) {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    vector&lt;int&gt; mem(n + 1, -1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.java<pre><code>/* Memoization search */\nint dfs(int i, int[] mem) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // If record dp[i] exists, return it directly\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // Record dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* Climbing stairs: Memoization search */\nint climbingStairsDFSMem(int n) {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    int[] mem = new int[n + 1];\n    Arrays.fill(mem, -1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.cs<pre><code>/* Memoization search */\nint DFS(int i, int[] mem) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // If record dp[i] exists, return it directly\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = DFS(i - 1, mem) + DFS(i - 2, mem);\n    // Record dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* Climbing stairs: Memoization search */\nint ClimbingStairsDFSMem(int n) {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    int[] mem = new int[n + 1];\n    Array.Fill(mem, -1);\n    return DFS(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.go<pre><code>/* Memoization search */\nfunc dfsMem(i int, mem []int) int {\n    // Known dp[1] and dp[2], return them\n    if i == 1 || i == 2 {\n        return i\n    }\n    // If record dp[i] exists, return it directly\n    if mem[i] != -1 {\n        return mem[i]\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    count := dfsMem(i-1, mem) + dfsMem(i-2, mem)\n    // Record dp[i]\n    mem[i] = count\n    return count\n}\n\n/* Climbing stairs: Memoization search */\nfunc climbingStairsDFSMem(n int) int {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    mem := make([]int, n+1)\n    for i := range mem {\n        mem[i] = -1\n    }\n    return dfsMem(n, mem)\n}\n</code></pre> climbing_stairs_dfs_mem.swift<pre><code>/* Memoization search */\nfunc dfs(i: Int, mem: inout [Int]) -&gt; Int {\n    // Known dp[1] and dp[2], return them\n    if i == 1 || i == 2 {\n        return i\n    }\n    // If record dp[i] exists, return it directly\n    if mem[i] != -1 {\n        return mem[i]\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i: i - 1, mem: &amp;mem) + dfs(i: i - 2, mem: &amp;mem)\n    // Record dp[i]\n    mem[i] = count\n    return count\n}\n\n/* Climbing stairs: Memoization search */\nfunc climbingStairsDFSMem(n: Int) -&gt; Int {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    var mem = Array(repeating: -1, count: n + 1)\n    return dfs(i: n, mem: &amp;mem)\n}\n</code></pre> climbing_stairs_dfs_mem.js<pre><code>/* Memoization search */\nfunction dfs(i, mem) {\n    // Known dp[1] and dp[2], return them\n    if (i === 1 || i === 2) return i;\n    // If record dp[i] exists, return it directly\n    if (mem[i] != -1) return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // Record dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* Climbing stairs: Memoization search */\nfunction climbingStairsDFSMem(n) {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    const mem = new Array(n + 1).fill(-1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.ts<pre><code>/* Memoization search */\nfunction dfs(i: number, mem: number[]): number {\n    // Known dp[1] and dp[2], return them\n    if (i === 1 || i === 2) return i;\n    // If record dp[i] exists, return it directly\n    if (mem[i] != -1) return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // Record dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* Climbing stairs: Memoization search */\nfunction climbingStairsDFSMem(n: number): number {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    const mem = new Array(n + 1).fill(-1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.dart<pre><code>/* Memoization search */\nint dfs(int i, List&lt;int&gt; mem) {\n  // Known dp[1] and dp[2], return them\n  if (i == 1 || i == 2) return i;\n  // If record dp[i] exists, return it directly\n  if (mem[i] != -1) return mem[i];\n  // dp[i] = dp[i-1] + dp[i-2]\n  int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n  // Record dp[i]\n  mem[i] = count;\n  return count;\n}\n\n/* Climbing stairs: Memoization search */\nint climbingStairsDFSMem(int n) {\n  // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n  List&lt;int&gt; mem = List.filled(n + 1, -1);\n  return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.rs<pre><code>/* Memoization search */\nfn dfs(i: usize, mem: &amp;mut [i32]) -&gt; i32 {\n    // Known dp[1] and dp[2], return them\n    if i == 1 || i == 2 {\n        return i as i32;\n    }\n    // If record dp[i] exists, return it directly\n    if mem[i] != -1 {\n        return mem[i];\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // Record dp[i]\n    mem[i] = count;\n    count\n}\n\n/* Climbing stairs: Memoization search */\nfn climbing_stairs_dfs_mem(n: usize) -&gt; i32 {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    let mut mem = vec![-1; n + 1];\n    dfs(n, &amp;mut mem)\n}\n</code></pre> climbing_stairs_dfs_mem.c<pre><code>/* Memoization search */\nint dfs(int i, int *mem) {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2)\n        return i;\n    // If record dp[i] exists, return it directly\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // Record dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* Climbing stairs: Memoization search */\nint climbingStairsDFSMem(int n) {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    int *mem = (int *)malloc((n + 1) * sizeof(int));\n    for (int i = 0; i &lt;= n; i++) {\n        mem[i] = -1;\n    }\n    int result = dfs(n, mem);\n    free(mem);\n    return result;\n}\n</code></pre> climbing_stairs_dfs_mem.kt<pre><code>/* Memoization search */\nfun dfs(i: Int, mem: IntArray): Int {\n    // Known dp[1] and dp[2], return them\n    if (i == 1 || i == 2) return i\n    // If record dp[i] exists, return it directly\n    if (mem[i] != -1) return mem[i]\n    // dp[i] = dp[i-1] + dp[i-2]\n    val count = dfs(i - 1, mem) + dfs(i - 2, mem)\n    // Record dp[i]\n    mem[i] = count\n    return count\n}\n\n/* Climbing stairs: Memoization search */\nfun climbingStairsDFSMem(n: Int): Int {\n    // mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n    val mem = IntArray(n + 1)\n    mem.fill(-1)\n    return dfs(n, mem)\n}\n</code></pre> climbing_stairs_dfs_mem.rb<pre><code>### Memoization search ###\ndef dfs(i, mem)\n  # Known dp[1] and dp[2], return them\n  return i if i == 1 || i == 2\n  # If record dp[i] exists, return it directly\n  return mem[i] if mem[i] != -1\n\n  # dp[i] = dp[i-1] + dp[i-2]\n  count = dfs(i - 1, mem) + dfs(i - 2, mem)\n  # Record dp[i]\n  mem[i] = count\nend\n\n### Climbing stairs: memoization search ###\ndef climbing_stairs_dfs_mem(n)\n  # mem[i] records the total number of solutions to climb to the i-th stair, -1 means no record\n  mem = Array.new(n + 1, -1)\n  dfs(n, mem)\nend\n</code></pre> <p>Observe Figure 14-4, after memoization, all overlapping subproblems only need to be computed once, optimizing the time complexity to \\(O(n)\\), which is a tremendous leap.</p> <p></p> <p> Figure 14-4 \u00a0 Recursion tree with memoization </p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1413-method-3-dynamic-programming","title":"14.1.3 \u00a0 Method 3: Dynamic Programming","text":"<p>Memoization is a \"top-down\" method: we start from the original problem (root node), recursively decompose larger subproblems into smaller ones, until reaching the smallest known subproblems (leaf nodes). Afterward, by backtracking, we collect the solutions to the subproblems layer by layer to construct the solution to the original problem.</p> <p>In contrast, dynamic programming is a \"bottom-up\" method: starting from the solutions to the smallest subproblems, iteratively constructing solutions to larger subproblems until obtaining the solution to the original problem.</p> <p>Since dynamic programming does not include a backtracking process, it only requires loop iteration for implementation and does not need recursion. In the following code, we initialize an array <code>dp</code> to store the solutions to subproblems, which serves the same recording function as the array <code>mem</code> in memoization:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby climbing_stairs_dp.py<pre><code>def climbing_stairs_dp(n: int) -&gt; int:\n    \"\"\"Climbing stairs: Dynamic programming\"\"\"\n    if n == 1 or n == 2:\n        return n\n    # Initialize dp table, used to store solutions to subproblems\n    dp = [0] * (n + 1)\n    # Initial state: preset the solution to the smallest subproblem\n    dp[1], dp[2] = 1, 2\n    # State transition: gradually solve larger subproblems from smaller ones\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n</code></pre> climbing_stairs_dp.cpp<pre><code>/* Climbing stairs: Dynamic programming */\nint climbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // Initialize dp table, used to store solutions to subproblems\n    vector&lt;int&gt; dp(n + 1);\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1;\n    dp[2] = 2;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.java<pre><code>/* Climbing stairs: Dynamic programming */\nint climbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // Initialize dp table, used to store solutions to subproblems\n    int[] dp = new int[n + 1];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1;\n    dp[2] = 2;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.cs<pre><code>/* Climbing stairs: Dynamic programming */\nint ClimbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // Initialize dp table, used to store solutions to subproblems\n    int[] dp = new int[n + 1];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1;\n    dp[2] = 2;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.go<pre><code>/* Climbing stairs: Dynamic programming */\nfunc climbingStairsDP(n int) int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    dp := make([]int, n+1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1\n    dp[2] = 2\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i := 3; i &lt;= n; i++ {\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n    return dp[n]\n}\n</code></pre> climbing_stairs_dp.swift<pre><code>/* Climbing stairs: Dynamic programming */\nfunc climbingStairsDP(n: Int) -&gt; Int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    var dp = Array(repeating: 0, count: n + 1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1\n    dp[2] = 2\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i in 3 ... n {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n}\n</code></pre> climbing_stairs_dp.js<pre><code>/* Climbing stairs: Dynamic programming */\nfunction climbingStairsDP(n) {\n    if (n === 1 || n === 2) return n;\n    // Initialize dp table, used to store solutions to subproblems\n    const dp = new Array(n + 1).fill(-1);\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1;\n    dp[2] = 2;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.ts<pre><code>/* Climbing stairs: Dynamic programming */\nfunction climbingStairsDP(n: number): number {\n    if (n === 1 || n === 2) return n;\n    // Initialize dp table, used to store solutions to subproblems\n    const dp = new Array(n + 1).fill(-1);\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1;\n    dp[2] = 2;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.dart<pre><code>/* Climbing stairs: Dynamic programming */\nint climbingStairsDP(int n) {\n  if (n == 1 || n == 2) return n;\n  // Initialize dp table, used to store solutions to subproblems\n  List&lt;int&gt; dp = List.filled(n + 1, 0);\n  // Initial state: preset the solution to the smallest subproblem\n  dp[1] = 1;\n  dp[2] = 2;\n  // State transition: gradually solve larger subproblems from smaller ones\n  for (int i = 3; i &lt;= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];\n}\n</code></pre> climbing_stairs_dp.rs<pre><code>/* Climbing stairs: Dynamic programming */\nfn climbing_stairs_dp(n: usize) -&gt; i32 {\n    // Known dp[1] and dp[2], return them\n    if n == 1 || n == 2 {\n        return n as i32;\n    }\n    // Initialize dp table, used to store solutions to subproblems\n    let mut dp = vec![-1; n + 1];\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1;\n    dp[2] = 2;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i in 3..=n {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    dp[n]\n}\n</code></pre> climbing_stairs_dp.c<pre><code>/* Climbing stairs: Dynamic programming */\nint climbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // Initialize dp table, used to store solutions to subproblems\n    int *dp = (int *)malloc((n + 1) * sizeof(int));\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1;\n    dp[2] = 2;\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    int result = dp[n];\n    free(dp);\n    return result;\n}\n</code></pre> climbing_stairs_dp.kt<pre><code>/* Climbing stairs: Dynamic programming */\nfun climbingStairsDP(n: Int): Int {\n    if (n == 1 || n == 2) return n\n    // Initialize dp table, used to store solutions to subproblems\n    val dp = IntArray(n + 1)\n    // Initial state: preset the solution to the smallest subproblem\n    dp[1] = 1\n    dp[2] = 2\n    // State transition: gradually solve larger subproblems from smaller ones\n    for (i in 3..n) {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n}\n</code></pre> climbing_stairs_dp.rb<pre><code>### Climbing stairs: dynamic programming ###\ndef climbing_stairs_dp(n)\n  return n  if n == 1 || n == 2\n\n  # Initialize dp table, used to store solutions to subproblems\n  dp = Array.new(n + 1, 0)\n  # Initial state: preset the solution to the smallest subproblem\n  dp[1], dp[2] = 1, 2\n  # State transition: gradually solve larger subproblems from smaller ones\n  (3...(n + 1)).each { |i| dp[i] = dp[i - 1] + dp[i - 2] }\n\n  dp[n]\nend\n</code></pre> <p>Figure 14-5 simulates the execution process of the above code.</p> <p></p> <p> Figure 14-5 \u00a0 Dynamic programming process for climbing stairs </p> <p>Like backtracking algorithms, dynamic programming also uses the \"state\" concept to represent specific stages of problem solving, with each state corresponding to a subproblem and its corresponding local optimal solution. For example, the state in the stair climbing problem is defined as the current stair step number \\(i\\).</p> <p>Based on the above content, we can summarize the commonly used terminology in dynamic programming.</p> <ul> <li>The array <code>dp</code> is called the dp table, where \\(dp[i]\\) represents the solution to the subproblem corresponding to state \\(i\\).</li> <li>The states corresponding to the smallest subproblems (the \\(1\\)st and \\(2\\)nd steps) are called initial states.</li> <li>The recurrence formula \\(dp[i] = dp[i-1] + dp[i-2]\\) is called the state transition equation.</li> </ul>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1414-space-optimization","title":"14.1.4 \u00a0 Space Optimization","text":"<p>Observant readers may have noticed that since \\(dp[i]\\) is only related to \\(dp[i-1]\\) and \\(dp[i-2]\\), we do not need to use an array <code>dp</code> to store the solutions to all subproblems, but can simply use two variables to roll forward. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby climbing_stairs_dp.py<pre><code>def climbing_stairs_dp_comp(n: int) -&gt; int:\n    \"\"\"Climbing stairs: Space-optimized dynamic programming\"\"\"\n    if n == 1 or n == 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b\n</code></pre> climbing_stairs_dp.cpp<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nint climbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.java<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nint climbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.cs<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nint ClimbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.go<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nfunc climbingStairsDPComp(n int) int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    a, b := 1, 2\n    // State transition: gradually solve larger subproblems from smaller ones\n    for i := 3; i &lt;= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n</code></pre> climbing_stairs_dp.swift<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nfunc climbingStairsDPComp(n: Int) -&gt; Int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    var a = 1\n    var b = 2\n    for _ in 3 ... n {\n        (a, b) = (b, a + b)\n    }\n    return b\n}\n</code></pre> climbing_stairs_dp.js<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nfunction climbingStairsDPComp(n) {\n    if (n === 1 || n === 2) return n;\n    let a = 1,\n        b = 2;\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.ts<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nfunction climbingStairsDPComp(n: number): number {\n    if (n === 1 || n === 2) return n;\n    let a = 1,\n        b = 2;\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.dart<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nint climbingStairsDPComp(int n) {\n  if (n == 1 || n == 2) return n;\n  int a = 1, b = 2;\n  for (int i = 3; i &lt;= n; i++) {\n    int tmp = b;\n    b = a + b;\n    a = tmp;\n  }\n  return b;\n}\n</code></pre> climbing_stairs_dp.rs<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nfn climbing_stairs_dp_comp(n: usize) -&gt; i32 {\n    if n == 1 || n == 2 {\n        return n as i32;\n    }\n    let (mut a, mut b) = (1, 2);\n    for _ in 3..=n {\n        let tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    b\n}\n</code></pre> climbing_stairs_dp.c<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nint climbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.kt<pre><code>/* Climbing stairs: Space-optimized dynamic programming */\nfun climbingStairsDPComp(n: Int): Int {\n    if (n == 1 || n == 2) return n\n    var a = 1\n    var b = 2\n    for (i in 3..n) {\n        val temp = b\n        b += a\n        a = temp\n    }\n    return b\n}\n</code></pre> climbing_stairs_dp.rb<pre><code>### Climbing stairs: space-optimized DP ###\ndef climbing_stairs_dp_comp(n)\n  return n if n == 1 || n == 2\n\n  a, b = 1, 2\n  (3...(n + 1)).each { a, b = b, a + b }\n\n  b\nend\n</code></pre> <p>Observing the above code, since the space occupied by the array <code>dp</code> is saved, the space complexity is reduced from \\(O(n)\\) to \\(O(1)\\).</p> <p>In dynamic programming problems, the current state often depends only on a limited number of preceding states, allowing us to retain only the necessary states and save memory space through \"dimension reduction\". This space optimization technique is called \"rolling variable\" or \"rolling array\".</p>"},{"location":"chapter_dynamic_programming/knapsack_problem/","title":"14.4 \u00a0 0-1 Knapsack Problem","text":"<p>The knapsack problem is an excellent introductory problem for dynamic programming and is one of the most common problem forms in dynamic programming. It has many variants, such as the 0-1 knapsack problem, the unbounded knapsack problem, and the multiple knapsack problem.</p> <p>In this section, we will first solve the most common 0-1 knapsack problem.</p> <p>Question</p> <p>Given \\(n\\) items, where the weight of the \\(i\\)-th item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a knapsack with capacity \\(cap\\). Each item can only be selected once. What is the maximum value that can be placed in the knapsack within the capacity limit?</p> <p>Observe Figure 14-17. Since item number \\(i\\) starts counting from \\(1\\) and array indices start from \\(0\\), item \\(i\\) corresponds to weight \\(wgt[i-1]\\) and value \\(val[i-1]\\).</p> <p></p> <p> Figure 14-17 \u00a0 Example data for 0-1 knapsack </p> <p>We can view the 0-1 knapsack problem as a process consisting of \\(n\\) rounds of decisions, where for each item there are two decisions: not putting it in and putting it in, thus the problem satisfies the decision tree model.</p> <p>The goal of this problem is to find \"the maximum value that can be placed in the knapsack within the capacity limit\", so it is more likely to be a dynamic programming problem.</p> <p>Step 1: Think about the decisions in each round, define the state, and thus obtain the \\(dp\\) table</p> <p>For each item, if not placed in the knapsack, the knapsack capacity remains unchanged; if placed in, the knapsack capacity decreases. From this, we can derive the state definition: current item number \\(i\\) and knapsack capacity \\(c\\), denoted as \\([i, c]\\).</p> <p>State \\([i, c]\\) corresponds to the subproblem: the maximum value among the first \\(i\\) items in a knapsack of capacity \\(c\\), denoted as \\(dp[i, c]\\).</p> <p>What we need to find is \\(dp[n, cap]\\), so we need a two-dimensional \\(dp\\) table of size \\((n+1) \\times (cap+1)\\).</p> <p>Step 2: Identify the optimal substructure, and then derive the state transition equation</p> <p>After making the decision for item \\(i\\), what remains is the subproblem of the first \\(i-1\\) items, which can be divided into the following two cases.</p> <ul> <li>Not putting item \\(i\\): The knapsack capacity remains unchanged, and the state changes to \\([i-1, c]\\).</li> <li>Putting item \\(i\\): The knapsack capacity decreases by \\(wgt[i-1]\\), the value increases by \\(val[i-1]\\), and the state changes to \\([i-1, c-wgt[i-1]]\\).</li> </ul> <p>The above analysis reveals the optimal substructure of this problem: the maximum value \\(dp[i, c]\\) equals the larger value between not putting item \\(i\\) and putting item \\(i\\). From this, the state transition equation can be derived:</p> \\[ dp[i, c] = \\max(dp[i-1, c], dp[i-1, c - wgt[i-1]] + val[i-1]) \\] <p>Note that if the weight of the current item \\(wgt[i - 1]\\) exceeds the remaining knapsack capacity \\(c\\), then the only option is not to put it in the knapsack.</p> <p>Step 3: Determine boundary conditions and state transition order</p> <p>When there are no items or the knapsack capacity is \\(0\\), the maximum value is \\(0\\), i.e., the first column \\(dp[i, 0]\\) and the first row \\(dp[0, c]\\) are both equal to \\(0\\).</p> <p>The current state \\([i, c]\\) is transferred from the state above \\([i-1, c]\\) and the state in the upper-left \\([i-1, c-wgt[i-1]]\\), so the entire \\(dp\\) table is traversed in order through two nested loops.</p> <p>Based on the above analysis, we will next implement the brute force search, memoization, and dynamic programming solutions in order.</p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#1-method-1-brute-force-search","title":"1. \u00a0 Method 1: Brute Force Search","text":"<p>The search code includes the following elements.</p> <ul> <li>Recursive parameters: state \\([i, c]\\).</li> <li>Return value: solution to the subproblem \\(dp[i, c]\\).</li> <li>Termination condition: when the item number is out of bounds \\(i = 0\\) or the remaining knapsack capacity is \\(0\\), terminate recursion and return value \\(0\\).</li> <li>Pruning: if the weight of the current item exceeds the remaining knapsack capacity, only the option of not putting it in is available.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby knapsack.py<pre><code>def knapsack_dfs(wgt: list[int], val: list[int], i: int, c: int) -&gt; int:\n    \"\"\"0-1 knapsack: Brute-force search\"\"\"\n    # If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 or c == 0:\n        return 0\n    # If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i - 1] &gt; c:\n        return knapsack_dfs(wgt, val, i - 1, c)\n    # Calculate the maximum value of not putting in and putting in item i\n    no = knapsack_dfs(wgt, val, i - 1, c)\n    yes = knapsack_dfs(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1]\n    # Return the larger value of the two options\n    return max(no, yes)\n</code></pre> knapsack.cpp<pre><code>/* 0-1 knapsack: Brute-force search */\nint knapsackDFS(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = knapsackDFS(wgt, val, i - 1, c);\n    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Return the larger value of the two options\n    return max(no, yes);\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 knapsack: Brute-force search */\nint knapsackDFS(int[] wgt, int[] val, int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = knapsackDFS(wgt, val, i - 1, c);\n    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Return the larger value of the two options\n    return Math.max(no, yes);\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 knapsack: Brute-force search */\nint KnapsackDFS(int[] weight, int[] val, int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (weight[i - 1] &gt; c) {\n        return KnapsackDFS(weight, val, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = KnapsackDFS(weight, val, i - 1, c);\n    int yes = KnapsackDFS(weight, val, i - 1, c - weight[i - 1]) + val[i - 1];\n    // Return the larger value of the two options\n    return Math.Max(no, yes);\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 knapsack: Brute-force search */\nfunc knapsackDFS(wgt, val []int, i, c int) int {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i-1] &gt; c {\n        return knapsackDFS(wgt, val, i-1, c)\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    no := knapsackDFS(wgt, val, i-1, c)\n    yes := knapsackDFS(wgt, val, i-1, c-wgt[i-1]) + val[i-1]\n    // Return the larger value of the two options\n    return int(math.Max(float64(no), float64(yes)))\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 knapsack: Brute-force search */\nfunc knapsackDFS(wgt: [Int], val: [Int], i: Int, c: Int) -&gt; Int {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i - 1] &gt; c {\n        return knapsackDFS(wgt: wgt, val: val, i: i - 1, c: c)\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    let no = knapsackDFS(wgt: wgt, val: val, i: i - 1, c: c)\n    let yes = knapsackDFS(wgt: wgt, val: val, i: i - 1, c: c - wgt[i - 1]) + val[i - 1]\n    // Return the larger value of the two options\n    return max(no, yes)\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 knapsack: Brute-force search */\nfunction knapsackDFS(wgt, val, i, c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    const no = knapsackDFS(wgt, val, i - 1, c);\n    const yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Return the larger value of the two options\n    return Math.max(no, yes);\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 knapsack: Brute-force search */\nfunction knapsackDFS(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    i: number,\n    c: number\n): number {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    const no = knapsackDFS(wgt, val, i - 1, c);\n    const yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Return the larger value of the two options\n    return Math.max(no, yes);\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 knapsack: Brute-force search */\nint knapsackDFS(List&lt;int&gt; wgt, List&lt;int&gt; val, int i, int c) {\n  // If all items have been selected or knapsack has no remaining capacity, return value 0\n  if (i == 0 || c == 0) {\n    return 0;\n  }\n  // If exceeds knapsack capacity, can only choose not to put it in\n  if (wgt[i - 1] &gt; c) {\n    return knapsackDFS(wgt, val, i - 1, c);\n  }\n  // Calculate the maximum value of not putting in and putting in item i\n  int no = knapsackDFS(wgt, val, i - 1, c);\n  int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n  // Return the larger value of the two options\n  return max(no, yes);\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 knapsack: Brute-force search */\nfn knapsack_dfs(wgt: &amp;[i32], val: &amp;[i32], i: usize, c: usize) -&gt; i32 {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 || c == 0 {\n        return 0;\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i - 1] &gt; c as i32 {\n        return knapsack_dfs(wgt, val, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    let no = knapsack_dfs(wgt, val, i - 1, c);\n    let yes = knapsack_dfs(wgt, val, i - 1, c - wgt[i - 1] as usize) + val[i - 1];\n    // Return the larger value of the two options\n    std::cmp::max(no, yes)\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 knapsack: Brute-force search */\nint knapsackDFS(int wgt[], int val[], int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = knapsackDFS(wgt, val, i - 1, c);\n    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Return the larger value of the two options\n    return myMax(no, yes);\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 knapsack: Brute-force search */\nfun knapsackDFS(\n    wgt: IntArray,\n    _val: IntArray,\n    i: Int,\n    c: Int\n): Int {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, _val, i - 1, c)\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    val no = knapsackDFS(wgt, _val, i - 1, c)\n    val yes = knapsackDFS(wgt, _val, i - 1, c - wgt[i - 1]) + _val[i - 1]\n    // Return the larger value of the two options\n    return max(no, yes)\n}\n</code></pre> knapsack.rb<pre><code>### 0-1 knapsack: brute force search ###\ndef knapsack_dfs(wgt, val, i, c)\n  # If all items have been selected or knapsack has no remaining capacity, return value 0\n  return 0 if i == 0 || c == 0\n  # If exceeds knapsack capacity, can only choose not to put it in\n  return knapsack_dfs(wgt, val, i - 1, c) if wgt[i - 1] &gt; c\n  # Calculate the maximum value of not putting in and putting in item i\n  no = knapsack_dfs(wgt, val, i - 1, c)\n  yes = knapsack_dfs(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1]\n  # Return the larger value of the two options\n  [no, yes].max\nend\n</code></pre> <p>As shown in Figure 14-18, since each item generates two search branches of not selecting and selecting, the time complexity is \\(O(2^n)\\).</p> <p>Observing the recursion tree, it is easy to see overlapping subproblems, such as \\(dp[1, 10]\\). When there are many items, large knapsack capacity, and especially many items with the same weight, the number of overlapping subproblems will increase significantly.</p> <p></p> <p> Figure 14-18 \u00a0 Brute force search recursion tree for 0-1 knapsack problem </p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#2-method-2-memoization","title":"2. \u00a0 Method 2: Memoization","text":"<p>To ensure that overlapping subproblems are only computed once, we use a memo list <code>mem</code> to record the solutions to subproblems, where <code>mem[i][c]</code> corresponds to \\(dp[i, c]\\).</p> <p>After introducing memoization, the time complexity depends on the number of subproblems, which is \\(O(n \\times cap)\\). The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby knapsack.py<pre><code>def knapsack_dfs_mem(\n    wgt: list[int], val: list[int], mem: list[list[int]], i: int, c: int\n) -&gt; int:\n    \"\"\"0-1 knapsack: Memoization search\"\"\"\n    # If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 or c == 0:\n        return 0\n    # If there's a record, return it directly\n    if mem[i][c] != -1:\n        return mem[i][c]\n    # If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i - 1] &gt; c:\n        return knapsack_dfs_mem(wgt, val, mem, i - 1, c)\n    # Calculate the maximum value of not putting in and putting in item i\n    no = knapsack_dfs_mem(wgt, val, mem, i - 1, c)\n    yes = knapsack_dfs_mem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1]\n    # Record and return the larger value of the two options\n    mem[i][c] = max(no, yes)\n    return mem[i][c]\n</code></pre> knapsack.cpp<pre><code>/* 0-1 knapsack: Memoization search */\nint knapsackDFSMem(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, vector&lt;vector&lt;int&gt;&gt; &amp;mem, int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If there's a record, return it directly\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Record and return the larger value of the two options\n    mem[i][c] = max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 knapsack: Memoization search */\nint knapsackDFSMem(int[] wgt, int[] val, int[][] mem, int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If there's a record, return it directly\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Record and return the larger value of the two options\n    mem[i][c] = Math.max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 knapsack: Memoization search */\nint KnapsackDFSMem(int[] weight, int[] val, int[][] mem, int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If there's a record, return it directly\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (weight[i - 1] &gt; c) {\n        return KnapsackDFSMem(weight, val, mem, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = KnapsackDFSMem(weight, val, mem, i - 1, c);\n    int yes = KnapsackDFSMem(weight, val, mem, i - 1, c - weight[i - 1]) + val[i - 1];\n    // Record and return the larger value of the two options\n    mem[i][c] = Math.Max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 knapsack: Memoization search */\nfunc knapsackDFSMem(wgt, val []int, mem [][]int, i, c int) int {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // If there's a record, return it directly\n    if mem[i][c] != -1 {\n        return mem[i][c]\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i-1] &gt; c {\n        return knapsackDFSMem(wgt, val, mem, i-1, c)\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    no := knapsackDFSMem(wgt, val, mem, i-1, c)\n    yes := knapsackDFSMem(wgt, val, mem, i-1, c-wgt[i-1]) + val[i-1]\n    // Return the larger value of the two options\n    mem[i][c] = int(math.Max(float64(no), float64(yes)))\n    return mem[i][c]\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 knapsack: Memoization search */\nfunc knapsackDFSMem(wgt: [Int], val: [Int], mem: inout [[Int]], i: Int, c: Int) -&gt; Int {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // If there's a record, return it directly\n    if mem[i][c] != -1 {\n        return mem[i][c]\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i - 1] &gt; c {\n        return knapsackDFSMem(wgt: wgt, val: val, mem: &amp;mem, i: i - 1, c: c)\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    let no = knapsackDFSMem(wgt: wgt, val: val, mem: &amp;mem, i: i - 1, c: c)\n    let yes = knapsackDFSMem(wgt: wgt, val: val, mem: &amp;mem, i: i - 1, c: c - wgt[i - 1]) + val[i - 1]\n    // Record and return the larger value of the two options\n    mem[i][c] = max(no, yes)\n    return mem[i][c]\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 knapsack: Memoization search */\nfunction knapsackDFSMem(wgt, val, mem, i, c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // If there's a record, return it directly\n    if (mem[i][c] !== -1) {\n        return mem[i][c];\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    const no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    const yes =\n        knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Record and return the larger value of the two options\n    mem[i][c] = Math.max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 knapsack: Memoization search */\nfunction knapsackDFSMem(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    mem: Array&lt;Array&lt;number&gt;&gt;,\n    i: number,\n    c: number\n): number {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // If there's a record, return it directly\n    if (mem[i][c] !== -1) {\n        return mem[i][c];\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    const no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    const yes =\n        knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Record and return the larger value of the two options\n    mem[i][c] = Math.max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 knapsack: Memoization search */\nint knapsackDFSMem(\n  List&lt;int&gt; wgt,\n  List&lt;int&gt; val,\n  List&lt;List&lt;int&gt;&gt; mem,\n  int i,\n  int c,\n) {\n  // If all items have been selected or knapsack has no remaining capacity, return value 0\n  if (i == 0 || c == 0) {\n    return 0;\n  }\n  // If there's a record, return it directly\n  if (mem[i][c] != -1) {\n    return mem[i][c];\n  }\n  // If exceeds knapsack capacity, can only choose not to put it in\n  if (wgt[i - 1] &gt; c) {\n    return knapsackDFSMem(wgt, val, mem, i - 1, c);\n  }\n  // Calculate the maximum value of not putting in and putting in item i\n  int no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n  int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n  // Record and return the larger value of the two options\n  mem[i][c] = max(no, yes);\n  return mem[i][c];\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 knapsack: Memoization search */\nfn knapsack_dfs_mem(wgt: &amp;[i32], val: &amp;[i32], mem: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, i: usize, c: usize) -&gt; i32 {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if i == 0 || c == 0 {\n        return 0;\n    }\n    // If there's a record, return it directly\n    if mem[i][c] != -1 {\n        return mem[i][c];\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if wgt[i - 1] &gt; c as i32 {\n        return knapsack_dfs_mem(wgt, val, mem, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    let no = knapsack_dfs_mem(wgt, val, mem, i - 1, c);\n    let yes = knapsack_dfs_mem(wgt, val, mem, i - 1, c - wgt[i - 1] as usize) + val[i - 1];\n    // Record and return the larger value of the two options\n    mem[i][c] = std::cmp::max(no, yes);\n    mem[i][c]\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 knapsack: Memoization search */\nint knapsackDFSMem(int wgt[], int val[], int memCols, int **mem, int i, int c) {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // If there's a record, return it directly\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, memCols, mem, i - 1, c);\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    int no = knapsackDFSMem(wgt, val, memCols, mem, i - 1, c);\n    int yes = knapsackDFSMem(wgt, val, memCols, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // Record and return the larger value of the two options\n    mem[i][c] = myMax(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 knapsack: Memoization search */\nfun knapsackDFSMem(\n    wgt: IntArray,\n    _val: IntArray,\n    mem: Array&lt;IntArray&gt;,\n    i: Int,\n    c: Int\n): Int {\n    // If all items have been selected or knapsack has no remaining capacity, return value 0\n    if (i == 0 || c == 0) {\n        return 0\n    }\n    // If there's a record, return it directly\n    if (mem[i][c] != -1) {\n        return mem[i][c]\n    }\n    // If exceeds knapsack capacity, can only choose not to put it in\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, _val, mem, i - 1, c)\n    }\n    // Calculate the maximum value of not putting in and putting in item i\n    val no = knapsackDFSMem(wgt, _val, mem, i - 1, c)\n    val yes = knapsackDFSMem(wgt, _val, mem, i - 1, c - wgt[i - 1]) + _val[i - 1]\n    // Record and return the larger value of the two options\n    mem[i][c] = max(no, yes)\n    return mem[i][c]\n}\n</code></pre> knapsack.rb<pre><code>### 0-1 knapsack: memoization search ###\ndef knapsack_dfs_mem(wgt, val, mem, i, c)\n  # If all items have been selected or knapsack has no remaining capacity, return value 0\n  return 0 if i == 0 || c == 0\n  # If there's a record, return it directly\n  return mem[i][c] if mem[i][c] != -1\n  # If exceeds knapsack capacity, can only choose not to put it in\n  return knapsack_dfs_mem(wgt, val, mem, i - 1, c) if wgt[i - 1] &gt; c\n  # Calculate the maximum value of not putting in and putting in item i\n  no = knapsack_dfs_mem(wgt, val, mem, i - 1, c)\n  yes = knapsack_dfs_mem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1]\n  # Record and return the larger value of the two options\n  mem[i][c] = [no, yes].max\nend\n</code></pre> <p>Figure 14-19 shows the search branches pruned in memoization.</p> <p></p> <p> Figure 14-19 \u00a0 Memoization recursion tree for 0-1 knapsack problem </p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#3-method-3-dynamic-programming","title":"3. \u00a0 Method 3: Dynamic Programming","text":"<p>Dynamic programming is essentially the process of filling the \\(dp\\) table during state transitions. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby knapsack.py<pre><code>def knapsack_dp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"0-1 knapsack: Dynamic programming\"\"\"\n    n = len(wgt)\n    # Initialize dp table\n    dp = [[0] * (cap + 1) for _ in range(n + 1)]\n    # State transition\n    for i in range(1, n + 1):\n        for c in range(1, cap + 1):\n            if wgt[i - 1] &gt; c:\n                # If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c]\n            else:\n                # The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1])\n    return dp[n][cap]\n</code></pre> knapsack.cpp<pre><code>/* 0-1 knapsack: Dynamic programming */\nint knapsackDP(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // Initialize dp table\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(cap + 1, 0));\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 knapsack: Dynamic programming */\nint knapsackDP(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // Initialize dp table\n    int[][] dp = new int[n + 1][cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = Math.max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 knapsack: Dynamic programming */\nint KnapsackDP(int[] weight, int[] val, int cap) {\n    int n = weight.Length;\n    // Initialize dp table\n    int[,] dp = new int[n + 1, cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (weight[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i, c] = dp[i - 1, c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i, c] = Math.Max(dp[i - 1, c - weight[i - 1]] + val[i - 1], dp[i - 1, c]);\n            }\n        }\n    }\n    return dp[n, cap];\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 knapsack: Dynamic programming */\nfunc knapsackDP(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // Initialize dp table\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, cap+1)\n    }\n    // State transition\n    for i := 1; i &lt;= n; i++ {\n        for c := 1; c &lt;= cap; c++ {\n            if wgt[i-1] &gt; c {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i-1][c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = int(math.Max(float64(dp[i-1][c]), float64(dp[i-1][c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 knapsack: Dynamic programming */\nfunc knapsackDP(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // Initialize dp table\n    var dp = Array(repeating: Array(repeating: 0, count: cap + 1), count: n + 1)\n    // State transition\n    for i in 1 ... n {\n        for c in 1 ... cap {\n            if wgt[i - 1] &gt; c {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 knapsack: Dynamic programming */\nfunction knapsackDP(wgt, val, cap) {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array(n + 1)\n        .fill(0)\n        .map(() =&gt; Array(cap + 1).fill(0));\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i - 1][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 knapsack: Dynamic programming */\nfunction knapsackDP(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: cap + 1 }, () =&gt; 0)\n    );\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i - 1][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 knapsack: Dynamic programming */\nint knapsackDP(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // Initialize dp table\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(cap + 1, 0));\n  // State transition\n  for (int i = 1; i &lt;= n; i++) {\n    for (int c = 1; c &lt;= cap; c++) {\n      if (wgt[i - 1] &gt; c) {\n        // If exceeds knapsack capacity, don't select item i\n        dp[i][c] = dp[i - 1][c];\n      } else {\n        // The larger value between not selecting and selecting item i\n        dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[n][cap];\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 knapsack: Dynamic programming */\nfn knapsack_dp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // Initialize dp table\n    let mut dp = vec![vec![0; cap + 1]; n + 1];\n    // State transition\n    for i in 1..=n {\n        for c in 1..=cap {\n            if wgt[i - 1] &gt; c as i32 {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = std::cmp::max(\n                    dp[i - 1][c],\n                    dp[i - 1][c - wgt[i - 1] as usize] + val[i - 1],\n                );\n            }\n        }\n    }\n    dp[n][cap]\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 knapsack: Dynamic programming */\nint knapsackDP(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // Initialize dp table\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(cap + 1, sizeof(int));\n    }\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = myMax(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[n][cap];\n    // Free memory\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 knapsack: Dynamic programming */\nfun knapsackDP(wgt: IntArray, _val: IntArray, cap: Int): Int {\n    val n = wgt.size\n    // Initialize dp table\n    val dp = Array(n + 1) { IntArray(cap + 1) }\n    // State transition\n    for (i in 1..n) {\n        for (c in 1..cap) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> knapsack.rb<pre><code>### 0-1 knapsack: dynamic programming ###\ndef knapsack_dp(wgt, val, cap)\n  n = wgt.length\n  # Initialize dp table\n  dp = Array.new(n + 1) { Array.new(cap + 1, 0) }\n  # State transition\n  for i in 1...(n + 1)\n    for c in 1...(cap + 1)\n      if wgt[i - 1] &gt; c\n        # If exceeds knapsack capacity, don't select item i\n        dp[i][c] = dp[i - 1][c]\n      else\n        # The larger value between not selecting and selecting item i\n        dp[i][c] = [dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]].max\n      end\n    end\n  end\n  dp[n][cap]\nend\n</code></pre> <p>As shown in Figure 14-20, both time complexity and space complexity are determined by the size of the array <code>dp</code>, which is \\(O(n \\times cap)\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-20 \u00a0 Dynamic programming process for 0-1 knapsack problem </p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#4-space-optimization","title":"4. \u00a0 Space Optimization","text":"<p>Since each state is only related to the state in the row above it, we can use two arrays rolling forward to reduce the space complexity from \\(O(n^2)\\) to \\(O(n)\\).</p> <p>Further thinking, can we achieve space optimization using just one array? Observing, we can see that each state is transferred from the cell directly above or the cell in the upper-left. If there is only one array, when we start traversing row \\(i\\), that array still stores the state of row \\(i-1\\).</p> <ul> <li>If using forward traversal, then when traversing to \\(dp[i, j]\\), the values in the upper-left \\(dp[i-1, 1]\\) ~ \\(dp[i-1, j-1]\\) may have already been overwritten, thus preventing correct state transition.</li> <li>If using reverse traversal, there will be no overwriting issue, and state transition can proceed correctly.</li> </ul> <p>Figure 14-21 shows the transition process from row \\(i = 1\\) to row \\(i = 2\\) using a single array. Please consider the difference between forward and reverse traversal.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-21 \u00a0 Space-optimized dynamic programming process for 0-1 knapsack </p> <p>In the code implementation, we simply need to delete the first dimension \\(i\\) of the array <code>dp</code> and change the inner loop to reverse traversal:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby knapsack.py<pre><code>def knapsack_dp_comp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"0-1 knapsack: Space-optimized dynamic programming\"\"\"\n    n = len(wgt)\n    # Initialize dp table\n    dp = [0] * (cap + 1)\n    # State transition\n    for i in range(1, n + 1):\n        # Traverse in reverse order\n        for c in range(cap, 0, -1):\n            if wgt[i - 1] &gt; c:\n                # If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c]\n            else:\n                # The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n    return dp[cap]\n</code></pre> knapsack.cpp<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nint knapsackDPComp(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // Initialize dp table\n    vector&lt;int&gt; dp(cap + 1, 0);\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        // Traverse in reverse order\n        for (int c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nint knapsackDPComp(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // Initialize dp table\n    int[] dp = new int[cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        // Traverse in reverse order\n        for (int c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nint KnapsackDPComp(int[] weight, int[] val, int cap) {\n    int n = weight.Length;\n    // Initialize dp table\n    int[] dp = new int[cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        // Traverse in reverse order\n        for (int c = cap; c &gt; 0; c--) {\n            if (weight[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.Max(dp[c], dp[c - weight[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nfunc knapsackDPComp(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // Initialize dp table\n    dp := make([]int, cap+1)\n    // State transition\n    for i := 1; i &lt;= n; i++ {\n        // Traverse in reverse order\n        for c := cap; c &gt;= 1; c-- {\n            if wgt[i-1] &lt;= c {\n                // The larger value between not selecting and selecting item i\n                dp[c] = int(math.Max(float64(dp[c]), float64(dp[c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nfunc knapsackDPComp(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // Initialize dp table\n    var dp = Array(repeating: 0, count: cap + 1)\n    // State transition\n    for i in 1 ... n {\n        // Traverse in reverse order\n        for c in (1 ... cap).reversed() {\n            if wgt[i - 1] &lt;= c {\n                // The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nfunction knapsackDPComp(wgt, val, cap) {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array(cap + 1).fill(0);\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        // Traverse in reverse order\n        for (let c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nfunction knapsackDPComp(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array(cap + 1).fill(0);\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        // Traverse in reverse order\n        for (let c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nint knapsackDPComp(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // Initialize dp table\n  List&lt;int&gt; dp = List.filled(cap + 1, 0);\n  // State transition\n  for (int i = 1; i &lt;= n; i++) {\n    // Traverse in reverse order\n    for (int c = cap; c &gt;= 1; c--) {\n      if (wgt[i - 1] &lt;= c) {\n        // The larger value between not selecting and selecting item i\n        dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[cap];\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nfn knapsack_dp_comp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // Initialize dp table\n    let mut dp = vec![0; cap + 1];\n    // State transition\n    for i in 1..=n {\n        // Traverse in reverse order\n        for c in (1..=cap).rev() {\n            if wgt[i - 1] &lt;= c as i32 {\n                // The larger value between not selecting and selecting item i\n                dp[c] = std::cmp::max(dp[c], dp[c - wgt[i - 1] as usize] + val[i - 1]);\n            }\n        }\n    }\n    dp[cap]\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nint knapsackDPComp(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // Initialize dp table\n    int *dp = calloc(cap + 1, sizeof(int));\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        // Traverse in reverse order\n        for (int c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // The larger value between not selecting and selecting item i\n                dp[c] = myMax(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[cap];\n    // Free memory\n    free(dp);\n    return res;\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 knapsack: Space-optimized dynamic programming */\nfun knapsackDPComp(wgt: IntArray, _val: IntArray, cap: Int): Int {\n    val n = wgt.size\n    // Initialize dp table\n    val dp = IntArray(cap + 1)\n    // State transition\n    for (i in 1..n) {\n        // Traverse in reverse order\n        for (c in cap downTo 1) {\n            if (wgt[i - 1] &lt;= c) {\n                // The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> knapsack.rb<pre><code>### 0-1 knapsack: space-optimized DP ###\ndef knapsack_dp_comp(wgt, val, cap)\n  n = wgt.length\n  # Initialize dp table\n  dp = Array.new(cap + 1, 0)\n  # State transition\n  for i in 1...(n + 1)\n    # Traverse in reverse order\n    for c in cap.downto(1)\n      if wgt[i - 1] &gt; c\n        # If exceeds knapsack capacity, don't select item i\n        dp[c] = dp[c]\n      else\n        # The larger value between not selecting and selecting item i\n        dp[c] = [dp[c], dp[c - wgt[i - 1]] + val[i - 1]].max\n      end\n    end\n  end\n  dp[cap]\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/summary/","title":"14.7 \u00a0 Summary","text":""},{"location":"chapter_dynamic_programming/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Dynamic programming decomposes problems and avoids redundant computation by storing the solutions to subproblems, thereby significantly improving computational efficiency.</li> <li>Without considering time constraints, all dynamic programming problems can be solved using backtracking (brute force search), but the recursion tree contains a large number of overlapping subproblems, resulting in extremely low efficiency. By introducing a memo list, we can store the solutions to all computed subproblems, ensuring that overlapping subproblems are only computed once.</li> <li>Memoization is a top-down recursive solution, while the corresponding dynamic programming is a bottom-up iterative solution, similar to \"filling in a table\". Since the current state only depends on certain local states, we can eliminate one dimension of the \\(dp\\) table to reduce space complexity.</li> <li>Subproblem decomposition is a general algorithmic approach, with different properties in divide and conquer, dynamic programming, and backtracking.</li> <li>Dynamic programming problems have three major characteristics: overlapping subproblems, optimal substructure, and no aftereffects.</li> <li>If the optimal solution to the original problem can be constructed from the optimal solutions to the subproblems, then it has optimal substructure.</li> <li>No aftereffects means that for a given state, its future development is only related to that state and has nothing to do with all past states. Many combinatorial optimization problems do not have no aftereffects and cannot be quickly solved using dynamic programming.</li> </ul> <p>Knapsack problem</p> <ul> <li>The knapsack problem is one of the most typical dynamic programming problems, with variants such as the 0-1 knapsack, unbounded knapsack, and multiple knapsack.</li> <li>The state definition for the 0-1 knapsack is the maximum value among the first \\(i\\) items in a knapsack of capacity \\(c\\). Based on the two decisions of not putting an item in the knapsack and putting it in, the optimal substructure can be identified and the state transition equation constructed. In space optimization, since each state depends on the state directly above and to the upper-left, the list needs to be traversed in reverse order to avoid overwriting the upper-left state.</li> <li>The unbounded knapsack problem has no limit on the selection quantity of each type of item, so the state transition for choosing to put in an item differs from the 0-1 knapsack problem. Since the state depends on the state directly above and directly to the left, space optimization should use forward traversal.</li> <li>The coin change problem is a variant of the unbounded knapsack problem. It changes from seeking the \"maximum\" value to seeking the \"minimum\" number of coins, so \\(\\max()\\) in the state transition equation should be changed to \\(\\min()\\). It changes from seeking \"not exceeding\" the knapsack capacity to seeking \"exactly\" making up the target amount, so \\(amt + 1\\) is used to represent the invalid solution of \"unable to make up the target amount\".</li> <li>Coin change problem II changes from seeking the \"minimum number of coins\" to seeking the \"number of coin combinations\", so the state transition equation correspondingly changes from \\(\\min()\\) to a summation operator.</li> </ul> <p>Edit distance problem</p> <ul> <li>Edit distance (Levenshtein distance) is used to measure the similarity between two strings, defined as the minimum number of edit steps from one string to another, with edit operations including insert, delete, and replace.</li> <li>The state definition for the edit distance problem is the minimum number of edit steps required to change the first \\(i\\) characters of \\(s\\) into the first \\(j\\) characters of \\(t\\). When \\(s[i] \\ne t[j]\\), there are three decisions: insert, delete, replace, each with corresponding remaining subproblems. From this, the optimal substructure can be identified and the state transition equation constructed. When \\(s[i] = t[j]\\), no edit is required for the current character.</li> <li>In edit distance, the state depends on the state directly above, directly to the left, and to the upper-left, so after space optimization, neither forward nor reverse traversal can correctly perform state transitions. For this reason, we use a variable to temporarily store the upper-left state, thus transforming to a situation equivalent to the unbounded knapsack problem, allowing for forward traversal after space optimization.</li> </ul>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/","title":"14.5 \u00a0 Unbounded Knapsack Problem","text":"<p>In this section, we first solve another common knapsack problem: the unbounded knapsack, and then explore a special case of it: the coin change problem.</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1451-unbounded-knapsack-problem","title":"14.5.1 \u00a0 Unbounded Knapsack Problem","text":"<p>Question</p> <p>Given \\(n\\) items, where the weight of the \\(i\\)-th item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a knapsack with capacity \\(cap\\). Each item can be selected multiple times. What is the maximum value that can be placed in the knapsack within the capacity limit? An example is shown in Figure 14-22.</p> <p></p> <p> Figure 14-22 \u00a0 Example data for unbounded knapsack problem </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1-dynamic-programming-approach","title":"1. \u00a0 Dynamic Programming Approach","text":"<p>The unbounded knapsack problem is very similar to the 0-1 knapsack problem, differing only in that there is no limit on the number of times an item can be selected.</p> <ul> <li>In the 0-1 knapsack problem, there is only one of each type of item, so after placing item \\(i\\) in the knapsack, we can only choose from the first \\(i-1\\) items.</li> <li>In the unbounded knapsack problem, the quantity of each type of item is unlimited, so after placing item \\(i\\) in the knapsack, we can still choose from the first \\(i\\) items.</li> </ul> <p>Under the rules of the unbounded knapsack problem, the changes in state \\([i, c]\\) are divided into two cases.</p> <ul> <li>Not putting item \\(i\\): Same as the 0-1 knapsack problem, transfer to \\([i-1, c]\\).</li> <li>Putting item \\(i\\): Different from the 0-1 knapsack problem, transfer to \\([i, c-wgt[i-1]]\\).</li> </ul> <p>Thus, the state transition equation becomes:</p> \\[ dp[i, c] = \\max(dp[i-1, c], dp[i, c - wgt[i-1]] + val[i-1]) \\]"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#2-code-implementation","title":"2. \u00a0 Code Implementation","text":"<p>Comparing the code for the two problems, there is one change in state transition from \\(i-1\\) to \\(i\\), with everything else identical:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby unbounded_knapsack.py<pre><code>def unbounded_knapsack_dp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"Unbounded knapsack: Dynamic programming\"\"\"\n    n = len(wgt)\n    # Initialize dp table\n    dp = [[0] * (cap + 1) for _ in range(n + 1)]\n    # State transition\n    for i in range(1, n + 1):\n        for c in range(1, cap + 1):\n            if wgt[i - 1] &gt; c:\n                # If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c]\n            else:\n                # The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1])\n    return dp[n][cap]\n</code></pre> unbounded_knapsack.cpp<pre><code>/* Unbounded knapsack: Dynamic programming */\nint unboundedKnapsackDP(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // Initialize dp table\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(cap + 1, 0));\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.java<pre><code>/* Unbounded knapsack: Dynamic programming */\nint unboundedKnapsackDP(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // Initialize dp table\n    int[][] dp = new int[n + 1][cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = Math.max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.cs<pre><code>/* Unbounded knapsack: Dynamic programming */\nint UnboundedKnapsackDP(int[] wgt, int[] val, int cap) {\n    int n = wgt.Length;\n    // Initialize dp table\n    int[,] dp = new int[n + 1, cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i, c] = dp[i - 1, c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i, c] = Math.Max(dp[i - 1, c], dp[i, c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n, cap];\n}\n</code></pre> unbounded_knapsack.go<pre><code>/* Unbounded knapsack: Dynamic programming */\nfunc unboundedKnapsackDP(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // Initialize dp table\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, cap+1)\n    }\n    // State transition\n    for i := 1; i &lt;= n; i++ {\n        for c := 1; c &lt;= cap; c++ {\n            if wgt[i-1] &gt; c {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i-1][c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = int(math.Max(float64(dp[i-1][c]), float64(dp[i][c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> unbounded_knapsack.swift<pre><code>/* Unbounded knapsack: Dynamic programming */\nfunc unboundedKnapsackDP(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // Initialize dp table\n    var dp = Array(repeating: Array(repeating: 0, count: cap + 1), count: n + 1)\n    // State transition\n    for i in 1 ... n {\n        for c in 1 ... cap {\n            if wgt[i - 1] &gt; c {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> unbounded_knapsack.js<pre><code>/* Unbounded knapsack: Dynamic programming */\nfunction unboundedKnapsackDP(wgt, val, cap) {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: cap + 1 }, () =&gt; 0)\n    );\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.ts<pre><code>/* Unbounded knapsack: Dynamic programming */\nfunction unboundedKnapsackDP(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: cap + 1 }, () =&gt; 0)\n    );\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.dart<pre><code>/* Unbounded knapsack: Dynamic programming */\nint unboundedKnapsackDP(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // Initialize dp table\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(cap + 1, 0));\n  // State transition\n  for (int i = 1; i &lt;= n; i++) {\n    for (int c = 1; c &lt;= cap; c++) {\n      if (wgt[i - 1] &gt; c) {\n        // If exceeds knapsack capacity, don't select item i\n        dp[i][c] = dp[i - 1][c];\n      } else {\n        // The larger value between not selecting and selecting item i\n        dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.rs<pre><code>/* Unbounded knapsack: Dynamic programming */\nfn unbounded_knapsack_dp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // Initialize dp table\n    let mut dp = vec![vec![0; cap + 1]; n + 1];\n    // State transition\n    for i in 1..=n {\n        for c in 1..=cap {\n            if wgt[i - 1] &gt; c as i32 {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = std::cmp::max(dp[i - 1][c], dp[i][c - wgt[i - 1] as usize] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.c<pre><code>/* Unbounded knapsack: Dynamic programming */\nint unboundedKnapsackDP(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // Initialize dp table\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(cap + 1, sizeof(int));\n    }\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = myMax(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[n][cap];\n    // Free memory\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> unbounded_knapsack.kt<pre><code>/* Unbounded knapsack: Dynamic programming */\nfun unboundedKnapsackDP(wgt: IntArray, _val: IntArray, cap: Int): Int {\n    val n = wgt.size\n    // Initialize dp table\n    val dp = Array(n + 1) { IntArray(cap + 1) }\n    // State transition\n    for (i in 1..n) {\n        for (c in 1..cap) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> unbounded_knapsack.rb<pre><code>### Unbounded knapsack: dynamic programming ###\ndef unbounded_knapsack_dp(wgt, val, cap)\n  n = wgt.length\n  # Initialize dp table\n  dp = Array.new(n + 1) { Array.new(cap + 1, 0) }\n  # State transition\n  for i in 1...(n + 1)\n    for c in 1...(cap + 1)\n      if wgt[i - 1] &gt; c\n        # If exceeds knapsack capacity, don't select item i\n        dp[i][c] = dp[i - 1][c]\n      else\n        # The larger value between not selecting and selecting item i\n        dp[i][c] = [dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]].max\n      end\n    end\n  end\n  dp[n][cap]\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#3-space-optimization","title":"3. \u00a0 Space Optimization","text":"<p>Since the current state is transferred from states on the left and above, after space optimization, each row in the \\(dp\\) table should be traversed in forward order.</p> <p>This traversal order is exactly opposite to the 0-1 knapsack. Please refer to Figure 14-23 to understand the difference between the two.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-23 \u00a0 Space-optimized dynamic programming process for unbounded knapsack problem </p> <p>The code implementation is relatively simple, just delete the first dimension of the array <code>dp</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby unbounded_knapsack.py<pre><code>def unbounded_knapsack_dp_comp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"Unbounded knapsack: Space-optimized dynamic programming\"\"\"\n    n = len(wgt)\n    # Initialize dp table\n    dp = [0] * (cap + 1)\n    # State transition\n    for i in range(1, n + 1):\n        # Traverse in forward order\n        for c in range(1, cap + 1):\n            if wgt[i - 1] &gt; c:\n                # If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c]\n            else:\n                # The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n    return dp[cap]\n</code></pre> unbounded_knapsack.cpp<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nint unboundedKnapsackDPComp(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // Initialize dp table\n    vector&lt;int&gt; dp(cap + 1, 0);\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.java<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nint unboundedKnapsackDPComp(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // Initialize dp table\n    int[] dp = new int[cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.cs<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nint UnboundedKnapsackDPComp(int[] wgt, int[] val, int cap) {\n    int n = wgt.Length;\n    // Initialize dp table\n    int[] dp = new int[cap + 1];\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.Max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.go<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nfunc unboundedKnapsackDPComp(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // Initialize dp table\n    dp := make([]int, cap+1)\n    // State transition\n    for i := 1; i &lt;= n; i++ {\n        for c := 1; c &lt;= cap; c++ {\n            if wgt[i-1] &gt; c {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = int(math.Max(float64(dp[c]), float64(dp[c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> unbounded_knapsack.swift<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nfunc unboundedKnapsackDPComp(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // Initialize dp table\n    var dp = Array(repeating: 0, count: cap + 1)\n    // State transition\n    for i in 1 ... n {\n        for c in 1 ... cap {\n            if wgt[i - 1] &gt; c {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> unbounded_knapsack.js<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nfunction unboundedKnapsackDPComp(wgt, val, cap) {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array.from({ length: cap + 1 }, () =&gt; 0);\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.ts<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nfunction unboundedKnapsackDPComp(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // Initialize dp table\n    const dp = Array.from({ length: cap + 1 }, () =&gt; 0);\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.dart<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nint unboundedKnapsackDPComp(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // Initialize dp table\n  List&lt;int&gt; dp = List.filled(cap + 1, 0);\n  // State transition\n  for (int i = 1; i &lt;= n; i++) {\n    for (int c = 1; c &lt;= cap; c++) {\n      if (wgt[i - 1] &gt; c) {\n        // If exceeds knapsack capacity, don't select item i\n        dp[c] = dp[c];\n      } else {\n        // The larger value between not selecting and selecting item i\n        dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[cap];\n}\n</code></pre> unbounded_knapsack.rs<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nfn unbounded_knapsack_dp_comp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // Initialize dp table\n    let mut dp = vec![0; cap + 1];\n    // State transition\n    for i in 1..=n {\n        for c in 1..=cap {\n            if wgt[i - 1] &gt; c as i32 {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = std::cmp::max(dp[c], dp[c - wgt[i - 1] as usize] + val[i - 1]);\n            }\n        }\n    }\n    dp[cap]\n}\n</code></pre> unbounded_knapsack.c<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nint unboundedKnapsackDPComp(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // Initialize dp table\n    int *dp = calloc(cap + 1, sizeof(int));\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c];\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = myMax(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[cap];\n    // Free memory\n    free(dp);\n    return res;\n}\n</code></pre> unbounded_knapsack.kt<pre><code>/* Unbounded knapsack: Space-optimized dynamic programming */\nfun unboundedKnapsackDPComp(\n    wgt: IntArray,\n    _val: IntArray,\n    cap: Int\n): Int {\n    val n = wgt.size\n    // Initialize dp table\n    val dp = IntArray(cap + 1)\n    // State transition\n    for (i in 1..n) {\n        for (c in 1..cap) {\n            if (wgt[i - 1] &gt; c) {\n                // If exceeds knapsack capacity, don't select item i\n                dp[c] = dp[c]\n            } else {\n                // The larger value between not selecting and selecting item i\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> unbounded_knapsack.rb<pre><code>### Unbounded knapsack: space-optimized DP ###\ndef unbounded_knapsack_dp_comp(wgt, val, cap)\n  n = wgt.length\n  # Initialize dp table\n  dp = Array.new(cap + 1, 0)\n  # State transition\n  for i in 1...(n + 1)\n    # Traverse in forward order\n    for c in 1...(cap + 1)\n      if wgt[i -1] &gt; c\n        # If exceeds knapsack capacity, don't select item i\n        dp[c] = dp[c]\n      else\n        # The larger value between not selecting and selecting item i\n        dp[c] = [dp[c], dp[c - wgt[i - 1]] + val[i - 1]].max\n      end\n    end\n  end\n  dp[cap]\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1452-coin-change-problem","title":"14.5.2 \u00a0 Coin Change Problem","text":"<p>The knapsack problem represents a large class of dynamic programming problems and has many variants, such as the coin change problem.</p> <p>Question</p> <p>Given \\(n\\) types of coins, where the denomination of the \\(i\\)-th type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\). Each type of coin can be selected multiple times. What is the minimum number of coins needed to make up the target amount? If it is impossible to make up the target amount, return \\(-1\\). An example is shown in Figure 14-24.</p> <p></p> <p> Figure 14-24 \u00a0 Example data for coin change problem </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1-dynamic-programming-approach_1","title":"1. \u00a0 Dynamic Programming Approach","text":"<p>The coin change problem can be viewed as a special case of the unbounded knapsack problem, with the following connections and differences.</p> <ul> <li>The two problems can be converted to each other: \"item\" corresponds to \"coin\", \"item weight\" corresponds to \"coin denomination\", and \"knapsack capacity\" corresponds to \"target amount\".</li> <li>The optimization goals are opposite: the unbounded knapsack problem aims to maximize item value, while the coin change problem aims to minimize the number of coins.</li> <li>The unbounded knapsack problem seeks solutions \"not exceeding\" the knapsack capacity, while the coin change problem seeks solutions that \"exactly\" make up the target amount.</li> </ul> <p>Step 1: Think about the decisions in each round, define the state, and thus obtain the \\(dp\\) table</p> <p>State \\([i, a]\\) corresponds to the subproblem: the minimum number of coins among the first \\(i\\) types of coins that can make up amount \\(a\\), denoted as \\(dp[i, a]\\).</p> <p>The two-dimensional \\(dp\\) table has size \\((n+1) \\times (amt+1)\\).</p> <p>Step 2: Identify the optimal substructure, and then derive the state transition equation</p> <p>This problem differs from the unbounded knapsack problem in the following two aspects regarding the state transition equation.</p> <ul> <li>This problem seeks the minimum value, so the operator \\(\\max()\\) needs to be changed to \\(\\min()\\).</li> <li>The optimization target is the number of coins rather than item value, so when a coin is selected, simply execute \\(+1\\).</li> </ul> \\[ dp[i, a] = \\min(dp[i-1, a], dp[i, a - coins[i-1]] + 1) \\] <p>Step 3: Determine boundary conditions and state transition order</p> <p>When the target amount is \\(0\\), the minimum number of coins needed to make it up is \\(0\\), so all \\(dp[i, 0]\\) in the first column equal \\(0\\).</p> <p>When there are no coins, it is impossible to make up any amount \\(&gt; 0\\), which is an invalid solution. To enable the \\(\\min()\\) function in the state transition equation to identify and filter out invalid solutions, we consider using \\(+ \\infty\\) to represent them, i.e., set all \\(dp[0, a]\\) in the first row to \\(+ \\infty\\).</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#2-code-implementation_1","title":"2. \u00a0 Code Implementation","text":"<p>Most programming languages do not provide a \\(+ \\infty\\) variable, and can only use the maximum value of integer type <code>int</code> as a substitute. However, this can lead to large number overflow: the \\(+ 1\\) operation in the state transition equation may cause overflow.</p> <p>For this reason, we use the number \\(amt + 1\\) to represent invalid solutions, because the maximum number of coins needed to make up \\(amt\\) is at most \\(amt\\). Before returning, check whether \\(dp[n, amt]\\) equals \\(amt + 1\\); if so, return \\(-1\\), indicating that the target amount cannot be made up. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby coin_change.py<pre><code>def coin_change_dp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"Coin change: Dynamic programming\"\"\"\n    n = len(coins)\n    MAX = amt + 1\n    # Initialize dp table\n    dp = [[0] * (amt + 1) for _ in range(n + 1)]\n    # State transition: first row and first column\n    for a in range(1, amt + 1):\n        dp[0][a] = MAX\n    # State transition: rest of the rows and columns\n    for i in range(1, n + 1):\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a]\n            else:\n                # The smaller value between not selecting and selecting coin i\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1)\n    return dp[n][amt] if dp[n][amt] != MAX else -1\n</code></pre> coin_change.cpp<pre><code>/* Coin change: Dynamic programming */\nint coinChangeDP(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    int MAX = amt + 1;\n    // Initialize dp table\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amt + 1, 0));\n    // State transition: first row and first column\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] != MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.java<pre><code>/* Coin change: Dynamic programming */\nint coinChangeDP(int[] coins, int amt) {\n    int n = coins.length;\n    int MAX = amt + 1;\n    // Initialize dp table\n    int[][] dp = new int[n + 1][amt + 1];\n    // State transition: first row and first column\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] != MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.cs<pre><code>/* Coin change: Dynamic programming */\nint CoinChangeDP(int[] coins, int amt) {\n    int n = coins.Length;\n    int MAX = amt + 1;\n    // Initialize dp table\n    int[,] dp = new int[n + 1, amt + 1];\n    // State transition: first row and first column\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0, a] = MAX;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i, a] = dp[i - 1, a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i, a] = Math.Min(dp[i - 1, a], dp[i, a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n, amt] != MAX ? dp[n, amt] : -1;\n}\n</code></pre> coin_change.go<pre><code>/* Coin change: Dynamic programming */\nfunc coinChangeDP(coins []int, amt int) int {\n    n := len(coins)\n    max := amt + 1\n    // Initialize dp table\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, amt+1)\n    }\n    // State transition: first row and first column\n    for a := 1; a &lt;= amt; a++ {\n        dp[0][a] = max\n    }\n    // State transition: rest of the rows and columns\n    for i := 1; i &lt;= n; i++ {\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i-1][a]\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = int(math.Min(float64(dp[i-1][a]), float64(dp[i][a-coins[i-1]]+1)))\n            }\n        }\n    }\n    if dp[n][amt] != max {\n        return dp[n][amt]\n    }\n    return -1\n}\n</code></pre> coin_change.swift<pre><code>/* Coin change: Dynamic programming */\nfunc coinChangeDP(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    let MAX = amt + 1\n    // Initialize dp table\n    var dp = Array(repeating: Array(repeating: 0, count: amt + 1), count: n + 1)\n    // State transition: first row and first column\n    for a in 1 ... amt {\n        dp[0][a] = MAX\n    }\n    // State transition: rest of the rows and columns\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return dp[n][amt] != MAX ? dp[n][amt] : -1\n}\n</code></pre> coin_change.js<pre><code>/* Coin change: Dynamic programming */\nfunction coinChangeDP(coins, amt) {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // Initialize dp table\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // State transition: first row and first column\n    for (let a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // State transition: rest of the rows and columns\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] !== MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.ts<pre><code>/* Coin change: Dynamic programming */\nfunction coinChangeDP(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // Initialize dp table\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // State transition: first row and first column\n    for (let a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // State transition: rest of the rows and columns\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] !== MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.dart<pre><code>/* Coin change: Dynamic programming */\nint coinChangeDP(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  int MAX = amt + 1;\n  // Initialize dp table\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(amt + 1, 0));\n  // State transition: first row and first column\n  for (int a = 1; a &lt;= amt; a++) {\n    dp[0][a] = MAX;\n  }\n  // State transition: rest of the rows and columns\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // If exceeds target amount, don't select coin i\n        dp[i][a] = dp[i - 1][a];\n      } else {\n        // The smaller value between not selecting and selecting coin i\n        dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n      }\n    }\n  }\n  return dp[n][amt] != MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.rs<pre><code>/* Coin change: Dynamic programming */\nfn coin_change_dp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    let max = amt + 1;\n    // Initialize dp table\n    let mut dp = vec![vec![0; amt + 1]; n + 1];\n    // State transition: first row and first column\n    for a in 1..=amt {\n        dp[0][a] = max;\n    }\n    // State transition: rest of the rows and columns\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = std::cmp::min(dp[i - 1][a], dp[i][a - coins[i - 1] as usize] + 1);\n            }\n        }\n    }\n    if dp[n][amt] != max {\n        return dp[n][amt] as i32;\n    } else {\n        -1\n    }\n}\n</code></pre> coin_change.c<pre><code>/* Coin change: Dynamic programming */\nint coinChangeDP(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    int MAX = amt + 1;\n    // Initialize dp table\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(amt + 1, sizeof(int));\n    }\n    // State transition: first row and first column\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // State transition: rest of the rows and columns\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = myMin(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    int res = dp[n][amt] != MAX ? dp[n][amt] : -1;\n    // Free memory\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return res;\n}\n</code></pre> coin_change.kt<pre><code>/* Coin change: Dynamic programming */\nfun coinChangeDP(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    val MAX = amt + 1\n    // Initialize dp table\n    val dp = Array(n + 1) { IntArray(amt + 1) }\n    // State transition: first row and first column\n    for (a in 1..amt) {\n        dp[0][a] = MAX\n    }\n    // State transition: rest of the rows and columns\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return if (dp[n][amt] != MAX) dp[n][amt] else -1\n}\n</code></pre> coin_change.rb<pre><code>### Coin change: dynamic programming ###\ndef coin_change_dp(coins, amt)\n  n = coins.length\n  _MAX = amt + 1\n  # Initialize dp table\n  dp = Array.new(n + 1) { Array.new(amt + 1, 0) }\n  # State transition: first row and first column\n  (1...(amt + 1)).each { |a| dp[0][a] = _MAX }\n  # State transition: rest of the rows and columns\n  for i in 1...(n + 1)\n    for a in 1...(amt + 1)\n      if coins[i - 1] &gt; a\n        # If exceeds target amount, don't select coin i\n        dp[i][a] = dp[i - 1][a]\n      else\n        # The smaller value between not selecting and selecting coin i\n        dp[i][a] = [dp[i - 1][a], dp[i][a - coins[i - 1]] + 1].min\n      end\n    end\n  end\n  dp[n][amt] != _MAX ? dp[n][amt] : -1\nend\n</code></pre> <p>Figure 14-25 shows the dynamic programming process for coin change, which is very similar to the unbounded knapsack problem.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt;&lt;15&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-25 \u00a0 Dynamic programming process for coin change problem </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#3-space-optimization_1","title":"3. \u00a0 Space Optimization","text":"<p>The space optimization for the coin change problem is handled in the same way as the unbounded knapsack problem:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby coin_change.py<pre><code>def coin_change_dp_comp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"Coin change: Space-optimized dynamic programming\"\"\"\n    n = len(coins)\n    MAX = amt + 1\n    # Initialize dp table\n    dp = [MAX] * (amt + 1)\n    dp[0] = 0\n    # State transition\n    for i in range(1, n + 1):\n        # Traverse in forward order\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            else:\n                # The smaller value between not selecting and selecting coin i\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1)\n    return dp[amt] if dp[amt] != MAX else -1\n</code></pre> coin_change.cpp<pre><code>/* Coin change: Space-optimized dynamic programming */\nint coinChangeDPComp(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    int MAX = amt + 1;\n    // Initialize dp table\n    vector&lt;int&gt; dp(amt + 1, MAX);\n    dp[0] = 0;\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.java<pre><code>/* Coin change: Space-optimized dynamic programming */\nint coinChangeDPComp(int[] coins, int amt) {\n    int n = coins.length;\n    int MAX = amt + 1;\n    // Initialize dp table\n    int[] dp = new int[amt + 1];\n    Arrays.fill(dp, MAX);\n    dp[0] = 0;\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.cs<pre><code>/* Coin change: Space-optimized dynamic programming */\nint CoinChangeDPComp(int[] coins, int amt) {\n    int n = coins.Length;\n    int MAX = amt + 1;\n    // Initialize dp table\n    int[] dp = new int[amt + 1];\n    Array.Fill(dp, MAX);\n    dp[0] = 0;\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = Math.Min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.go<pre><code>/* Coin change: Dynamic programming */\nfunc coinChangeDPComp(coins []int, amt int) int {\n    n := len(coins)\n    max := amt + 1\n    // Initialize dp table\n    dp := make([]int, amt+1)\n    for i := 1; i &lt;= amt; i++ {\n        dp[i] = max\n    }\n    // State transition\n    for i := 1; i &lt;= n; i++ {\n        // Traverse in forward order\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = int(math.Min(float64(dp[a]), float64(dp[a-coins[i-1]]+1)))\n            }\n        }\n    }\n    if dp[amt] != max {\n        return dp[amt]\n    }\n    return -1\n}\n</code></pre> coin_change.swift<pre><code>/* Coin change: Space-optimized dynamic programming */\nfunc coinChangeDPComp(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    let MAX = amt + 1\n    // Initialize dp table\n    var dp = Array(repeating: MAX, count: amt + 1)\n    dp[0] = 0\n    // State transition\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1\n}\n</code></pre> coin_change.js<pre><code>/* Coin change: Space-optimized dynamic programming */\nfunction coinChangeDPComp(coins, amt) {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // Initialize dp table\n    const dp = Array.from({ length: amt + 1 }, () =&gt; MAX);\n    dp[0] = 0;\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] !== MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.ts<pre><code>/* Coin change: Space-optimized dynamic programming */\nfunction coinChangeDPComp(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // Initialize dp table\n    const dp = Array.from({ length: amt + 1 }, () =&gt; MAX);\n    dp[0] = 0;\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] !== MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.dart<pre><code>/* Coin change: Space-optimized dynamic programming */\nint coinChangeDPComp(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  int MAX = amt + 1;\n  // Initialize dp table\n  List&lt;int&gt; dp = List.filled(amt + 1, MAX);\n  dp[0] = 0;\n  // State transition\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // If exceeds target amount, don't select coin i\n        dp[a] = dp[a];\n      } else {\n        // The smaller value between not selecting and selecting coin i\n        dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);\n      }\n    }\n  }\n  return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.rs<pre><code>/* Coin change: Space-optimized dynamic programming */\nfn coin_change_dp_comp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    let max = amt + 1;\n    // Initialize dp table\n    let mut dp = vec![0; amt + 1];\n    dp.fill(max);\n    dp[0] = 0;\n    // State transition\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = std::cmp::min(dp[a], dp[a - coins[i - 1] as usize] + 1);\n            }\n        }\n    }\n    if dp[amt] != max {\n        return dp[amt] as i32;\n    } else {\n        -1\n    }\n}\n</code></pre> coin_change.c<pre><code>/* Coin change: Space-optimized dynamic programming */\nint coinChangeDPComp(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    int MAX = amt + 1;\n    // Initialize dp table\n    int *dp = malloc((amt + 1) * sizeof(int));\n    for (int j = 1; j &lt;= amt; j++) {\n        dp[j] = MAX;\n    } \n    dp[0] = 0;\n\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = myMin(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    int res = dp[amt] != MAX ? dp[amt] : -1;\n    // Free memory\n    free(dp);\n    return res;\n}\n</code></pre> coin_change.kt<pre><code>/* Coin change: Space-optimized dynamic programming */\nfun coinChangeDPComp(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    val MAX = amt + 1\n    // Initialize dp table\n    val dp = IntArray(amt + 1)\n    dp.fill(MAX)\n    dp[0] = 0\n    // State transition\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            } else {\n                // The smaller value between not selecting and selecting coin i\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return if (dp[amt] != MAX) dp[amt] else -1\n}\n</code></pre> coin_change.rb<pre><code>### Coin change: space-optimized DP ###\ndef coin_change_dp_comp(coins, amt)\n  n = coins.length\n  _MAX = amt + 1\n  # Initialize dp table\n  dp = Array.new(amt + 1, _MAX)\n  dp[0] = 0\n  # State transition\n  for i in 1...(n + 1)\n    # Traverse in forward order\n    for a in 1...(amt + 1)\n      if coins[i - 1] &gt; a\n        # If exceeds target amount, don't select coin i\n        dp[a] = dp[a]\n      else\n        # The smaller value between not selecting and selecting coin i\n        dp[a] = [dp[a], dp[a - coins[i - 1]] + 1].min\n      end\n    end\n  end\n  dp[amt] != _MAX ? dp[amt] : -1\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1453-coin-change-problem-ii","title":"14.5.3 \u00a0 Coin Change Problem Ii","text":"<p>Question</p> <p>Given \\(n\\) types of coins, where the denomination of the \\(i\\)-th type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\). Each type of coin can be selected multiple times. What is the number of coin combinations that can make up the target amount? An example is shown in Figure 14-26.</p> <p></p> <p> Figure 14-26 \u00a0 Example data for coin change problem II </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1-dynamic-programming-approach_2","title":"1. \u00a0 Dynamic Programming Approach","text":"<p>Compared to the previous problem, this problem's goal is to find the number of combinations, so the subproblem becomes: the number of combinations among the first \\(i\\) types of coins that can make up amount \\(a\\). The \\(dp\\) table remains a two-dimensional matrix of size \\((n+1) \\times (amt + 1)\\).</p> <p>The number of combinations for the current state equals the sum of the combinations from not selecting the current coin and selecting the current coin. The state transition equation is:</p> \\[ dp[i, a] = dp[i-1, a] + dp[i, a - coins[i-1]] \\] <p>When the target amount is \\(0\\), no coins need to be selected to make up the target amount, so all \\(dp[i, 0]\\) in the first column should be initialized to \\(1\\). When there are no coins, it is impossible to make up any amount \\(&gt;0\\), so all \\(dp[0, a]\\) in the first row equal \\(0\\).</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#2-code-implementation_2","title":"2. \u00a0 Code Implementation","text":"PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby coin_change_ii.py<pre><code>def coin_change_ii_dp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"Coin change II: Dynamic programming\"\"\"\n    n = len(coins)\n    # Initialize dp table\n    dp = [[0] * (amt + 1) for _ in range(n + 1)]\n    # Initialize first column\n    for i in range(n + 1):\n        dp[i][0] = 1\n    # State transition\n    for i in range(1, n + 1):\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a]\n            else:\n                # Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]]\n    return dp[n][amt]\n</code></pre> coin_change_ii.cpp<pre><code>/* Coin change II: Dynamic programming */\nint coinChangeIIDP(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    // Initialize dp table\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amt + 1, 0));\n    // Initialize first column\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.java<pre><code>/* Coin change II: Dynamic programming */\nint coinChangeIIDP(int[] coins, int amt) {\n    int n = coins.length;\n    // Initialize dp table\n    int[][] dp = new int[n + 1][amt + 1];\n    // Initialize first column\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.cs<pre><code>/* Coin change II: Dynamic programming */\nint CoinChangeIIDP(int[] coins, int amt) {\n    int n = coins.Length;\n    // Initialize dp table\n    int[,] dp = new int[n + 1, amt + 1];\n    // Initialize first column\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i, 0] = 1;\n    }\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i, a] = dp[i - 1, a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i, a] = dp[i - 1, a] + dp[i, a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n, amt];\n}\n</code></pre> coin_change_ii.go<pre><code>/* Coin change II: Dynamic programming */\nfunc coinChangeIIDP(coins []int, amt int) int {\n    n := len(coins)\n    // Initialize dp table\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, amt+1)\n    }\n    // Initialize first column\n    for i := 0; i &lt;= n; i++ {\n        dp[i][0] = 1\n    }\n    // State transition: rest of the rows and columns\n    for i := 1; i &lt;= n; i++ {\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i-1][a]\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i-1][a] + dp[i][a-coins[i-1]]\n            }\n        }\n    }\n    return dp[n][amt]\n}\n</code></pre> coin_change_ii.swift<pre><code>/* Coin change II: Dynamic programming */\nfunc coinChangeIIDP(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    // Initialize dp table\n    var dp = Array(repeating: Array(repeating: 0, count: amt + 1), count: n + 1)\n    // Initialize first column\n    for i in 0 ... n {\n        dp[i][0] = 1\n    }\n    // State transition\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[n][amt]\n}\n</code></pre> coin_change_ii.js<pre><code>/* Coin change II: Dynamic programming */\nfunction coinChangeIIDP(coins, amt) {\n    const n = coins.length;\n    // Initialize dp table\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // Initialize first column\n    for (let i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.ts<pre><code>/* Coin change II: Dynamic programming */\nfunction coinChangeIIDP(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    // Initialize dp table\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // Initialize first column\n    for (let i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.dart<pre><code>/* Coin change II: Dynamic programming */\nint coinChangeIIDP(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  // Initialize dp table\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(amt + 1, 0));\n  // Initialize first column\n  for (int i = 0; i &lt;= n; i++) {\n    dp[i][0] = 1;\n  }\n  // State transition\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // If exceeds target amount, don't select coin i\n        dp[i][a] = dp[i - 1][a];\n      } else {\n        // Sum of the two options: not selecting and selecting coin i\n        dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n      }\n    }\n  }\n  return dp[n][amt];\n}\n</code></pre> coin_change_ii.rs<pre><code>/* Coin change II: Dynamic programming */\nfn coin_change_ii_dp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    // Initialize dp table\n    let mut dp = vec![vec![0; amt + 1]; n + 1];\n    // Initialize first column\n    for i in 0..=n {\n        dp[i][0] = 1;\n    }\n    // State transition\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1] as usize];\n            }\n        }\n    }\n    dp[n][amt]\n}\n</code></pre> coin_change_ii.c<pre><code>/* Coin change II: Dynamic programming */\nint coinChangeIIDP(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    // Initialize dp table\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(amt + 1, sizeof(int));\n    }\n    // Initialize first column\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    int res = dp[n][amt];\n    // Free memory\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return res;\n}\n</code></pre> coin_change_ii.kt<pre><code>/* Coin change II: Dynamic programming */\nfun coinChangeIIDP(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    // Initialize dp table\n    val dp = Array(n + 1) { IntArray(amt + 1) }\n    // Initialize first column\n    for (i in 0..n) {\n        dp[i][0] = 1\n    }\n    // State transition\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[n][amt]\n}\n</code></pre> coin_change_ii.rb<pre><code>### Coin change II: dynamic programming ###\ndef coin_change_ii_dp(coins, amt)\n  n = coins.length\n  # Initialize dp table\n  dp = Array.new(n + 1) { Array.new(amt + 1, 0) }\n  # Initialize first column\n  (0...(n + 1)).each { |i| dp[i][0] = 1 }\n  # State transition\n  for i in 1...(n + 1)\n    for a in 1...(amt + 1)\n      if coins[i - 1] &gt; a\n        # If exceeds target amount, don't select coin i\n        dp[i][a] = dp[i - 1][a]\n      else\n        # Sum of the two options: not selecting and selecting coin i\n        dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]]\n      end\n    end\n  end\n  dp[n][amt]\nend\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#3-space-optimization_2","title":"3. \u00a0 Space Optimization","text":"<p>The space optimization is handled in the same way, just delete the coin dimension:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby coin_change_ii.py<pre><code>def coin_change_ii_dp_comp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"Coin change II: Space-optimized dynamic programming\"\"\"\n    n = len(coins)\n    # Initialize dp table\n    dp = [0] * (amt + 1)\n    dp[0] = 1\n    # State transition\n    for i in range(1, n + 1):\n        # Traverse in forward order\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            else:\n                # Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]]\n    return dp[amt]\n</code></pre> coin_change_ii.cpp<pre><code>/* Coin change II: Space-optimized dynamic programming */\nint coinChangeIIDPComp(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    // Initialize dp table\n    vector&lt;int&gt; dp(amt + 1, 0);\n    dp[0] = 1;\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.java<pre><code>/* Coin change II: Space-optimized dynamic programming */\nint coinChangeIIDPComp(int[] coins, int amt) {\n    int n = coins.length;\n    // Initialize dp table\n    int[] dp = new int[amt + 1];\n    dp[0] = 1;\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.cs<pre><code>/* Coin change II: Space-optimized dynamic programming */\nint CoinChangeIIDPComp(int[] coins, int amt) {\n    int n = coins.Length;\n    // Initialize dp table\n    int[] dp = new int[amt + 1];\n    dp[0] = 1;\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.go<pre><code>/* Coin change II: Space-optimized dynamic programming */\nfunc coinChangeIIDPComp(coins []int, amt int) int {\n    n := len(coins)\n    // Initialize dp table\n    dp := make([]int, amt+1)\n    dp[0] = 1\n    // State transition\n    for i := 1; i &lt;= n; i++ {\n        // Traverse in forward order\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a-coins[i-1]]\n            }\n        }\n    }\n    return dp[amt]\n}\n</code></pre> coin_change_ii.swift<pre><code>/* Coin change II: Space-optimized dynamic programming */\nfunc coinChangeIIDPComp(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    // Initialize dp table\n    var dp = Array(repeating: 0, count: amt + 1)\n    dp[0] = 1\n    // State transition\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[amt]\n}\n</code></pre> coin_change_ii.js<pre><code>/* Coin change II: Space-optimized dynamic programming */\nfunction coinChangeIIDPComp(coins, amt) {\n    const n = coins.length;\n    // Initialize dp table\n    const dp = Array.from({ length: amt + 1 }, () =&gt; 0);\n    dp[0] = 1;\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.ts<pre><code>/* Coin change II: Space-optimized dynamic programming */\nfunction coinChangeIIDPComp(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    // Initialize dp table\n    const dp = Array.from({ length: amt + 1 }, () =&gt; 0);\n    dp[0] = 1;\n    // State transition\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.dart<pre><code>/* Coin change II: Space-optimized dynamic programming */\nint coinChangeIIDPComp(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  // Initialize dp table\n  List&lt;int&gt; dp = List.filled(amt + 1, 0);\n  dp[0] = 1;\n  // State transition\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // If exceeds target amount, don't select coin i\n        dp[a] = dp[a];\n      } else {\n        // Sum of the two options: not selecting and selecting coin i\n        dp[a] = dp[a] + dp[a - coins[i - 1]];\n      }\n    }\n  }\n  return dp[amt];\n}\n</code></pre> coin_change_ii.rs<pre><code>/* Coin change II: Space-optimized dynamic programming */\nfn coin_change_ii_dp_comp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    // Initialize dp table\n    let mut dp = vec![0; amt + 1];\n    dp[0] = 1;\n    // State transition\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1] as usize];\n            }\n        }\n    }\n    dp[amt]\n}\n</code></pre> coin_change_ii.c<pre><code>/* Coin change II: Space-optimized dynamic programming */\nint coinChangeIIDPComp(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    // Initialize dp table\n    int *dp = calloc(amt + 1, sizeof(int));\n    dp[0] = 1;\n    // State transition\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a];\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    int res = dp[amt];\n    // Free memory\n    free(dp);\n    return res;\n}\n</code></pre> coin_change_ii.kt<pre><code>/* Coin change II: Space-optimized dynamic programming */\nfun coinChangeIIDPComp(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    // Initialize dp table\n    val dp = IntArray(amt + 1)\n    dp[0] = 1\n    // State transition\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // If exceeds target amount, don't select coin i\n                dp[a] = dp[a]\n            } else {\n                // Sum of the two options: not selecting and selecting coin i\n                dp[a] = dp[a] + dp[a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[amt]\n}\n</code></pre> coin_change_ii.rb<pre><code>### Coin change II: space-optimized DP ###\ndef coin_change_ii_dp_comp(coins, amt)\n  n = coins.length\n  # Initialize dp table\n  dp = Array.new(amt + 1, 0)\n  dp[0] = 1\n  # State transition\n  for i in 1...(n + 1)\n    # Traverse in forward order\n    for a in 1...(amt + 1)\n      if coins[i - 1] &gt; a\n        # If exceeds target amount, don't select coin i\n        dp[a] = dp[a]\n      else\n        # Sum of the two options: not selecting and selecting coin i\n        dp[a] = dp[a] + dp[a - coins[i - 1]]\n      end\n    end\n  end\n  dp[amt]\nend\n</code></pre>"},{"location":"chapter_graph/","title":"Chapter 9. \u00a0 Graph","text":"<p>Abstract</p> <p>In the journey of life, we are like nodes, connected by countless invisible edges.</p> <p>Each encounter and parting leaves a unique mark on this vast network graph.</p>"},{"location":"chapter_graph/#chapter-contents","title":"Chapter contents","text":"<ul> <li>9.1 \u00a0 Graph</li> <li>9.2 \u00a0 Basic Operations on Graphs</li> <li>9.3 \u00a0 Graph Traversal</li> <li>9.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_graph/graph/","title":"9.1 \u00a0 Graph","text":"<p>A graph is a nonlinear data structure consisting of vertices and edges. We can abstractly represent a graph \\(G\\) as a set of vertices \\(V\\) and a set of edges \\(E\\). The following example shows a graph containing 5 vertices and 7 edges.</p> \\[ \\begin{aligned} V &amp; = \\{ 1, 2, 3, 4, 5 \\} \\newline E &amp; = \\{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \\} \\newline G &amp; = \\{ V, E \\} \\newline \\end{aligned} \\] <p>If we view vertices as nodes and edges as references (pointers) connecting the nodes, we can see graphs as a data structure extended from linked lists. As shown in Figure 9-1, compared to linear relationships (linked lists) and divide-and-conquer relationships (trees), network relationships (graphs) have a higher degree of freedom and are therefore more complex.</p> <p></p> <p> Figure 9-1 \u00a0 Relationships among linked lists, trees, and graphs </p>"},{"location":"chapter_graph/graph/#911-common-types-and-terminology-of-graphs","title":"9.1.1 \u00a0 Common Types and Terminology of Graphs","text":"<p>Graphs can be divided into undirected graphs and directed graphs based on whether edges have direction, as shown in Figure 9-2.</p> <ul> <li>In undirected graphs, edges represent a \"bidirectional\" connection between two vertices, such as the \"friend relationship\" on WeChat or QQ.</li> <li>In directed graphs, edges have directionality, meaning edges \\(A \\rightarrow B\\) and \\(A \\leftarrow B\\) are independent of each other, such as the \"follow\" and \"be followed\" relationships on Weibo or TikTok.</li> </ul> <p></p> <p> Figure 9-2 \u00a0 Directed and undirected graphs </p> <p>Graphs can be divided into connected graphs and disconnected graphs based on whether all vertices are connected, as shown in Figure 9-3.</p> <ul> <li>For connected graphs, starting from any vertex, all other vertices can be reached.</li> <li>For disconnected graphs, starting from a certain vertex, at least one vertex cannot be reached.</li> </ul> <p></p> <p> Figure 9-3 \u00a0 Connected and disconnected graphs </p> <p>We can also add a \"weight\" variable to edges, resulting in weighted graphs as shown in Figure 9-4. For example, in mobile games like \"Honor of Kings\", the system calculates the \"intimacy\" between players based on their shared game time, and such intimacy networks can be represented using weighted graphs.</p> <p></p> <p> Figure 9-4 \u00a0 Weighted and unweighted graphs </p> <p>Graph data structures include the following commonly used terms.</p> <ul> <li>Adjacency: When two vertices are connected by an edge, these two vertices are said to be \"adjacent\". In Figure 9-4, the adjacent vertices of vertex 1 are vertices 2, 3, and 5.</li> <li>Path: The sequence of edges from vertex A to vertex B is called a \"path\" from A to B. In Figure 9-4, the edge sequence 1-5-2-4 is a path from vertex 1 to vertex 4.</li> <li>Degree: The number of edges a vertex has. For directed graphs, in-degree indicates how many edges point to the vertex, and out-degree indicates how many edges point out from the vertex.</li> </ul>"},{"location":"chapter_graph/graph/#912-representation-of-graphs","title":"9.1.2 \u00a0 Representation of Graphs","text":"<p>Common representations of graphs include \"adjacency matrices\" and \"adjacency lists\". The following uses undirected graphs as examples.</p>"},{"location":"chapter_graph/graph/#1-adjacency-matrix","title":"1. \u00a0 Adjacency Matrix","text":"<p>Given a graph with \\(n\\) vertices, an adjacency matrix uses an \\(n \\times n\\) matrix to represent the graph, where each row (column) represents a vertex, and matrix elements represent edges, using \\(1\\) or \\(0\\) to indicate whether an edge exists between two vertices.</p> <p>As shown in Figure 9-5, let the adjacency matrix be \\(M\\) and the vertex list be \\(V\\). Then matrix element \\(M[i, j] = 1\\) indicates that an edge exists between vertex \\(V[i]\\) and vertex \\(V[j]\\), whereas \\(M[i, j] = 0\\) indicates no edge between the two vertices.</p> <p></p> <p> Figure 9-5 \u00a0 Adjacency matrix representation of a graph </p> <p>Adjacency matrices have the following properties.</p> <ul> <li>In simple graphs, vertices cannot connect to themselves, so the elements on the main diagonal of the adjacency matrix are meaningless.</li> <li>For undirected graphs, edges in both directions are equivalent, so the adjacency matrix is symmetric about the main diagonal.</li> <li>Replacing the elements of the adjacency matrix from \\(1\\) and \\(0\\) to weights allows representation of weighted graphs.</li> </ul> <p>When using adjacency matrices to represent graphs, we can directly access matrix elements to obtain edges, resulting in highly efficient addition, deletion, lookup, and modification operations, all with a time complexity of \\(O(1)\\). However, the space complexity of the matrix is \\(O(n^2)\\), which consumes significant memory.</p>"},{"location":"chapter_graph/graph/#2-adjacency-list","title":"2. \u00a0 Adjacency List","text":"<p>An adjacency list uses \\(n\\) linked lists to represent a graph, with linked list nodes representing vertices. The \\(i\\)-th linked list corresponds to vertex \\(i\\) and stores all adjacent vertices of that vertex (vertices connected to that vertex). Figure 9-6 shows an example of a graph stored using an adjacency list.</p> <p></p> <p> Figure 9-6 \u00a0 Adjacency list representation of a graph </p> <p>Adjacency lists only store edges that actually exist, and the total number of edges is typically much less than \\(n^2\\), making them more space-efficient. However, finding edges in an adjacency list requires traversing the linked list, so its time efficiency is inferior to that of adjacency matrices.</p> <p>Observing Figure 9-6, the structure of adjacency lists is very similar to \"chaining\" in hash tables, so we can adopt similar methods to optimize efficiency. For example, when linked lists are long, they can be converted to AVL trees or red-black trees, thereby optimizing time efficiency from \\(O(n)\\) to \\(O(\\log n)\\); linked lists can also be converted to hash tables, thereby reducing time complexity to \\(O(1)\\).</p>"},{"location":"chapter_graph/graph/#913-common-applications-of-graphs","title":"9.1.3 \u00a0 Common Applications of Graphs","text":"<p>As shown in Table 9-1, many real-world systems can be modeled using graphs, and corresponding problems can be reduced to graph computation problems.</p> <p> Table 9-1 \u00a0 Common graphs in real life </p> Vertices Edges Graph Computation Problem Social network Users Friend relationships Potential friend recommendation Subway lines Stations Connectivity between stations Shortest route recommendation Solar system Celestial bodies Gravitational forces between celestial bodies Planetary orbit calculation"},{"location":"chapter_graph/graph_operations/","title":"9.2 \u00a0 Basic Operations on Graphs","text":"<p>Basic operations on graphs can be divided into operations on \"edges\" and operations on \"vertices\". Under the two representation methods of \"adjacency matrix\" and \"adjacency list\", the implementation methods differ.</p>"},{"location":"chapter_graph/graph_operations/#921-implementation-based-on-adjacency-matrix","title":"9.2.1 \u00a0 Implementation Based on Adjacency Matrix","text":"<p>Given an undirected graph with \\(n\\) vertices, the various operations are implemented as shown in Figure 9-7.</p> <ul> <li>Adding or removing an edge: Directly modify the specified edge in the adjacency matrix, using \\(O(1)\\) time. Since it is an undirected graph, both directions of the edge need to be updated simultaneously.</li> <li>Adding a vertex: Add a row and a column at the end of the adjacency matrix and fill them all with \\(0\\)s, using \\(O(n)\\) time.</li> <li>Removing a vertex: Delete a row and a column in the adjacency matrix. The worst case occurs when removing the first row and column, requiring \\((n-1)^2\\) elements to be \"moved up and to the left\", thus using \\(O(n^2)\\) time.</li> <li>Initialization: Pass in \\(n\\) vertices, initialize a vertex list <code>vertices</code> of length \\(n\\), using \\(O(n)\\) time; initialize an adjacency matrix <code>adjMat</code> of size \\(n \\times n\\), using \\(O(n^2)\\) time.</li> </ul> Initialize adjacency matrixAdd an edgeRemove an edgeAdd a vertexRemove a vertex <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-7 \u00a0 Initialization, adding and removing edges, adding and removing vertices in adjacency matrix </p> <p>The following is the implementation code for graphs represented using an adjacency matrix:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby graph_adjacency_matrix.py<pre><code>class GraphAdjMat:\n    \"\"\"Undirected graph class based on adjacency matrix\"\"\"\n\n    def __init__(self, vertices: list[int], edges: list[list[int]]):\n        \"\"\"Constructor\"\"\"\n        # Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n        self.vertices: list[int] = []\n        # Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n        self.adj_mat: list[list[int]] = []\n        # Add vertices\n        for val in vertices:\n            self.add_vertex(val)\n        # Add edges\n        # Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for e in edges:\n            self.add_edge(e[0], e[1])\n\n    def size(self) -&gt; int:\n        \"\"\"Get the number of vertices\"\"\"\n        return len(self.vertices)\n\n    def add_vertex(self, val: int):\n        \"\"\"Add vertex\"\"\"\n        n = self.size()\n        # Add the value of the new vertex to the vertex list\n        self.vertices.append(val)\n        # Add a row to the adjacency matrix\n        new_row = [0] * n\n        self.adj_mat.append(new_row)\n        # Add a column to the adjacency matrix\n        for row in self.adj_mat:\n            row.append(0)\n\n    def remove_vertex(self, index: int):\n        \"\"\"Remove vertex\"\"\"\n        if index &gt;= self.size():\n            raise IndexError()\n        # Remove the vertex at index from the vertex list\n        self.vertices.pop(index)\n        # Remove the row at index from the adjacency matrix\n        self.adj_mat.pop(index)\n        # Remove the column at index from the adjacency matrix\n        for row in self.adj_mat:\n            row.pop(index)\n\n    def add_edge(self, i: int, j: int):\n        \"\"\"Add edge\"\"\"\n        # Parameters i, j correspond to the vertices element indices\n        # Handle index out of bounds and equality\n        if i &lt; 0 or j &lt; 0 or i &gt;= self.size() or j &gt;= self.size() or i == j:\n            raise IndexError()\n        # In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n        self.adj_mat[i][j] = 1\n        self.adj_mat[j][i] = 1\n\n    def remove_edge(self, i: int, j: int):\n        \"\"\"Remove edge\"\"\"\n        # Parameters i, j correspond to the vertices element indices\n        # Handle index out of bounds and equality\n        if i &lt; 0 or j &lt; 0 or i &gt;= self.size() or j &gt;= self.size() or i == j:\n            raise IndexError()\n        self.adj_mat[i][j] = 0\n        self.adj_mat[j][i] = 0\n\n    def print(self):\n        \"\"\"Print adjacency matrix\"\"\"\n        print(\"Vertex list =\", self.vertices)\n        print(\"Adjacency matrix =\")\n        print_matrix(self.adj_mat)\n</code></pre> graph_adjacency_matrix.cpp<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat {\n    vector&lt;int&gt; vertices;       // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    vector&lt;vector&lt;int&gt;&gt; adjMat; // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n  public:\n    /* Constructor */\n    GraphAdjMat(const vector&lt;int&gt; &amp;vertices, const vector&lt;vector&lt;int&gt;&gt; &amp;edges) {\n        // Add vertex\n        for (int val : vertices) {\n            addVertex(val);\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for (const vector&lt;int&gt; &amp;edge : edges) {\n            addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    int size() const {\n        return vertices.size();\n    }\n\n    /* Add vertex */\n    void addVertex(int val) {\n        int n = size();\n        // Add the value of the new vertex to the vertex list\n        vertices.push_back(val);\n        // Add a row to the adjacency matrix\n        adjMat.emplace_back(vector&lt;int&gt;(n, 0));\n        // Add a column to the adjacency matrix\n        for (vector&lt;int&gt; &amp;row : adjMat) {\n            row.push_back(0);\n        }\n    }\n\n    /* Remove vertex */\n    void removeVertex(int index) {\n        if (index &gt;= size()) {\n            throw out_of_range(\"Vertex does not exist\");\n        }\n        // Remove the vertex at index from the vertex list\n        vertices.erase(vertices.begin() + index);\n        // Remove the row at index from the adjacency matrix\n        adjMat.erase(adjMat.begin() + index);\n        // Remove the column at index from the adjacency matrix\n        for (vector&lt;int&gt; &amp;row : adjMat) {\n            row.erase(row.begin() + index);\n        }\n    }\n\n    /* Add edge */\n    // Parameters i, j correspond to the vertices element indices\n    void addEdge(int i, int j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n            throw out_of_range(\"Vertex does not exist\");\n        }\n        // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n        adjMat[i][j] = 1;\n        adjMat[j][i] = 1;\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    void removeEdge(int i, int j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n            throw out_of_range(\"Vertex does not exist\");\n        }\n        adjMat[i][j] = 0;\n        adjMat[j][i] = 0;\n    }\n\n    /* Print adjacency matrix */\n    void print() {\n        cout &lt;&lt; \"Vertex list = \";\n        printVector(vertices);\n        cout &lt;&lt; \"Adjacency matrix =\" &lt;&lt; endl;\n        printVectorMatrix(adjMat);\n    }\n};\n</code></pre> graph_adjacency_matrix.java<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat {\n    List&lt;Integer&gt; vertices; // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    List&lt;List&lt;Integer&gt;&gt; adjMat; // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n    /* Constructor */\n    public GraphAdjMat(int[] vertices, int[][] edges) {\n        this.vertices = new ArrayList&lt;&gt;();\n        this.adjMat = new ArrayList&lt;&gt;();\n        // Add vertex\n        for (int val : vertices) {\n            addVertex(val);\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for (int[] e : edges) {\n            addEdge(e[0], e[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    public int size() {\n        return vertices.size();\n    }\n\n    /* Add vertex */\n    public void addVertex(int val) {\n        int n = size();\n        // Add the value of the new vertex to the vertex list\n        vertices.add(val);\n        // Add a row to the adjacency matrix\n        List&lt;Integer&gt; newRow = new ArrayList&lt;&gt;(n);\n        for (int j = 0; j &lt; n; j++) {\n            newRow.add(0);\n        }\n        adjMat.add(newRow);\n        // Add a column to the adjacency matrix\n        for (List&lt;Integer&gt; row : adjMat) {\n            row.add(0);\n        }\n    }\n\n    /* Remove vertex */\n    public void removeVertex(int index) {\n        if (index &gt;= size())\n            throw new IndexOutOfBoundsException();\n        // Remove the vertex at index from the vertex list\n        vertices.remove(index);\n        // Remove the row at index from the adjacency matrix\n        adjMat.remove(index);\n        // Remove the column at index from the adjacency matrix\n        for (List&lt;Integer&gt; row : adjMat) {\n            row.remove(index);\n        }\n    }\n\n    /* Add edge */\n    // Parameters i, j correspond to the vertices element indices\n    public void addEdge(int i, int j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw new IndexOutOfBoundsException();\n        // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n        adjMat.get(i).set(j, 1);\n        adjMat.get(j).set(i, 1);\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    public void removeEdge(int i, int j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw new IndexOutOfBoundsException();\n        adjMat.get(i).set(j, 0);\n        adjMat.get(j).set(i, 0);\n    }\n\n    /* Print adjacency matrix */\n    public void print() {\n        System.out.print(\"Vertex list = \");\n        System.out.println(vertices);\n        System.out.println(\"Adjacency matrix =\");\n        PrintUtil.printMatrix(adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.cs<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat {\n    List&lt;int&gt; vertices;     // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    List&lt;List&lt;int&gt;&gt; adjMat; // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n    /* Constructor */\n    public GraphAdjMat(int[] vertices, int[][] edges) {\n        this.vertices = [];\n        this.adjMat = [];\n        // Add vertex\n        foreach (int val in vertices) {\n            AddVertex(val);\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        foreach (int[] e in edges) {\n            AddEdge(e[0], e[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    int Size() {\n        return vertices.Count;\n    }\n\n    /* Add vertex */\n    public void AddVertex(int val) {\n        int n = Size();\n        // Add the value of the new vertex to the vertex list\n        vertices.Add(val);\n        // Add a row to the adjacency matrix\n        List&lt;int&gt; newRow = new(n);\n        for (int j = 0; j &lt; n; j++) {\n            newRow.Add(0);\n        }\n        adjMat.Add(newRow);\n        // Add a column to the adjacency matrix\n        foreach (List&lt;int&gt; row in adjMat) {\n            row.Add(0);\n        }\n    }\n\n    /* Remove vertex */\n    public void RemoveVertex(int index) {\n        if (index &gt;= Size())\n            throw new IndexOutOfRangeException();\n        // Remove the vertex at index from the vertex list\n        vertices.RemoveAt(index);\n        // Remove the row at index from the adjacency matrix\n        adjMat.RemoveAt(index);\n        // Remove the column at index from the adjacency matrix\n        foreach (List&lt;int&gt; row in adjMat) {\n            row.RemoveAt(index);\n        }\n    }\n\n    /* Add edge */\n    // Parameters i, j correspond to the vertices element indices\n    public void AddEdge(int i, int j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= Size() || j &gt;= Size() || i == j)\n            throw new IndexOutOfRangeException();\n        // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n        adjMat[i][j] = 1;\n        adjMat[j][i] = 1;\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    public void RemoveEdge(int i, int j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= Size() || j &gt;= Size() || i == j)\n            throw new IndexOutOfRangeException();\n        adjMat[i][j] = 0;\n        adjMat[j][i] = 0;\n    }\n\n    /* Print adjacency matrix */\n    public void Print() {\n        Console.Write(\"Vertex list = \");\n        PrintUtil.PrintList(vertices);\n        Console.WriteLine(\"Adjacency matrix =\");\n        PrintUtil.PrintMatrix(adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.go<pre><code>/* Undirected graph class based on adjacency matrix */\ntype graphAdjMat struct {\n    // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    vertices []int\n    // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n    adjMat [][]int\n}\n\n/* Constructor */\nfunc newGraphAdjMat(vertices []int, edges [][]int) *graphAdjMat {\n    // Add vertex\n    n := len(vertices)\n    adjMat := make([][]int, n)\n    for i := range adjMat {\n        adjMat[i] = make([]int, n)\n    }\n    // Initialize graph\n    g := &amp;graphAdjMat{\n        vertices: vertices,\n        adjMat:   adjMat,\n    }\n    // Add edge\n    // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n    for i := range edges {\n        g.addEdge(edges[i][0], edges[i][1])\n    }\n    return g\n}\n\n/* Get the number of vertices */\nfunc (g *graphAdjMat) size() int {\n    return len(g.vertices)\n}\n\n/* Add vertex */\nfunc (g *graphAdjMat) addVertex(val int) {\n    n := g.size()\n    // Add the value of the new vertex to the vertex list\n    g.vertices = append(g.vertices, val)\n    // Add a row to the adjacency matrix\n    newRow := make([]int, n)\n    g.adjMat = append(g.adjMat, newRow)\n    // Add a column to the adjacency matrix\n    for i := range g.adjMat {\n        g.adjMat[i] = append(g.adjMat[i], 0)\n    }\n}\n\n/* Remove vertex */\nfunc (g *graphAdjMat) removeVertex(index int) {\n    if index &gt;= g.size() {\n        return\n    }\n    // Remove the vertex at index from the vertex list\n    g.vertices = append(g.vertices[:index], g.vertices[index+1:]...)\n    // Remove the row at index from the adjacency matrix\n    g.adjMat = append(g.adjMat[:index], g.adjMat[index+1:]...)\n    // Remove the column at index from the adjacency matrix\n    for i := range g.adjMat {\n        g.adjMat[i] = append(g.adjMat[i][:index], g.adjMat[i][index+1:]...)\n    }\n}\n\n/* Add edge */\n// Parameters i, j correspond to the vertices element indices\nfunc (g *graphAdjMat) addEdge(i, j int) {\n    // Handle index out of bounds and equality\n    if i &lt; 0 || j &lt; 0 || i &gt;= g.size() || j &gt;= g.size() || i == j {\n        fmt.Errorf(\"%s\", \"Index Out Of Bounds Exception\")\n    }\n    // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n    g.adjMat[i][j] = 1\n    g.adjMat[j][i] = 1\n}\n\n/* Remove edge */\n// Parameters i, j correspond to the vertices element indices\nfunc (g *graphAdjMat) removeEdge(i, j int) {\n    // Handle index out of bounds and equality\n    if i &lt; 0 || j &lt; 0 || i &gt;= g.size() || j &gt;= g.size() || i == j {\n        fmt.Errorf(\"%s\", \"Index Out Of Bounds Exception\")\n    }\n    g.adjMat[i][j] = 0\n    g.adjMat[j][i] = 0\n}\n\n/* Print adjacency matrix */\nfunc (g *graphAdjMat) print() {\n    fmt.Printf(\"\\tVertex list = %v\\n\", g.vertices)\n    fmt.Printf(\"\\tAdjacency matrix = \\n\")\n    for i := range g.adjMat {\n        fmt.Printf(\"\\t\\t\\t%v\\n\", g.adjMat[i])\n    }\n}\n</code></pre> graph_adjacency_matrix.swift<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat {\n    private var vertices: [Int] // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    private var adjMat: [[Int]] // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n    /* Constructor */\n    init(vertices: [Int], edges: [[Int]]) {\n        self.vertices = []\n        adjMat = []\n        // Add vertex\n        for val in vertices {\n            addVertex(val: val)\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for e in edges {\n            addEdge(i: e[0], j: e[1])\n        }\n    }\n\n    /* Get the number of vertices */\n    func size() -&gt; Int {\n        vertices.count\n    }\n\n    /* Add vertex */\n    func addVertex(val: Int) {\n        let n = size()\n        // Add the value of the new vertex to the vertex list\n        vertices.append(val)\n        // Add a row to the adjacency matrix\n        let newRow = Array(repeating: 0, count: n)\n        adjMat.append(newRow)\n        // Add a column to the adjacency matrix\n        for i in adjMat.indices {\n            adjMat[i].append(0)\n        }\n    }\n\n    /* Remove vertex */\n    func removeVertex(index: Int) {\n        if index &gt;= size() {\n            fatalError(\"Out of bounds\")\n        }\n        // Remove the vertex at index from the vertex list\n        vertices.remove(at: index)\n        // Remove the row at index from the adjacency matrix\n        adjMat.remove(at: index)\n        // Remove the column at index from the adjacency matrix\n        for i in adjMat.indices {\n            adjMat[i].remove(at: index)\n        }\n    }\n\n    /* Add edge */\n    // Parameters i, j correspond to the vertices element indices\n    func addEdge(i: Int, j: Int) {\n        // Handle index out of bounds and equality\n        if i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j {\n            fatalError(\"Out of bounds\")\n        }\n        // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n        adjMat[i][j] = 1\n        adjMat[j][i] = 1\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    func removeEdge(i: Int, j: Int) {\n        // Handle index out of bounds and equality\n        if i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j {\n            fatalError(\"Out of bounds\")\n        }\n        adjMat[i][j] = 0\n        adjMat[j][i] = 0\n    }\n\n    /* Print adjacency matrix */\n    func print() {\n        Swift.print(\"Vertex list = \", terminator: \"\")\n        Swift.print(vertices)\n        Swift.print(\"Adjacency matrix =\")\n        PrintUtil.printMatrix(matrix: adjMat)\n    }\n}\n</code></pre> graph_adjacency_matrix.js<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat {\n    vertices; // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    adjMat; // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n    /* Constructor */\n    constructor(vertices, edges) {\n        this.vertices = [];\n        this.adjMat = [];\n        // Add vertex\n        for (const val of vertices) {\n            this.addVertex(val);\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for (const e of edges) {\n            this.addEdge(e[0], e[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    size() {\n        return this.vertices.length;\n    }\n\n    /* Add vertex */\n    addVertex(val) {\n        const n = this.size();\n        // Add the value of the new vertex to the vertex list\n        this.vertices.push(val);\n        // Add a row to the adjacency matrix\n        const newRow = [];\n        for (let j = 0; j &lt; n; j++) {\n            newRow.push(0);\n        }\n        this.adjMat.push(newRow);\n        // Add a column to the adjacency matrix\n        for (const row of this.adjMat) {\n            row.push(0);\n        }\n    }\n\n    /* Remove vertex */\n    removeVertex(index) {\n        if (index &gt;= this.size()) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // Remove the vertex at index from the vertex list\n        this.vertices.splice(index, 1);\n\n        // Remove the row at index from the adjacency matrix\n        this.adjMat.splice(index, 1);\n        // Remove the column at index from the adjacency matrix\n        for (const row of this.adjMat) {\n            row.splice(index, 1);\n        }\n    }\n\n    /* Add edge */\n    // Parameters i, j correspond to the vertices element indices\n    addEdge(i, j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // In undirected graph, adjacency matrix is symmetric about main diagonal, i.e., satisfies (i, j) === (j, i)\n        this.adjMat[i][j] = 1;\n        this.adjMat[j][i] = 1;\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    removeEdge(i, j) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        this.adjMat[i][j] = 0;\n        this.adjMat[j][i] = 0;\n    }\n\n    /* Print adjacency matrix */\n    print() {\n        console.log('Vertex list = ', this.vertices);\n        console.log('Adjacency matrix =', this.adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.ts<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat {\n    vertices: number[]; // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    adjMat: number[][]; // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n    /* Constructor */\n    constructor(vertices: number[], edges: number[][]) {\n        this.vertices = [];\n        this.adjMat = [];\n        // Add vertex\n        for (const val of vertices) {\n            this.addVertex(val);\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for (const e of edges) {\n            this.addEdge(e[0], e[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    size(): number {\n        return this.vertices.length;\n    }\n\n    /* Add vertex */\n    addVertex(val: number): void {\n        const n: number = this.size();\n        // Add the value of the new vertex to the vertex list\n        this.vertices.push(val);\n        // Add a row to the adjacency matrix\n        const newRow: number[] = [];\n        for (let j: number = 0; j &lt; n; j++) {\n            newRow.push(0);\n        }\n        this.adjMat.push(newRow);\n        // Add a column to the adjacency matrix\n        for (const row of this.adjMat) {\n            row.push(0);\n        }\n    }\n\n    /* Remove vertex */\n    removeVertex(index: number): void {\n        if (index &gt;= this.size()) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // Remove the vertex at index from the vertex list\n        this.vertices.splice(index, 1);\n\n        // Remove the row at index from the adjacency matrix\n        this.adjMat.splice(index, 1);\n        // Remove the column at index from the adjacency matrix\n        for (const row of this.adjMat) {\n            row.splice(index, 1);\n        }\n    }\n\n    /* Add edge */\n    // Parameters i, j correspond to the vertices element indices\n    addEdge(i: number, j: number): void {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // In undirected graph, adjacency matrix is symmetric about main diagonal, i.e., satisfies (i, j) === (j, i)\n        this.adjMat[i][j] = 1;\n        this.adjMat[j][i] = 1;\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    removeEdge(i: number, j: number): void {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        this.adjMat[i][j] = 0;\n        this.adjMat[j][i] = 0;\n    }\n\n    /* Print adjacency matrix */\n    print(): void {\n        console.log('Vertex list = ', this.vertices);\n        console.log('Adjacency matrix =', this.adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.dart<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat {\n  List&lt;int&gt; vertices = []; // Vertex elements, elements represent \"vertex values\", indices represent \"vertex indices\"\n  List&lt;List&lt;int&gt;&gt; adjMat = []; // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n  /* Constructor */\n  GraphAdjMat(List&lt;int&gt; vertices, List&lt;List&lt;int&gt;&gt; edges) {\n    this.vertices = [];\n    this.adjMat = [];\n    // Add vertex\n    for (int val in vertices) {\n      addVertex(val);\n    }\n    // Add edge\n    // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n    for (List&lt;int&gt; e in edges) {\n      addEdge(e[0], e[1]);\n    }\n  }\n\n  /* Get the number of vertices */\n  int size() {\n    return vertices.length;\n  }\n\n  /* Add vertex */\n  void addVertex(int val) {\n    int n = size();\n    // Add the value of the new vertex to the vertex list\n    vertices.add(val);\n    // Add a row to the adjacency matrix\n    List&lt;int&gt; newRow = List.filled(n, 0, growable: true);\n    adjMat.add(newRow);\n    // Add a column to the adjacency matrix\n    for (List&lt;int&gt; row in adjMat) {\n      row.add(0);\n    }\n  }\n\n  /* Remove vertex */\n  void removeVertex(int index) {\n    if (index &gt;= size()) {\n      throw IndexError;\n    }\n    // Remove the vertex at index from the vertex list\n    vertices.removeAt(index);\n    // Remove the row at index from the adjacency matrix\n    adjMat.removeAt(index);\n    // Remove the column at index from the adjacency matrix\n    for (List&lt;int&gt; row in adjMat) {\n      row.removeAt(index);\n    }\n  }\n\n  /* Add edge */\n  // Parameters i, j correspond to the vertices element indices\n  void addEdge(int i, int j) {\n    // Handle index out of bounds and equality\n    if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n      throw IndexError;\n    }\n    // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n    adjMat[i][j] = 1;\n    adjMat[j][i] = 1;\n  }\n\n  /* Remove edge */\n  // Parameters i, j correspond to the vertices element indices\n  void removeEdge(int i, int j) {\n    // Handle index out of bounds and equality\n    if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n      throw IndexError;\n    }\n    adjMat[i][j] = 0;\n    adjMat[j][i] = 0;\n  }\n\n  /* Print adjacency matrix */\n  void printAdjMat() {\n    print(\"Vertex list = $vertices\");\n    print(\"Adjacency matrix = \");\n    printMatrix(adjMat);\n  }\n}\n</code></pre> graph_adjacency_matrix.rs<pre><code>/* Undirected graph type based on adjacency matrix */\npub struct GraphAdjMat {\n    // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    pub vertices: Vec&lt;i32&gt;,\n    // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n    pub adj_mat: Vec&lt;Vec&lt;i32&gt;&gt;,\n}\n\nimpl GraphAdjMat {\n    /* Constructor */\n    pub fn new(vertices: Vec&lt;i32&gt;, edges: Vec&lt;[usize; 2]&gt;) -&gt; Self {\n        let mut graph = GraphAdjMat {\n            vertices: vec![],\n            adj_mat: vec![],\n        };\n        // Add vertex\n        for val in vertices {\n            graph.add_vertex(val);\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for edge in edges {\n            graph.add_edge(edge[0], edge[1])\n        }\n\n        graph\n    }\n\n    /* Get the number of vertices */\n    pub fn size(&amp;self) -&gt; usize {\n        self.vertices.len()\n    }\n\n    /* Add vertex */\n    pub fn add_vertex(&amp;mut self, val: i32) {\n        let n = self.size();\n        // Add the value of the new vertex to the vertex list\n        self.vertices.push(val);\n        // Add a row to the adjacency matrix\n        self.adj_mat.push(vec![0; n]);\n        // Add a column to the adjacency matrix\n        for row in self.adj_mat.iter_mut() {\n            row.push(0);\n        }\n    }\n\n    /* Remove vertex */\n    pub fn remove_vertex(&amp;mut self, index: usize) {\n        if index &gt;= self.size() {\n            panic!(\"index error\")\n        }\n        // Remove the vertex at index from the vertex list\n        self.vertices.remove(index);\n        // Remove the row at index from the adjacency matrix\n        self.adj_mat.remove(index);\n        // Remove the column at index from the adjacency matrix\n        for row in self.adj_mat.iter_mut() {\n            row.remove(index);\n        }\n    }\n\n    /* Add edge */\n    pub fn add_edge(&amp;mut self, i: usize, j: usize) {\n        // Parameters i, j correspond to the vertices element indices\n        // Handle index out of bounds and equality\n        if i &gt;= self.size() || j &gt;= self.size() || i == j {\n            panic!(\"index error\")\n        }\n        // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n        self.adj_mat[i][j] = 1;\n        self.adj_mat[j][i] = 1;\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    pub fn remove_edge(&amp;mut self, i: usize, j: usize) {\n        // Parameters i, j correspond to the vertices element indices\n        // Handle index out of bounds and equality\n        if i &gt;= self.size() || j &gt;= self.size() || i == j {\n            panic!(\"index error\")\n        }\n        self.adj_mat[i][j] = 0;\n        self.adj_mat[j][i] = 0;\n    }\n\n    /* Print adjacency matrix */\n    pub fn print(&amp;self) {\n        println!(\"Vertex list = {:?}\", self.vertices);\n        println!(\"Adjacency matrix =\");\n        println!(\"[\");\n        for row in &amp;self.adj_mat {\n            println!(\"  {:?},\", row);\n        }\n        println!(\"]\")\n    }\n}\n</code></pre> graph_adjacency_matrix.c<pre><code>/* Undirected graph structure based on adjacency matrix */\ntypedef struct {\n    int vertices[MAX_SIZE];\n    int adjMat[MAX_SIZE][MAX_SIZE];\n    int size;\n} GraphAdjMat;\n\n/* Constructor */\nGraphAdjMat *newGraphAdjMat() {\n    GraphAdjMat *graph = (GraphAdjMat *)malloc(sizeof(GraphAdjMat));\n    graph-&gt;size = 0;\n    for (int i = 0; i &lt; MAX_SIZE; i++) {\n        for (int j = 0; j &lt; MAX_SIZE; j++) {\n            graph-&gt;adjMat[i][j] = 0;\n        }\n    }\n    return graph;\n}\n\n/* Destructor */\nvoid delGraphAdjMat(GraphAdjMat *graph) {\n    free(graph);\n}\n\n/* Add vertex */\nvoid addVertex(GraphAdjMat *graph, int val) {\n    if (graph-&gt;size == MAX_SIZE) {\n        fprintf(stderr, \"Graph vertex count has reached maximum\\n\");\n        return;\n    }\n    // Add nth vertex and zero nth row and column\n    int n = graph-&gt;size;\n    graph-&gt;vertices[n] = val;\n    for (int i = 0; i &lt;= n; i++) {\n        graph-&gt;adjMat[n][i] = graph-&gt;adjMat[i][n] = 0;\n    }\n    graph-&gt;size++;\n}\n\n/* Remove vertex */\nvoid removeVertex(GraphAdjMat *graph, int index) {\n    if (index &lt; 0 || index &gt;= graph-&gt;size) {\n        fprintf(stderr, \"Vertex index out of bounds\\n\");\n        return;\n    }\n    // Remove the vertex at index from the vertex list\n    for (int i = index; i &lt; graph-&gt;size - 1; i++) {\n        graph-&gt;vertices[i] = graph-&gt;vertices[i + 1];\n    }\n    // Remove the row at index from the adjacency matrix\n    for (int i = index; i &lt; graph-&gt;size - 1; i++) {\n        for (int j = 0; j &lt; graph-&gt;size; j++) {\n            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i + 1][j];\n        }\n    }\n    // Remove the column at index from the adjacency matrix\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        for (int j = index; j &lt; graph-&gt;size - 1; j++) {\n            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i][j + 1];\n        }\n    }\n    graph-&gt;size--;\n}\n\n/* Add edge */\n// Parameters i, j correspond to the vertices element indices\nvoid addEdge(GraphAdjMat *graph, int i, int j) {\n    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {\n        fprintf(stderr, \"Edge index out of bounds or equal\\n\");\n        return;\n    }\n    graph-&gt;adjMat[i][j] = 1;\n    graph-&gt;adjMat[j][i] = 1;\n}\n\n/* Remove edge */\n// Parameters i, j correspond to the vertices element indices\nvoid removeEdge(GraphAdjMat *graph, int i, int j) {\n    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {\n        fprintf(stderr, \"Edge index out of bounds or equal\\n\");\n        return;\n    }\n    graph-&gt;adjMat[i][j] = 0;\n    graph-&gt;adjMat[j][i] = 0;\n}\n\n/* Print adjacency matrix */\nvoid printGraphAdjMat(GraphAdjMat *graph) {\n    printf(\"Vertex list = \");\n    printArray(graph-&gt;vertices, graph-&gt;size);\n    printf(\"Adjacency matrix =\\n\");\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        printArray(graph-&gt;adjMat[i], graph-&gt;size);\n    }\n}\n</code></pre> graph_adjacency_matrix.kt<pre><code>/* Undirected graph class based on adjacency matrix */\nclass GraphAdjMat(vertices: IntArray, edges: Array&lt;IntArray&gt;) {\n    val vertices = mutableListOf&lt;Int&gt;() // Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    val adjMat = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() // Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n\n    /* Constructor */\n    init {\n        // Add vertex\n        for (vertex in vertices) {\n            addVertex(vertex)\n        }\n        // Add edge\n        // Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n        for (edge in edges) {\n            addEdge(edge[0], edge[1])\n        }\n    }\n\n    /* Get the number of vertices */\n    fun size(): Int {\n        return vertices.size\n    }\n\n    /* Add vertex */\n    fun addVertex(_val: Int) {\n        val n = size()\n        // Add the value of the new vertex to the vertex list\n        vertices.add(_val)\n        // Add a row to the adjacency matrix\n        val newRow = mutableListOf&lt;Int&gt;()\n        for (j in 0..&lt;n) {\n            newRow.add(0)\n        }\n        adjMat.add(newRow)\n        // Add a column to the adjacency matrix\n        for (row in adjMat) {\n            row.add(0)\n        }\n    }\n\n    /* Remove vertex */\n    fun removeVertex(index: Int) {\n        if (index &gt;= size())\n            throw IndexOutOfBoundsException()\n        // Remove the vertex at index from the vertex list\n        vertices.removeAt(index)\n        // Remove the row at index from the adjacency matrix\n        adjMat.removeAt(index)\n        // Remove the column at index from the adjacency matrix\n        for (row in adjMat) {\n            row.removeAt(index)\n        }\n    }\n\n    /* Add edge */\n    // Parameters i, j correspond to the vertices element indices\n    fun addEdge(i: Int, j: Int) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw IndexOutOfBoundsException()\n        // In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n        adjMat[i][j] = 1\n        adjMat[j][i] = 1\n    }\n\n    /* Remove edge */\n    // Parameters i, j correspond to the vertices element indices\n    fun removeEdge(i: Int, j: Int) {\n        // Handle index out of bounds and equality\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw IndexOutOfBoundsException()\n        adjMat[i][j] = 0\n        adjMat[j][i] = 0\n    }\n\n    /* Print adjacency matrix */\n    fun print() {\n        print(\"Vertex list = \")\n        println(vertices)\n        println(\"Adjacency matrix =\")\n        printMatrix(adjMat)\n    }\n}\n</code></pre> graph_adjacency_matrix.rb<pre><code>### Undirected graph class based on adjacency matrix ###\nclass GraphAdjMat\n  def initialize(vertices, edges)\n    ### Constructor ###\n    # Vertex list, where the element represents the \"vertex value\" and the index represents the \"vertex index\"\n    @vertices = []\n    # Adjacency matrix, where the row and column indices correspond to the \"vertex index\"\n    @adj_mat = []\n    # Add vertex\n    vertices.each { |val| add_vertex(val) }\n    # Add edge\n    # Note that the edges elements represent vertex indices, i.e., corresponding to the vertices element indices\n    edges.each { |e| add_edge(e[0], e[1]) }\n  end\n\n  ### Get number of vertices ###\n  def size\n    @vertices.length\n  end\n\n  ### Add vertex ###\n  def add_vertex(val)\n    n = size\n    # Add the value of the new vertex to the vertex list\n    @vertices &lt;&lt; val\n    # Add a row to the adjacency matrix\n    new_row = Array.new(n, 0)\n    @adj_mat &lt;&lt; new_row\n    # Add a column to the adjacency matrix\n    @adj_mat.each { |row| row &lt;&lt; 0 }\n  end\n\n  ### Delete vertex ###\n  def remove_vertex(index)\n    raise IndexError if index &gt;= size\n\n    # Remove the vertex at index from the vertex list\n    @vertices.delete_at(index)\n    # Remove the row at index from the adjacency matrix\n    @adj_mat.delete_at(index)\n    # Remove the column at index from the adjacency matrix\n    @adj_mat.each { |row| row.delete_at(index) }\n  end\n\n  ### Add edge ###\n  def add_edge(i, j)\n    # Parameters i, j correspond to the vertices element indices\n    # Handle index out of bounds and equality\n    if i &lt; 0 || j &lt; 0 || i &gt;= size || j &gt;= size || i == j\n      raise IndexError\n    end\n    # In an undirected graph, the adjacency matrix is symmetric about the main diagonal, i.e., (i, j) == (j, i)\n    @adj_mat[i][j] = 1\n    @adj_mat[j][i] = 1\n  end\n\n  ### Delete edge ###\n  def remove_edge(i, j)\n    # Parameters i, j correspond to the vertices element indices\n    # Handle index out of bounds and equality\n    if i &lt; 0 || j &lt; 0 || i &gt;= size || j &gt;= size || i == j\n      raise IndexError\n    end\n    @adj_mat[i][j] = 0\n    @adj_mat[j][i] = 0\n  end\n\n  ### Print adjacency matrix ###\n  def __print__\n    puts \"Vertex list = #{@vertices}\"\n    puts 'Adjacency matrix ='\n    print_matrix(@adj_mat)\n  end\nend\n</code></pre>"},{"location":"chapter_graph/graph_operations/#922-implementation-based-on-adjacency-list","title":"9.2.2 \u00a0 Implementation Based on Adjacency List","text":"<p>Given an undirected graph with a total of \\(n\\) vertices and \\(m\\) edges, the various operations can be implemented as shown in Figure 9-8.</p> <ul> <li>Adding an edge: Add the edge at the end of the corresponding vertex's linked list, using \\(O(1)\\) time. Since it is an undirected graph, edges in both directions need to be added simultaneously.</li> <li>Removing an edge: Find and remove the specified edge in the corresponding vertex's linked list, using \\(O(m)\\) time. In an undirected graph, edges in both directions need to be removed simultaneously.</li> <li>Adding a vertex: Add a linked list in the adjacency list and set the new vertex as the head node of the list, using \\(O(1)\\) time.</li> <li>Removing a vertex: Traverse the entire adjacency list and remove all edges containing the specified vertex, using \\(O(n + m)\\) time.</li> <li>Initialization: Create \\(n\\) vertices and \\(2m\\) edges in the adjacency list, using \\(O(n + m)\\) time.</li> </ul> Initialize adjacency listAdd an edgeRemove an edgeAdd a vertexRemove a vertex <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-8 \u00a0 Initialization, adding and removing edges, adding and removing vertices in adjacency list </p> <p>The following is the adjacency list code implementation. Compared to Figure 9-8, the actual code has the following differences.</p> <ul> <li>For convenience in adding and removing vertices, and to simplify the code, we use lists (dynamic arrays) instead of linked lists.</li> <li>A hash table is used to store the adjacency list, where <code>key</code> is the vertex instance and <code>value</code> is the list (linked list) of adjacent vertices for that vertex.</li> </ul> <p>Additionally, we use the <code>Vertex</code> class to represent vertices in the adjacency list. The reason for this is: if we used list indices to distinguish different vertices as with adjacency matrices, then to delete the vertex at index \\(i\\), we would need to traverse the entire adjacency list and decrement all indices greater than \\(i\\) by \\(1\\), which is very inefficient. However, if each vertex is a unique <code>Vertex</code> instance, deleting a vertex does not require modifying other vertices.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby graph_adjacency_list.py<pre><code>class GraphAdjList:\n    \"\"\"Undirected graph class based on adjacency list\"\"\"\n\n    def __init__(self, edges: list[list[Vertex]]):\n        \"\"\"Constructor\"\"\"\n        # Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n        self.adj_list = dict[Vertex, list[Vertex]]()\n        # Add all vertices and edges\n        for edge in edges:\n            self.add_vertex(edge[0])\n            self.add_vertex(edge[1])\n            self.add_edge(edge[0], edge[1])\n\n    def size(self) -&gt; int:\n        \"\"\"Get the number of vertices\"\"\"\n        return len(self.adj_list)\n\n    def add_edge(self, vet1: Vertex, vet2: Vertex):\n        \"\"\"Add edge\"\"\"\n        if vet1 not in self.adj_list or vet2 not in self.adj_list or vet1 == vet2:\n            raise ValueError()\n        # Add edge vet1 - vet2\n        self.adj_list[vet1].append(vet2)\n        self.adj_list[vet2].append(vet1)\n\n    def remove_edge(self, vet1: Vertex, vet2: Vertex):\n        \"\"\"Remove edge\"\"\"\n        if vet1 not in self.adj_list or vet2 not in self.adj_list or vet1 == vet2:\n            raise ValueError()\n        # Remove edge vet1 - vet2\n        self.adj_list[vet1].remove(vet2)\n        self.adj_list[vet2].remove(vet1)\n\n    def add_vertex(self, vet: Vertex):\n        \"\"\"Add vertex\"\"\"\n        if vet in self.adj_list:\n            return\n        # Add a new linked list in the adjacency list\n        self.adj_list[vet] = []\n\n    def remove_vertex(self, vet: Vertex):\n        \"\"\"Remove vertex\"\"\"\n        if vet not in self.adj_list:\n            raise ValueError()\n        # Remove the linked list corresponding to vertex vet in the adjacency list\n        self.adj_list.pop(vet)\n        # Traverse the linked lists of other vertices and remove all edges containing vet\n        for vertex in self.adj_list:\n            if vet in self.adj_list[vertex]:\n                self.adj_list[vertex].remove(vet)\n\n    def print(self):\n        \"\"\"Print adjacency list\"\"\"\n        print(\"Adjacency list =\")\n        for vertex in self.adj_list:\n            tmp = [v.val for v in self.adj_list[vertex]]\n            print(f\"{vertex.val}: {tmp},\")\n</code></pre> graph_adjacency_list.cpp<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList {\n  public:\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    unordered_map&lt;Vertex *, vector&lt;Vertex *&gt;&gt; adjList;\n\n    /* Remove specified node from vector */\n    void remove(vector&lt;Vertex *&gt; &amp;vec, Vertex *vet) {\n        for (int i = 0; i &lt; vec.size(); i++) {\n            if (vec[i] == vet) {\n                vec.erase(vec.begin() + i);\n                break;\n            }\n        }\n    }\n\n    /* Constructor */\n    GraphAdjList(const vector&lt;vector&lt;Vertex *&gt;&gt; &amp;edges) {\n        // Add all vertices and edges\n        for (const vector&lt;Vertex *&gt; &amp;edge : edges) {\n            addVertex(edge[0]);\n            addVertex(edge[1]);\n            addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    int size() {\n        return adjList.size();\n    }\n\n    /* Add edge */\n    void addEdge(Vertex *vet1, Vertex *vet2) {\n        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)\n            throw invalid_argument(\"Vertex does not exist\");\n        // Add edge vet1 - vet2\n        adjList[vet1].push_back(vet2);\n        adjList[vet2].push_back(vet1);\n    }\n\n    /* Remove edge */\n    void removeEdge(Vertex *vet1, Vertex *vet2) {\n        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)\n            throw invalid_argument(\"Vertex does not exist\");\n        // Remove edge vet1 - vet2\n        remove(adjList[vet1], vet2);\n        remove(adjList[vet2], vet1);\n    }\n\n    /* Add vertex */\n    void addVertex(Vertex *vet) {\n        if (adjList.count(vet))\n            return;\n        // Add a new linked list in the adjacency list\n        adjList[vet] = vector&lt;Vertex *&gt;();\n    }\n\n    /* Remove vertex */\n    void removeVertex(Vertex *vet) {\n        if (!adjList.count(vet))\n            throw invalid_argument(\"Vertex does not exist\");\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        adjList.erase(vet);\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        for (auto &amp;adj : adjList) {\n            remove(adj.second, vet);\n        }\n    }\n\n    /* Print adjacency list */\n    void print() {\n        cout &lt;&lt; \"Adjacency list =\" &lt;&lt; endl;\n        for (auto &amp;adj : adjList) {\n            const auto &amp;key = adj.first;\n            const auto &amp;vec = adj.second;\n            cout &lt;&lt; key-&gt;val &lt;&lt; \": \";\n            printVector(vetsToVals(vec));\n        }\n    }\n};\n</code></pre> graph_adjacency_list.java<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;\n\n    /* Constructor */\n    public GraphAdjList(Vertex[][] edges) {\n        this.adjList = new HashMap&lt;&gt;();\n        // Add all vertices and edges\n        for (Vertex[] edge : edges) {\n            addVertex(edge[0]);\n            addVertex(edge[1]);\n            addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    public int size() {\n        return adjList.size();\n    }\n\n    /* Add edge */\n    public void addEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw new IllegalArgumentException();\n        // Add edge vet1 - vet2\n        adjList.get(vet1).add(vet2);\n        adjList.get(vet2).add(vet1);\n    }\n\n    /* Remove edge */\n    public void removeEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw new IllegalArgumentException();\n        // Remove edge vet1 - vet2\n        adjList.get(vet1).remove(vet2);\n        adjList.get(vet2).remove(vet1);\n    }\n\n    /* Add vertex */\n    public void addVertex(Vertex vet) {\n        if (adjList.containsKey(vet))\n            return;\n        // Add a new linked list in the adjacency list\n        adjList.put(vet, new ArrayList&lt;&gt;());\n    }\n\n    /* Remove vertex */\n    public void removeVertex(Vertex vet) {\n        if (!adjList.containsKey(vet))\n            throw new IllegalArgumentException();\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        adjList.remove(vet);\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        for (List&lt;Vertex&gt; list : adjList.values()) {\n            list.remove(vet);\n        }\n    }\n\n    /* Print adjacency list */\n    public void print() {\n        System.out.println(\"Adjacency list =\");\n        for (Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt; pair : adjList.entrySet()) {\n            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n            for (Vertex vertex : pair.getValue())\n                tmp.add(vertex.val);\n            System.out.println(pair.getKey().val + \": \" + tmp + \",\");\n        }\n    }\n}\n</code></pre> graph_adjacency_list.cs<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    public Dictionary&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;\n\n    /* Constructor */\n    public GraphAdjList(Vertex[][] edges) {\n        adjList = [];\n        // Add all vertices and edges\n        foreach (Vertex[] edge in edges) {\n            AddVertex(edge[0]);\n            AddVertex(edge[1]);\n            AddEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    int Size() {\n        return adjList.Count;\n    }\n\n    /* Add edge */\n    public void AddEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.ContainsKey(vet1) || !adjList.ContainsKey(vet2) || vet1 == vet2)\n            throw new InvalidOperationException();\n        // Add edge vet1 - vet2\n        adjList[vet1].Add(vet2);\n        adjList[vet2].Add(vet1);\n    }\n\n    /* Remove edge */\n    public void RemoveEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.ContainsKey(vet1) || !adjList.ContainsKey(vet2) || vet1 == vet2)\n            throw new InvalidOperationException();\n        // Remove edge vet1 - vet2\n        adjList[vet1].Remove(vet2);\n        adjList[vet2].Remove(vet1);\n    }\n\n    /* Add vertex */\n    public void AddVertex(Vertex vet) {\n        if (adjList.ContainsKey(vet))\n            return;\n        // Add a new linked list in the adjacency list\n        adjList.Add(vet, []);\n    }\n\n    /* Remove vertex */\n    public void RemoveVertex(Vertex vet) {\n        if (!adjList.ContainsKey(vet))\n            throw new InvalidOperationException();\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        adjList.Remove(vet);\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        foreach (List&lt;Vertex&gt; list in adjList.Values) {\n            list.Remove(vet);\n        }\n    }\n\n    /* Print adjacency list */\n    public void Print() {\n        Console.WriteLine(\"Adjacency list =\");\n        foreach (KeyValuePair&lt;Vertex, List&lt;Vertex&gt;&gt; pair in adjList) {\n            List&lt;int&gt; tmp = [];\n            foreach (Vertex vertex in pair.Value)\n                tmp.Add(vertex.val);\n            Console.WriteLine(pair.Key.val + \": [\" + string.Join(\", \", tmp) + \"],\");\n        }\n    }\n}\n</code></pre> graph_adjacency_list.go<pre><code>/* Undirected graph class based on adjacency list */\ntype graphAdjList struct {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    adjList map[Vertex][]Vertex\n}\n\n/* Constructor */\nfunc newGraphAdjList(edges [][]Vertex) *graphAdjList {\n    g := &amp;graphAdjList{\n        adjList: make(map[Vertex][]Vertex),\n    }\n    // Add all vertices and edges\n    for _, edge := range edges {\n        g.addVertex(edge[0])\n        g.addVertex(edge[1])\n        g.addEdge(edge[0], edge[1])\n    }\n    return g\n}\n\n/* Get the number of vertices */\nfunc (g *graphAdjList) size() int {\n    return len(g.adjList)\n}\n\n/* Add edge */\nfunc (g *graphAdjList) addEdge(vet1 Vertex, vet2 Vertex) {\n    _, ok1 := g.adjList[vet1]\n    _, ok2 := g.adjList[vet2]\n    if !ok1 || !ok2 || vet1 == vet2 {\n        panic(\"error\")\n    }\n    // Add edge vet1 - vet2, add anonymous struct{},\n    g.adjList[vet1] = append(g.adjList[vet1], vet2)\n    g.adjList[vet2] = append(g.adjList[vet2], vet1)\n}\n\n/* Remove edge */\nfunc (g *graphAdjList) removeEdge(vet1 Vertex, vet2 Vertex) {\n    _, ok1 := g.adjList[vet1]\n    _, ok2 := g.adjList[vet2]\n    if !ok1 || !ok2 || vet1 == vet2 {\n        panic(\"error\")\n    }\n    // Remove edge vet1 - vet2\n    g.adjList[vet1] = DeleteSliceElms(g.adjList[vet1], vet2)\n    g.adjList[vet2] = DeleteSliceElms(g.adjList[vet2], vet1)\n}\n\n/* Add vertex */\nfunc (g *graphAdjList) addVertex(vet Vertex) {\n    _, ok := g.adjList[vet]\n    if ok {\n        return\n    }\n    // Add a new linked list in the adjacency list\n    g.adjList[vet] = make([]Vertex, 0)\n}\n\n/* Remove vertex */\nfunc (g *graphAdjList) removeVertex(vet Vertex) {\n    _, ok := g.adjList[vet]\n    if !ok {\n        panic(\"error\")\n    }\n    // Remove the linked list corresponding to vertex vet in the adjacency list\n    delete(g.adjList, vet)\n    // Traverse the linked lists of other vertices and remove all edges containing vet\n    for v, list := range g.adjList {\n        g.adjList[v] = DeleteSliceElms(list, vet)\n    }\n}\n\n/* Print adjacency list */\nfunc (g *graphAdjList) print() {\n    var builder strings.Builder\n    fmt.Printf(\"Adjacency list = \\n\")\n    for k, v := range g.adjList {\n        builder.WriteString(\"\\t\\t\" + strconv.Itoa(k.Val) + \": \")\n        for _, vet := range v {\n            builder.WriteString(strconv.Itoa(vet.Val) + \" \")\n        }\n        fmt.Println(builder.String())\n        builder.Reset()\n    }\n}\n</code></pre> graph_adjacency_list.swift<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    public private(set) var adjList: [Vertex: [Vertex]]\n\n    /* Constructor */\n    public init(edges: [[Vertex]]) {\n        adjList = [:]\n        // Add all vertices and edges\n        for edge in edges {\n            addVertex(vet: edge[0])\n            addVertex(vet: edge[1])\n            addEdge(vet1: edge[0], vet2: edge[1])\n        }\n    }\n\n    /* Get the number of vertices */\n    public func size() -&gt; Int {\n        adjList.count\n    }\n\n    /* Add edge */\n    public func addEdge(vet1: Vertex, vet2: Vertex) {\n        if adjList[vet1] == nil || adjList[vet2] == nil || vet1 == vet2 {\n            fatalError(\"Invalid parameter\")\n        }\n        // Add edge vet1 - vet2\n        adjList[vet1]?.append(vet2)\n        adjList[vet2]?.append(vet1)\n    }\n\n    /* Remove edge */\n    public func removeEdge(vet1: Vertex, vet2: Vertex) {\n        if adjList[vet1] == nil || adjList[vet2] == nil || vet1 == vet2 {\n            fatalError(\"Invalid parameter\")\n        }\n        // Remove edge vet1 - vet2\n        adjList[vet1]?.removeAll { $0 == vet2 }\n        adjList[vet2]?.removeAll { $0 == vet1 }\n    }\n\n    /* Add vertex */\n    public func addVertex(vet: Vertex) {\n        if adjList[vet] != nil {\n            return\n        }\n        // Add a new linked list in the adjacency list\n        adjList[vet] = []\n    }\n\n    /* Remove vertex */\n    public func removeVertex(vet: Vertex) {\n        if adjList[vet] == nil {\n            fatalError(\"Invalid parameter\")\n        }\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        adjList.removeValue(forKey: vet)\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        for key in adjList.keys {\n            adjList[key]?.removeAll { $0 == vet }\n        }\n    }\n\n    /* Print adjacency list */\n    public func print() {\n        Swift.print(\"Adjacency list =\")\n        for (vertex, list) in adjList {\n            let list = list.map { $0.val }\n            Swift.print(\"\\(vertex.val): \\(list),\")\n        }\n    }\n}\n</code></pre> graph_adjacency_list.js<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    adjList;\n\n    /* Constructor */\n    constructor(edges) {\n        this.adjList = new Map();\n        // Add all vertices and edges\n        for (const edge of edges) {\n            this.addVertex(edge[0]);\n            this.addVertex(edge[1]);\n            this.addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    size() {\n        return this.adjList.size;\n    }\n\n    /* Add edge */\n    addEdge(vet1, vet2) {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // Add edge vet1 - vet2\n        this.adjList.get(vet1).push(vet2);\n        this.adjList.get(vet2).push(vet1);\n    }\n\n    /* Remove edge */\n    removeEdge(vet1, vet2) {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2 ||\n            this.adjList.get(vet1).indexOf(vet2) === -1\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // Remove edge vet1 - vet2\n        this.adjList.get(vet1).splice(this.adjList.get(vet1).indexOf(vet2), 1);\n        this.adjList.get(vet2).splice(this.adjList.get(vet2).indexOf(vet1), 1);\n    }\n\n    /* Add vertex */\n    addVertex(vet) {\n        if (this.adjList.has(vet)) return;\n        // Add a new linked list in the adjacency list\n        this.adjList.set(vet, []);\n    }\n\n    /* Remove vertex */\n    removeVertex(vet) {\n        if (!this.adjList.has(vet)) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        this.adjList.delete(vet);\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        for (const set of this.adjList.values()) {\n            const index = set.indexOf(vet);\n            if (index &gt; -1) {\n                set.splice(index, 1);\n            }\n        }\n    }\n\n    /* Print adjacency list */\n    print() {\n        console.log('Adjacency list =');\n        for (const [key, value] of this.adjList) {\n            const tmp = [];\n            for (const vertex of value) {\n                tmp.push(vertex.val);\n            }\n            console.log(key.val + ': ' + tmp.join());\n        }\n    }\n}\n</code></pre> graph_adjacency_list.ts<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    adjList: Map&lt;Vertex, Vertex[]&gt;;\n\n    /* Constructor */\n    constructor(edges: Vertex[][]) {\n        this.adjList = new Map();\n        // Add all vertices and edges\n        for (const edge of edges) {\n            this.addVertex(edge[0]);\n            this.addVertex(edge[1]);\n            this.addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* Get the number of vertices */\n    size(): number {\n        return this.adjList.size;\n    }\n\n    /* Add edge */\n    addEdge(vet1: Vertex, vet2: Vertex): void {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // Add edge vet1 - vet2\n        this.adjList.get(vet1).push(vet2);\n        this.adjList.get(vet2).push(vet1);\n    }\n\n    /* Remove edge */\n    removeEdge(vet1: Vertex, vet2: Vertex): void {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2 ||\n            this.adjList.get(vet1).indexOf(vet2) === -1\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // Remove edge vet1 - vet2\n        this.adjList.get(vet1).splice(this.adjList.get(vet1).indexOf(vet2), 1);\n        this.adjList.get(vet2).splice(this.adjList.get(vet2).indexOf(vet1), 1);\n    }\n\n    /* Add vertex */\n    addVertex(vet: Vertex): void {\n        if (this.adjList.has(vet)) return;\n        // Add a new linked list in the adjacency list\n        this.adjList.set(vet, []);\n    }\n\n    /* Remove vertex */\n    removeVertex(vet: Vertex): void {\n        if (!this.adjList.has(vet)) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        this.adjList.delete(vet);\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        for (const set of this.adjList.values()) {\n            const index: number = set.indexOf(vet);\n            if (index &gt; -1) {\n                set.splice(index, 1);\n            }\n        }\n    }\n\n    /* Print adjacency list */\n    print(): void {\n        console.log('Adjacency list =');\n        for (const [key, value] of this.adjList.entries()) {\n            const tmp = [];\n            for (const vertex of value) {\n                tmp.push(vertex.val);\n            }\n            console.log(key.val + ': ' + tmp.join());\n        }\n    }\n}\n</code></pre> graph_adjacency_list.dart<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList {\n  // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n  Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList = {};\n\n  /* Constructor */\n  GraphAdjList(List&lt;List&lt;Vertex&gt;&gt; edges) {\n    for (List&lt;Vertex&gt; edge in edges) {\n      addVertex(edge[0]);\n      addVertex(edge[1]);\n      addEdge(edge[0], edge[1]);\n    }\n  }\n\n  /* Get the number of vertices */\n  int size() {\n    return adjList.length;\n  }\n\n  /* Add edge */\n  void addEdge(Vertex vet1, Vertex vet2) {\n    if (!adjList.containsKey(vet1) ||\n        !adjList.containsKey(vet2) ||\n        vet1 == vet2) {\n      throw ArgumentError;\n    }\n    // Add edge vet1 - vet2\n    adjList[vet1]!.add(vet2);\n    adjList[vet2]!.add(vet1);\n  }\n\n  /* Remove edge */\n  void removeEdge(Vertex vet1, Vertex vet2) {\n    if (!adjList.containsKey(vet1) ||\n        !adjList.containsKey(vet2) ||\n        vet1 == vet2) {\n      throw ArgumentError;\n    }\n    // Remove edge vet1 - vet2\n    adjList[vet1]!.remove(vet2);\n    adjList[vet2]!.remove(vet1);\n  }\n\n  /* Add vertex */\n  void addVertex(Vertex vet) {\n    if (adjList.containsKey(vet)) return;\n    // Add a new linked list in the adjacency list\n    adjList[vet] = [];\n  }\n\n  /* Remove vertex */\n  void removeVertex(Vertex vet) {\n    if (!adjList.containsKey(vet)) {\n      throw ArgumentError;\n    }\n    // Remove the linked list corresponding to vertex vet in the adjacency list\n    adjList.remove(vet);\n    // Traverse the linked lists of other vertices and remove all edges containing vet\n    adjList.forEach((key, value) {\n      value.remove(vet);\n    });\n  }\n\n  /* Print adjacency list */\n  void printAdjList() {\n    print(\"Adjacency list =\");\n    adjList.forEach((key, value) {\n      List&lt;int&gt; tmp = [];\n      for (Vertex vertex in value) {\n        tmp.add(vertex.val);\n      }\n      print(\"${key.val}: $tmp,\");\n    });\n  }\n}\n</code></pre> graph_adjacency_list.rs<pre><code>/* Undirected graph type based on adjacency list */\npub struct GraphAdjList {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    pub adj_list: HashMap&lt;Vertex, Vec&lt;Vertex&gt;&gt;, // maybe HashSet&lt;Vertex&gt; for value part is better?\n}\n\nimpl GraphAdjList {\n    /* Constructor */\n    pub fn new(edges: Vec&lt;[Vertex; 2]&gt;) -&gt; Self {\n        let mut graph = GraphAdjList {\n            adj_list: HashMap::new(),\n        };\n        // Add all vertices and edges\n        for edge in edges {\n            graph.add_vertex(edge[0]);\n            graph.add_vertex(edge[1]);\n            graph.add_edge(edge[0], edge[1]);\n        }\n\n        graph\n    }\n\n    /* Get the number of vertices */\n    #[allow(unused)]\n    pub fn size(&amp;self) -&gt; usize {\n        self.adj_list.len()\n    }\n\n    /* Add edge */\n    pub fn add_edge(&amp;mut self, vet1: Vertex, vet2: Vertex) {\n        if vet1 == vet2 {\n            panic!(\"value error\");\n        }\n        // Add edge vet1 - vet2\n        self.adj_list.entry(vet1).or_default().push(vet2);\n        self.adj_list.entry(vet2).or_default().push(vet1);\n    }\n\n    /* Remove edge */\n    #[allow(unused)]\n    pub fn remove_edge(&amp;mut self, vet1: Vertex, vet2: Vertex) {\n        if vet1 == vet2 {\n            panic!(\"value error\");\n        }\n        // Remove edge vet1 - vet2\n        self.adj_list\n            .entry(vet1)\n            .and_modify(|v| v.retain(|&amp;e| e != vet2));\n        self.adj_list\n            .entry(vet2)\n            .and_modify(|v| v.retain(|&amp;e| e != vet1));\n    }\n\n    /* Add vertex */\n    pub fn add_vertex(&amp;mut self, vet: Vertex) {\n        if self.adj_list.contains_key(&amp;vet) {\n            return;\n        }\n        // Add a new linked list in the adjacency list\n        self.adj_list.insert(vet, vec![]);\n    }\n\n    /* Remove vertex */\n    #[allow(unused)]\n    pub fn remove_vertex(&amp;mut self, vet: Vertex) {\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        self.adj_list.remove(&amp;vet);\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        for list in self.adj_list.values_mut() {\n            list.retain(|&amp;v| v != vet);\n        }\n    }\n\n    /* Print adjacency list */\n    pub fn print(&amp;self) {\n        println!(\"Adjacency list =\");\n        for (vertex, list) in &amp;self.adj_list {\n            let list = list.iter().map(|vertex| vertex.val).collect::&lt;Vec&lt;i32&gt;&gt;();\n            println!(\"{}: {:?},\", vertex.val, list);\n        }\n    }\n}\n</code></pre> graph_adjacency_list.c<pre><code>/* Node structure */\ntypedef struct AdjListNode {\n    Vertex *vertex;           // Vertex\n    struct AdjListNode *next; // Successor node\n} AdjListNode;\n\n/* Find node corresponding to vertex */\nAdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        if (graph-&gt;heads[i]-&gt;vertex == vet) {\n            return graph-&gt;heads[i];\n        }\n    }\n    return NULL;\n}\n\n/* Add edge helper function */\nvoid addEdgeHelper(AdjListNode *head, Vertex *vet) {\n    AdjListNode *node = (AdjListNode *)malloc(sizeof(AdjListNode));\n    node-&gt;vertex = vet;\n    // Head insertion\n    node-&gt;next = head-&gt;next;\n    head-&gt;next = node;\n}\n\n/* Remove edge helper function */\nvoid removeEdgeHelper(AdjListNode *head, Vertex *vet) {\n    AdjListNode *pre = head;\n    AdjListNode *cur = head-&gt;next;\n    // Search for node corresponding to vet in list\n    while (cur != NULL &amp;&amp; cur-&gt;vertex != vet) {\n        pre = cur;\n        cur = cur-&gt;next;\n    }\n    if (cur == NULL)\n        return;\n    // Remove node corresponding to vet from list\n    pre-&gt;next = cur-&gt;next;\n    // Free memory\n    free(cur);\n}\n\n/* Undirected graph class based on adjacency list */\ntypedef struct {\n    AdjListNode *heads[MAX_SIZE]; // Node array\n    int size;                     // Node count\n} GraphAdjList;\n\n/* Constructor */\nGraphAdjList *newGraphAdjList() {\n    GraphAdjList *graph = (GraphAdjList *)malloc(sizeof(GraphAdjList));\n    if (!graph) {\n        return NULL;\n    }\n    graph-&gt;size = 0;\n    for (int i = 0; i &lt; MAX_SIZE; i++) {\n        graph-&gt;heads[i] = NULL;\n    }\n    return graph;\n}\n\n/* Destructor */\nvoid delGraphAdjList(GraphAdjList *graph) {\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        AdjListNode *cur = graph-&gt;heads[i];\n        while (cur != NULL) {\n            AdjListNode *next = cur-&gt;next;\n            if (cur != graph-&gt;heads[i]) {\n                free(cur);\n            }\n            cur = next;\n        }\n        free(graph-&gt;heads[i]-&gt;vertex);\n        free(graph-&gt;heads[i]);\n    }\n    free(graph);\n}\n\n/* Find node corresponding to vertex */\nAdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        if (graph-&gt;heads[i]-&gt;vertex == vet) {\n            return graph-&gt;heads[i];\n        }\n    }\n    return NULL;\n}\n\n/* Add edge */\nvoid addEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {\n    AdjListNode *head1 = findNode(graph, vet1);\n    AdjListNode *head2 = findNode(graph, vet2);\n    assert(head1 != NULL &amp;&amp; head2 != NULL &amp;&amp; head1 != head2);\n    // Add edge vet1 - vet2\n    addEdgeHelper(head1, vet2);\n    addEdgeHelper(head2, vet1);\n}\n\n/* Remove edge */\nvoid removeEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {\n    AdjListNode *head1 = findNode(graph, vet1);\n    AdjListNode *head2 = findNode(graph, vet2);\n    assert(head1 != NULL &amp;&amp; head2 != NULL);\n    // Remove edge vet1 - vet2\n    removeEdgeHelper(head1, head2-&gt;vertex);\n    removeEdgeHelper(head2, head1-&gt;vertex);\n}\n\n/* Add vertex */\nvoid addVertex(GraphAdjList *graph, Vertex *vet) {\n    assert(graph != NULL &amp;&amp; graph-&gt;size &lt; MAX_SIZE);\n    AdjListNode *head = (AdjListNode *)malloc(sizeof(AdjListNode));\n    head-&gt;vertex = vet;\n    head-&gt;next = NULL;\n    // Add a new linked list in the adjacency list\n    graph-&gt;heads[graph-&gt;size++] = head;\n}\n\n/* Remove vertex */\nvoid removeVertex(GraphAdjList *graph, Vertex *vet) {\n    AdjListNode *node = findNode(graph, vet);\n    assert(node != NULL);\n    // Remove the linked list corresponding to vertex vet in the adjacency list\n    AdjListNode *cur = node, *pre = NULL;\n    while (cur) {\n        pre = cur;\n        cur = cur-&gt;next;\n        free(pre);\n    }\n    // Traverse the linked lists of other vertices and remove all edges containing vet\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        cur = graph-&gt;heads[i];\n        pre = NULL;\n        while (cur) {\n            pre = cur;\n            cur = cur-&gt;next;\n            if (cur &amp;&amp; cur-&gt;vertex == vet) {\n                pre-&gt;next = cur-&gt;next;\n                free(cur);\n                break;\n            }\n        }\n    }\n    // Move vertices after this vertex forward to fill gap\n    int i;\n    for (i = 0; i &lt; graph-&gt;size; i++) {\n        if (graph-&gt;heads[i] == node)\n            break;\n    }\n    for (int j = i; j &lt; graph-&gt;size - 1; j++) {\n        graph-&gt;heads[j] = graph-&gt;heads[j + 1];\n    }\n    graph-&gt;size--;\n    free(vet);\n}\n</code></pre> graph_adjacency_list.kt<pre><code>/* Undirected graph class based on adjacency list */\nclass GraphAdjList(edges: Array&lt;Array&lt;Vertex?&gt;&gt;) {\n    // Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    val adjList = HashMap&lt;Vertex, MutableList&lt;Vertex&gt;&gt;()\n\n    /* Constructor */\n    init {\n        // Add all vertices and edges\n        for (edge in edges) {\n            addVertex(edge[0]!!)\n            addVertex(edge[1]!!)\n            addEdge(edge[0]!!, edge[1]!!)\n        }\n    }\n\n    /* Get the number of vertices */\n    fun size(): Int {\n        return adjList.size\n    }\n\n    /* Add edge */\n    fun addEdge(vet1: Vertex, vet2: Vertex) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw IllegalArgumentException()\n        // Add edge vet1 - vet2\n        adjList[vet1]?.add(vet2)\n        adjList[vet2]?.add(vet1)\n    }\n\n    /* Remove edge */\n    fun removeEdge(vet1: Vertex, vet2: Vertex) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw IllegalArgumentException()\n        // Remove edge vet1 - vet2\n        adjList[vet1]?.remove(vet2)\n        adjList[vet2]?.remove(vet1)\n    }\n\n    /* Add vertex */\n    fun addVertex(vet: Vertex) {\n        if (adjList.containsKey(vet))\n            return\n        // Add a new linked list in the adjacency list\n        adjList[vet] = mutableListOf()\n    }\n\n    /* Remove vertex */\n    fun removeVertex(vet: Vertex) {\n        if (!adjList.containsKey(vet))\n            throw IllegalArgumentException()\n        // Remove the linked list corresponding to vertex vet in the adjacency list\n        adjList.remove(vet)\n        // Traverse the linked lists of other vertices and remove all edges containing vet\n        for (list in adjList.values) {\n            list.remove(vet)\n        }\n    }\n\n    /* Print adjacency list */\n    fun print() {\n        println(\"Adjacency list =\")\n        for (pair in adjList.entries) {\n            val tmp = mutableListOf&lt;Int&gt;()\n            for (vertex in pair.value) {\n                tmp.add(vertex._val)\n            }\n            println(\"${pair.key._val}: $tmp,\")\n        }\n    }\n}\n</code></pre> graph_adjacency_list.rb<pre><code>### Undirected graph class based on adjacency list ###\nclass GraphAdjList\n  attr_reader :adj_list\n\n  ### Constructor ###\n  def initialize(edges)\n    # Adjacency list, key: vertex, value: all adjacent vertices of that vertex\n    @adj_list = {}\n    # Add all vertices and edges\n    for edge in edges\n      add_vertex(edge[0])\n      add_vertex(edge[1])\n      add_edge(edge[0], edge[1])\n    end\n  end\n\n  ### Get number of vertices ###\n  def size\n    @adj_list.length\n  end\n\n  ### Add edge ###\n  def add_edge(vet1, vet2)\n    raise ArgumentError if !@adj_list.include?(vet1) || !@adj_list.include?(vet2)\n\n    @adj_list[vet1] &lt;&lt; vet2\n    @adj_list[vet2] &lt;&lt; vet1\n  end\n\n  ### Delete edge ###\n  def remove_edge(vet1, vet2)\n    raise ArgumentError if !@adj_list.include?(vet1) || !@adj_list.include?(vet2)\n\n    # Remove edge vet1 - vet2\n    @adj_list[vet1].delete(vet2)\n    @adj_list[vet2].delete(vet1)\n  end\n\n  ### Add vertex ###\n  def add_vertex(vet)\n    return if @adj_list.include?(vet)\n\n    # Add a new linked list in the adjacency list\n    @adj_list[vet] = []\n  end\n\n  ### Delete vertex ###\n  def remove_vertex(vet)\n    raise ArgumentError unless @adj_list.include?(vet)\n\n    # Remove the linked list corresponding to vertex vet in the adjacency list\n    @adj_list.delete(vet)\n    # Traverse the linked lists of other vertices and remove all edges containing vet\n    for vertex in @adj_list\n      @adj_list[vertex.first].delete(vet) if @adj_list[vertex.first].include?(vet)\n    end\n  end\n\n  ### Print adjacency list ###\n  def __print__\n    puts 'Adjacency list ='\n    for vertex in @adj_list\n      tmp = @adj_list[vertex.first].map { |v| v.val }\n      puts \"#{vertex.first.val}: #{tmp},\"\n    end\n  end\nend\n</code></pre>"},{"location":"chapter_graph/graph_operations/#923-efficiency-comparison","title":"9.2.3 \u00a0 Efficiency Comparison","text":"<p>Assuming the graph has \\(n\\) vertices and \\(m\\) edges, Table 9-2 compares the time efficiency and space efficiency of adjacency matrices and adjacency lists. Note that the adjacency list (linked list) corresponds to the implementation in this text, while the adjacency list (hash table) refers specifically to the implementation where all linked lists are replaced with hash tables.</p> <p> Table 9-2 \u00a0 Comparison of adjacency matrix and adjacency list </p> Adjacency matrix Adjacency list (linked list) Adjacency list (hash table) Determine adjacency \\(O(1)\\) \\(O(n)\\) \\(O(1)\\) Add an edge \\(O(1)\\) \\(O(1)\\) \\(O(1)\\) Remove an edge \\(O(1)\\) \\(O(n)\\) \\(O(1)\\) Add a vertex \\(O(n)\\) \\(O(1)\\) \\(O(1)\\) Remove a vertex \\(O(n^2)\\) \\(O(n + m)\\) \\(O(n)\\) Memory space usage \\(O(n^2)\\) \\(O(n + m)\\) \\(O(n + m)\\) <p>Observing Table 9-2, it appears that the adjacency list (hash table) has the best time efficiency and space efficiency. However, in practice, operating on edges in the adjacency matrix is more efficient, requiring only a single array access or assignment operation. Overall, adjacency matrices embody the principle of \"trading space for time\", while adjacency lists embody \"trading time for space\".</p>"},{"location":"chapter_graph/graph_traversal/","title":"9.3 \u00a0 Graph Traversal","text":"<p>Trees represent \"one-to-many\" relationships, while graphs have a higher degree of freedom and can represent any \"many-to-many\" relationships. Therefore, we can view trees as a special case of graphs. Clearly, tree traversal operations are also a special case of graph traversal operations.</p> <p>Both graphs and trees require the application of search algorithms to implement traversal operations. Graph traversal methods can also be divided into two types: breadth-first traversal and depth-first traversal.</p>"},{"location":"chapter_graph/graph_traversal/#931-breadth-first-search","title":"9.3.1 \u00a0 Breadth-First Search","text":"<p>Breadth-first search is a near-to-far traversal method that, starting from a certain node, always prioritizes visiting the nearest vertices and expands outward layer by layer. As shown in Figure 9-9, starting from the top-left vertex, first traverse all adjacent vertices of that vertex, then traverse all adjacent vertices of the next vertex, and so on, until all vertices have been visited.</p> <p></p> <p> Figure 9-9 \u00a0 Breadth-first search of a graph </p>"},{"location":"chapter_graph/graph_traversal/#1-algorithm-implementation","title":"1. \u00a0 Algorithm Implementation","text":"<p>BFS is typically implemented with the help of a queue, as shown in the code below. The queue has a \"first in, first out\" property, which aligns with the BFS idea of \"near to far\".</p> <ol> <li>Add the starting vertex <code>startVet</code> to the queue and begin the loop.</li> <li>In each iteration of the loop, pop the vertex at the front of the queue and record it as visited, then add all adjacent vertices of that vertex to the back of the queue.</li> <li>Repeat step <code>2.</code> until all vertices have been visited.</li> </ol> <p>To prevent revisiting vertices, we use a hash set <code>visited</code> to record which nodes have been visited.</p> <p>Tip</p> <p>A hash set can be viewed as a hash table that stores only <code>key</code> without storing <code>value</code>. It can perform addition, deletion, lookup, and modification operations on <code>key</code> in \\(O(1)\\) time complexity. Based on the uniqueness of <code>key</code>, hash sets are typically used for data deduplication and similar scenarios.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby graph_bfs.py<pre><code>def graph_bfs(graph: GraphAdjList, start_vet: Vertex) -&gt; list[Vertex]:\n    \"\"\"Breadth-first traversal\"\"\"\n    # Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\n    # Vertex traversal sequence\n    res = []\n    # Hash set for recording vertices that have been visited\n    visited = set[Vertex]([start_vet])\n    # Queue used to implement BFS\n    que = deque[Vertex]([start_vet])\n    # Starting from vertex vet, loop until all vertices are visited\n    while len(que) &gt; 0:\n        vet = que.popleft()  # Dequeue the front vertex\n        res.append(vet)  # Record visited vertex\n        # Traverse all adjacent vertices of this vertex\n        for adj_vet in graph.adj_list[vet]:\n            if adj_vet in visited:\n                continue  # Skip vertices that have been visited\n            que.append(adj_vet)  # Only enqueue unvisited vertices\n            visited.add(adj_vet)  # Mark this vertex as visited\n    # Return vertex traversal sequence\n    return res\n</code></pre> graph_bfs.cpp<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nvector&lt;Vertex *&gt; graphBFS(GraphAdjList &amp;graph, Vertex *startVet) {\n    // Vertex traversal sequence\n    vector&lt;Vertex *&gt; res;\n    // Hash set for recording vertices that have been visited\n    unordered_set&lt;Vertex *&gt; visited = {startVet};\n    // Queue used to implement BFS\n    queue&lt;Vertex *&gt; que;\n    que.push(startVet);\n    // Starting from vertex vet, loop until all vertices are visited\n    while (!que.empty()) {\n        Vertex *vet = que.front();\n        que.pop();          // Dequeue the front vertex\n        res.push_back(vet); // Record visited vertex\n        // Traverse all adjacent vertices of this vertex\n        for (auto adjVet : graph.adjList[vet]) {\n            if (visited.count(adjVet))\n                continue;            // Skip vertices that have been visited\n            que.push(adjVet);        // Only enqueue unvisited vertices\n            visited.emplace(adjVet); // Mark this vertex as visited\n        }\n    }\n    // Return vertex traversal sequence\n    return res;\n}\n</code></pre> graph_bfs.java<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nList&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) {\n    // Vertex traversal sequence\n    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();\n    // Hash set for recording vertices that have been visited\n    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();\n    visited.add(startVet);\n    // Queue used to implement BFS\n    Queue&lt;Vertex&gt; que = new LinkedList&lt;&gt;();\n    que.offer(startVet);\n    // Starting from vertex vet, loop until all vertices are visited\n    while (!que.isEmpty()) {\n        Vertex vet = que.poll(); // Dequeue the front vertex\n        res.add(vet);            // Record visited vertex\n        // Traverse all adjacent vertices of this vertex\n        for (Vertex adjVet : graph.adjList.get(vet)) {\n            if (visited.contains(adjVet))\n                continue;        // Skip vertices that have been visited\n            que.offer(adjVet);   // Only enqueue unvisited vertices\n            visited.add(adjVet); // Mark this vertex as visited\n        }\n    }\n    // Return vertex traversal sequence\n    return res;\n}\n</code></pre> graph_bfs.cs<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nList&lt;Vertex&gt; GraphBFS(GraphAdjList graph, Vertex startVet) {\n    // Vertex traversal sequence\n    List&lt;Vertex&gt; res = [];\n    // Hash set for recording vertices that have been visited\n    HashSet&lt;Vertex&gt; visited = [startVet];\n    // Queue used to implement BFS\n    Queue&lt;Vertex&gt; que = new();\n    que.Enqueue(startVet);\n    // Starting from vertex vet, loop until all vertices are visited\n    while (que.Count &gt; 0) {\n        Vertex vet = que.Dequeue(); // Dequeue the front vertex\n        res.Add(vet);               // Record visited vertex\n        foreach (Vertex adjVet in graph.adjList[vet]) {\n            if (visited.Contains(adjVet)) {\n                continue;          // Skip vertices that have been visited\n            }\n            que.Enqueue(adjVet);   // Only enqueue unvisited vertices\n            visited.Add(adjVet);   // Mark this vertex as visited\n        }\n    }\n\n    // Return vertex traversal sequence\n    return res;\n}\n</code></pre> graph_bfs.go<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunc graphBFS(g *graphAdjList, startVet Vertex) []Vertex {\n    // Vertex traversal sequence\n    res := make([]Vertex, 0)\n    // Hash set for recording vertices that have been visited\n    visited := make(map[Vertex]struct{})\n    visited[startVet] = struct{}{}\n    // Queue used to implement BFS, using slice to simulate queue\n    queue := make([]Vertex, 0)\n    queue = append(queue, startVet)\n    // Starting from vertex vet, loop until all vertices are visited\n    for len(queue) &gt; 0 {\n        // Dequeue the front vertex\n        vet := queue[0]\n        queue = queue[1:]\n        // Record visited vertex\n        res = append(res, vet)\n        // Traverse all adjacent vertices of this vertex\n        for _, adjVet := range g.adjList[vet] {\n            _, isExist := visited[adjVet]\n            // Only enqueue unvisited vertices\n            if !isExist {\n                queue = append(queue, adjVet)\n                visited[adjVet] = struct{}{}\n            }\n        }\n    }\n    // Return vertex traversal sequence\n    return res\n}\n</code></pre> graph_bfs.swift<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunc graphBFS(graph: GraphAdjList, startVet: Vertex) -&gt; [Vertex] {\n    // Vertex traversal sequence\n    var res: [Vertex] = []\n    // Hash set for recording vertices that have been visited\n    var visited: Set&lt;Vertex&gt; = [startVet]\n    // Queue used to implement BFS\n    var que: [Vertex] = [startVet]\n    // Starting from vertex vet, loop until all vertices are visited\n    while !que.isEmpty {\n        let vet = que.removeFirst() // Dequeue the front vertex\n        res.append(vet) // Record visited vertex\n        // Traverse all adjacent vertices of this vertex\n        for adjVet in graph.adjList[vet] ?? [] {\n            if visited.contains(adjVet) {\n                continue // Skip vertices that have been visited\n            }\n            que.append(adjVet) // Only enqueue unvisited vertices\n            visited.insert(adjVet) // Mark this vertex as visited\n        }\n    }\n    // Return vertex traversal sequence\n    return res\n}\n</code></pre> graph_bfs.js<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunction graphBFS(graph, startVet) {\n    // Vertex traversal sequence\n    const res = [];\n    // Hash set for recording vertices that have been visited\n    const visited = new Set();\n    visited.add(startVet);\n    // Queue used to implement BFS\n    const que = [startVet];\n    // Starting from vertex vet, loop until all vertices are visited\n    while (que.length) {\n        const vet = que.shift(); // Dequeue the front vertex\n        res.push(vet); // Record visited vertex\n        // Traverse all adjacent vertices of this vertex\n        for (const adjVet of graph.adjList.get(vet) ?? []) {\n            if (visited.has(adjVet)) {\n                continue; // Skip vertices that have been visited\n            }\n            que.push(adjVet); // Only enqueue unvisited vertices\n            visited.add(adjVet); // Mark this vertex as visited\n        }\n    }\n    // Return vertex traversal sequence\n    return res;\n}\n</code></pre> graph_bfs.ts<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunction graphBFS(graph: GraphAdjList, startVet: Vertex): Vertex[] {\n    // Vertex traversal sequence\n    const res: Vertex[] = [];\n    // Hash set for recording vertices that have been visited\n    const visited: Set&lt;Vertex&gt; = new Set();\n    visited.add(startVet);\n    // Queue used to implement BFS\n    const que = [startVet];\n    // Starting from vertex vet, loop until all vertices are visited\n    while (que.length) {\n        const vet = que.shift(); // Dequeue the front vertex\n        res.push(vet); // Record visited vertex\n        // Traverse all adjacent vertices of this vertex\n        for (const adjVet of graph.adjList.get(vet) ?? []) {\n            if (visited.has(adjVet)) {\n                continue; // Skip vertices that have been visited\n            }\n            que.push(adjVet); // Only enqueue unvisited\n            visited.add(adjVet); // Mark this vertex as visited\n        }\n    }\n    // Return vertex traversal sequence\n    return res;\n}\n</code></pre> graph_bfs.dart<pre><code>/* Breadth-first traversal */\nList&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) {\n  // Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\n  // Vertex traversal sequence\n  List&lt;Vertex&gt; res = [];\n  // Hash set for recording vertices that have been visited\n  Set&lt;Vertex&gt; visited = {};\n  visited.add(startVet);\n  // Queue used to implement BFS\n  Queue&lt;Vertex&gt; que = Queue();\n  que.add(startVet);\n  // Starting from vertex vet, loop until all vertices are visited\n  while (que.isNotEmpty) {\n    Vertex vet = que.removeFirst(); // Dequeue the front vertex\n    res.add(vet); // Record visited vertex\n    // Traverse all adjacent vertices of this vertex\n    for (Vertex adjVet in graph.adjList[vet]!) {\n      if (visited.contains(adjVet)) {\n        continue; // Skip vertices that have been visited\n      }\n      que.add(adjVet); // Only enqueue unvisited vertices\n      visited.add(adjVet); // Mark this vertex as visited\n    }\n  }\n  // Return vertex traversal sequence\n  return res;\n}\n</code></pre> graph_bfs.rs<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfn graph_bfs(graph: GraphAdjList, start_vet: Vertex) -&gt; Vec&lt;Vertex&gt; {\n    // Vertex traversal sequence\n    let mut res = vec![];\n    // Hash set for recording vertices that have been visited\n    let mut visited = HashSet::new();\n    visited.insert(start_vet);\n    // Queue used to implement BFS\n    let mut que = VecDeque::new();\n    que.push_back(start_vet);\n    // Starting from vertex vet, loop until all vertices are visited\n    while let Some(vet) = que.pop_front() {\n        res.push(vet); // Record visited vertex\n\n        // Traverse all adjacent vertices of this vertex\n        if let Some(adj_vets) = graph.adj_list.get(&amp;vet) {\n            for &amp;adj_vet in adj_vets {\n                if visited.contains(&amp;adj_vet) {\n                    continue; // Skip vertices that have been visited\n                }\n                que.push_back(adj_vet); // Only enqueue unvisited vertices\n                visited.insert(adj_vet); // Mark this vertex as visited\n            }\n        }\n    }\n    // Return vertex traversal sequence\n    res\n}\n</code></pre> graph_bfs.c<pre><code>/* Node queue structure */\ntypedef struct {\n    Vertex *vertices[MAX_SIZE];\n    int front, rear, size;\n} Queue;\n\n/* Constructor */\nQueue *newQueue() {\n    Queue *q = (Queue *)malloc(sizeof(Queue));\n    q-&gt;front = q-&gt;rear = q-&gt;size = 0;\n    return q;\n}\n\n/* Check if the queue is empty */\nint isEmpty(Queue *q) {\n    return q-&gt;size == 0;\n}\n\n/* Enqueue operation */\nvoid enqueue(Queue *q, Vertex *vet) {\n    q-&gt;vertices[q-&gt;rear] = vet;\n    q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE;\n    q-&gt;size++;\n}\n\n/* Dequeue operation */\nVertex *dequeue(Queue *q) {\n    Vertex *vet = q-&gt;vertices[q-&gt;front];\n    q-&gt;front = (q-&gt;front + 1) % MAX_SIZE;\n    q-&gt;size--;\n    return vet;\n}\n\n/* Check if vertex has been visited */\nint isVisited(Vertex **visited, int size, Vertex *vet) {\n    // Traverse to find node using O(n) time\n    for (int i = 0; i &lt; size; i++) {\n        if (visited[i] == vet)\n            return 1;\n    }\n    return 0;\n}\n\n/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nvoid graphBFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize, Vertex **visited, int *visitedSize) {\n    // Queue used to implement BFS\n    Queue *queue = newQueue();\n    enqueue(queue, startVet);\n    visited[(*visitedSize)++] = startVet;\n    // Starting from vertex vet, loop until all vertices are visited\n    while (!isEmpty(queue)) {\n        Vertex *vet = dequeue(queue); // Dequeue the front vertex\n        res[(*resSize)++] = vet;      // Record visited vertex\n        // Traverse all adjacent vertices of this vertex\n        AdjListNode *node = findNode(graph, vet);\n        while (node != NULL) {\n            // Skip vertices that have been visited\n            if (!isVisited(visited, *visitedSize, node-&gt;vertex)) {\n                enqueue(queue, node-&gt;vertex);             // Only enqueue unvisited vertices\n                visited[(*visitedSize)++] = node-&gt;vertex; // Mark this vertex as visited\n            }\n            node = node-&gt;next;\n        }\n    }\n    // Free memory\n    free(queue);\n}\n</code></pre> graph_bfs.kt<pre><code>/* Breadth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfun graphBFS(graph: GraphAdjList, startVet: Vertex): MutableList&lt;Vertex?&gt; {\n    // Vertex traversal sequence\n    val res = mutableListOf&lt;Vertex?&gt;()\n    // Hash set for recording vertices that have been visited\n    val visited = HashSet&lt;Vertex&gt;()\n    visited.add(startVet)\n    // Queue used to implement BFS\n    val que = LinkedList&lt;Vertex&gt;()\n    que.offer(startVet)\n    // Starting from vertex vet, loop until all vertices are visited\n    while (!que.isEmpty()) {\n        val vet = que.poll() // Dequeue the front vertex\n        res.add(vet)         // Record visited vertex\n        // Traverse all adjacent vertices of this vertex\n        for (adjVet in graph.adjList[vet]!!) {\n            if (visited.contains(adjVet))\n                continue        // Skip vertices that have been visited\n            que.offer(adjVet)   // Only enqueue unvisited vertices\n            visited.add(adjVet) // Mark this vertex as visited\n        }\n    }\n    // Return vertex traversal sequence\n    return res\n}\n</code></pre> graph_bfs.rb<pre><code>### Breadth-first traversal ###\ndef graph_bfs(graph, start_vet)\n  # Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\n  # Vertex traversal sequence\n  res = []\n  # Hash set for recording vertices that have been visited\n  visited = Set.new([start_vet])\n  # Queue used to implement BFS\n  que = [start_vet]\n  # Starting from vertex vet, loop until all vertices are visited\n  while que.length &gt; 0\n    vet = que.shift # Dequeue the front vertex\n    res &lt;&lt; vet # Record visited vertex\n    # Traverse all adjacent vertices of this vertex\n    for adj_vet in graph.adj_list[vet]\n      next if visited.include?(adj_vet) # Skip vertices that have been visited\n      que &lt;&lt; adj_vet # Only enqueue unvisited vertices\n      visited.add(adj_vet) # Mark this vertex as visited\n    end\n  end\n  # Return vertex traversal sequence\n  res\nend\n</code></pre> <p>The code is relatively abstract; it is recommended to refer to Figure 9-10 to deepen understanding.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-10 \u00a0 Steps of breadth-first search of a graph </p> <p>Is the breadth-first traversal sequence unique?</p> <p>Not unique. Breadth-first search only requires traversing in a \"near to far\" order, and the traversal order of vertices at the same distance can be arbitrarily shuffled. Taking Figure 9-10 as an example, the visit order of vertices \\(1\\) and \\(3\\) can be swapped, as can the visit order of vertices \\(2\\), \\(4\\), and \\(6\\).</p>"},{"location":"chapter_graph/graph_traversal/#2-complexity-analysis","title":"2. \u00a0 Complexity Analysis","text":"<p>Time complexity: All vertices will be enqueued and dequeued once, using \\(O(|V|)\\) time; in the process of traversing adjacent vertices, since it is an undirected graph, all edges will be visited \\(2\\) times, using \\(O(2|E|)\\) time; overall using \\(O(|V| + |E|)\\) time.</p> <p>Space complexity: The list <code>res</code>, hash set <code>visited</code>, and queue <code>que</code> can contain at most \\(|V|\\) vertices, using \\(O(|V|)\\) space.</p>"},{"location":"chapter_graph/graph_traversal/#932-depth-first-search","title":"9.3.2 \u00a0 Depth-First Search","text":"<p>Depth-first search is a traversal method that prioritizes going as far as possible, then backtracks when no path remains. As shown in Figure 9-11, starting from the top-left vertex, visit an adjacent vertex of the current vertex, continuing until reaching a dead end, then return and continue going as far as possible before returning again, and so on, until all vertices have been traversed.</p> <p></p> <p> Figure 9-11 \u00a0 Depth-first search of a graph </p>"},{"location":"chapter_graph/graph_traversal/#1-algorithm-implementation_1","title":"1. \u00a0 Algorithm Implementation","text":"<p>This \"go as far as possible then return\" algorithm paradigm is typically implemented using recursion. Similar to breadth-first search, in depth-first search we also need a hash set <code>visited</code> to record visited vertices and avoid revisiting.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby graph_dfs.py<pre><code>def dfs(graph: GraphAdjList, visited: set[Vertex], res: list[Vertex], vet: Vertex):\n    \"\"\"Depth-first traversal helper function\"\"\"\n    res.append(vet)  # Record visited vertex\n    visited.add(vet)  # Mark this vertex as visited\n    # Traverse all adjacent vertices of this vertex\n    for adjVet in graph.adj_list[vet]:\n        if adjVet in visited:\n            continue  # Skip vertices that have been visited\n        # Recursively visit adjacent vertices\n        dfs(graph, visited, res, adjVet)\n\ndef graph_dfs(graph: GraphAdjList, start_vet: Vertex) -&gt; list[Vertex]:\n    \"\"\"Depth-first traversal\"\"\"\n    # Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\n    # Vertex traversal sequence\n    res = []\n    # Hash set for recording vertices that have been visited\n    visited = set[Vertex]()\n    dfs(graph, visited, res, start_vet)\n    return res\n</code></pre> graph_dfs.cpp<pre><code>/* Depth-first traversal helper function */\nvoid dfs(GraphAdjList &amp;graph, unordered_set&lt;Vertex *&gt; &amp;visited, vector&lt;Vertex *&gt; &amp;res, Vertex *vet) {\n    res.push_back(vet);   // Record visited vertex\n    visited.emplace(vet); // Mark this vertex as visited\n    // Traverse all adjacent vertices of this vertex\n    for (Vertex *adjVet : graph.adjList[vet]) {\n        if (visited.count(adjVet))\n            continue; // Skip vertices that have been visited\n        // Recursively visit adjacent vertices\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nvector&lt;Vertex *&gt; graphDFS(GraphAdjList &amp;graph, Vertex *startVet) {\n    // Vertex traversal sequence\n    vector&lt;Vertex *&gt; res;\n    // Hash set for recording vertices that have been visited\n    unordered_set&lt;Vertex *&gt; visited;\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.java<pre><code>/* Depth-first traversal helper function */\nvoid dfs(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) {\n    res.add(vet);     // Record visited vertex\n    visited.add(vet); // Mark this vertex as visited\n    // Traverse all adjacent vertices of this vertex\n    for (Vertex adjVet : graph.adjList.get(vet)) {\n        if (visited.contains(adjVet))\n            continue; // Skip vertices that have been visited\n        // Recursively visit adjacent vertices\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nList&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) {\n    // Vertex traversal sequence\n    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();\n    // Hash set for recording vertices that have been visited\n    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.cs<pre><code>/* Depth-first traversal helper function */\nvoid DFS(GraphAdjList graph, HashSet&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) {\n    res.Add(vet);     // Record visited vertex\n    visited.Add(vet); // Mark this vertex as visited\n    // Traverse all adjacent vertices of this vertex\n    foreach (Vertex adjVet in graph.adjList[vet]) {\n        if (visited.Contains(adjVet)) {\n            continue; // Skip vertices that have been visited\n        }\n        // Recursively visit adjacent vertices\n        DFS(graph, visited, res, adjVet);\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nList&lt;Vertex&gt; GraphDFS(GraphAdjList graph, Vertex startVet) {\n    // Vertex traversal sequence\n    List&lt;Vertex&gt; res = [];\n    // Hash set for recording vertices that have been visited\n    HashSet&lt;Vertex&gt; visited = [];\n    DFS(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.go<pre><code>/* Depth-first traversal helper function */\nfunc dfs(g *graphAdjList, visited map[Vertex]struct{}, res *[]Vertex, vet Vertex) {\n    // append operation returns a new reference, must reassign original reference to new slice's reference\n    *res = append(*res, vet)\n    visited[vet] = struct{}{}\n    // Traverse all adjacent vertices of this vertex\n    for _, adjVet := range g.adjList[vet] {\n        _, isExist := visited[adjVet]\n        // Recursively visit adjacent vertices\n        if !isExist {\n            dfs(g, visited, res, adjVet)\n        }\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunc graphDFS(g *graphAdjList, startVet Vertex) []Vertex {\n    // Vertex traversal sequence\n    res := make([]Vertex, 0)\n    // Hash set for recording vertices that have been visited\n    visited := make(map[Vertex]struct{})\n    dfs(g, visited, &amp;res, startVet)\n    // Return vertex traversal sequence\n    return res\n}\n</code></pre> graph_dfs.swift<pre><code>/* Depth-first traversal helper function */\nfunc dfs(graph: GraphAdjList, visited: inout Set&lt;Vertex&gt;, res: inout [Vertex], vet: Vertex) {\n    res.append(vet) // Record visited vertex\n    visited.insert(vet) // Mark this vertex as visited\n    // Traverse all adjacent vertices of this vertex\n    for adjVet in graph.adjList[vet] ?? [] {\n        if visited.contains(adjVet) {\n            continue // Skip vertices that have been visited\n        }\n        // Recursively visit adjacent vertices\n        dfs(graph: graph, visited: &amp;visited, res: &amp;res, vet: adjVet)\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunc graphDFS(graph: GraphAdjList, startVet: Vertex) -&gt; [Vertex] {\n    // Vertex traversal sequence\n    var res: [Vertex] = []\n    // Hash set for recording vertices that have been visited\n    var visited: Set&lt;Vertex&gt; = []\n    dfs(graph: graph, visited: &amp;visited, res: &amp;res, vet: startVet)\n    return res\n}\n</code></pre> graph_dfs.js<pre><code>/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunction dfs(graph, visited, res, vet) {\n    res.push(vet); // Record visited vertex\n    visited.add(vet); // Mark this vertex as visited\n    // Traverse all adjacent vertices of this vertex\n    for (const adjVet of graph.adjList.get(vet)) {\n        if (visited.has(adjVet)) {\n            continue; // Skip vertices that have been visited\n        }\n        // Recursively visit adjacent vertices\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunction graphDFS(graph, startVet) {\n    // Vertex traversal sequence\n    const res = [];\n    // Hash set for recording vertices that have been visited\n    const visited = new Set();\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.ts<pre><code>/* Depth-first traversal helper function */\nfunction dfs(\n    graph: GraphAdjList,\n    visited: Set&lt;Vertex&gt;,\n    res: Vertex[],\n    vet: Vertex\n): void {\n    res.push(vet); // Record visited vertex\n    visited.add(vet); // Mark this vertex as visited\n    // Traverse all adjacent vertices of this vertex\n    for (const adjVet of graph.adjList.get(vet)) {\n        if (visited.has(adjVet)) {\n            continue; // Skip vertices that have been visited\n        }\n        // Recursively visit adjacent vertices\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfunction graphDFS(graph: GraphAdjList, startVet: Vertex): Vertex[] {\n    // Vertex traversal sequence\n    const res: Vertex[] = [];\n    // Hash set for recording vertices that have been visited\n    const visited: Set&lt;Vertex&gt; = new Set();\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.dart<pre><code>/* Depth-first traversal helper function */\nvoid dfs(\n  GraphAdjList graph,\n  Set&lt;Vertex&gt; visited,\n  List&lt;Vertex&gt; res,\n  Vertex vet,\n) {\n  res.add(vet); // Record visited vertex\n  visited.add(vet); // Mark this vertex as visited\n  // Traverse all adjacent vertices of this vertex\n  for (Vertex adjVet in graph.adjList[vet]!) {\n    if (visited.contains(adjVet)) {\n      continue; // Skip vertices that have been visited\n    }\n    // Recursively visit adjacent vertices\n    dfs(graph, visited, res, adjVet);\n  }\n}\n\n/* Depth-first traversal */\nList&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) {\n  // Vertex traversal sequence\n  List&lt;Vertex&gt; res = [];\n  // Hash set for recording vertices that have been visited\n  Set&lt;Vertex&gt; visited = {};\n  dfs(graph, visited, res, startVet);\n  return res;\n}\n</code></pre> graph_dfs.rs<pre><code>/* Depth-first traversal helper function */\nfn dfs(graph: &amp;GraphAdjList, visited: &amp;mut HashSet&lt;Vertex&gt;, res: &amp;mut Vec&lt;Vertex&gt;, vet: Vertex) {\n    res.push(vet); // Record visited vertex\n    visited.insert(vet); // Mark this vertex as visited\n                         // Traverse all adjacent vertices of this vertex\n    if let Some(adj_vets) = graph.adj_list.get(&amp;vet) {\n        for &amp;adj_vet in adj_vets {\n            if visited.contains(&amp;adj_vet) {\n                continue; // Skip vertices that have been visited\n            }\n            // Recursively visit adjacent vertices\n            dfs(graph, visited, res, adj_vet);\n        }\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfn graph_dfs(graph: GraphAdjList, start_vet: Vertex) -&gt; Vec&lt;Vertex&gt; {\n    // Vertex traversal sequence\n    let mut res = vec![];\n    // Hash set for recording vertices that have been visited\n    let mut visited = HashSet::new();\n    dfs(&amp;graph, &amp;mut visited, &amp;mut res, start_vet);\n\n    res\n}\n</code></pre> graph_dfs.c<pre><code>/* Check if vertex has been visited */\nint isVisited(Vertex **res, int size, Vertex *vet) {\n    // Traverse to find node using O(n) time\n    for (int i = 0; i &lt; size; i++) {\n        if (res[i] == vet) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Depth-first traversal helper function */\nvoid dfs(GraphAdjList *graph, Vertex **res, int *resSize, Vertex *vet) {\n    // Record visited vertex\n    res[(*resSize)++] = vet;\n    // Traverse all adjacent vertices of this vertex\n    AdjListNode *node = findNode(graph, vet);\n    while (node != NULL) {\n        // Skip vertices that have been visited\n        if (!isVisited(res, *resSize, node-&gt;vertex)) {\n            // Recursively visit adjacent vertices\n            dfs(graph, res, resSize, node-&gt;vertex);\n        }\n        node = node-&gt;next;\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nvoid graphDFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize) {\n    dfs(graph, res, resSize, startVet);\n}\n</code></pre> graph_dfs.kt<pre><code>/* Depth-first traversal helper function */\nfun dfs(\n    graph: GraphAdjList,\n    visited: MutableSet&lt;Vertex?&gt;,\n    res: MutableList&lt;Vertex?&gt;,\n    vet: Vertex?\n) {\n    res.add(vet)     // Record visited vertex\n    visited.add(vet) // Mark this vertex as visited\n    // Traverse all adjacent vertices of this vertex\n    for (adjVet in graph.adjList[vet]!!) {\n        if (visited.contains(adjVet))\n            continue  // Skip vertices that have been visited\n        // Recursively visit adjacent vertices\n        dfs(graph, visited, res, adjVet)\n    }\n}\n\n/* Depth-first traversal */\n// Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\nfun graphDFS(graph: GraphAdjList, startVet: Vertex?): MutableList&lt;Vertex?&gt; {\n    // Vertex traversal sequence\n    val res = mutableListOf&lt;Vertex?&gt;()\n    // Hash set for recording vertices that have been visited\n    val visited = HashSet&lt;Vertex?&gt;()\n    dfs(graph, visited, res, startVet)\n    return res\n}\n</code></pre> graph_dfs.rb<pre><code>### Depth-first traversal helper function ###\ndef dfs(graph, visited, res, vet)\n  res &lt;&lt; vet # Record visited vertex\n  visited.add(vet) # Mark this vertex as visited\n  # Traverse all adjacent vertices of this vertex\n  for adj_vet in graph.adj_list[vet]\n    next if visited.include?(adj_vet) # Skip vertices that have been visited\n    # Recursively visit adjacent vertices\n    dfs(graph, visited, res, adj_vet)\n  end\nend\n\n### Depth-first traversal ###\ndef graph_dfs(graph, start_vet)\n  # Use adjacency list to represent the graph, in order to obtain all adjacent vertices of a specified vertex\n  # Vertex traversal sequence\n  res = []\n  # Hash set for recording vertices that have been visited\n  visited = Set.new\n  dfs(graph, visited, res, start_vet)\n  res\nend\n</code></pre> <p>The algorithm flow of depth-first search is shown in Figure 9-12.</p> <ul> <li>Straight dashed lines represent downward recursion, indicating that a new recursive method has been initiated to visit a new vertex.</li> <li>Curved dashed lines represent upward backtracking, indicating that this recursive method has returned to the position where it was initiated.</li> </ul> <p>To deepen understanding, it is recommended to combine Figure 9-12 with the code to mentally simulate (or draw out) the entire DFS process, including when each recursive method is initiated and when it returns.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-12 \u00a0 Steps of depth-first search of a graph </p> <p>Is the depth-first traversal sequence unique?</p> <p>Similar to breadth-first search, the order of depth-first traversal sequences is also not unique. Given a certain vertex, exploring in any direction first is valid, meaning the order of adjacent vertices can be arbitrarily shuffled, all being depth-first search.</p> <p>Taking tree traversal as an example, \"root \\(\\rightarrow\\) left \\(\\rightarrow\\) right\", \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\", and \"left \\(\\rightarrow\\) right \\(\\rightarrow\\) root\" correspond to pre-order, in-order, and post-order traversals, respectively. They represent three different traversal priorities, yet all three belong to depth-first search.</p>"},{"location":"chapter_graph/graph_traversal/#2-complexity-analysis_1","title":"2. \u00a0 Complexity Analysis","text":"<p>Time complexity: All vertices will be visited \\(1\\) time, using \\(O(|V|)\\) time; all edges will be visited \\(2\\) times, using \\(O(2|E|)\\) time; overall using \\(O(|V| + |E|)\\) time.</p> <p>Space complexity: The list <code>res</code> and hash set <code>visited</code> can contain at most \\(|V|\\) vertices, and the maximum recursion depth is \\(|V|\\), therefore using \\(O(|V|)\\) space.</p>"},{"location":"chapter_graph/summary/","title":"9.4 \u00a0 Summary","text":""},{"location":"chapter_graph/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Graphs consist of vertices and edges and can be represented as a set of vertices and a set of edges.</li> <li>Compared to linear relationships (linked lists) and divide-and-conquer relationships (trees), network relationships (graphs) have a higher degree of freedom and are therefore more complex.</li> <li>Directed graphs have edges with directionality, connected graphs have all vertices reachable from any vertex, and weighted graphs have edges that each contain a weight variable.</li> <li>Adjacency matrices use matrices to represent graphs, where each row (column) represents a vertex, and matrix elements represent edges, using \\(1\\) or \\(0\\) to indicate whether two vertices have an edge or not. Adjacency matrices are highly efficient for addition, deletion, lookup, and modification operations, but consume significant space.</li> <li>Adjacency lists use multiple linked lists to represent graphs, where the \\(i\\)-th linked list corresponds to vertex \\(i\\) and stores all adjacent vertices of that vertex. Adjacency lists are more space-efficient than adjacency matrices, but have lower time efficiency because they require traversing linked lists to find edges.</li> <li>When linked lists in adjacency lists become too long, they can be converted to red-black trees or hash tables, thereby improving lookup efficiency.</li> <li>From an algorithmic perspective, adjacency matrices embody \"trading space for time\", while adjacency lists embody \"trading time for space\".</li> <li>Graphs can be used to model various real-world systems, such as social networks and subway lines.</li> <li>Trees are a special case of graphs, and tree traversal is a special case of graph traversal.</li> <li>Breadth-first search of graphs is a near-to-far, layer-by-layer expansion search method, typically implemented using a queue.</li> <li>Depth-first search of graphs is a search method that prioritizes going as far as possible and backtracks when no path remains, commonly implemented using recursion.</li> </ul>"},{"location":"chapter_graph/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Is a path defined as a sequence of vertices or a sequence of edges?</p> <p>The definitions in different language versions of Wikipedia are inconsistent: the English version states \"a path is a sequence of edges\", while the Chinese version states \"a path is a sequence of vertices\". The following is the original English text: In graph theory, a path in a graph is a finite or infinite sequence of edges which joins a sequence of vertices.</p> <p>In this text, a path is viewed as a sequence of edges, not a sequence of vertices. This is because there may be multiple edges connecting two vertices, in which case each edge corresponds to a path.</p> <p>Q: In a disconnected graph, will there be unreachable vertices?</p> <p>In a disconnected graph, starting from a certain vertex, at least one vertex cannot be reached. Traversing a disconnected graph requires setting multiple starting points to traverse all connected components of the graph.</p> <p>Q: In an adjacency list, is there a requirement for the order of \"all vertices connected to that vertex\"?</p> <p>It can be in any order. However, in practical applications, it may be necessary to sort according to specified rules, such as the order in which vertices were added, or the order of vertex values, which helps quickly find vertices \"with certain extreme values\".</p>"},{"location":"chapter_greedy/","title":"Chapter 15. \u00a0 Greedy","text":"<p>Abstract</p> <p>Sunflowers turn toward the sun, constantly pursuing the maximum potential for their own growth.</p> <p>Through rounds of simple choices, greedy strategies gradually lead to the best answer.</p>"},{"location":"chapter_greedy/#chapter-contents","title":"Chapter contents","text":"<ul> <li>15.1 \u00a0 Greedy Algorithm</li> <li>15.2 \u00a0 Fractional Knapsack Problem</li> <li>15.3 \u00a0 Maximum Capacity Problem</li> <li>15.4 \u00a0 Maximum Product Cutting Problem</li> <li>15.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_greedy/fractional_knapsack_problem/","title":"15.2 \u00a0 Fractional Knapsack Problem","text":"<p>Question</p> <p>Given \\(n\\) items, where the weight of the \\(i\\)-th item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a knapsack with capacity \\(cap\\). Each item can be selected only once, but a portion of an item can be selected, with the value calculated based on the proportion of weight selected, what is the maximum value of items in the knapsack under the limited capacity? An example is shown in Figure 15-3.</p> <p></p> <p> Figure 15-3 \u00a0 Example data for the fractional knapsack problem </p> <p>The fractional knapsack problem is very similar overall to the 0-1 knapsack problem, with states including the current item \\(i\\) and capacity \\(c\\), and the goal being to maximize value under the limited knapsack capacity.</p> <p>The difference is that this problem allows selecting only a portion of an item. As shown in Figure 15-4, we can arbitrarily split items and calculate the corresponding value based on the weight proportion.</p> <ol> <li>For item \\(i\\), its value per unit weight is \\(val[i-1] / wgt[i-1]\\), referred to as unit value.</li> <li>Suppose we put a portion of item \\(i\\) with weight \\(w\\) into the knapsack, then the value added to the knapsack is \\(w \\times val[i-1] / wgt[i-1]\\).</li> </ol> <p></p> <p> Figure 15-4 \u00a0 Value of items per unit weight </p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#1-greedy-strategy-determination","title":"1. \u00a0 Greedy Strategy Determination","text":"<p>Maximizing the total value of items in the knapsack is essentially maximizing the value per unit weight of items. From this, we can derive the greedy strategy shown in Figure 15-5.</p> <ol> <li>Sort items by unit value from high to low.</li> <li>Iterate through all items, greedily selecting the item with the highest unit value in each round.</li> <li>If the remaining knapsack capacity is insufficient, use a portion of the current item to fill the knapsack.</li> </ol> <p></p> <p> Figure 15-5 \u00a0 Greedy strategy for the fractional knapsack problem </p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#2-code-implementation","title":"2. \u00a0 Code Implementation","text":"<p>We created an <code>Item</code> class to facilitate sorting items by unit value. We loop to make greedy selections, breaking when the knapsack is full and returning the solution:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby fractional_knapsack.py<pre><code>class Item:\n    \"\"\"Item\"\"\"\n\n    def __init__(self, w: int, v: int):\n        self.w = w  # Item weight\n        self.v = v  # Item value\n\ndef fractional_knapsack(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"Fractional knapsack: Greedy algorithm\"\"\"\n    # Create item list with two attributes: weight, value\n    items = [Item(w, v) for w, v in zip(wgt, val)]\n    # Sort by unit value item.v / item.w from high to low\n    items.sort(key=lambda item: item.v / item.w, reverse=True)\n    # Loop for greedy selection\n    res = 0\n    for item in items:\n        if item.w &lt;= cap:\n            # If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v\n            cap -= item.w\n        else:\n            # If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += (item.v / item.w) * cap\n            # No remaining capacity, so break out of the loop\n            break\n    return res\n</code></pre> fractional_knapsack.cpp<pre><code>/* Item */\nclass Item {\n  public:\n    int w; // Item weight\n    int v; // Item value\n\n    Item(int w, int v) : w(w), v(v) {\n    }\n};\n\n/* Fractional knapsack: Greedy algorithm */\ndouble fractionalKnapsack(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    // Create item list with two attributes: weight, value\n    vector&lt;Item&gt; items;\n    for (int i = 0; i &lt; wgt.size(); i++) {\n        items.push_back(Item(wgt[i], val[i]));\n    }\n    // Sort by unit value item.v / item.w from high to low\n    sort(items.begin(), items.end(), [](Item &amp;a, Item &amp;b) { return (double)a.v / a.w &gt; (double)b.v / b.w; });\n    // Loop for greedy selection\n    double res = 0;\n    for (auto &amp;item : items) {\n        if (item.w &lt;= cap) {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += (double)item.v / item.w * cap;\n            // No remaining capacity, so break out of the loop\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.java<pre><code>/* Item */\nclass Item {\n    int w; // Item weight\n    int v; // Item value\n\n    public Item(int w, int v) {\n        this.w = w;\n        this.v = v;\n    }\n}\n\n/* Fractional knapsack: Greedy algorithm */\ndouble fractionalKnapsack(int[] wgt, int[] val, int cap) {\n    // Create item list with two attributes: weight, value\n    Item[] items = new Item[wgt.length];\n    for (int i = 0; i &lt; wgt.length; i++) {\n        items[i] = new Item(wgt[i], val[i]);\n    }\n    // Sort by unit value item.v / item.w from high to low\n    Arrays.sort(items, Comparator.comparingDouble(item -&gt; -((double) item.v / item.w)));\n    // Loop for greedy selection\n    double res = 0;\n    for (Item item : items) {\n        if (item.w &lt;= cap) {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += (double) item.v / item.w * cap;\n            // No remaining capacity, so break out of the loop\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.cs<pre><code>/* Item */\nclass Item(int w, int v) {\n    public int w = w; // Item weight\n    public int v = v; // Item value\n}\n\n/* Fractional knapsack: Greedy algorithm */\ndouble FractionalKnapsack(int[] wgt, int[] val, int cap) {\n    // Create item list with two attributes: weight, value\n    Item[] items = new Item[wgt.Length];\n    for (int i = 0; i &lt; wgt.Length; i++) {\n        items[i] = new Item(wgt[i], val[i]);\n    }\n    // Sort by unit value item.v / item.w from high to low\n    Array.Sort(items, (x, y) =&gt; (y.v / y.w).CompareTo(x.v / x.w));\n    // Loop for greedy selection\n    double res = 0;\n    foreach (Item item in items) {\n        if (item.w &lt;= cap) {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += (double)item.v / item.w * cap;\n            // No remaining capacity, so break out of the loop\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.go<pre><code>/* Item */\ntype Item struct {\n    w int // Item weight\n    v int // Item value\n}\n\n/* Fractional knapsack: Greedy algorithm */\nfunc fractionalKnapsack(wgt []int, val []int, cap int) float64 {\n    // Create item list with two attributes: weight, value\n    items := make([]Item, len(wgt))\n    for i := 0; i &lt; len(wgt); i++ {\n        items[i] = Item{wgt[i], val[i]}\n    }\n    // Sort by unit value item.v / item.w from high to low\n    sort.Slice(items, func(i, j int) bool {\n        return float64(items[i].v)/float64(items[i].w) &gt; float64(items[j].v)/float64(items[j].w)\n    })\n    // Loop for greedy selection\n    res := 0.0\n    for _, item := range items {\n        if item.w &lt;= cap {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += float64(item.v)\n            cap -= item.w\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += float64(item.v) / float64(item.w) * float64(cap)\n            // No remaining capacity, so break out of the loop\n            break\n        }\n    }\n    return res\n}\n</code></pre> fractional_knapsack.swift<pre><code>/* Item */\nclass Item {\n    var w: Int // Item weight\n    var v: Int // Item value\n\n    init(w: Int, v: Int) {\n        self.w = w\n        self.v = v\n    }\n}\n\n/* Fractional knapsack: Greedy algorithm */\nfunc fractionalKnapsack(wgt: [Int], val: [Int], cap: Int) -&gt; Double {\n    // Create item list with two attributes: weight, value\n    var items = zip(wgt, val).map { Item(w: $0, v: $1) }\n    // Sort by unit value item.v / item.w from high to low\n    items.sort { -(Double($0.v) / Double($0.w)) &lt; -(Double($1.v) / Double($1.w)) }\n    // Loop for greedy selection\n    var res = 0.0\n    var cap = cap\n    for item in items {\n        if item.w &lt;= cap {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += Double(item.v)\n            cap -= item.w\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += Double(item.v) / Double(item.w) * Double(cap)\n            // No remaining capacity, so break out of the loop\n            break\n        }\n    }\n    return res\n}\n</code></pre> fractional_knapsack.js<pre><code>/* Item */\nclass Item {\n    constructor(w, v) {\n        this.w = w; // Item weight\n        this.v = v; // Item value\n    }\n}\n\n/* Fractional knapsack: Greedy algorithm */\nfunction fractionalKnapsack(wgt, val, cap) {\n    // Create item list with two attributes: weight, value\n    const items = wgt.map((w, i) =&gt; new Item(w, val[i]));\n    // Sort by unit value item.v / item.w from high to low\n    items.sort((a, b) =&gt; b.v / b.w - a.v / a.w);\n    // Loop for greedy selection\n    let res = 0;\n    for (const item of items) {\n        if (item.w &lt;= cap) {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += (item.v / item.w) * cap;\n            // No remaining capacity, so break out of the loop\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.ts<pre><code>/* Item */\nclass Item {\n    w: number; // Item weight\n    v: number; // Item value\n\n    constructor(w: number, v: number) {\n        this.w = w;\n        this.v = v;\n    }\n}\n\n/* Fractional knapsack: Greedy algorithm */\nfunction fractionalKnapsack(wgt: number[], val: number[], cap: number): number {\n    // Create item list with two attributes: weight, value\n    const items: Item[] = wgt.map((w, i) =&gt; new Item(w, val[i]));\n    // Sort by unit value item.v / item.w from high to low\n    items.sort((a, b) =&gt; b.v / b.w - a.v / a.w);\n    // Loop for greedy selection\n    let res = 0;\n    for (const item of items) {\n        if (item.w &lt;= cap) {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += (item.v / item.w) * cap;\n            // No remaining capacity, so break out of the loop\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.dart<pre><code>/* Item */\nclass Item {\n  int w; // Item weight\n  int v; // Item value\n\n  Item(this.w, this.v);\n}\n\n/* Fractional knapsack: Greedy algorithm */\ndouble fractionalKnapsack(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  // Create item list with two attributes: weight, value\n  List&lt;Item&gt; items = List.generate(wgt.length, (i) =&gt; Item(wgt[i], val[i]));\n  // Sort by unit value item.v / item.w from high to low\n  items.sort((a, b) =&gt; (b.v / b.w).compareTo(a.v / a.w));\n  // Loop for greedy selection\n  double res = 0;\n  for (Item item in items) {\n    if (item.w &lt;= cap) {\n      // If remaining capacity is sufficient, put the entire current item into the knapsack\n      res += item.v;\n      cap -= item.w;\n    } else {\n      // If remaining capacity is insufficient, put part of the current item into the knapsack\n      res += item.v / item.w * cap;\n      // No remaining capacity, so break out of the loop\n      break;\n    }\n  }\n  return res;\n}\n</code></pre> fractional_knapsack.rs<pre><code>/* Item */\nstruct Item {\n    w: i32, // Item weight\n    v: i32, // Item value\n}\n\nimpl Item {\n    fn new(w: i32, v: i32) -&gt; Self {\n        Self { w, v }\n    }\n}\n\n/* Fractional knapsack: Greedy algorithm */\nfn fractional_knapsack(wgt: &amp;[i32], val: &amp;[i32], mut cap: i32) -&gt; f64 {\n    // Create item list with two attributes: weight, value\n    let mut items = wgt\n        .iter()\n        .zip(val.iter())\n        .map(|(&amp;w, &amp;v)| Item::new(w, v))\n        .collect::&lt;Vec&lt;Item&gt;&gt;();\n    // Sort by unit value item.v / item.w from high to low\n    items.sort_by(|a, b| {\n        (b.v as f64 / b.w as f64)\n            .partial_cmp(&amp;(a.v as f64 / a.w as f64))\n            .unwrap()\n    });\n    // Loop for greedy selection\n    let mut res = 0.0;\n    for item in &amp;items {\n        if item.w &lt;= cap {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v as f64;\n            cap -= item.w;\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += item.v as f64 / item.w as f64 * cap as f64;\n            // No remaining capacity, so break out of the loop\n            break;\n        }\n    }\n    res\n}\n</code></pre> fractional_knapsack.c<pre><code>/* Item */\ntypedef struct {\n    int w; // Item weight\n    int v; // Item value\n} Item;\n\n/* Fractional knapsack: Greedy algorithm */\nfloat fractionalKnapsack(int wgt[], int val[], int itemCount, int cap) {\n    // Create item list with two attributes: weight, value\n    Item *items = malloc(sizeof(Item) * itemCount);\n    for (int i = 0; i &lt; itemCount; i++) {\n        items[i] = (Item){.w = wgt[i], .v = val[i]};\n    }\n    // Sort by unit value item.v / item.w from high to low\n    qsort(items, (size_t)itemCount, sizeof(Item), sortByValueDensity);\n    // Loop for greedy selection\n    float res = 0.0;\n    for (int i = 0; i &lt; itemCount; i++) {\n        if (items[i].w &lt;= cap) {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += items[i].v;\n            cap -= items[i].w;\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += (float)cap / items[i].w * items[i].v;\n            cap = 0;\n            break;\n        }\n    }\n    free(items);\n    return res;\n}\n</code></pre> fractional_knapsack.kt<pre><code>/* Item */\nclass Item(\n    val w: Int, // Item\n    val v: Int  // Item value\n)\n\n/* Fractional knapsack: Greedy algorithm */\nfun fractionalKnapsack(wgt: IntArray, _val: IntArray, c: Int): Double {\n    // Create item list with two attributes: weight, value\n    var cap = c\n    val items = arrayOfNulls&lt;Item&gt;(wgt.size)\n    for (i in wgt.indices) {\n        items[i] = Item(wgt[i], _val[i])\n    }\n    // Sort by unit value item.v / item.w from high to low\n    items.sortBy { item: Item? -&gt; -(item!!.v.toDouble() / item.w) }\n    // Loop for greedy selection\n    var res = 0.0\n    for (item in items) {\n        if (item!!.w &lt;= cap) {\n            // If remaining capacity is sufficient, put the entire current item into the knapsack\n            res += item.v\n            cap -= item.w\n        } else {\n            // If remaining capacity is insufficient, put part of the current item into the knapsack\n            res += item.v.toDouble() / item.w * cap\n            // No remaining capacity, so break out of the loop\n            break\n        }\n    }\n    return res\n}\n</code></pre> fractional_knapsack.rb<pre><code>### Item ###\nclass Item\n  attr_accessor :w # Item weight\n  attr_accessor :v # Item value\n\n  def initialize(w, v)\n    @w = w\n    @v = v\n  end\nend\n\n### Fractional knapsack: greedy ###\ndef fractional_knapsack(wgt, val, cap)\n  # Create item list with two attributes: weight, value\n  items = wgt.each_with_index.map { |w, i| Item.new(w, val[i]) }\n  # Sort by unit value item.v / item.w from high to low\n  items.sort! { |a, b| (b.v.to_f / b.w) &lt;=&gt; (a.v.to_f / a.w) }\n  # Loop for greedy selection\n  res = 0\n  for item in items\n    if item.w &lt;= cap\n      # If remaining capacity is sufficient, put the entire current item into the knapsack\n      res += item.v\n      cap -= item.w\n    else\n      # If remaining capacity is insufficient, put part of the current item into the knapsack\n      res += (item.v.to_f / item.w) * cap\n      # No remaining capacity, so break out of the loop\n      break\n    end\n  end\n  res\nend\n</code></pre> <p>The time complexity of built-in sorting algorithms is usually \\(O(\\log n)\\), and the space complexity is usually \\(O(\\log n)\\) or \\(O(n)\\), depending on the specific implementation of the programming language.</p> <p>Apart from sorting, in the worst case the entire item list needs to be traversed, therefore the time complexity is \\(O(n)\\), where \\(n\\) is the number of items.</p> <p>Since an <code>Item</code> object list is initialized, the space complexity is \\(O(n)\\).</p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#3-correctness-proof","title":"3. \u00a0 Correctness Proof","text":"<p>Using proof by contradiction. Suppose item \\(x\\) has the highest unit value, and some algorithm yields a maximum value of <code>res</code>, but this solution does not include item \\(x\\).</p> <p>Now remove a unit weight of any item from the knapsack and replace it with a unit weight of item \\(x\\). Since item \\(x\\) has the highest unit value, the total value after replacement will definitely be greater than <code>res</code>. This contradicts the assumption that <code>res</code> is the optimal solution, proving that the optimal solution must include item \\(x\\).</p> <p>For other items in this solution, we can also construct the above contradiction. In summary, items with greater unit value are always better choices, which proves that the greedy strategy is effective.</p> <p>As shown in Figure 15-6, if we view item weight and item unit value as the horizontal and vertical axes of a two-dimensional chart respectively, then the fractional knapsack problem can be transformed into \"finding the maximum area enclosed within a limited horizontal axis range\". This analogy can help us understand the effectiveness of the greedy strategy from a geometric perspective.</p> <p></p> <p> Figure 15-6 \u00a0 Geometric representation of the fractional knapsack problem </p>"},{"location":"chapter_greedy/greedy_algorithm/","title":"15.1 \u00a0 Greedy Algorithm","text":"<p>Greedy algorithm is a common algorithm for solving optimization problems. Its basic idea is to make the seemingly best choice at each decision stage of the problem, that is, to greedily make locally optimal decisions in hopes of obtaining a globally optimal solution. Greedy algorithms are simple and efficient, and are widely applied in many practical problems.</p> <p>Greedy algorithms and dynamic programming are both commonly used to solve optimization problems. They share some similarities, such as both relying on the optimal substructure property, but they work differently.</p> <ul> <li>Dynamic programming considers all previous decisions when making the current decision, and uses solutions to past subproblems to construct the solution to the current subproblem.</li> <li>Greedy algorithms do not consider past decisions, but instead make greedy choices moving forward, continually reducing the problem size until the problem is solved.</li> </ul> <p>We will first understand how greedy algorithms work through the example problem \"coin change\". This problem has already been introduced in the \"Complete Knapsack Problem\" chapter, so I believe you are not unfamiliar with it.</p> <p>Question</p> <p>Given \\(n\\) types of coins, where the denomination of the \\(i\\)-th type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\), with each type of coin available for repeated selection, what is the minimum number of coins needed to make up the target amount? If it is impossible to make up the target amount, return \\(-1\\).</p> <p>The greedy strategy adopted for this problem is shown in Figure 15-1. Given a target amount, we greedily select the coin that is not greater than and closest to it, and continuously repeat this step until the target amount is reached.</p> <p></p> <p> Figure 15-1 \u00a0 Greedy strategy for coin change </p> <p>The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby coin_change_greedy.py<pre><code>def coin_change_greedy(coins: list[int], amt: int) -&gt; int:\n    \"\"\"Coin change: Greedy algorithm\"\"\"\n    # Assume coins list is sorted\n    i = len(coins) - 1\n    count = 0\n    # Loop to make greedy choices until no remaining amount\n    while amt &gt; 0:\n        # Find the coin that is less than and closest to the remaining amount\n        while i &gt; 0 and coins[i] &gt; amt:\n            i -= 1\n        # Choose coins[i]\n        amt -= coins[i]\n        count += 1\n    # If no feasible solution is found, return -1\n    return count if amt == 0 else -1\n</code></pre> coin_change_greedy.cpp<pre><code>/* Coin change: Greedy algorithm */\nint coinChangeGreedy(vector&lt;int&gt; &amp;coins, int amt) {\n    // Assume coins list is sorted\n    int i = coins.size() - 1;\n    int count = 0;\n    // Loop to make greedy choices until no remaining amount\n    while (amt &gt; 0) {\n        // Find the coin that is less than and closest to the remaining amount\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // Choose coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // If no feasible solution is found, return -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.java<pre><code>/* Coin change: Greedy algorithm */\nint coinChangeGreedy(int[] coins, int amt) {\n    // Assume coins list is sorted\n    int i = coins.length - 1;\n    int count = 0;\n    // Loop to make greedy choices until no remaining amount\n    while (amt &gt; 0) {\n        // Find the coin that is less than and closest to the remaining amount\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // Choose coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // If no feasible solution is found, return -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.cs<pre><code>/* Coin change: Greedy algorithm */\nint CoinChangeGreedy(int[] coins, int amt) {\n    // Assume coins list is sorted\n    int i = coins.Length - 1;\n    int count = 0;\n    // Loop to make greedy choices until no remaining amount\n    while (amt &gt; 0) {\n        // Find the coin that is less than and closest to the remaining amount\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // Choose coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // If no feasible solution is found, return -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.go<pre><code>/* Coin change: Greedy algorithm */\nfunc coinChangeGreedy(coins []int, amt int) int {\n    // Assume coins list is sorted\n    i := len(coins) - 1\n    count := 0\n    // Loop to make greedy choices until no remaining amount\n    for amt &gt; 0 {\n        // Find the coin that is less than and closest to the remaining amount\n        for i &gt; 0 &amp;&amp; coins[i] &gt; amt {\n            i--\n        }\n        // Choose coins[i]\n        amt -= coins[i]\n        count++\n    }\n    // If no feasible solution is found, return -1\n    if amt != 0 {\n        return -1\n    }\n    return count\n}\n</code></pre> coin_change_greedy.swift<pre><code>/* Coin change: Greedy algorithm */\nfunc coinChangeGreedy(coins: [Int], amt: Int) -&gt; Int {\n    // Assume coins list is sorted\n    var i = coins.count - 1\n    var count = 0\n    var amt = amt\n    // Loop to make greedy choices until no remaining amount\n    while amt &gt; 0 {\n        // Find the coin that is less than and closest to the remaining amount\n        while i &gt; 0 &amp;&amp; coins[i] &gt; amt {\n            i -= 1\n        }\n        // Choose coins[i]\n        amt -= coins[i]\n        count += 1\n    }\n    // If no feasible solution is found, return -1\n    return amt == 0 ? count : -1\n}\n</code></pre> coin_change_greedy.js<pre><code>/* Coin change: Greedy algorithm */\nfunction coinChangeGreedy(coins, amt) {\n    // Assume coins array is sorted\n    let i = coins.length - 1;\n    let count = 0;\n    // Loop to make greedy choices until no remaining amount\n    while (amt &gt; 0) {\n        // Find the coin that is less than and closest to the remaining amount\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // Choose coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // If no feasible solution is found, return -1\n    return amt === 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.ts<pre><code>/* Coin change: Greedy algorithm */\nfunction coinChangeGreedy(coins: number[], amt: number): number {\n    // Assume coins array is sorted\n    let i = coins.length - 1;\n    let count = 0;\n    // Loop to make greedy choices until no remaining amount\n    while (amt &gt; 0) {\n        // Find the coin that is less than and closest to the remaining amount\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // Choose coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // If no feasible solution is found, return -1\n    return amt === 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.dart<pre><code>/* Coin change: Greedy algorithm */\nint coinChangeGreedy(List&lt;int&gt; coins, int amt) {\n  // Assume coins list is sorted\n  int i = coins.length - 1;\n  int count = 0;\n  // Loop to make greedy choices until no remaining amount\n  while (amt &gt; 0) {\n    // Find the coin that is less than and closest to the remaining amount\n    while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n      i--;\n    }\n    // Choose coins[i]\n    amt -= coins[i];\n    count++;\n  }\n  // If no feasible solution is found, return -1\n  return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.rs<pre><code>/* Coin change: Greedy algorithm */\nfn coin_change_greedy(coins: &amp;[i32], mut amt: i32) -&gt; i32 {\n    // Assume coins list is sorted\n    let mut i = coins.len() - 1;\n    let mut count = 0;\n    // Loop to make greedy choices until no remaining amount\n    while amt &gt; 0 {\n        // Find the coin that is less than and closest to the remaining amount\n        while i &gt; 0 &amp;&amp; coins[i] &gt; amt {\n            i -= 1;\n        }\n        // Choose coins[i]\n        amt -= coins[i];\n        count += 1;\n    }\n    // If no feasible solution is found, return -1\n    if amt == 0 {\n        count\n    } else {\n        -1\n    }\n}\n</code></pre> coin_change_greedy.c<pre><code>/* Coin change: Greedy algorithm */\nint coinChangeGreedy(int *coins, int size, int amt) {\n    // Assume coins list is sorted\n    int i = size - 1;\n    int count = 0;\n    // Loop to make greedy choices until no remaining amount\n    while (amt &gt; 0) {\n        // Find the coin that is less than and closest to the remaining amount\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // Choose coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // If no feasible solution is found, return -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.kt<pre><code>/* Coin change: Greedy algorithm */\nfun coinChangeGreedy(coins: IntArray, amt: Int): Int {\n    // Assume coins list is sorted\n    var am = amt\n    var i = coins.size - 1\n    var count = 0\n    // Loop to make greedy choices until no remaining amount\n    while (am &gt; 0) {\n        // Find the coin that is less than and closest to the remaining amount\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; am) {\n            i--\n        }\n        // Choose coins[i]\n        am -= coins[i]\n        count++\n    }\n    // If no feasible solution is found, return -1\n    return if (am == 0) count else -1\n}\n</code></pre> coin_change_greedy.rb<pre><code>### Coin change: greedy ###\ndef coin_change_greedy(coins, amt)\n  # Assume coins list is sorted\n  i = coins.length - 1\n  count = 0\n  # Loop to make greedy choices until no remaining amount\n  while amt &gt; 0\n    # Find the coin that is less than and closest to the remaining amount\n    while i &gt; 0 &amp;&amp; coins[i] &gt; amt\n      i -= 1\n    end\n    # Choose coins[i]\n    amt -= coins[i]\n    count += 1\n  end\n  # Return -1 if no solution found\n  amt == 0 ? count : -1\nend\n</code></pre> <p>You might exclaim: So clean! The greedy algorithm solves the coin change problem in about ten lines of code.</p>"},{"location":"chapter_greedy/greedy_algorithm/#1511-advantages-and-limitations-of-greedy-algorithms","title":"15.1.1 \u00a0 Advantages and Limitations of Greedy Algorithms","text":"<p>Greedy algorithms are not only straightforward and simple to implement, but are also usually very efficient. In the code above, if the smallest coin denomination is \\(\\min(coins)\\), the greedy choice loops at most \\(amt / \\min(coins)\\) times, giving a time complexity of \\(O(amt / \\min(coins))\\). This is an order of magnitude smaller than the time complexity of the dynamic programming solution \\(O(n \\times amt)\\).</p> <p>However, for certain coin denomination combinations, greedy algorithms cannot find the optimal solution. Figure 15-2 provides two examples.</p> <ul> <li>Positive example \\(coins = [1, 5, 10, 20, 50, 100]\\): With this coin combination, given any \\(amt\\), the greedy algorithm can find the optimal solution.</li> <li>Negative example \\(coins = [1, 20, 50]\\): Suppose \\(amt = 60\\), the greedy algorithm can only find the combination \\(50 + 1 \\times 10\\), totaling \\(11\\) coins, but dynamic programming can find the optimal solution \\(20 + 20 + 20\\), requiring only \\(3\\) coins.</li> <li>Negative example \\(coins = [1, 49, 50]\\): Suppose \\(amt = 98\\), the greedy algorithm can only find the combination \\(50 + 1 \\times 48\\), totaling \\(49\\) coins, but dynamic programming can find the optimal solution \\(49 + 49\\), requiring only \\(2\\) coins.</li> </ul> <p></p> <p> Figure 15-2 \u00a0 Examples where greedy algorithms cannot find the optimal solution </p> <p>In other words, for the coin change problem, greedy algorithms cannot guarantee finding the global optimal solution, and may even find very poor solutions. It is better suited for solving with dynamic programming.</p> <p>Generally, the applicability of greedy algorithms falls into the following two situations.</p> <ol> <li>Can guarantee finding the optimal solution: In this situation, greedy algorithms are often the best choice, because they tend to be more efficient than backtracking and dynamic programming.</li> <li>Can find an approximate optimal solution: Greedy algorithms are also applicable in this situation. For many complex problems, finding the global optimal solution is very difficult, and being able to find a suboptimal solution with high efficiency is also very good.</li> </ol>"},{"location":"chapter_greedy/greedy_algorithm/#1512-characteristics-of-greedy-algorithms","title":"15.1.2 \u00a0 Characteristics of Greedy Algorithms","text":"<p>So the question arises: what kind of problems are suitable for solving with greedy algorithms? Or in other words, under what conditions can greedy algorithms guarantee finding the optimal solution?</p> <p>Compared to dynamic programming, the conditions for using greedy algorithms are stricter, mainly focusing on two properties of the problem.</p> <ul> <li>Greedy choice property: Only when locally optimal choices can always lead to a globally optimal solution can greedy algorithms guarantee obtaining the optimal solution.</li> <li>Optimal substructure: The optimal solution to the original problem contains the optimal solutions to subproblems.</li> </ul> <p>Optimal substructure has already been introduced in the \"Dynamic Programming\" chapter, so we won't elaborate on it here. It's worth noting that the optimal substructure of some problems is not obvious, but they can still be solved using greedy algorithms.</p> <p>We mainly explore methods for determining the greedy choice property. Although its description seems relatively simple, in practice, for many problems, proving the greedy choice property is not easy.</p> <p>For example, in the coin change problem, although we can easily provide counterexamples to disprove the greedy choice property, proving it is quite difficult. If asked: what conditions must a coin combination satisfy to be solvable using a greedy algorithm? We often can only rely on intuition or examples to give an ambiguous answer, and find it difficult to provide a rigorous mathematical proof.</p> <p>Quote</p> <p>There is a paper that presents an algorithm with \\(O(n^3)\\) time complexity for determining whether a coin combination can use a greedy algorithm to find the optimal solution for any amount.</p> <p>Pearson, D. A polynomial-time algorithm for the change-making problem[J]. Operations Research Letters, 2005, 33(3): 231-234.</p>"},{"location":"chapter_greedy/greedy_algorithm/#1513-steps-for-solving-problems-with-greedy-algorithms","title":"15.1.3 \u00a0 Steps for Solving Problems with Greedy Algorithms","text":"<p>The problem-solving process for greedy problems can generally be divided into the following three steps.</p> <ol> <li>Problem analysis: Sort out and understand the problem characteristics, including state definition, optimization objectives, and constraints, etc. This step is also involved in backtracking and dynamic programming.</li> <li>Determine the greedy strategy: Determine how to make greedy choices at each step. This strategy should be able to reduce the problem size at each step, ultimately solving the entire problem.</li> <li>Correctness proof: It is usually necessary to prove that the problem has both greedy choice property and optimal substructure. This step may require mathematical proofs, such as mathematical induction or proof by contradiction.</li> </ol> <p>Determining the greedy strategy is the core step in solving the problem, but it may not be easy to implement, mainly for the following reasons.</p> <ul> <li>Greedy strategies differ greatly between different problems. For many problems, the greedy strategy is relatively straightforward, and we can derive it through some general thinking and attempts. However, for some complex problems, the greedy strategy may be very elusive, which really tests one's problem-solving experience and algorithmic ability.</li> <li>Some greedy strategies are highly misleading. When we confidently design a greedy strategy, write the solution code and submit it for testing, we may find that some test cases cannot pass. This is because the designed greedy strategy is only \"partially correct\", as exemplified by the coin change problem discussed above.</li> </ul> <p>To ensure correctness, we should rigorously mathematically prove the greedy strategy, usually using proof by contradiction or mathematical induction.</p> <p>However, correctness proofs may also not be easy. If we have no clue, we usually choose to debug the code based on test cases, step by step modifying and verifying the greedy strategy.</p>"},{"location":"chapter_greedy/greedy_algorithm/#1514-typical-problems-solved-by-greedy-algorithms","title":"15.1.4 \u00a0 Typical Problems Solved by Greedy Algorithms","text":"<p>Greedy algorithms are often applied to optimization problems that satisfy greedy choice property and optimal substructure. Below are some typical greedy algorithm problems.</p> <ul> <li>Coin change problem: With certain coin combinations, greedy algorithms can always obtain the optimal solution.</li> <li>Interval scheduling problem: Suppose you have some tasks, each taking place during a period of time, and your goal is to complete as many tasks as possible. If you always choose the task that ends earliest, then the greedy algorithm can obtain the optimal solution.</li> <li>Fractional knapsack problem: Given a set of items and a carrying capacity, your goal is to select a set of items such that the total weight does not exceed the carrying capacity and the total value is maximized. If you always choose the item with the highest value-to-weight ratio (value / weight), then the greedy algorithm can obtain the optimal solution in some cases.</li> <li>Stock trading problem: Given a set of historical stock prices, you can make multiple trades, but if you already hold stocks, you cannot buy again before selling, and the goal is to obtain the maximum profit.</li> <li>Huffman coding: Huffman coding is a greedy algorithm used for lossless data compression. By constructing a Huffman tree and always merging the two nodes with the lowest frequency, the resulting Huffman tree has the minimum weighted path length (encoding length).</li> <li>Dijkstra's algorithm: It is a greedy algorithm for solving the shortest path problem from a given source vertex to all other vertices.</li> </ul>"},{"location":"chapter_greedy/max_capacity_problem/","title":"15.3 \u00a0 Max Capacity Problem","text":"<p>Question</p> <p>Input an array \\(ht\\), where each element represents the height of a vertical partition. Any two partitions in the array, along with the space between them, can form a container.</p> <p>The capacity of the container equals the product of height and width (area), where the height is determined by the shorter partition, and the width is the difference in array indices between the two partitions.</p> <p>Please select two partitions in the array such that the capacity of the formed container is maximized, and return the maximum capacity. An example is shown in Figure 15-7.</p> <p></p> <p> Figure 15-7 \u00a0 Example data for the max capacity problem </p> <p>The container is formed by any two partitions, therefore the state of this problem is the indices of two partitions, denoted as \\([i, j]\\).</p> <p>According to the problem description, capacity equals height multiplied by width, where height is determined by the shorter partition, and width is the difference in array indices between the two partitions. Let the capacity be \\(cap[i, j]\\), then the calculation formula is:</p> \\[ cap[i, j] = \\min(ht[i], ht[j]) \\times (j - i) \\] <p>Let the array length be \\(n\\), then the number of combinations of two partitions (total number of states) is \\(C_n^2 = \\frac{n(n - 1)}{2}\\). Most directly, we can exhaustively enumerate all states to find the maximum capacity, with time complexity \\(O(n^2)\\).</p>"},{"location":"chapter_greedy/max_capacity_problem/#1-greedy-strategy-determination","title":"1. \u00a0 Greedy Strategy Determination","text":"<p>This problem has a more efficient solution. As shown in Figure 15-8, select a state \\([i, j]\\) where index \\(i &lt; j\\) and height \\(ht[i] &lt; ht[j]\\), meaning \\(i\\) is the short partition and \\(j\\) is the long partition.</p> <p></p> <p> Figure 15-8 \u00a0 Initial state </p> <p>As shown in Figure 15-9, if we now move the long partition \\(j\\) closer to the short partition \\(i\\), the capacity will definitely decrease.</p> <p>This is because after moving the long partition \\(j\\), the width \\(j-i\\) definitely decreases; and since height is determined by the short partition, the height can only remain unchanged (\\(i\\) is still the short partition) or decrease (the moved \\(j\\) becomes the short partition).</p> <p></p> <p> Figure 15-9 \u00a0 State after moving the long partition inward </p> <p>Conversely, we can only possibly increase capacity by contracting the short partition \\(i\\) inward. Because although width will definitely decrease, height may increase (the moved short partition \\(i\\) may become taller). For example, in Figure 15-10, the area increases after moving the short partition.</p> <p></p> <p> Figure 15-10 \u00a0 State after moving the short partition inward </p> <p>From this we can derive the greedy strategy for this problem: initialize two pointers at both ends of the container, and in each round contract the pointer corresponding to the short partition inward, until the two pointers meet.</p> <p>Figure 15-11 shows the execution process of the greedy strategy.</p> <ol> <li>In the initial state, pointers \\(i\\) and \\(j\\) are at both ends of the array.</li> <li>Calculate the capacity of the current state \\(cap[i, j]\\), and update the maximum capacity.</li> <li>Compare the heights of partition \\(i\\) and partition \\(j\\), and move the short partition inward by one position.</li> <li>Loop through steps <code>2.</code> and <code>3.</code> until \\(i\\) and \\(j\\) meet.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 15-11 \u00a0 Greedy process for the max capacity problem </p>"},{"location":"chapter_greedy/max_capacity_problem/#2-code-implementation","title":"2. \u00a0 Code Implementation","text":"<p>The code loops at most \\(n\\) rounds, therefore the time complexity is \\(O(n)\\).</p> <p>Variables \\(i\\), \\(j\\), and \\(res\\) use a constant amount of extra space, therefore the space complexity is \\(O(1)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby max_capacity.py<pre><code>def max_capacity(ht: list[int]) -&gt; int:\n    \"\"\"Max capacity: Greedy algorithm\"\"\"\n    # Initialize i, j to be at both ends of the array\n    i, j = 0, len(ht) - 1\n    # Initial max capacity is 0\n    res = 0\n    # Loop for greedy selection until the two boards meet\n    while i &lt; j:\n        # Update max capacity\n        cap = min(ht[i], ht[j]) * (j - i)\n        res = max(res, cap)\n        # Move the shorter board inward\n        if ht[i] &lt; ht[j]:\n            i += 1\n        else:\n            j -= 1\n    return res\n</code></pre> max_capacity.cpp<pre><code>/* Max capacity: Greedy algorithm */\nint maxCapacity(vector&lt;int&gt; &amp;ht) {\n    // Initialize i, j to be at both ends of the array\n    int i = 0, j = ht.size() - 1;\n    // Initial max capacity is 0\n    int res = 0;\n    // Loop for greedy selection until the two boards meet\n    while (i &lt; j) {\n        // Update max capacity\n        int cap = min(ht[i], ht[j]) * (j - i);\n        res = max(res, cap);\n        // Move the shorter board inward\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.java<pre><code>/* Max capacity: Greedy algorithm */\nint maxCapacity(int[] ht) {\n    // Initialize i, j to be at both ends of the array\n    int i = 0, j = ht.length - 1;\n    // Initial max capacity is 0\n    int res = 0;\n    // Loop for greedy selection until the two boards meet\n    while (i &lt; j) {\n        // Update max capacity\n        int cap = Math.min(ht[i], ht[j]) * (j - i);\n        res = Math.max(res, cap);\n        // Move the shorter board inward\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.cs<pre><code>/* Max capacity: Greedy algorithm */\nint MaxCapacity(int[] ht) {\n    // Initialize i, j to be at both ends of the array\n    int i = 0, j = ht.Length - 1;\n    // Initial max capacity is 0\n    int res = 0;\n    // Loop for greedy selection until the two boards meet\n    while (i &lt; j) {\n        // Update max capacity\n        int cap = Math.Min(ht[i], ht[j]) * (j - i);\n        res = Math.Max(res, cap);\n        // Move the shorter board inward\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.go<pre><code>/* Max capacity: Greedy algorithm */\nfunc maxCapacity(ht []int) int {\n    // Initialize i, j to be at both ends of the array\n    i, j := 0, len(ht)-1\n    // Initial max capacity is 0\n    res := 0\n    // Loop for greedy selection until the two boards meet\n    for i &lt; j {\n        // Update max capacity\n        capacity := int(math.Min(float64(ht[i]), float64(ht[j]))) * (j - i)\n        res = int(math.Max(float64(res), float64(capacity)))\n        // Move the shorter board inward\n        if ht[i] &lt; ht[j] {\n            i++\n        } else {\n            j--\n        }\n    }\n    return res\n}\n</code></pre> max_capacity.swift<pre><code>/* Max capacity: Greedy algorithm */\nfunc maxCapacity(ht: [Int]) -&gt; Int {\n    // Initialize i, j to be at both ends of the array\n    var i = ht.startIndex, j = ht.endIndex - 1\n    // Initial max capacity is 0\n    var res = 0\n    // Loop for greedy selection until the two boards meet\n    while i &lt; j {\n        // Update max capacity\n        let cap = min(ht[i], ht[j]) * (j - i)\n        res = max(res, cap)\n        // Move the shorter board inward\n        if ht[i] &lt; ht[j] {\n            i += 1\n        } else {\n            j -= 1\n        }\n    }\n    return res\n}\n</code></pre> max_capacity.js<pre><code>/* Max capacity: Greedy algorithm */\nfunction maxCapacity(ht) {\n    // Initialize i, j to be at both ends of the array\n    let i = 0,\n        j = ht.length - 1;\n    // Initial max capacity is 0\n    let res = 0;\n    // Loop for greedy selection until the two boards meet\n    while (i &lt; j) {\n        // Update max capacity\n        const cap = Math.min(ht[i], ht[j]) * (j - i);\n        res = Math.max(res, cap);\n        // Move the shorter board inward\n        if (ht[i] &lt; ht[j]) {\n            i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.ts<pre><code>/* Max capacity: Greedy algorithm */\nfunction maxCapacity(ht: number[]): number {\n    // Initialize i, j to be at both ends of the array\n    let i = 0,\n        j = ht.length - 1;\n    // Initial max capacity is 0\n    let res = 0;\n    // Loop for greedy selection until the two boards meet\n    while (i &lt; j) {\n        // Update max capacity\n        const cap: number = Math.min(ht[i], ht[j]) * (j - i);\n        res = Math.max(res, cap);\n        // Move the shorter board inward\n        if (ht[i] &lt; ht[j]) {\n            i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.dart<pre><code>/* Max capacity: Greedy algorithm */\nint maxCapacity(List&lt;int&gt; ht) {\n  // Initialize i, j to be at both ends of the array\n  int i = 0, j = ht.length - 1;\n  // Initial max capacity is 0\n  int res = 0;\n  // Loop for greedy selection until the two boards meet\n  while (i &lt; j) {\n    // Update max capacity\n    int cap = min(ht[i], ht[j]) * (j - i);\n    res = max(res, cap);\n    // Move the shorter board inward\n    if (ht[i] &lt; ht[j]) {\n      i++;\n    } else {\n      j--;\n    }\n  }\n  return res;\n}\n</code></pre> max_capacity.rs<pre><code>/* Max capacity: Greedy algorithm */\nfn max_capacity(ht: &amp;[i32]) -&gt; i32 {\n    // Initialize i, j to be at both ends of the array\n    let mut i = 0;\n    let mut j = ht.len() - 1;\n    // Initial max capacity is 0\n    let mut res = 0;\n    // Loop for greedy selection until the two boards meet\n    while i &lt; j {\n        // Update max capacity\n        let cap = std::cmp::min(ht[i], ht[j]) * (j - i) as i32;\n        res = std::cmp::max(res, cap);\n        // Move the shorter board inward\n        if ht[i] &lt; ht[j] {\n            i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    res\n}\n</code></pre> max_capacity.c<pre><code>/* Max capacity: Greedy algorithm */\nint maxCapacity(int ht[], int htLength) {\n    // Initialize i, j to be at both ends of the array\n    int i = 0;\n    int j = htLength - 1;\n    // Initial max capacity is 0\n    int res = 0;\n    // Loop for greedy selection until the two boards meet\n    while (i &lt; j) {\n        // Update max capacity\n        int capacity = myMin(ht[i], ht[j]) * (j - i);\n        res = myMax(res, capacity);\n        // Move the shorter board inward\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.kt<pre><code>/* Max capacity: Greedy algorithm */\nfun maxCapacity(ht: IntArray): Int {\n    // Initialize i, j to be at both ends of the array\n    var i = 0\n    var j = ht.size - 1\n    // Initial max capacity is 0\n    var res = 0\n    // Loop for greedy selection until the two boards meet\n    while (i &lt; j) {\n        // Update max capacity\n        val cap = min(ht[i], ht[j]) * (j - i)\n        res = max(res, cap)\n        // Move the shorter board inward\n        if (ht[i] &lt; ht[j]) {\n            i++\n        } else {\n            j--\n        }\n    }\n    return res\n}\n</code></pre> max_capacity.rb<pre><code>### Maximum capacity: greedy ###\ndef max_capacity(ht)\n  # Initialize i, j to be at both ends of the array\n  i, j = 0, ht.length - 1\n  # Initial max capacity is 0\n  res = 0\n\n  # Loop for greedy selection until the two boards meet\n  while i &lt; j\n    # Update max capacity\n    cap = [ht[i], ht[j]].min * (j - i)\n    res = [res, cap].max\n    # Move the shorter board inward\n    if ht[i] &lt; ht[j]\n      i += 1\n    else\n      j -= 1\n    end\n  end\n\n  res\nend\n</code></pre>"},{"location":"chapter_greedy/max_capacity_problem/#3-correctness-proof","title":"3. \u00a0 Correctness Proof","text":"<p>The reason greedy is faster than exhaustive enumeration is that each round of greedy selection \"skips\" some states.</p> <p>For example, in state \\(cap[i, j]\\) where \\(i\\) is the short partition and \\(j\\) is the long partition, if we greedily move the short partition \\(i\\) inward by one position, the states shown in Figure 15-12 will be \"skipped\". This means that the capacities of these states cannot be verified later.</p> \\[ cap[i, i+1], cap[i, i+2], \\dots, cap[i, j-2], cap[i, j-1] \\] <p></p> <p> Figure 15-12 \u00a0 States skipped by moving the short partition </p> <p>Observing carefully, these skipped states are actually all the states obtained by moving the long partition \\(j\\) inward. We have already proven that moving the long partition inward will definitely decrease capacity. That is, the skipped states cannot possibly be the optimal solution, skipping them will not cause us to miss the optimal solution.</p> <p>The above analysis shows that the operation of moving the short partition is \"safe\", and the greedy strategy is effective.</p>"},{"location":"chapter_greedy/max_product_cutting_problem/","title":"15.4 \u00a0 Max Product Cutting Problem","text":"<p>Question</p> <p>Given a positive integer \\(n\\), split it into the sum of at least two positive integers, and find the maximum product of all integers after splitting, as shown in Figure 15-13.</p> <p></p> <p> Figure 15-13 \u00a0 Problem definition of max product cutting </p> <p>Suppose we split \\(n\\) into \\(m\\) integer factors, where the \\(i\\)-th factor is denoted as \\(n_i\\), that is</p> \\[ n = \\sum_{i=1}^{m}n_i \\] <p>The goal of this problem is to find the maximum product of all integer factors, namely</p> \\[ \\max(\\prod_{i=1}^{m}n_i) \\] <p>We need to think about: how large should the splitting count \\(m\\) be, and what should each \\(n_i\\) be?</p>"},{"location":"chapter_greedy/max_product_cutting_problem/#1-greedy-strategy-determination","title":"1. \u00a0 Greedy Strategy Determination","text":"<p>Based on experience, the product of two integers is often greater than their sum. Suppose we split out a factor of \\(2\\) from \\(n\\), then their product is \\(2(n-2)\\). We compare this product with \\(n\\):</p> \\[ \\begin{aligned} 2(n-2) &amp; \\geq n \\newline 2n - n - 4 &amp; \\geq 0 \\newline n &amp; \\geq 4 \\end{aligned} \\] <p>As shown in Figure 15-14, when \\(n \\geq 4\\), splitting out a \\(2\\) will increase the product, which indicates that integers greater than or equal to \\(4\\) should all be split.</p> <p>Greedy strategy one: If the splitting scheme includes factors \\(\\geq 4\\), then they should continue to be split. The final splitting scheme should only contain factors \\(1\\), \\(2\\), and \\(3\\).</p> <p></p> <p> Figure 15-14 \u00a0 Splitting causes product to increase </p> <p>Next, consider which factor is optimal. Among the three factors \\(1\\), \\(2\\), and \\(3\\), clearly \\(1\\) is the worst, because \\(1 \\times (n-1) &lt; n\\) always holds, meaning splitting out \\(1\\) will actually decrease the product.</p> <p>As shown in Figure 15-15, when \\(n = 6\\), we have \\(3 \\times 3 &gt; 2 \\times 2 \\times 2\\). This means that splitting out \\(3\\) is better than splitting out \\(2\\).</p> <p>Greedy strategy two: In the splitting scheme, there should be at most two \\(2\\)s. Because three \\(2\\)s can always be replaced by two \\(3\\)s to obtain a larger product.</p> <p></p> <p> Figure 15-15 \u00a0 Optimal splitting factor </p> <p>In summary, the following greedy strategies can be derived.</p> <ol> <li>Input integer \\(n\\), continuously split out factor \\(3\\) until the remainder is \\(0\\), \\(1\\), or \\(2\\).</li> <li>When the remainder is \\(0\\), it means \\(n\\) is a multiple of \\(3\\), so no further action is needed.</li> <li>When the remainder is \\(2\\), do not continue splitting, keep it.</li> <li>When the remainder is \\(1\\), since \\(2 \\times 2 &gt; 1 \\times 3\\), the last \\(3\\) should be replaced with \\(2\\).</li> </ol>"},{"location":"chapter_greedy/max_product_cutting_problem/#2-code-implementation","title":"2. \u00a0 Code Implementation","text":"<p>As shown in Figure 15-16, we don't need to use loops to split the integer, but can use integer division to get the count of \\(3\\)s as \\(a\\), and modulo operation to get the remainder as \\(b\\), at which point we have:</p> \\[ n = 3 a + b \\] <p>Please note that for the edge case of \\(n \\leq 3\\), a \\(1\\) must be split out, with product \\(1 \\times (n - 1)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby max_product_cutting.py<pre><code>def max_product_cutting(n: int) -&gt; int:\n    \"\"\"Max product cutting: Greedy algorithm\"\"\"\n    # When n &lt;= 3, must cut out a 1\n    if n &lt;= 3:\n        return 1 * (n - 1)\n    # Greedily cut out 3, a is the number of 3s, b is the remainder\n    a, b = n // 3, n % 3\n    if b == 1:\n        # When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return int(math.pow(3, a - 1)) * 2 * 2\n    if b == 2:\n        # When the remainder is 2, do nothing\n        return int(math.pow(3, a)) * 2\n    # When the remainder is 0, do nothing\n    return int(math.pow(3, a))\n</code></pre> max_product_cutting.cpp<pre><code>/* Max product cutting: Greedy algorithm */\nint maxProductCutting(int n) {\n    // When n &lt;= 3, must cut out a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return (int)pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // When the remainder is 2, do nothing\n        return (int)pow(3, a) * 2;\n    }\n    // When the remainder is 0, do nothing\n    return (int)pow(3, a);\n}\n</code></pre> max_product_cutting.java<pre><code>/* Max product cutting: Greedy algorithm */\nint maxProductCutting(int n) {\n    // When n &lt;= 3, must cut out a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return (int) Math.pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // When the remainder is 2, do nothing\n        return (int) Math.pow(3, a) * 2;\n    }\n    // When the remainder is 0, do nothing\n    return (int) Math.pow(3, a);\n}\n</code></pre> max_product_cutting.cs<pre><code>/* Max product cutting: Greedy algorithm */\nint MaxProductCutting(int n) {\n    // When n &lt;= 3, must cut out a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return (int)Math.Pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // When the remainder is 2, do nothing\n        return (int)Math.Pow(3, a) * 2;\n    }\n    // When the remainder is 0, do nothing\n    return (int)Math.Pow(3, a);\n}\n</code></pre> max_product_cutting.go<pre><code>/* Max product cutting: Greedy algorithm */\nfunc maxProductCutting(n int) int {\n    // When n &lt;= 3, must cut out a 1\n    if n &lt;= 3 {\n        return 1 * (n - 1)\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    a := n / 3\n    b := n % 3\n    if b == 1 {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return int(math.Pow(3, float64(a-1))) * 2 * 2\n    }\n    if b == 2 {\n        // When the remainder is 2, do nothing\n        return int(math.Pow(3, float64(a))) * 2\n    }\n    // When the remainder is 0, do nothing\n    return int(math.Pow(3, float64(a)))\n}\n</code></pre> max_product_cutting.swift<pre><code>/* Max product cutting: Greedy algorithm */\nfunc maxProductCutting(n: Int) -&gt; Int {\n    // When n &lt;= 3, must cut out a 1\n    if n &lt;= 3 {\n        return 1 * (n - 1)\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    let a = n / 3\n    let b = n % 3\n    if b == 1 {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return pow(3, a - 1) * 2 * 2\n    }\n    if b == 2 {\n        // When the remainder is 2, do nothing\n        return pow(3, a) * 2\n    }\n    // When the remainder is 0, do nothing\n    return pow(3, a)\n}\n</code></pre> max_product_cutting.js<pre><code>/* Max product cutting: Greedy algorithm */\nfunction maxProductCutting(n) {\n    // When n &lt;= 3, must cut out a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    let a = Math.floor(n / 3);\n    let b = n % 3;\n    if (b === 1) {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return Math.pow(3, a - 1) * 2 * 2;\n    }\n    if (b === 2) {\n        // When the remainder is 2, do nothing\n        return Math.pow(3, a) * 2;\n    }\n    // When the remainder is 0, do nothing\n    return Math.pow(3, a);\n}\n</code></pre> max_product_cutting.ts<pre><code>/* Max product cutting: Greedy algorithm */\nfunction maxProductCutting(n: number): number {\n    // When n &lt;= 3, must cut out a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    let a: number = Math.floor(n / 3);\n    let b: number = n % 3;\n    if (b === 1) {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return Math.pow(3, a - 1) * 2 * 2;\n    }\n    if (b === 2) {\n        // When the remainder is 2, do nothing\n        return Math.pow(3, a) * 2;\n    }\n    // When the remainder is 0, do nothing\n    return Math.pow(3, a);\n}\n</code></pre> max_product_cutting.dart<pre><code>/* Max product cutting: Greedy algorithm */\nint maxProductCutting(int n) {\n  // When n &lt;= 3, must cut out a 1\n  if (n &lt;= 3) {\n    return 1 * (n - 1);\n  }\n  // Greedily cut out 3, a is the number of 3s, b is the remainder\n  int a = n ~/ 3;\n  int b = n % 3;\n  if (b == 1) {\n    // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n    return (pow(3, a - 1) * 2 * 2).toInt();\n  }\n  if (b == 2) {\n    // When the remainder is 2, do nothing\n    return (pow(3, a) * 2).toInt();\n  }\n  // When the remainder is 0, do nothing\n  return pow(3, a).toInt();\n}\n</code></pre> max_product_cutting.rs<pre><code>/* Max product cutting: Greedy algorithm */\nfn max_product_cutting(n: i32) -&gt; i32 {\n    // When n &lt;= 3, must cut out a 1\n    if n &lt;= 3 {\n        return 1 * (n - 1);\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    let a = n / 3;\n    let b = n % 3;\n    if b == 1 {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        3_i32.pow(a as u32 - 1) * 2 * 2\n    } else if b == 2 {\n        // When the remainder is 2, do nothing\n        3_i32.pow(a as u32) * 2\n    } else {\n        // When the remainder is 0, do nothing\n        3_i32.pow(a as u32)\n    }\n}\n</code></pre> max_product_cutting.c<pre><code>/* Max product cutting: Greedy algorithm */\nint maxProductCutting(int n) {\n    // When n &lt;= 3, must cut out a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // When the remainder is 2, do nothing\n        return pow(3, a) * 2;\n    }\n    // When the remainder is 0, do nothing\n    return pow(3, a);\n}\n</code></pre> max_product_cutting.kt<pre><code>/* Max product cutting: Greedy algorithm */\nfun maxProductCutting(n: Int): Int {\n    // When n &lt;= 3, must cut out a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1)\n    }\n    // Greedily cut out 3, a is the number of 3s, b is the remainder\n    val a = n / 3\n    val b = n % 3\n    if (b == 1) {\n        // When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n        return 3.0.pow((a - 1)).toInt() * 2 * 2\n    }\n    if (b == 2) {\n        // When the remainder is 2, do nothing\n        return 3.0.pow(a).toInt() * 2 * 2\n    }\n    // When the remainder is 0, do nothing\n    return 3.0.pow(a).toInt()\n}\n</code></pre> max_product_cutting.rb<pre><code>### Maximum cutting product: greedy ###\ndef max_product_cutting(n)\n  # When n &lt;= 3, must cut out a 1\n  return 1 * (n - 1) if n &lt;= 3\n  # Greedily cut out 3, a is the number of 3s, b is the remainder\n  a, b = n / 3, n % 3\n  # When the remainder is 1, convert a pair of 1 * 3 to 2 * 2\n  return (3.pow(a - 1) * 2 * 2).to_i if b == 1\n  # When the remainder is 2, do nothing\n  return (3.pow(a) * 2).to_i if b == 2\n  # When the remainder is 0, do nothing\n  3.pow(a).to_i\nend\n</code></pre> <p></p> <p> Figure 15-16 \u00a0 Calculation method for max product cutting </p> <p>The time complexity depends on the implementation of the exponentiation operation in the programming language. Taking Python as an example, there are three commonly used power calculation functions.</p> <ul> <li>Both the operator <code>**</code> and the function <code>pow()</code> have time complexity \\(O(\\log\u2061 a)\\).</li> <li>The function <code>math.pow()</code> internally calls the C library's <code>pow()</code> function, which performs floating-point exponentiation, with time complexity \\(O(1)\\).</li> </ul> <p>Variables \\(a\\) and \\(b\\) use a constant amount of extra space, therefore the space complexity is \\(O(1)\\).</p>"},{"location":"chapter_greedy/max_product_cutting_problem/#3-correctness-proof","title":"3. \u00a0 Correctness Proof","text":"<p>Using proof by contradiction, only analyzing the case where \\(n \\geq 4\\).</p> <ol> <li>All factors \\(\\leq 3\\): Suppose the optimal splitting scheme includes a factor \\(x \\geq 4\\), then it can definitely continue to be split into \\(2(x-2)\\) to obtain a larger (or equal) product. This contradicts the assumption.</li> <li>The splitting scheme does not contain \\(1\\): Suppose the optimal splitting scheme includes a factor of \\(1\\), then it can definitely be merged into another factor to obtain a larger product. This contradicts the assumption.</li> <li>The splitting scheme contains at most two \\(2\\)s: Suppose the optimal splitting scheme includes three \\(2\\)s, then they can definitely be replaced by two \\(3\\)s for a larger product. This contradicts the assumption.</li> </ol>"},{"location":"chapter_greedy/summary/","title":"15.5 \u00a0 Summary","text":""},{"location":"chapter_greedy/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Greedy algorithms are typically used to solve optimization problems. The principle is to make locally optimal decisions at each decision stage in hopes of obtaining a globally optimal solution.</li> <li>Greedy algorithms iteratively make one greedy choice after another, transforming the problem into a smaller subproblem in each round, until the problem is solved.</li> <li>Greedy algorithms are not only simple to implement, but also have high problem-solving efficiency. Compared to dynamic programming, greedy algorithms typically have lower time complexity.</li> <li>In the coin change problem, for certain coin combinations, greedy algorithms can guarantee finding the optimal solution; for other coin combinations, however, greedy algorithms may find very poor solutions.</li> <li>Problems suitable for solving with greedy algorithms have two major properties: greedy choice property and optimal substructure. The greedy choice property represents the effectiveness of the greedy strategy.</li> <li>For some complex problems, proving the greedy choice property is not simple. Relatively speaking, disproving it is easier, such as in the coin change problem.</li> <li>Solving greedy problems mainly consists of three steps: problem analysis, determining the greedy strategy, and correctness proof. Among these, determining the greedy strategy is the core step, and correctness proof is often the difficult point.</li> <li>The fractional knapsack problem, based on the 0-1 knapsack problem, allows selecting a portion of items, and therefore can be solved using greedy algorithms. The correctness of the greedy strategy can be proven using proof by contradiction.</li> <li>The max capacity problem can be solved using exhaustive enumeration with time complexity \\(O(n^2)\\). By designing a greedy strategy to move the short partition inward in each round, the time complexity can be optimized to \\(O(n)\\).</li> <li>In the max product cutting problem, we successively derive two greedy strategies: integers \\(\\geq 4\\) should all continue to be split, and the optimal splitting factor is \\(3\\). The code includes exponentiation operations, and the time complexity depends on the implementation method of exponentiation, typically being \\(O(1)\\) or \\(O(\\log n)\\).</li> </ul>"},{"location":"chapter_hashing/","title":"Chapter 6. \u00a0 Hashing","text":"<p>Abstract</p> <p>In the world of computing, a hash table is like a clever librarian.</p> <p>They know how to calculate call numbers, enabling them to quickly locate the target book.</p>"},{"location":"chapter_hashing/#chapter-contents","title":"Chapter contents","text":"<ul> <li>6.1 \u00a0 Hash Table</li> <li>6.2 \u00a0 Hash Collision</li> <li>6.3 \u00a0 Hash Algorithm</li> <li>6.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_hashing/hash_algorithm/","title":"6.3 \u00a0 Hash Algorithm","text":"<p>The previous two sections introduced the working principle of hash tables and the methods to handle hash collisions. However, both open addressing and separate chaining can only ensure that the hash table functions normally when hash collisions occur, but cannot reduce the frequency of hash collisions.</p> <p>If hash collisions occur too frequently, the performance of the hash table will deteriorate drastically. As shown in Figure 6-8, for a separate chaining hash table, in the ideal case, the key-value pairs are evenly distributed across the buckets, achieving optimal query efficiency; in the worst case, all key-value pairs are stored in the same bucket, degrading the time complexity to \\(O(n)\\).</p> <p></p> <p> Figure 6-8 \u00a0 Ideal and worst cases of hash collisions </p> <p>The distribution of key-value pairs is determined by the hash function. Recalling the calculation steps of the hash function, first compute the hash value, then take the modulo by the array length:</p> <pre><code>index = hash(key) % capacity\n</code></pre> <p>Observing the above formula, when the hash table capacity <code>capacity</code> is fixed, the hash algorithm <code>hash()</code> determines the output value, thereby determining the distribution of key-value pairs in the hash table.</p> <p>This means that, to reduce the probability of hash collisions, we should focus on the design of the hash algorithm <code>hash()</code>.</p>"},{"location":"chapter_hashing/hash_algorithm/#631-goals-of-hash-algorithms","title":"6.3.1 \u00a0 Goals of Hash Algorithms","text":"<p>To achieve a \"fast and stable\" hash table data structure, hash algorithms should have the following characteristics:</p> <ul> <li>Determinism: For the same input, the hash algorithm should always produce the same output. Only then can the hash table be reliable.</li> <li>High efficiency: The process of computing the hash value should be fast enough. The smaller the computational overhead, the more practical the hash table.</li> <li>Uniform distribution: The hash algorithm should ensure that key-value pairs are evenly distributed in the hash table. The more uniform the distribution, the lower the probability of hash collisions.</li> </ul> <p>In fact, hash algorithms are not only used to implement hash tables but are also widely applied in other fields.</p> <ul> <li>Password storage: To protect the security of user passwords, systems usually do not store the plaintext passwords but rather the hash values of the passwords. When a user enters a password, the system calculates the hash value of the input and compares it with the stored hash value. If they match, the password is considered correct.</li> <li>Data integrity check: The data sender can calculate the hash value of the data and send it along; the receiver can recalculate the hash value of the received data and compare it with the received hash value. If they match, the data is considered intact.</li> </ul> <p>For cryptographic applications, to prevent reverse engineering such as deducing the original password from the hash value, hash algorithms need higher-level security features.</p> <ul> <li>Unidirectionality: It should be impossible to deduce any information about the input data from the hash value.</li> <li>Collision resistance: It should be extremely difficult to find two different inputs that produce the same hash value.</li> <li>Avalanche effect: Minor changes in the input should lead to significant and unpredictable changes in the output.</li> </ul> <p>Note that \"uniform distribution\" and \"collision resistance\" are two independent concepts. Satisfying uniform distribution does not necessarily mean collision resistance. For example, under random input <code>key</code>, the hash function <code>key % 100</code> can produce a uniformly distributed output. However, this hash algorithm is too simple, and all <code>key</code> with the same last two digits will have the same output, making it easy to deduce a usable <code>key</code> from the hash value, thereby cracking the password.</p>"},{"location":"chapter_hashing/hash_algorithm/#632-design-of-hash-algorithms","title":"6.3.2 \u00a0 Design of Hash Algorithms","text":"<p>The design of hash algorithms is a complex issue that requires consideration of many factors. However, for some less demanding scenarios, we can also design some simple hash algorithms.</p> <ul> <li>Additive hash: Add up the ASCII codes of each character in the input and use the total sum as the hash value.</li> <li>Multiplicative hash: Utilize the non-correlation of multiplication, multiplying each round by a constant, accumulating the ASCII codes of each character into the hash value.</li> <li>XOR hash: Accumulate the hash value by XORing each element of the input data.</li> <li>Rotating hash: Accumulate the ASCII code of each character into a hash value, performing a rotation operation on the hash value before each accumulation.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby simple_hash.py<pre><code>def add_hash(key: str) -&gt; int:\n    \"\"\"Additive hash\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash += ord(c)\n    return hash % modulus\n\ndef mul_hash(key: str) -&gt; int:\n    \"\"\"Multiplicative hash\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash = 31 * hash + ord(c)\n    return hash % modulus\n\ndef xor_hash(key: str) -&gt; int:\n    \"\"\"XOR hash\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash ^= ord(c)\n    return hash % modulus\n\ndef rot_hash(key: str) -&gt; int:\n    \"\"\"Rotational hash\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash = (hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ ord(c)\n    return hash % modulus\n</code></pre> simple_hash.cpp<pre><code>/* Additive hash */\nint addHash(string key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash = (hash + (int)c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* Multiplicative hash */\nint mulHash(string key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash = (31 * hash + (int)c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* XOR hash */\nint xorHash(string key) {\n    int hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash ^= (int)c;\n    }\n    return hash &amp; MODULUS;\n}\n\n/* Rotational hash */\nint rotHash(string key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ (int)c) % MODULUS;\n    }\n    return (int)hash;\n}\n</code></pre> simple_hash.java<pre><code>/* Additive hash */\nint addHash(String key) {\n    long hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash = (hash + (int) c) % MODULUS;\n    }\n    return (int) hash;\n}\n\n/* Multiplicative hash */\nint mulHash(String key) {\n    long hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash = (31 * hash + (int) c) % MODULUS;\n    }\n    return (int) hash;\n}\n\n/* XOR hash */\nint xorHash(String key) {\n    int hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash ^= (int) c;\n    }\n    return hash &amp; MODULUS;\n}\n\n/* Rotational hash */\nint rotHash(String key) {\n    long hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ (int) c) % MODULUS;\n    }\n    return (int) hash;\n}\n</code></pre> simple_hash.cs<pre><code>/* Additive hash */\nint AddHash(string key) {\n    long hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash = (hash + c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* Multiplicative hash */\nint MulHash(string key) {\n    long hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash = (31 * hash + c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* XOR hash */\nint XorHash(string key) {\n    int hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash ^= c;\n    }\n    return hash &amp; MODULUS;\n}\n\n/* Rotational hash */\nint RotHash(string key) {\n    long hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c) % MODULUS;\n    }\n    return (int)hash;\n}\n</code></pre> simple_hash.go<pre><code>/* Additive hash */\nfunc addHash(key string) int {\n    var hash int64\n    var modulus int64\n\n    modulus = 1000000007\n    for _, b := range []byte(key) {\n        hash = (hash + int64(b)) % modulus\n    }\n    return int(hash)\n}\n\n/* Multiplicative hash */\nfunc mulHash(key string) int {\n    var hash int64\n    var modulus int64\n\n    modulus = 1000000007\n    for _, b := range []byte(key) {\n        hash = (31*hash + int64(b)) % modulus\n    }\n    return int(hash)\n}\n\n/* XOR hash */\nfunc xorHash(key string) int {\n    hash := 0\n    modulus := 1000000007\n    for _, b := range []byte(key) {\n        fmt.Println(int(b))\n        hash ^= int(b)\n        hash = (31*hash + int(b)) % modulus\n    }\n    return hash &amp; modulus\n}\n\n/* Rotational hash */\nfunc rotHash(key string) int {\n    var hash int64\n    var modulus int64\n\n    modulus = 1000000007\n    for _, b := range []byte(key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ int64(b)) % modulus\n    }\n    return int(hash)\n}\n</code></pre> simple_hash.swift<pre><code>/* Additive hash */\nfunc addHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash = (hash + Int(scalar.value)) % MODULUS\n        }\n    }\n    return hash\n}\n\n/* Multiplicative hash */\nfunc mulHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash = (31 * hash + Int(scalar.value)) % MODULUS\n        }\n    }\n    return hash\n}\n\n/* XOR hash */\nfunc xorHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash ^= Int(scalar.value)\n        }\n    }\n    return hash &amp; MODULUS\n}\n\n/* Rotational hash */\nfunc rotHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ Int(scalar.value)) % MODULUS\n        }\n    }\n    return hash\n}\n</code></pre> simple_hash.js<pre><code>/* Additive hash */\nfunction addHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* Multiplicative hash */\nfunction mulHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (31 * hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* XOR hash */\nfunction xorHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash ^= c.charCodeAt(0);\n    }\n    return hash % MODULUS;\n}\n\n/* Rotational hash */\nfunction rotHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n</code></pre> simple_hash.ts<pre><code>/* Additive hash */\nfunction addHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* Multiplicative hash */\nfunction mulHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (31 * hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* XOR hash */\nfunction xorHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash ^= c.charCodeAt(0);\n    }\n    return hash % MODULUS;\n}\n\n/* Rotational hash */\nfunction rotHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n</code></pre> simple_hash.dart<pre><code>/* Additive hash */\nint addHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash = (hash + key.codeUnitAt(i)) % MODULUS;\n  }\n  return hash;\n}\n\n/* Multiplicative hash */\nint mulHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash = (31 * hash + key.codeUnitAt(i)) % MODULUS;\n  }\n  return hash;\n}\n\n/* XOR hash */\nint xorHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash ^= key.codeUnitAt(i);\n  }\n  return hash &amp; MODULUS;\n}\n\n/* Rotational hash */\nint rotHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ key.codeUnitAt(i)) % MODULUS;\n  }\n  return hash;\n}\n</code></pre> simple_hash.rs<pre><code>/* Additive hash */\nfn add_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash = (hash + c as i64) % MODULUS;\n    }\n\n    hash as i32\n}\n\n/* Multiplicative hash */\nfn mul_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash = (31 * hash + c as i64) % MODULUS;\n    }\n\n    hash as i32\n}\n\n/* XOR hash */\nfn xor_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash ^= c as i64;\n    }\n\n    (hash &amp; MODULUS) as i32\n}\n\n/* Rotational hash */\nfn rot_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c as i64) % MODULUS;\n    }\n\n    hash as i32\n}\n</code></pre> simple_hash.c<pre><code>/* Additive hash */\nint addHash(char *key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash = (hash + (unsigned char)key[i]) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* Multiplicative hash */\nint mulHash(char *key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash = (31 * hash + (unsigned char)key[i]) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* XOR hash */\nint xorHash(char *key) {\n    int hash = 0;\n    const int MODULUS = 1000000007;\n\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash ^= (unsigned char)key[i];\n    }\n    return hash &amp; MODULUS;\n}\n\n/* Rotational hash */\nint rotHash(char *key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ (unsigned char)key[i]) % MODULUS;\n    }\n\n    return (int)hash;\n}\n</code></pre> simple_hash.kt<pre><code>/* Additive hash */\nfun addHash(key: String): Int {\n    var hash = 0L\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = (hash + c.code) % MODULUS\n    }\n    return hash.toInt()\n}\n\n/* Multiplicative hash */\nfun mulHash(key: String): Int {\n    var hash = 0L\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = (31 * hash + c.code) % MODULUS\n    }\n    return hash.toInt()\n}\n\n/* XOR hash */\nfun xorHash(key: String): Int {\n    var hash = 0\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = hash xor c.code\n    }\n    return hash and MODULUS\n}\n\n/* Rotational hash */\nfun rotHash(key: String): Int {\n    var hash = 0L\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = ((hash shl 4) xor (hash shr 28) xor c.code.toLong()) % MODULUS\n    }\n    return hash.toInt()\n}\n</code></pre> simple_hash.rb<pre><code>### Additive hash ###\ndef add_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash += c.ord }\n\n  hash % modulus\nend\n\n### Multiplicative hash ###\ndef mul_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash = 31 * hash + c.ord }\n\n  hash % modulus\nend\n\n### XOR hash ###\ndef xor_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash ^= c.ord }\n\n  hash % modulus\nend\n\n### Rotational hash ###\ndef rot_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash = (hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c.ord }\n\n  hash % modulus\nend\n</code></pre> <p>It is observed that the last step of each hash algorithm is to take the modulus of the large prime number \\(1000000007\\) to ensure that the hash value is within an appropriate range. It is worth pondering why emphasis is placed on modulo a prime number, or what are the disadvantages of modulo a composite number? This is an interesting question.</p> <p>To conclude: Using a large prime number as the modulus can maximize the uniform distribution of hash values. Since a prime number does not share common factors with other numbers, it can reduce the periodic patterns caused by the modulo operation, thus avoiding hash collisions.</p> <p>For example, suppose we choose the composite number \\(9\\) as the modulus, which can be divided by \\(3\\), then all <code>key</code> divisible by \\(3\\) will be mapped to hash values \\(0\\), \\(3\\), \\(6\\).</p> \\[ \\begin{aligned} \\text{modulus} &amp; = 9 \\newline \\text{key} &amp; = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline \\text{hash} &amp; = \\{ 0, 3, 6, 0, 3, 6, 0, 3, 6, 0, 3, 6,\\dots \\} \\end{aligned} \\] <p>If the input <code>key</code> happens to have this kind of arithmetic sequence distribution, then the hash values will cluster, thereby exacerbating hash collisions. Now, suppose we replace <code>modulus</code> with the prime number \\(13\\), since there are no common factors between <code>key</code> and <code>modulus</code>, the uniformity of the output hash values will be significantly improved.</p> \\[ \\begin{aligned} \\text{modulus} &amp; = 13 \\newline \\text{key} &amp; = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline \\text{hash} &amp; = \\{ 0, 3, 6, 9, 12, 2, 5, 8, 11, 1, 4, 7, \\dots \\} \\end{aligned} \\] <p>It is worth noting that if the <code>key</code> is guaranteed to be randomly and uniformly distributed, then choosing a prime number or a composite number as the modulus can both produce uniformly distributed hash values. However, when the distribution of <code>key</code> has some periodicity, modulo a composite number is more likely to result in clustering.</p> <p>In summary, we usually choose a prime number as the modulus, and this prime number should be large enough to eliminate periodic patterns as much as possible, enhancing the robustness of the hash algorithm.</p>"},{"location":"chapter_hashing/hash_algorithm/#633-common-hash-algorithms","title":"6.3.3 \u00a0 Common Hash Algorithms","text":"<p>It is not hard to see that the simple hash algorithms mentioned above are quite \"fragile\" and far from reaching the design goals of hash algorithms. For example, since addition and XOR obey the commutative law, additive hash and XOR hash cannot distinguish strings with the same content but in different order, which may exacerbate hash collisions and cause security issues.</p> <p>In practice, we usually use some standard hash algorithms, such as MD5, SHA-1, SHA-2, and SHA-3. They can map input data of any length to a fixed-length hash value.</p> <p>Over the past century, hash algorithms have been in a continuous process of upgrading and optimization. Some researchers strive to improve the performance of hash algorithms, while others, including hackers, are dedicated to finding security issues in hash algorithms. Table 6-2 shows hash algorithms commonly used in practical applications.</p> <ul> <li>MD5 and SHA-1 have been successfully attacked multiple times and are thus abandoned in various security applications.</li> <li>SHA-2 series, especially SHA-256, is one of the most secure hash algorithms to date, with no successful attacks reported, hence commonly used in various security applications and protocols.</li> <li>SHA-3 has lower implementation costs and higher computational efficiency compared to SHA-2, but its current usage coverage is not as extensive as the SHA-2 series.</li> </ul> <p> Table 6-2 \u00a0 Common hash algorithms </p> MD5 SHA-1 SHA-2 SHA-3 Release Year 1992 1995 2002 2008 Output Length 128 bit 160 bit 256/512 bit 224/256/384/512 bit Hash Collisions Frequent Frequent Rare Rare Security Level Low, has been successfully attacked Low, has been successfully attacked High High Applications Abandoned, still used for data integrity checks Abandoned Cryptocurrency transaction verification, digital signatures, etc. Can be used to replace SHA-2"},{"location":"chapter_hashing/hash_algorithm/#hash-values-in-data-structures","title":"Hash Values in Data Structures","text":"<p>We know that the keys in a hash table can be of various data types such as integers, decimals, or strings. Programming languages usually provide built-in hash algorithms for these data types to calculate the bucket indices in the hash table. Taking Python as an example, we can use the <code>hash()</code> function to compute the hash values for various data types.</p> <ul> <li>The hash values of integers and booleans are their own values.</li> <li>The calculation of hash values for floating-point numbers and strings is more complex, and interested readers are encouraged to study this on their own.</li> <li>The hash value of a tuple is a combination of the hash values of each of its elements, resulting in a single hash value.</li> <li>The hash value of an object is generated based on its memory address. By overriding the hash method of an object, hash values can be generated based on content.</li> </ul> <p>Tip</p> <p>Be aware that the definition and methods of the built-in hash value calculation functions in different programming languages vary.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby built_in_hash.py<pre><code>num = 3\nhash_num = hash(num)\n# Hash value of integer 3 is 3\n\nbol = True\nhash_bol = hash(bol)\n# Hash value of boolean True is 1\n\ndec = 3.14159\nhash_dec = hash(dec)\n# Hash value of decimal 3.14159 is 326484311674566659\n\nstr = \"Hello \u7b97\u6cd5\"\nhash_str = hash(str)\n# Hash value of string \"Hello \u7b97\u6cd5\" is 4617003410720528961\n\ntup = (12836, \"\u5c0f\u54c8\")\nhash_tup = hash(tup)\n# Hash value of tuple (12836, '\u5c0f\u54c8') is 1029005403108185979\n\nobj = ListNode(0)\nhash_obj = hash(obj)\n# Hash value of ListNode object at 0x1058fd810 is 274267521\n</code></pre> built_in_hash.cpp<pre><code>int num = 3;\nsize_t hashNum = hash&lt;int&gt;()(num);\n// Hash value of integer 3 is 3\n\nbool bol = true;\nsize_t hashBol = hash&lt;bool&gt;()(bol);\n// Hash value of boolean 1 is 1\n\ndouble dec = 3.14159;\nsize_t hashDec = hash&lt;double&gt;()(dec);\n// Hash value of decimal 3.14159 is 4614256650576692846\n\nstring str = \"Hello \u7b97\u6cd5\";\nsize_t hashStr = hash&lt;string&gt;()(str);\n// Hash value of string \"Hello \u7b97\u6cd5\" is 15466937326284535026\n\n// In C++, built-in std::hash() only provides hash values for basic data types\n// Hash values for arrays and objects need to be implemented separately\n</code></pre> built_in_hash.java<pre><code>int num = 3;\nint hashNum = Integer.hashCode(num);\n// Hash value of integer 3 is 3\n\nboolean bol = true;\nint hashBol = Boolean.hashCode(bol);\n// Hash value of boolean true is 1231\n\ndouble dec = 3.14159;\nint hashDec = Double.hashCode(dec);\n// Hash value of decimal 3.14159 is -1340954729\n\nString str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.hashCode();\n// Hash value of string \"Hello \u7b97\u6cd5\" is -727081396\n\nObject[] arr = { 12836, \"\u5c0f\u54c8\" };\nint hashTup = Arrays.hashCode(arr);\n// Hash value of array [12836, \u5c0f\u54c8] is 1151158\n\nListNode obj = new ListNode(0);\nint hashObj = obj.hashCode();\n// Hash value of ListNode object utils.ListNode@7dc5e7b4 is 2110121908\n</code></pre> built_in_hash.cs<pre><code>int num = 3;\nint hashNum = num.GetHashCode();\n// Hash value of integer 3 is 3;\n\nbool bol = true;\nint hashBol = bol.GetHashCode();\n// Hash value of boolean true is 1;\n\ndouble dec = 3.14159;\nint hashDec = dec.GetHashCode();\n// Hash value of decimal 3.14159 is -1340954729;\n\nstring str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.GetHashCode();\n// Hash value of string \"Hello \u7b97\u6cd5\" is -586107568;\n\nobject[] arr = [12836, \"\u5c0f\u54c8\"];\nint hashTup = arr.GetHashCode();\n// Hash value of array [12836, \u5c0f\u54c8] is 42931033;\n\nListNode obj = new(0);\nint hashObj = obj.GetHashCode();\n// Hash value of ListNode object 0 is 39053774;\n</code></pre> built_in_hash.go<pre><code>// Go does not provide built-in hash code functions\n</code></pre> built_in_hash.swift<pre><code>let num = 3\nlet hashNum = num.hashValue\n// Hash value of integer 3 is 9047044699613009734\n\nlet bol = true\nlet hashBol = bol.hashValue\n// Hash value of boolean true is -4431640247352757451\n\nlet dec = 3.14159\nlet hashDec = dec.hashValue\n// Hash value of decimal 3.14159 is -2465384235396674631\n\nlet str = \"Hello \u7b97\u6cd5\"\nlet hashStr = str.hashValue\n// Hash value of string \"Hello \u7b97\u6cd5\" is -7850626797806988787\n\nlet arr = [AnyHashable(12836), AnyHashable(\"\u5c0f\u54c8\")]\nlet hashTup = arr.hashValue\n// Hash value of array [AnyHashable(12836), AnyHashable(\"\u5c0f\u54c8\")] is -2308633508154532996\n\nlet obj = ListNode(x: 0)\nlet hashObj = obj.hashValue\n// Hash value of ListNode object utils.ListNode is -2434780518035996159\n</code></pre> built_in_hash.js<pre><code>// JavaScript does not provide built-in hash code functions\n</code></pre> built_in_hash.ts<pre><code>// TypeScript does not provide built-in hash code functions\n</code></pre> built_in_hash.dart<pre><code>int num = 3;\nint hashNum = num.hashCode;\n// Hash value of integer 3 is 34803\n\nbool bol = true;\nint hashBol = bol.hashCode;\n// Hash value of boolean true is 1231\n\ndouble dec = 3.14159;\nint hashDec = dec.hashCode;\n// Hash value of decimal 3.14159 is 2570631074981783\n\nString str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.hashCode;\n// Hash value of string \"Hello \u7b97\u6cd5\" is 468167534\n\nList arr = [12836, \"\u5c0f\u54c8\"];\nint hashArr = arr.hashCode;\n// Hash value of array [12836, \u5c0f\u54c8] is 976512528\n\nListNode obj = new ListNode(0);\nint hashObj = obj.hashCode;\n// Hash value of ListNode object Instance of 'ListNode' is 1033450432\n</code></pre> built_in_hash.rs<pre><code>use std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nlet num = 3;\nlet mut num_hasher = DefaultHasher::new();\nnum.hash(&amp;mut num_hasher);\nlet hash_num = num_hasher.finish();\n// Hash value of integer 3 is 568126464209439262\n\nlet bol = true;\nlet mut bol_hasher = DefaultHasher::new();\nbol.hash(&amp;mut bol_hasher);\nlet hash_bol = bol_hasher.finish();\n// Hash value of boolean true is 4952851536318644461\n\nlet dec: f32 = 3.14159;\nlet mut dec_hasher = DefaultHasher::new();\ndec.to_bits().hash(&amp;mut dec_hasher);\nlet hash_dec = dec_hasher.finish();\n// Hash value of decimal 3.14159 is 2566941990314602357\n\nlet str = \"Hello \u7b97\u6cd5\";\nlet mut str_hasher = DefaultHasher::new();\nstr.hash(&amp;mut str_hasher);\nlet hash_str = str_hasher.finish();\n// Hash value of string \"Hello \u7b97\u6cd5\" is 16092673739211250988\n\nlet arr = (&amp;12836, &amp;\"\u5c0f\u54c8\");\nlet mut tup_hasher = DefaultHasher::new();\narr.hash(&amp;mut tup_hasher);\nlet hash_tup = tup_hasher.finish();\n// Hash value of tuple (12836, \"\u5c0f\u54c8\") is 1885128010422702749\n\nlet node = ListNode::new(42);\nlet mut hasher = DefaultHasher::new();\nnode.borrow().val.hash(&amp;mut hasher);\nlet hash = hasher.finish();\n// Hash value of ListNode object RefCell { value: ListNode { val: 42, next: None } } is 15387811073369036852\n</code></pre> built_in_hash.c<pre><code>// C does not provide built-in hash code functions\n</code></pre> built_in_hash.kt<pre><code>val num = 3\nval hashNum = num.hashCode()\n// Hash value of integer 3 is 3\n\nval bol = true\nval hashBol = bol.hashCode()\n// Hash value of boolean true is 1231\n\nval dec = 3.14159\nval hashDec = dec.hashCode()\n// Hash value of decimal 3.14159 is -1340954729\n\nval str = \"Hello \u7b97\u6cd5\"\nval hashStr = str.hashCode()\n// Hash value of string \"Hello \u7b97\u6cd5\" is -727081396\n\nval arr = arrayOf&lt;Any&gt;(12836, \"\u5c0f\u54c8\")\nval hashTup = arr.hashCode()\n// Hash value of array [12836, \u5c0f\u54c8] is 189568618\n\nval obj = ListNode(0)\nval hashObj = obj.hashCode()\n// Hash value of ListNode object utils.ListNode@1d81eb93 is 495053715\n</code></pre> built_in_hash.rb<pre><code>num = 3\nhash_num = num.hash\n# Hash value of integer 3 is -4385856518450339636\n\nbol = true\nhash_bol = bol.hash\n# Hash value of boolean true is -1617938112149317027\n\ndec = 3.14159\nhash_dec = dec.hash\n# Hash value of decimal 3.14159 is -1479186995943067893\n\nstr = \"Hello \u7b97\u6cd5\"\nhash_str = str.hash\n# Hash value of string \"Hello \u7b97\u6cd5\" is -4075943250025831763\n\ntup = [12836, '\u5c0f\u54c8']\nhash_tup = tup.hash\n# Hash value of tuple (12836, '\u5c0f\u54c8') is 1999544809202288822\n\nobj = ListNode.new(0)\nhash_obj = obj.hash\n# Hash value of ListNode object #&lt;ListNode:0x000078133140ab70&gt; is 4302940560806366381\n</code></pre> Visualized Execution <p>https://pythontutor.com/render.html#code=class%20ListNode%3A%0A%20%20%20%20%22%22%22%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%B1%BB%22%22%22%0A%20%20%20%20def%20__init__%28self,%20val%3A%20int%29%3A%0A%20%20%20%20%20%20%20%20self.val%3A%20int%20%3D%20val%20%20%23%20%E8%8A%82%E7%82%B9%E5%80%BC%0A%20%20%20%20%20%20%20%20self.next%3A%20ListNode%20%7C%20None%20%3D%20None%20%20%23%20%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20num%20%3D%203%0A%20%20%20%20hash_num%20%3D%20hash%28num%29%0A%20%20%20%20%23%20%E6%95%B4%E6%95%B0%203%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%203%0A%0A%20%20%20%20bol%20%3D%20True%0A%20%20%20%20hash_bol%20%3D%20hash%28bol%29%0A%20%20%20%20%23%20%E5%B8%83%E5%B0%94%E9%87%8F%20True%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%201%0A%0A%20%20%20%20dec%20%3D%203.14159%0A%20%20%20%20hash_dec%20%3D%20hash%28dec%29%0A%20%20%20%20%23%20%E5%B0%8F%E6%95%B0%203.14159%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%20326484311674566659%0A%0A%20%20%20%20str%20%3D%20%22Hello%20%E7%AE%97%E6%B3%95%22%0A%20%20%20%20hash_str%20%3D%20hash%28str%29%0A%20%20%20%20%23%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9CHello%20%E7%AE%97%E6%B3%95%E2%80%9D%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%204617003410720528961%0A%0A%20%20%20%20tup%20%3D%20%2812836,%20%22%E5%B0%8F%E5%93%88%22%29%0A%20%20%20%20hash_tup%20%3D%20hash%28tup%29%0A%20%20%20%20%23%20%E5%85%83%E7%BB%84%20%2812836,%20'%E5%B0%8F%E5%93%88'%29%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%201029005403108185979%0A%0A%20%20%20%20obj%20%3D%20ListNode%280%29%0A%20%20%20%20hash_obj%20%3D%20hash%28obj%29%0A%20%20%20%20%23%20%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1%20%3CListNode%20object%20at%200x1058fd810%3E%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%20274267521&amp;cumulative=false&amp;curInstr=19&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p> <p>In many programming languages, only immutable objects can serve as the <code>key</code> in a hash table. If we use a list (dynamic array) as a <code>key</code>, when the contents of the list change, its hash value also changes, and we would no longer be able to find the original <code>value</code> in the hash table.</p> <p>Although the member variables of a custom object (such as a linked list node) are mutable, it is hashable. This is because the hash value of an object is usually generated based on its memory address, and even if the contents of the object change, the memory address remains the same, so the hash value remains unchanged.</p> <p>You might have noticed that the hash values output in different consoles are different. This is because the Python interpreter adds a random salt to the string hash function each time it starts up. This approach effectively prevents HashDoS attacks and enhances the security of the hash algorithm.</p>"},{"location":"chapter_hashing/hash_collision/","title":"6.2 \u00a0 Hash Collision","text":"<p>The previous section mentioned that, in most cases, the input space of a hash function is much larger than the output space, so theoretically, hash collisions are inevitable. For example, if the input space is all integers and the output space is the array capacity size, then multiple integers will inevitably be mapped to the same bucket index.</p> <p>Hash collisions can lead to incorrect query results, severely impacting the usability of the hash table. To address this issue, whenever a hash collision occurs, we can perform hash table expansion until the collision disappears. This approach is simple, straightforward, and effective, but it is very inefficient because hash table expansion involves a large amount of data migration and hash value recalculation. To improve efficiency, we can adopt the following strategies:</p> <ol> <li>Improve the hash table data structure so that the hash table can function normally when hash collisions occur.</li> <li>Only expand when necessary, that is, only when hash collisions are severe.</li> </ol> <p>The main methods for improving the structure of hash tables include \"separate chaining\" and \"open addressing\".</p>"},{"location":"chapter_hashing/hash_collision/#621-separate-chaining","title":"6.2.1 \u00a0 Separate Chaining","text":"<p>In the original hash table, each bucket can store only one key-value pair. Separate chaining converts a single element into a linked list, treating key-value pairs as linked list nodes and storing all colliding key-value pairs in the same linked list. Figure 6-5 shows an example of a separate chaining hash table.</p> <p></p> <p> Figure 6-5 \u00a0 Separate chaining hash table </p> <p>The operations of a hash table implemented with separate chaining have changed as follows:</p> <ul> <li>Querying elements: Input <code>key</code>, obtain the bucket index through the hash function, then access the head node of the linked list, then traverse the linked list and compare <code>key</code> to find the target key-value pair.</li> <li>Adding elements: First access the linked list head node through the hash function, then append the node (key-value pair) to the linked list.</li> <li>Deleting elements: Access the head of the linked list based on the result of the hash function, then traverse the linked list to find the target node and delete it.</li> </ul> <p>Separate chaining has the following limitations:</p> <ul> <li>Increased Space Usage: The linked list contains node pointers, which consume more memory space than arrays.</li> <li>Reduced Query Efficiency: This is because linear traversal of the linked list is required to find the corresponding element.</li> </ul> <p>The code below provides a simple implementation of a separate chaining hash table, with two things to note:</p> <ul> <li>Lists (dynamic arrays) are used instead of linked lists to simplify the code. In this setup, the hash table (array) contains multiple buckets, each of which is a list.</li> <li>This implementation includes a hash table expansion method. When the load factor exceeds \\(\\frac{2}{3}\\), we expand the hash table to \\(2\\) times its original size.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby hash_map_chaining.py<pre><code>class HashMapChaining:\n    \"\"\"Hash table with separate chaining\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self.size = 0  # Number of key-value pairs\n        self.capacity = 4  # Hash table capacity\n        self.load_thres = 2.0 / 3.0  # Load factor threshold for triggering expansion\n        self.extend_ratio = 2  # Expansion multiplier\n        self.buckets = [[] for _ in range(self.capacity)]  # Bucket array\n\n    def hash_func(self, key: int) -&gt; int:\n        \"\"\"Hash function\"\"\"\n        return key % self.capacity\n\n    def load_factor(self) -&gt; float:\n        \"\"\"Load factor\"\"\"\n        return self.size / self.capacity\n\n    def get(self, key: int) -&gt; str | None:\n        \"\"\"Query operation\"\"\"\n        index = self.hash_func(key)\n        bucket = self.buckets[index]\n        # Traverse bucket, if key is found, return corresponding val\n        for pair in bucket:\n            if pair.key == key:\n                return pair.val\n        # If key is not found, return None\n        return None\n\n    def put(self, key: int, val: str):\n        \"\"\"Add operation\"\"\"\n        # When load factor exceeds threshold, perform expansion\n        if self.load_factor() &gt; self.load_thres:\n            self.extend()\n        index = self.hash_func(key)\n        bucket = self.buckets[index]\n        # Traverse bucket, if specified key is encountered, update corresponding val and return\n        for pair in bucket:\n            if pair.key == key:\n                pair.val = val\n                return\n        # If key does not exist, append key-value pair to the end\n        pair = Pair(key, val)\n        bucket.append(pair)\n        self.size += 1\n\n    def remove(self, key: int):\n        \"\"\"Remove operation\"\"\"\n        index = self.hash_func(key)\n        bucket = self.buckets[index]\n        # Traverse bucket and remove key-value pair from it\n        for pair in bucket:\n            if pair.key == key:\n                bucket.remove(pair)\n                self.size -= 1\n                break\n\n    def extend(self):\n        \"\"\"Expand hash table\"\"\"\n        # Temporarily store the original hash table\n        buckets = self.buckets\n        # Initialize expanded new hash table\n        self.capacity *= self.extend_ratio\n        self.buckets = [[] for _ in range(self.capacity)]\n        self.size = 0\n        # Move key-value pairs from original hash table to new hash table\n        for bucket in buckets:\n            for pair in bucket:\n                self.put(pair.key, pair.val)\n\n    def print(self):\n        \"\"\"Print hash table\"\"\"\n        for bucket in self.buckets:\n            res = []\n            for pair in bucket:\n                res.append(str(pair.key) + \" -&gt; \" + pair.val)\n            print(res)\n</code></pre> hash_map_chaining.cpp<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n  private:\n    int size;                       // Number of key-value pairs\n    int capacity;                   // Hash table capacity\n    double loadThres;               // Load factor threshold for triggering expansion\n    int extendRatio;                // Expansion multiplier\n    vector&lt;vector&lt;Pair *&gt;&gt; buckets; // Bucket array\n\n  public:\n    /* Constructor */\n    HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3.0), extendRatio(2) {\n        buckets.resize(capacity);\n    }\n\n    /* Destructor */\n    ~HashMapChaining() {\n        for (auto &amp;bucket : buckets) {\n            for (Pair *pair : bucket) {\n                // Free memory\n                delete pair;\n            }\n        }\n    }\n\n    /* Hash function */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* Load factor */\n    double loadFactor() {\n        return (double)size / (double)capacity;\n    }\n\n    /* Query operation */\n    string get(int key) {\n        int index = hashFunc(key);\n        // Traverse bucket, if key is found, return corresponding val\n        for (Pair *pair : buckets[index]) {\n            if (pair-&gt;key == key) {\n                return pair-&gt;val;\n            }\n        }\n        // Return empty string if key not found\n        return \"\";\n    }\n\n    /* Add operation */\n    void put(int key, string val) {\n        // When load factor exceeds threshold, perform expansion\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        int index = hashFunc(key);\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        for (Pair *pair : buckets[index]) {\n            if (pair-&gt;key == key) {\n                pair-&gt;val = val;\n                return;\n            }\n        }\n        // If key does not exist, append key-value pair to the end\n        buckets[index].push_back(new Pair(key, val));\n        size++;\n    }\n\n    /* Remove operation */\n    void remove(int key) {\n        int index = hashFunc(key);\n        auto &amp;bucket = buckets[index];\n        // Traverse bucket and remove key-value pair from it\n        for (int i = 0; i &lt; bucket.size(); i++) {\n            if (bucket[i]-&gt;key == key) {\n                Pair *tmp = bucket[i];\n                bucket.erase(bucket.begin() + i); // Remove key-value pair from it\n                delete tmp;                       // Free memory\n                size--;\n                return;\n            }\n        }\n    }\n\n    /* Expand hash table */\n    void extend() {\n        // Temporarily store the original hash table\n        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;\n        // Initialize expanded new hash table\n        capacity *= extendRatio;\n        buckets.clear();\n        buckets.resize(capacity);\n        size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (auto &amp;bucket : bucketsTmp) {\n            for (Pair *pair : bucket) {\n                put(pair-&gt;key, pair-&gt;val);\n                // Free memory\n                delete pair;\n            }\n        }\n    }\n\n    /* Print hash table */\n    void print() {\n        for (auto &amp;bucket : buckets) {\n            cout &lt;&lt; \"[\";\n            for (Pair *pair : bucket) {\n                cout &lt;&lt; pair-&gt;key &lt;&lt; \" -&gt; \" &lt;&lt; pair-&gt;val &lt;&lt; \", \";\n            }\n            cout &lt;&lt; \"]\\n\";\n        }\n    }\n};\n</code></pre> hash_map_chaining.java<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n    int size; // Number of key-value pairs\n    int capacity; // Hash table capacity\n    double loadThres; // Load factor threshold for triggering expansion\n    int extendRatio; // Expansion multiplier\n    List&lt;List&lt;Pair&gt;&gt; buckets; // Bucket array\n\n    /* Constructor */\n    public HashMapChaining() {\n        size = 0;\n        capacity = 4;\n        loadThres = 2.0 / 3.0;\n        extendRatio = 2;\n        buckets = new ArrayList&lt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.add(new ArrayList&lt;&gt;());\n        }\n    }\n\n    /* Hash function */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* Load factor */\n    double loadFactor() {\n        return (double) size / capacity;\n    }\n\n    /* Query operation */\n    String get(int key) {\n        int index = hashFunc(key);\n        List&lt;Pair&gt; bucket = buckets.get(index);\n        // Traverse bucket, if key is found, return corresponding val\n        for (Pair pair : bucket) {\n            if (pair.key == key) {\n                return pair.val;\n            }\n        }\n        // If key is not found, return null\n        return null;\n    }\n\n    /* Add operation */\n    void put(int key, String val) {\n        // When load factor exceeds threshold, perform expansion\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        int index = hashFunc(key);\n        List&lt;Pair&gt; bucket = buckets.get(index);\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        for (Pair pair : bucket) {\n            if (pair.key == key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // If key does not exist, append key-value pair to the end\n        Pair pair = new Pair(key, val);\n        bucket.add(pair);\n        size++;\n    }\n\n    /* Remove operation */\n    void remove(int key) {\n        int index = hashFunc(key);\n        List&lt;Pair&gt; bucket = buckets.get(index);\n        // Traverse bucket and remove key-value pair from it\n        for (Pair pair : bucket) {\n            if (pair.key == key) {\n                bucket.remove(pair);\n                size--;\n                break;\n            }\n        }\n    }\n\n    /* Expand hash table */\n    void extend() {\n        // Temporarily store the original hash table\n        List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;\n        // Initialize expanded new hash table\n        capacity *= extendRatio;\n        buckets = new ArrayList&lt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.add(new ArrayList&lt;&gt;());\n        }\n        size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (List&lt;Pair&gt; bucket : bucketsTmp) {\n            for (Pair pair : bucket) {\n                put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    void print() {\n        for (List&lt;Pair&gt; bucket : buckets) {\n            List&lt;String&gt; res = new ArrayList&lt;&gt;();\n            for (Pair pair : bucket) {\n                res.add(pair.key + \" -&gt; \" + pair.val);\n            }\n            System.out.println(res);\n        }\n    }\n}\n</code></pre> hash_map_chaining.cs<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n    int size; // Number of key-value pairs\n    int capacity; // Hash table capacity\n    double loadThres; // Load factor threshold for triggering expansion\n    int extendRatio; // Expansion multiplier\n    List&lt;List&lt;Pair&gt;&gt; buckets; // Bucket array\n\n    /* Constructor */\n    public HashMapChaining() {\n        size = 0;\n        capacity = 4;\n        loadThres = 2.0 / 3.0;\n        extendRatio = 2;\n        buckets = new List&lt;List&lt;Pair&gt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.Add([]);\n        }\n    }\n\n    /* Hash function */\n    int HashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* Load factor */\n    double LoadFactor() {\n        return (double)size / capacity;\n    }\n\n    /* Query operation */\n    public string? Get(int key) {\n        int index = HashFunc(key);\n        // Traverse bucket, if key is found, return corresponding val\n        foreach (Pair pair in buckets[index]) {\n            if (pair.key == key) {\n                return pair.val;\n            }\n        }\n        // If key is not found, return null\n        return null;\n    }\n\n    /* Add operation */\n    public void Put(int key, string val) {\n        // When load factor exceeds threshold, perform expansion\n        if (LoadFactor() &gt; loadThres) {\n            Extend();\n        }\n        int index = HashFunc(key);\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        foreach (Pair pair in buckets[index]) {\n            if (pair.key == key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // If key does not exist, append key-value pair to the end\n        buckets[index].Add(new Pair(key, val));\n        size++;\n    }\n\n    /* Remove operation */\n    public void Remove(int key) {\n        int index = HashFunc(key);\n        // Traverse bucket and remove key-value pair from it\n        foreach (Pair pair in buckets[index].ToList()) {\n            if (pair.key == key) {\n                buckets[index].Remove(pair);\n                size--;\n                break;\n            }\n        }\n    }\n\n    /* Expand hash table */\n    void Extend() {\n        // Temporarily store the original hash table\n        List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;\n        // Initialize expanded new hash table\n        capacity *= extendRatio;\n        buckets = new List&lt;List&lt;Pair&gt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.Add([]);\n        }\n        size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        foreach (List&lt;Pair&gt; bucket in bucketsTmp) {\n            foreach (Pair pair in bucket) {\n                Put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    public void Print() {\n        foreach (List&lt;Pair&gt; bucket in buckets) {\n            List&lt;string&gt; res = [];\n            foreach (Pair pair in bucket) {\n                res.Add(pair.key + \" -&gt; \" + pair.val);\n            }\n            foreach (string kv in res) {\n                Console.WriteLine(kv);\n            }\n        }\n    }\n}\n</code></pre> hash_map_chaining.go<pre><code>/* Hash table with separate chaining */\ntype hashMapChaining struct {\n    size        int      // Number of key-value pairs\n    capacity    int      // Hash table capacity\n    loadThres   float64  // Load factor threshold for triggering expansion\n    extendRatio int      // Expansion multiplier\n    buckets     [][]pair // Bucket array\n}\n\n/* Constructor */\nfunc newHashMapChaining() *hashMapChaining {\n    buckets := make([][]pair, 4)\n    for i := 0; i &lt; 4; i++ {\n        buckets[i] = make([]pair, 0)\n    }\n    return &amp;hashMapChaining{\n        size:        0,\n        capacity:    4,\n        loadThres:   2.0 / 3.0,\n        extendRatio: 2,\n        buckets:     buckets,\n    }\n}\n\n/* Hash function */\nfunc (m *hashMapChaining) hashFunc(key int) int {\n    return key % m.capacity\n}\n\n/* Load factor */\nfunc (m *hashMapChaining) loadFactor() float64 {\n    return float64(m.size) / float64(m.capacity)\n}\n\n/* Query operation */\nfunc (m *hashMapChaining) get(key int) string {\n    idx := m.hashFunc(key)\n    bucket := m.buckets[idx]\n    // Traverse bucket, if key is found, return corresponding val\n    for _, p := range bucket {\n        if p.key == key {\n            return p.val\n        }\n    }\n    // Return empty string if key not found\n    return \"\"\n}\n\n/* Add operation */\nfunc (m *hashMapChaining) put(key int, val string) {\n    // When load factor exceeds threshold, perform expansion\n    if m.loadFactor() &gt; m.loadThres {\n        m.extend()\n    }\n    idx := m.hashFunc(key)\n    // Traverse bucket, if specified key is encountered, update corresponding val and return\n    for i := range m.buckets[idx] {\n        if m.buckets[idx][i].key == key {\n            m.buckets[idx][i].val = val\n            return\n        }\n    }\n    // If key does not exist, append key-value pair to the end\n    p := pair{\n        key: key,\n        val: val,\n    }\n    m.buckets[idx] = append(m.buckets[idx], p)\n    m.size += 1\n}\n\n/* Remove operation */\nfunc (m *hashMapChaining) remove(key int) {\n    idx := m.hashFunc(key)\n    // Traverse bucket and remove key-value pair from it\n    for i, p := range m.buckets[idx] {\n        if p.key == key {\n            // Slice deletion\n            m.buckets[idx] = append(m.buckets[idx][:i], m.buckets[idx][i+1:]...)\n            m.size -= 1\n            break\n        }\n    }\n}\n\n/* Expand hash table */\nfunc (m *hashMapChaining) extend() {\n    // Temporarily store the original hash table\n    tmpBuckets := make([][]pair, len(m.buckets))\n    for i := 0; i &lt; len(m.buckets); i++ {\n        tmpBuckets[i] = make([]pair, len(m.buckets[i]))\n        copy(tmpBuckets[i], m.buckets[i])\n    }\n    // Initialize expanded new hash table\n    m.capacity *= m.extendRatio\n    m.buckets = make([][]pair, m.capacity)\n    for i := 0; i &lt; m.capacity; i++ {\n        m.buckets[i] = make([]pair, 0)\n    }\n    m.size = 0\n    // Move key-value pairs from original hash table to new hash table\n    for _, bucket := range tmpBuckets {\n        for _, p := range bucket {\n            m.put(p.key, p.val)\n        }\n    }\n}\n\n/* Print hash table */\nfunc (m *hashMapChaining) print() {\n    var builder strings.Builder\n\n    for _, bucket := range m.buckets {\n        builder.WriteString(\"[\")\n        for _, p := range bucket {\n            builder.WriteString(strconv.Itoa(p.key) + \" -&gt; \" + p.val + \" \")\n        }\n        builder.WriteString(\"]\")\n        fmt.Println(builder.String())\n        builder.Reset()\n    }\n}\n</code></pre> hash_map_chaining.swift<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n    var size: Int // Number of key-value pairs\n    var capacity: Int // Hash table capacity\n    var loadThres: Double // Load factor threshold for triggering expansion\n    var extendRatio: Int // Expansion multiplier\n    var buckets: [[Pair]] // Bucket array\n\n    /* Constructor */\n    init() {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = Array(repeating: [], count: capacity)\n    }\n\n    /* Hash function */\n    func hashFunc(key: Int) -&gt; Int {\n        key % capacity\n    }\n\n    /* Load factor */\n    func loadFactor() -&gt; Double {\n        Double(size) / Double(capacity)\n    }\n\n    /* Query operation */\n    func get(key: Int) -&gt; String? {\n        let index = hashFunc(key: key)\n        let bucket = buckets[index]\n        // Traverse bucket, if key is found, return corresponding val\n        for pair in bucket {\n            if pair.key == key {\n                return pair.val\n            }\n        }\n        // Return nil if key not found\n        return nil\n    }\n\n    /* Add operation */\n    func put(key: Int, val: String) {\n        // When load factor exceeds threshold, perform expansion\n        if loadFactor() &gt; loadThres {\n            extend()\n        }\n        let index = hashFunc(key: key)\n        let bucket = buckets[index]\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        for pair in bucket {\n            if pair.key == key {\n                pair.val = val\n                return\n            }\n        }\n        // If key does not exist, append key-value pair to the end\n        let pair = Pair(key: key, val: val)\n        buckets[index].append(pair)\n        size += 1\n    }\n\n    /* Remove operation */\n    func remove(key: Int) {\n        let index = hashFunc(key: key)\n        let bucket = buckets[index]\n        // Traverse bucket and remove key-value pair from it\n        for (pairIndex, pair) in bucket.enumerated() {\n            if pair.key == key {\n                buckets[index].remove(at: pairIndex)\n                size -= 1\n                break\n            }\n        }\n    }\n\n    /* Expand hash table */\n    func extend() {\n        // Temporarily store the original hash table\n        let bucketsTmp = buckets\n        // Initialize expanded new hash table\n        capacity *= extendRatio\n        buckets = Array(repeating: [], count: capacity)\n        size = 0\n        // Move key-value pairs from original hash table to new hash table\n        for bucket in bucketsTmp {\n            for pair in bucket {\n                put(key: pair.key, val: pair.val)\n            }\n        }\n    }\n\n    /* Print hash table */\n    func print() {\n        for bucket in buckets {\n            let res = bucket.map { \"\\($0.key) -&gt; \\($0.val)\" }\n            Swift.print(res)\n        }\n    }\n}\n</code></pre> hash_map_chaining.js<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n    #size; // Number of key-value pairs\n    #capacity; // Hash table capacity\n    #loadThres; // Load factor threshold for triggering expansion\n    #extendRatio; // Expansion multiplier\n    #buckets; // Bucket array\n\n    /* Constructor */\n    constructor() {\n        this.#size = 0;\n        this.#capacity = 4;\n        this.#loadThres = 2.0 / 3.0;\n        this.#extendRatio = 2;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n    }\n\n    /* Hash function */\n    #hashFunc(key) {\n        return key % this.#capacity;\n    }\n\n    /* Load factor */\n    #loadFactor() {\n        return this.#size / this.#capacity;\n    }\n\n    /* Query operation */\n    get(key) {\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // Traverse bucket, if key is found, return corresponding val\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                return pair.val;\n            }\n        }\n        // If key is not found, return null\n        return null;\n    }\n\n    /* Add operation */\n    put(key, val) {\n        // When load factor exceeds threshold, perform expansion\n        if (this.#loadFactor() &gt; this.#loadThres) {\n            this.#extend();\n        }\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // If key does not exist, append key-value pair to the end\n        const pair = new Pair(key, val);\n        bucket.push(pair);\n        this.#size++;\n    }\n\n    /* Remove operation */\n    remove(key) {\n        const index = this.#hashFunc(key);\n        let bucket = this.#buckets[index];\n        // Traverse bucket and remove key-value pair from it\n        for (let i = 0; i &lt; bucket.length; i++) {\n            if (bucket[i].key === key) {\n                bucket.splice(i, 1);\n                this.#size--;\n                break;\n            }\n        }\n    }\n\n    /* Expand hash table */\n    #extend() {\n        // Temporarily store the original hash table\n        const bucketsTmp = this.#buckets;\n        // Initialize expanded new hash table\n        this.#capacity *= this.#extendRatio;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n        this.#size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (const bucket of bucketsTmp) {\n            for (const pair of bucket) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    print() {\n        for (const bucket of this.#buckets) {\n            let res = [];\n            for (const pair of bucket) {\n                res.push(pair.key + ' -&gt; ' + pair.val);\n            }\n            console.log(res);\n        }\n    }\n}\n</code></pre> hash_map_chaining.ts<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n    #size: number; // Number of key-value pairs\n    #capacity: number; // Hash table capacity\n    #loadThres: number; // Load factor threshold for triggering expansion\n    #extendRatio: number; // Expansion multiplier\n    #buckets: Pair[][]; // Bucket array\n\n    /* Constructor */\n    constructor() {\n        this.#size = 0;\n        this.#capacity = 4;\n        this.#loadThres = 2.0 / 3.0;\n        this.#extendRatio = 2;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n    }\n\n    /* Hash function */\n    #hashFunc(key: number): number {\n        return key % this.#capacity;\n    }\n\n    /* Load factor */\n    #loadFactor(): number {\n        return this.#size / this.#capacity;\n    }\n\n    /* Query operation */\n    get(key: number): string | null {\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // Traverse bucket, if key is found, return corresponding val\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                return pair.val;\n            }\n        }\n        // If key is not found, return null\n        return null;\n    }\n\n    /* Add operation */\n    put(key: number, val: string): void {\n        // When load factor exceeds threshold, perform expansion\n        if (this.#loadFactor() &gt; this.#loadThres) {\n            this.#extend();\n        }\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // If key does not exist, append key-value pair to the end\n        const pair = new Pair(key, val);\n        bucket.push(pair);\n        this.#size++;\n    }\n\n    /* Remove operation */\n    remove(key: number): void {\n        const index = this.#hashFunc(key);\n        let bucket = this.#buckets[index];\n        // Traverse bucket and remove key-value pair from it\n        for (let i = 0; i &lt; bucket.length; i++) {\n            if (bucket[i].key === key) {\n                bucket.splice(i, 1);\n                this.#size--;\n                break;\n            }\n        }\n    }\n\n    /* Expand hash table */\n    #extend(): void {\n        // Temporarily store the original hash table\n        const bucketsTmp = this.#buckets;\n        // Initialize expanded new hash table\n        this.#capacity *= this.#extendRatio;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n        this.#size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (const bucket of bucketsTmp) {\n            for (const pair of bucket) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    print(): void {\n        for (const bucket of this.#buckets) {\n            let res = [];\n            for (const pair of bucket) {\n                res.push(pair.key + ' -&gt; ' + pair.val);\n            }\n            console.log(res);\n        }\n    }\n}\n</code></pre> hash_map_chaining.dart<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n  late int size; // Number of key-value pairs\n  late int capacity; // Hash table capacity\n  late double loadThres; // Load factor threshold for triggering expansion\n  late int extendRatio; // Expansion multiplier\n  late List&lt;List&lt;Pair&gt;&gt; buckets; // Bucket array\n\n  /* Constructor */\n  HashMapChaining() {\n    size = 0;\n    capacity = 4;\n    loadThres = 2.0 / 3.0;\n    extendRatio = 2;\n    buckets = List.generate(capacity, (_) =&gt; []);\n  }\n\n  /* Hash function */\n  int hashFunc(int key) {\n    return key % capacity;\n  }\n\n  /* Load factor */\n  double loadFactor() {\n    return size / capacity;\n  }\n\n  /* Query operation */\n  String? get(int key) {\n    int index = hashFunc(key);\n    List&lt;Pair&gt; bucket = buckets[index];\n    // Traverse bucket, if key is found, return corresponding val\n    for (Pair pair in bucket) {\n      if (pair.key == key) {\n        return pair.val;\n      }\n    }\n    // If key is not found, return null\n    return null;\n  }\n\n  /* Add operation */\n  void put(int key, String val) {\n    // When load factor exceeds threshold, perform expansion\n    if (loadFactor() &gt; loadThres) {\n      extend();\n    }\n    int index = hashFunc(key);\n    List&lt;Pair&gt; bucket = buckets[index];\n    // Traverse bucket, if specified key is encountered, update corresponding val and return\n    for (Pair pair in bucket) {\n      if (pair.key == key) {\n        pair.val = val;\n        return;\n      }\n    }\n    // If key does not exist, append key-value pair to the end\n    Pair pair = Pair(key, val);\n    bucket.add(pair);\n    size++;\n  }\n\n  /* Remove operation */\n  void remove(int key) {\n    int index = hashFunc(key);\n    List&lt;Pair&gt; bucket = buckets[index];\n    // Traverse bucket and remove key-value pair from it\n    for (Pair pair in bucket) {\n      if (pair.key == key) {\n        bucket.remove(pair);\n        size--;\n        break;\n      }\n    }\n  }\n\n  /* Expand hash table */\n  void extend() {\n    // Temporarily store the original hash table\n    List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;\n    // Initialize expanded new hash table\n    capacity *= extendRatio;\n    buckets = List.generate(capacity, (_) =&gt; []);\n    size = 0;\n    // Move key-value pairs from original hash table to new hash table\n    for (List&lt;Pair&gt; bucket in bucketsTmp) {\n      for (Pair pair in bucket) {\n        put(pair.key, pair.val);\n      }\n    }\n  }\n\n  /* Print hash table */\n  void printHashMap() {\n    for (List&lt;Pair&gt; bucket in buckets) {\n      List&lt;String&gt; res = [];\n      for (Pair pair in bucket) {\n        res.add(\"${pair.key} -&gt; ${pair.val}\");\n      }\n      print(res);\n    }\n  }\n}\n</code></pre> hash_map_chaining.rs<pre><code>/* Hash table with separate chaining */\nstruct HashMapChaining {\n    size: usize,\n    capacity: usize,\n    load_thres: f32,\n    extend_ratio: usize,\n    buckets: Vec&lt;Vec&lt;Pair&gt;&gt;,\n}\n\nimpl HashMapChaining {\n    /* Constructor */\n    fn new() -&gt; Self {\n        Self {\n            size: 0,\n            capacity: 4,\n            load_thres: 2.0 / 3.0,\n            extend_ratio: 2,\n            buckets: vec![vec![]; 4],\n        }\n    }\n\n    /* Hash function */\n    fn hash_func(&amp;self, key: i32) -&gt; usize {\n        key as usize % self.capacity\n    }\n\n    /* Load factor */\n    fn load_factor(&amp;self) -&gt; f32 {\n        self.size as f32 / self.capacity as f32\n    }\n\n    /* Remove operation */\n    fn remove(&amp;mut self, key: i32) -&gt; Option&lt;String&gt; {\n        let index = self.hash_func(key);\n\n        // Traverse bucket and remove key-value pair from it\n        for (i, p) in self.buckets[index].iter_mut().enumerate() {\n            if p.key == key {\n                let pair = self.buckets[index].remove(i);\n                self.size -= 1;\n                return Some(pair.val);\n            }\n        }\n\n        // If key is not found, return None\n        None\n    }\n\n    /* Expand hash table */\n    fn extend(&amp;mut self) {\n        // Temporarily store the original hash table\n        let buckets_tmp = std::mem::take(&amp;mut self.buckets);\n\n        // Initialize expanded new hash table\n        self.capacity *= self.extend_ratio;\n        self.buckets = vec![Vec::new(); self.capacity as usize];\n        self.size = 0;\n\n        // Move key-value pairs from original hash table to new hash table\n        for bucket in buckets_tmp {\n            for pair in bucket {\n                self.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    fn print(&amp;self) {\n        for bucket in &amp;self.buckets {\n            let mut res = Vec::new();\n            for pair in bucket {\n                res.push(format!(\"{} -&gt; {}\", pair.key, pair.val));\n            }\n            println!(\"{:?}\", res);\n        }\n    }\n\n    /* Add operation */\n    fn put(&amp;mut self, key: i32, val: String) {\n        // When load factor exceeds threshold, perform expansion\n        if self.load_factor() &gt; self.load_thres {\n            self.extend();\n        }\n\n        let index = self.hash_func(key);\n\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        for pair in self.buckets[index].iter_mut() {\n            if pair.key == key {\n                pair.val = val;\n                return;\n            }\n        }\n\n        // If key does not exist, append key-value pair to the end\n        let pair = Pair { key, val };\n        self.buckets[index].push(pair);\n        self.size += 1;\n    }\n\n    /* Query operation */\n    fn get(&amp;self, key: i32) -&gt; Option&lt;&amp;str&gt; {\n        let index = self.hash_func(key);\n\n        // Traverse bucket, if key is found, return corresponding val\n        for pair in self.buckets[index].iter() {\n            if pair.key == key {\n                return Some(&amp;pair.val);\n            }\n        }\n\n        // If key is not found, return None\n        None\n    }\n}\n</code></pre> hash_map_chaining.c<pre><code>/* Linked list node */\ntypedef struct Node {\n    Pair *pair;\n    struct Node *next;\n} Node;\n\n/* Hash table with separate chaining */\ntypedef struct {\n    int size;         // Number of key-value pairs\n    int capacity;     // Hash table capacity\n    double loadThres; // Load factor threshold for triggering expansion\n    int extendRatio;  // Expansion multiplier\n    Node **buckets;   // Bucket array\n} HashMapChaining;\n\n/* Constructor */\nHashMapChaining *newHashMapChaining() {\n    HashMapChaining *hashMap = (HashMapChaining *)malloc(sizeof(HashMapChaining));\n    hashMap-&gt;size = 0;\n    hashMap-&gt;capacity = 4;\n    hashMap-&gt;loadThres = 2.0 / 3.0;\n    hashMap-&gt;extendRatio = 2;\n    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        hashMap-&gt;buckets[i] = NULL;\n    }\n    return hashMap;\n}\n\n/* Destructor */\nvoid delHashMapChaining(HashMapChaining *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Node *cur = hashMap-&gt;buckets[i];\n        while (cur) {\n            Node *tmp = cur;\n            cur = cur-&gt;next;\n            free(tmp-&gt;pair);\n            free(tmp);\n        }\n    }\n    free(hashMap-&gt;buckets);\n    free(hashMap);\n}\n\n/* Hash function */\nint hashFunc(HashMapChaining *hashMap, int key) {\n    return key % hashMap-&gt;capacity;\n}\n\n/* Load factor */\ndouble loadFactor(HashMapChaining *hashMap) {\n    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;\n}\n\n/* Query operation */\nchar *get(HashMapChaining *hashMap, int key) {\n    int index = hashFunc(hashMap, key);\n    // Traverse bucket, if key is found, return corresponding val\n    Node *cur = hashMap-&gt;buckets[index];\n    while (cur) {\n        if (cur-&gt;pair-&gt;key == key) {\n            return cur-&gt;pair-&gt;val;\n        }\n        cur = cur-&gt;next;\n    }\n    return \"\"; // Return empty string if key not found\n}\n\n/* Add operation */\nvoid put(HashMapChaining *hashMap, int key, const char *val) {\n    // When load factor exceeds threshold, perform expansion\n    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {\n        extend(hashMap);\n    }\n    int index = hashFunc(hashMap, key);\n    // Traverse bucket, if specified key is encountered, update corresponding val and return\n    Node *cur = hashMap-&gt;buckets[index];\n    while (cur) {\n        if (cur-&gt;pair-&gt;key == key) {\n            strcpy(cur-&gt;pair-&gt;val, val); // If specified key is found, update corresponding val and return\n            return;\n        }\n        cur = cur-&gt;next;\n    }\n    // If key not found, add key-value pair to list head\n    Pair *newPair = (Pair *)malloc(sizeof(Pair));\n    newPair-&gt;key = key;\n    strcpy(newPair-&gt;val, val);\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode-&gt;pair = newPair;\n    newNode-&gt;next = hashMap-&gt;buckets[index];\n    hashMap-&gt;buckets[index] = newNode;\n    hashMap-&gt;size++;\n}\n\n/* Expand hash table */\nvoid extend(HashMapChaining *hashMap) {\n    // Temporarily store the original hash table\n    int oldCapacity = hashMap-&gt;capacity;\n    Node **oldBuckets = hashMap-&gt;buckets;\n    // Initialize expanded new hash table\n    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;\n    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        hashMap-&gt;buckets[i] = NULL;\n    }\n    hashMap-&gt;size = 0;\n    // Move key-value pairs from original hash table to new hash table\n    for (int i = 0; i &lt; oldCapacity; i++) {\n        Node *cur = oldBuckets[i];\n        while (cur) {\n            put(hashMap, cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);\n            Node *temp = cur;\n            cur = cur-&gt;next;\n            // Free memory\n            free(temp-&gt;pair);\n            free(temp);\n        }\n    }\n\n    free(oldBuckets);\n}\n\n/* Remove operation */\nvoid removeItem(HashMapChaining *hashMap, int key) {\n    int index = hashFunc(hashMap, key);\n    Node *cur = hashMap-&gt;buckets[index];\n    Node *pre = NULL;\n    while (cur) {\n        if (cur-&gt;pair-&gt;key == key) {\n            // Remove key-value pair from it\n            if (pre) {\n                pre-&gt;next = cur-&gt;next;\n            } else {\n                hashMap-&gt;buckets[index] = cur-&gt;next;\n            }\n            // Free memory\n            free(cur-&gt;pair);\n            free(cur);\n            hashMap-&gt;size--;\n            return;\n        }\n        pre = cur;\n        cur = cur-&gt;next;\n    }\n}\n\n/* Print hash table */\nvoid print(HashMapChaining *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Node *cur = hashMap-&gt;buckets[i];\n        printf(\"[\");\n        while (cur) {\n            printf(\"%d -&gt; %s, \", cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);\n            cur = cur-&gt;next;\n        }\n        printf(\"]\\n\");\n    }\n}\n</code></pre> hash_map_chaining.kt<pre><code>/* Hash table with separate chaining */\nclass HashMapChaining {\n    var size: Int // Number of key-value pairs\n    var capacity: Int // Hash table capacity\n    val loadThres: Double // Load factor threshold for triggering expansion\n    val extendRatio: Int // Expansion multiplier\n    var buckets: MutableList&lt;MutableList&lt;Pair&gt;&gt; // Bucket array\n\n    /* Constructor */\n    init {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = mutableListOf()\n        for (i in 0..&lt;capacity) {\n            buckets.add(mutableListOf())\n        }\n    }\n\n    /* Hash function */\n    fun hashFunc(key: Int): Int {\n        return key % capacity\n    }\n\n    /* Load factor */\n    fun loadFactor(): Double {\n        return (size / capacity).toDouble()\n    }\n\n    /* Query operation */\n    fun get(key: Int): String? {\n        val index = hashFunc(key)\n        val bucket = buckets[index]\n        // Traverse bucket, if key is found, return corresponding val\n        for (pair in bucket) {\n            if (pair.key == key) return pair._val\n        }\n        // If key is not found, return null\n        return null\n    }\n\n    /* Add operation */\n    fun put(key: Int, _val: String) {\n        // When load factor exceeds threshold, perform expansion\n        if (loadFactor() &gt; loadThres) {\n            extend()\n        }\n        val index = hashFunc(key)\n        val bucket = buckets[index]\n        // Traverse bucket, if specified key is encountered, update corresponding val and return\n        for (pair in bucket) {\n            if (pair.key == key) {\n                pair._val = _val\n                return\n            }\n        }\n        // If key does not exist, append key-value pair to the end\n        val pair = Pair(key, _val)\n        bucket.add(pair)\n        size++\n    }\n\n    /* Remove operation */\n    fun remove(key: Int) {\n        val index = hashFunc(key)\n        val bucket = buckets[index]\n        // Traverse bucket and remove key-value pair from it\n        for (pair in bucket) {\n            if (pair.key == key) {\n                bucket.remove(pair)\n                size--\n                break\n            }\n        }\n    }\n\n    /* Expand hash table */\n    fun extend() {\n        // Temporarily store the original hash table\n        val bucketsTmp = buckets\n        // Initialize expanded new hash table\n        capacity *= extendRatio\n        // mutablelist has no fixed size\n        buckets = mutableListOf()\n        for (i in 0..&lt;capacity) {\n            buckets.add(mutableListOf())\n        }\n        size = 0\n        // Move key-value pairs from original hash table to new hash table\n        for (bucket in bucketsTmp) {\n            for (pair in bucket) {\n                put(pair.key, pair._val)\n            }\n        }\n    }\n\n    /* Print hash table */\n    fun print() {\n        for (bucket in buckets) {\n            val res = mutableListOf&lt;String&gt;()\n            for (pair in bucket) {\n                val k = pair.key\n                val v = pair._val\n                res.add(\"$k -&gt; $v\")\n            }\n            println(res)\n        }\n    }\n}\n</code></pre> hash_map_chaining.rb<pre><code>### Hash map with chaining ###\nclass HashMapChaining\n  ### Constructor ###\n  def initialize\n    @size = 0 # Number of key-value pairs\n    @capacity = 4 # Hash table capacity\n    @load_thres = 2.0 / 3.0 # Load factor threshold for triggering expansion\n    @extend_ratio = 2 # Expansion multiplier\n    @buckets = Array.new(@capacity) { [] } # Bucket array\n  end\n\n  ### Hash function ###\n  def hash_func(key)\n    key % @capacity\n  end\n\n  ### Load factor ###\n  def load_factor\n    @size / @capacity\n  end\n\n  ### Query operation ###\n  def get(key)\n    index = hash_func(key)\n    bucket = @buckets[index]\n    # Traverse bucket, if key is found, return corresponding val\n    for pair in bucket\n      return pair.val if pair.key == key\n    end\n    # Return nil if key not found\n    nil\n  end\n\n  ### Add operation ###\n  def put(key, val)\n    # When load factor exceeds threshold, perform expansion\n    extend if load_factor &gt; @load_thres\n    index = hash_func(key)\n    bucket = @buckets[index]\n    # Traverse bucket, if specified key is encountered, update corresponding val and return\n    for pair in bucket\n      if pair.key == key\n        pair.val = val\n        return\n      end\n    end\n    # If key does not exist, append key-value pair to the end\n    pair = Pair.new(key, val)\n    bucket &lt;&lt; pair\n    @size += 1\n  end\n\n  ### Delete operation ###\n  def remove(key)\n    index = hash_func(key)\n    bucket = @buckets[index]\n    # Traverse bucket and remove key-value pair from it\n    for pair in bucket\n      if pair.key == key\n        bucket.delete(pair)\n        @size -= 1\n        break\n      end\n    end\n  end\n\n  ### Expand hash table ###\n  def extend\n    # Temporarily store original hash table\n    buckets = @buckets\n    # Initialize expanded new hash table\n    @capacity *= @extend_ratio\n    @buckets = Array.new(@capacity) { [] }\n    @size = 0\n    # Move key-value pairs from original hash table to new hash table\n    for bucket in buckets\n      for pair in bucket\n        put(pair.key, pair.val)\n      end\n    end\n  end\n\n  ### Print hash table ###\n  def print\n    for bucket in @buckets\n      res = []\n      for pair in bucket\n        res &lt;&lt; \"#{pair.key} -&gt; #{pair.val}\"\n      end\n      pp res\n    end\n  end\nend\n</code></pre> <p>It's worth noting that when the linked list is very long, the query efficiency \\(O(n)\\) is poor. In this case, the list can be converted to an \"AVL tree\" or \"Red-Black tree\" to optimize the time complexity of the query operation to \\(O(\\log n)\\).</p>"},{"location":"chapter_hashing/hash_collision/#622-open-addressing","title":"6.2.2 \u00a0 Open Addressing","text":"<p>Open addressing does not introduce additional data structures but instead handles hash collisions through \"multiple probes\". The probing methods mainly include linear probing, quadratic probing, and double hashing.</p> <p>Let's use linear probing as an example to introduce the mechanism of open addressing hash tables.</p>"},{"location":"chapter_hashing/hash_collision/#1-linear-probing","title":"1. \u00a0 Linear Probing","text":"<p>Linear probing uses a fixed-step linear search for probing, and its operation method differs from ordinary hash tables.</p> <ul> <li>Inserting elements: Calculate the bucket index using the hash function. If the bucket already contains an element, linearly traverse forward from the conflict position (usually with a step size of \\(1\\)) until an empty bucket is found, then insert the element.</li> <li>Searching for elements: If a hash collision is encountered, use the same step size to linearly traverse forward until the corresponding element is found and return <code>value</code>; if an empty bucket is encountered, it means the target element is not in the hash table, so return <code>None</code>.</li> </ul> <p>Figure 6-6 shows the distribution of key-value pairs in an open addressing (linear probing) hash table. According to this hash function, keys with the same last two digits will be mapped to the same bucket. Through linear probing, they are stored sequentially in that bucket and the buckets below it.</p> <p></p> <p> Figure 6-6 \u00a0 Distribution of key-value pairs in open addressing (linear probing) hash table </p> <p>However, linear probing is prone to create \"clustering\". Specifically, the longer the continuously occupied positions in the array, the greater the probability of hash collisions occurring in these continuous positions, further promoting clustering growth at that position, forming a vicious cycle, and ultimately leading to degraded efficiency of insertion, deletion, query, and update operations.</p> <p>It's important to note that we cannot directly delete elements in an open addressing hash table. Deleting an element creates an empty bucket <code>None</code> in the array. When searching for elements, if linear probing encounters this empty bucket, it will return, making the elements below this empty bucket inaccessible. The program may incorrectly assume these elements do not exist, as shown in Figure 6-7.</p> <p></p> <p> Figure 6-7 \u00a0 Query issues caused by deletion in open addressing </p> <p>To solve this problem, we can adopt the lazy deletion mechanism: instead of directly removing elements from the hash table, use a constant <code>TOMBSTONE</code> to mark the bucket. In this mechanism, both <code>None</code> and <code>TOMBSTONE</code> represent empty buckets and can hold key-value pairs. However, when linear probing encounters <code>TOMBSTONE</code>, it should continue traversing since there may still be key-value pairs below it.</p> <p>However, lazy deletion may accelerate the performance degradation of the hash table. Every deletion operation produces a deletion mark, and as <code>TOMBSTONE</code> increases, the search time will also increase because linear probing may need to skip multiple <code>TOMBSTONE</code> to find the target element.</p> <p>To address this, consider recording the index of the first encountered <code>TOMBSTONE</code> during linear probing and swapping the searched target element with that <code>TOMBSTONE</code>. The benefit of doing this is that each time an element is queried or added, the element will be moved to a bucket closer to its ideal position (the starting point of probing), thereby optimizing query efficiency.</p> <p>The code below implements an open addressing (linear probing) hash table with lazy deletion. To make better use of the hash table space, we treat the hash table as a \"circular array\". When going beyond the end of the array, we return to the beginning and continue traversing.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby hash_map_open_addressing.py<pre><code>class HashMapOpenAddressing:\n    \"\"\"Hash table with open addressing\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self.size = 0  # Number of key-value pairs\n        self.capacity = 4  # Hash table capacity\n        self.load_thres = 2.0 / 3.0  # Load factor threshold for triggering expansion\n        self.extend_ratio = 2  # Expansion multiplier\n        self.buckets: list[Pair | None] = [None] * self.capacity  # Bucket array\n        self.TOMBSTONE = Pair(-1, \"-1\")  # Removal marker\n\n    def hash_func(self, key: int) -&gt; int:\n        \"\"\"Hash function\"\"\"\n        return key % self.capacity\n\n    def load_factor(self) -&gt; float:\n        \"\"\"Load factor\"\"\"\n        return self.size / self.capacity\n\n    def find_bucket(self, key: int) -&gt; int:\n        \"\"\"Search for bucket index corresponding to key\"\"\"\n        index = self.hash_func(key)\n        first_tombstone = -1\n        # Linear probing, break when encountering an empty bucket\n        while self.buckets[index] is not None:\n            # If key is encountered, return the corresponding bucket index\n            if self.buckets[index].key == key:\n                # If a removal marker was encountered before, move the key-value pair to that index\n                if first_tombstone != -1:\n                    self.buckets[first_tombstone] = self.buckets[index]\n                    self.buckets[index] = self.TOMBSTONE\n                    return first_tombstone  # Return the moved bucket index\n                return index  # Return bucket index\n            # Record the first removal marker encountered\n            if first_tombstone == -1 and self.buckets[index] is self.TOMBSTONE:\n                first_tombstone = index\n            # Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % self.capacity\n        # If key does not exist, return the index for insertion\n        return index if first_tombstone == -1 else first_tombstone\n\n    def get(self, key: int) -&gt; str:\n        \"\"\"Query operation\"\"\"\n        # Search for bucket index corresponding to key\n        index = self.find_bucket(key)\n        # If key-value pair is found, return corresponding val\n        if self.buckets[index] not in [None, self.TOMBSTONE]:\n            return self.buckets[index].val\n        # If key-value pair does not exist, return None\n        return None\n\n    def put(self, key: int, val: str):\n        \"\"\"Add operation\"\"\"\n        # When load factor exceeds threshold, perform expansion\n        if self.load_factor() &gt; self.load_thres:\n            self.extend()\n        # Search for bucket index corresponding to key\n        index = self.find_bucket(key)\n        # If key-value pair is found, overwrite val and return\n        if self.buckets[index] not in [None, self.TOMBSTONE]:\n            self.buckets[index].val = val\n            return\n        # If key-value pair does not exist, add the key-value pair\n        self.buckets[index] = Pair(key, val)\n        self.size += 1\n\n    def remove(self, key: int):\n        \"\"\"Remove operation\"\"\"\n        # Search for bucket index corresponding to key\n        index = self.find_bucket(key)\n        # If key-value pair is found, overwrite it with removal marker\n        if self.buckets[index] not in [None, self.TOMBSTONE]:\n            self.buckets[index] = self.TOMBSTONE\n            self.size -= 1\n\n    def extend(self):\n        \"\"\"Expand hash table\"\"\"\n        # Temporarily store the original hash table\n        buckets_tmp = self.buckets\n        # Initialize expanded new hash table\n        self.capacity *= self.extend_ratio\n        self.buckets = [None] * self.capacity\n        self.size = 0\n        # Move key-value pairs from original hash table to new hash table\n        for pair in buckets_tmp:\n            if pair not in [None, self.TOMBSTONE]:\n                self.put(pair.key, pair.val)\n\n    def print(self):\n        \"\"\"Print hash table\"\"\"\n        for pair in self.buckets:\n            if pair is None:\n                print(\"None\")\n            elif pair is self.TOMBSTONE:\n                print(\"TOMBSTONE\")\n            else:\n                print(pair.key, \"-&gt;\", pair.val)\n</code></pre> hash_map_open_addressing.cpp<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n  private:\n    int size;                             // Number of key-value pairs\n    int capacity = 4;                     // Hash table capacity\n    const double loadThres = 2.0 / 3.0;     // Load factor threshold for triggering expansion\n    const int extendRatio = 2;            // Expansion multiplier\n    vector&lt;Pair *&gt; buckets;               // Bucket array\n    Pair *TOMBSTONE = new Pair(-1, \"-1\"); // Removal marker\n\n  public:\n    /* Constructor */\n    HashMapOpenAddressing() : size(0), buckets(capacity, nullptr) {\n    }\n\n    /* Destructor */\n    ~HashMapOpenAddressing() {\n        for (Pair *pair : buckets) {\n            if (pair != nullptr &amp;&amp; pair != TOMBSTONE) {\n                delete pair;\n            }\n        }\n        delete TOMBSTONE;\n    }\n\n    /* Hash function */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* Load factor */\n    double loadFactor() {\n        return (double)size / capacity;\n    }\n\n    /* Search for bucket index corresponding to key */\n    int findBucket(int key) {\n        int index = hashFunc(key);\n        int firstTombstone = -1;\n        // Linear probing, break when encountering an empty bucket\n        while (buckets[index] != nullptr) {\n            // If key is encountered, return the corresponding bucket index\n            if (buckets[index]-&gt;key == key) {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index];\n                    buckets[index] = TOMBSTONE;\n                    return firstTombstone; // Return the moved bucket index\n                }\n                return index; // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index;\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % capacity;\n        }\n        // If key does not exist, return the index for insertion\n        return firstTombstone == -1 ? index : firstTombstone;\n    }\n\n    /* Query operation */\n    string get(int key) {\n        // Search for bucket index corresponding to key\n        int index = findBucket(key);\n        // If key-value pair is found, return corresponding val\n        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index]-&gt;val;\n        }\n        // Return empty string if key-value pair does not exist\n        return \"\";\n    }\n\n    /* Add operation */\n    void put(int key, string val) {\n        // When load factor exceeds threshold, perform expansion\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        // Search for bucket index corresponding to key\n        int index = findBucket(key);\n        // If key-value pair is found, overwrite val and return\n        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index]-&gt;val = val;\n            return;\n        }\n        // If key-value pair does not exist, add the key-value pair\n        buckets[index] = new Pair(key, val);\n        size++;\n    }\n\n    /* Remove operation */\n    void remove(int key) {\n        // Search for bucket index corresponding to key\n        int index = findBucket(key);\n        // If key-value pair is found, overwrite it with removal marker\n        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) {\n            delete buckets[index];\n            buckets[index] = TOMBSTONE;\n            size--;\n        }\n    }\n\n    /* Expand hash table */\n    void extend() {\n        // Temporarily store the original hash table\n        vector&lt;Pair *&gt; bucketsTmp = buckets;\n        // Initialize expanded new hash table\n        capacity *= extendRatio;\n        buckets = vector&lt;Pair *&gt;(capacity, nullptr);\n        size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (Pair *pair : bucketsTmp) {\n            if (pair != nullptr &amp;&amp; pair != TOMBSTONE) {\n                put(pair-&gt;key, pair-&gt;val);\n                delete pair;\n            }\n        }\n    }\n\n    /* Print hash table */\n    void print() {\n        for (Pair *pair : buckets) {\n            if (pair == nullptr) {\n                cout &lt;&lt; \"nullptr\" &lt;&lt; endl;\n            } else if (pair == TOMBSTONE) {\n                cout &lt;&lt; \"TOMBSTONE\" &lt;&lt; endl;\n            } else {\n                cout &lt;&lt; pair-&gt;key &lt;&lt; \" -&gt; \" &lt;&lt; pair-&gt;val &lt;&lt; endl;\n            }\n        }\n    }\n};\n</code></pre> hash_map_open_addressing.java<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n    private int size; // Number of key-value pairs\n    private int capacity = 4; // Hash table capacity\n    private final double loadThres = 2.0 / 3.0; // Load factor threshold for triggering expansion\n    private final int extendRatio = 2; // Expansion multiplier\n    private Pair[] buckets; // Bucket array\n    private final Pair TOMBSTONE = new Pair(-1, \"-1\"); // Removal marker\n\n    /* Constructor */\n    public HashMapOpenAddressing() {\n        size = 0;\n        buckets = new Pair[capacity];\n    }\n\n    /* Hash function */\n    private int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* Load factor */\n    private double loadFactor() {\n        return (double) size / capacity;\n    }\n\n    /* Search for bucket index corresponding to key */\n    private int findBucket(int key) {\n        int index = hashFunc(key);\n        int firstTombstone = -1;\n        // Linear probing, break when encountering an empty bucket\n        while (buckets[index] != null) {\n            // If key is encountered, return the corresponding bucket index\n            if (buckets[index].key == key) {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index];\n                    buckets[index] = TOMBSTONE;\n                    return firstTombstone; // Return the moved bucket index\n                }\n                return index; // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index;\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % capacity;\n        }\n        // If key does not exist, return the index for insertion\n        return firstTombstone == -1 ? index : firstTombstone;\n    }\n\n    /* Query operation */\n    public String get(int key) {\n        // Search for bucket index corresponding to key\n        int index = findBucket(key);\n        // If key-value pair is found, return corresponding val\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index].val;\n        }\n        // If key-value pair does not exist, return null\n        return null;\n    }\n\n    /* Add operation */\n    public void put(int key, String val) {\n        // When load factor exceeds threshold, perform expansion\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        // Search for bucket index corresponding to key\n        int index = findBucket(key);\n        // If key-value pair is found, overwrite val and return\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index].val = val;\n            return;\n        }\n        // If key-value pair does not exist, add the key-value pair\n        buckets[index] = new Pair(key, val);\n        size++;\n    }\n\n    /* Remove operation */\n    public void remove(int key) {\n        // Search for bucket index corresponding to key\n        int index = findBucket(key);\n        // If key-value pair is found, overwrite it with removal marker\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index] = TOMBSTONE;\n            size--;\n        }\n    }\n\n    /* Expand hash table */\n    private void extend() {\n        // Temporarily store the original hash table\n        Pair[] bucketsTmp = buckets;\n        // Initialize expanded new hash table\n        capacity *= extendRatio;\n        buckets = new Pair[capacity];\n        size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (Pair pair : bucketsTmp) {\n            if (pair != null &amp;&amp; pair != TOMBSTONE) {\n                put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    public void print() {\n        for (Pair pair : buckets) {\n            if (pair == null) {\n                System.out.println(\"null\");\n            } else if (pair == TOMBSTONE) {\n                System.out.println(\"TOMBSTONE\");\n            } else {\n                System.out.println(pair.key + \" -&gt; \" + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.cs<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n    int size; // Number of key-value pairs\n    int capacity = 4; // Hash table capacity\n    double loadThres = 2.0 / 3.0; // Load factor threshold for triggering expansion\n    int extendRatio = 2; // Expansion multiplier\n    Pair[] buckets; // Bucket array\n    Pair TOMBSTONE = new(-1, \"-1\"); // Removal marker\n\n    /* Constructor */\n    public HashMapOpenAddressing() {\n        size = 0;\n        buckets = new Pair[capacity];\n    }\n\n    /* Hash function */\n    int HashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* Load factor */\n    double LoadFactor() {\n        return (double)size / capacity;\n    }\n\n    /* Search for bucket index corresponding to key */\n    int FindBucket(int key) {\n        int index = HashFunc(key);\n        int firstTombstone = -1;\n        // Linear probing, break when encountering an empty bucket\n        while (buckets[index] != null) {\n            // If key is encountered, return the corresponding bucket index\n            if (buckets[index].key == key) {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index];\n                    buckets[index] = TOMBSTONE;\n                    return firstTombstone; // Return the moved bucket index\n                }\n                return index; // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index;\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % capacity;\n        }\n        // If key does not exist, return the index for insertion\n        return firstTombstone == -1 ? index : firstTombstone;\n    }\n\n    /* Query operation */\n    public string? Get(int key) {\n        // Search for bucket index corresponding to key\n        int index = FindBucket(key);\n        // If key-value pair is found, return corresponding val\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index].val;\n        }\n        // If key-value pair does not exist, return null\n        return null;\n    }\n\n    /* Add operation */\n    public void Put(int key, string val) {\n        // When load factor exceeds threshold, perform expansion\n        if (LoadFactor() &gt; loadThres) {\n            Extend();\n        }\n        // Search for bucket index corresponding to key\n        int index = FindBucket(key);\n        // If key-value pair is found, overwrite val and return\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index].val = val;\n            return;\n        }\n        // If key-value pair does not exist, add the key-value pair\n        buckets[index] = new Pair(key, val);\n        size++;\n    }\n\n    /* Remove operation */\n    public void Remove(int key) {\n        // Search for bucket index corresponding to key\n        int index = FindBucket(key);\n        // If key-value pair is found, overwrite it with removal marker\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index] = TOMBSTONE;\n            size--;\n        }\n    }\n\n    /* Expand hash table */\n    void Extend() {\n        // Temporarily store the original hash table\n        Pair[] bucketsTmp = buckets;\n        // Initialize expanded new hash table\n        capacity *= extendRatio;\n        buckets = new Pair[capacity];\n        size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        foreach (Pair pair in bucketsTmp) {\n            if (pair != null &amp;&amp; pair != TOMBSTONE) {\n                Put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    public void Print() {\n        foreach (Pair pair in buckets) {\n            if (pair == null) {\n                Console.WriteLine(\"null\");\n            } else if (pair == TOMBSTONE) {\n                Console.WriteLine(\"TOMBSTONE\");\n            } else {\n                Console.WriteLine(pair.key + \" -&gt; \" + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.go<pre><code>/* Hash table with open addressing */\ntype hashMapOpenAddressing struct {\n    size        int     // Number of key-value pairs\n    capacity    int     // Hash table capacity\n    loadThres   float64 // Load factor threshold for triggering expansion\n    extendRatio int     // Expansion multiplier\n    buckets     []*pair // Bucket array\n    TOMBSTONE   *pair   // Removal marker\n}\n\n/* Constructor */\nfunc newHashMapOpenAddressing() *hashMapOpenAddressing {\n    return &amp;hashMapOpenAddressing{\n        size:        0,\n        capacity:    4,\n        loadThres:   2.0 / 3.0,\n        extendRatio: 2,\n        buckets:     make([]*pair, 4),\n        TOMBSTONE:   &amp;pair{-1, \"-1\"},\n    }\n}\n\n/* Hash function */\nfunc (h *hashMapOpenAddressing) hashFunc(key int) int {\n    return key % h.capacity // Calculate hash value based on key\n}\n\n/* Load factor */\nfunc (h *hashMapOpenAddressing) loadFactor() float64 {\n    return float64(h.size) / float64(h.capacity) // Calculate current load factor\n}\n\n/* Search for bucket index corresponding to key */\nfunc (h *hashMapOpenAddressing) findBucket(key int) int {\n    index := h.hashFunc(key) // Get initial index\n    firstTombstone := -1     // Record position of first TOMBSTONE encountered\n    for h.buckets[index] != nil {\n        if h.buckets[index].key == key {\n            if firstTombstone != -1 {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                h.buckets[firstTombstone] = h.buckets[index]\n                h.buckets[index] = h.TOMBSTONE\n                return firstTombstone // Return the moved bucket index\n            }\n            return index // Return found index\n        }\n        if firstTombstone == -1 &amp;&amp; h.buckets[index] == h.TOMBSTONE {\n            firstTombstone = index // Record position of first deletion marker encountered\n        }\n        index = (index + 1) % h.capacity // Linear probing, wrap around to head if past tail\n    }\n    // If key does not exist, return the index for insertion\n    if firstTombstone != -1 {\n        return firstTombstone\n    }\n    return index\n}\n\n/* Query operation */\nfunc (h *hashMapOpenAddressing) get(key int) string {\n    index := h.findBucket(key) // Search for bucket index corresponding to key\n    if h.buckets[index] != nil &amp;&amp; h.buckets[index] != h.TOMBSTONE {\n        return h.buckets[index].val // If key-value pair is found, return corresponding val\n    }\n    return \"\" // Return \"\" if key-value pair does not exist\n}\n\n/* Add operation */\nfunc (h *hashMapOpenAddressing) put(key int, val string) {\n    if h.loadFactor() &gt; h.loadThres {\n        h.extend() // When load factor exceeds threshold, perform expansion\n    }\n    index := h.findBucket(key) // Search for bucket index corresponding to key\n    if h.buckets[index] == nil || h.buckets[index] == h.TOMBSTONE {\n        h.buckets[index] = &amp;pair{key, val} // If key-value pair does not exist, add the key-value pair\n        h.size++\n    } else {\n        h.buckets[index].val = val // If key-value pair found, overwrite val\n    }\n}\n\n/* Remove operation */\nfunc (h *hashMapOpenAddressing) remove(key int) {\n    index := h.findBucket(key) // Search for bucket index corresponding to key\n    if h.buckets[index] != nil &amp;&amp; h.buckets[index] != h.TOMBSTONE {\n        h.buckets[index] = h.TOMBSTONE // If key-value pair is found, overwrite it with removal marker\n        h.size--\n    }\n}\n\n/* Expand hash table */\nfunc (h *hashMapOpenAddressing) extend() {\n    oldBuckets := h.buckets               // Temporarily store the original hash table\n    h.capacity *= h.extendRatio           // Update capacity\n    h.buckets = make([]*pair, h.capacity) // Initialize expanded new hash table\n    h.size = 0                            // Reset size\n    // Move key-value pairs from original hash table to new hash table\n    for _, pair := range oldBuckets {\n        if pair != nil &amp;&amp; pair != h.TOMBSTONE {\n            h.put(pair.key, pair.val)\n        }\n    }\n}\n\n/* Print hash table */\nfunc (h *hashMapOpenAddressing) print() {\n    for _, pair := range h.buckets {\n        if pair == nil {\n            fmt.Println(\"nil\")\n        } else if pair == h.TOMBSTONE {\n            fmt.Println(\"TOMBSTONE\")\n        } else {\n            fmt.Printf(\"%d -&gt; %s\\n\", pair.key, pair.val)\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.swift<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n    var size: Int // Number of key-value pairs\n    var capacity: Int // Hash table capacity\n    var loadThres: Double // Load factor threshold for triggering expansion\n    var extendRatio: Int // Expansion multiplier\n    var buckets: [Pair?] // Bucket array\n    var TOMBSTONE: Pair // Removal marker\n\n    /* Constructor */\n    init() {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = Array(repeating: nil, count: capacity)\n        TOMBSTONE = Pair(key: -1, val: \"-1\")\n    }\n\n    /* Hash function */\n    func hashFunc(key: Int) -&gt; Int {\n        key % capacity\n    }\n\n    /* Load factor */\n    func loadFactor() -&gt; Double {\n        Double(size) / Double(capacity)\n    }\n\n    /* Search for bucket index corresponding to key */\n    func findBucket(key: Int) -&gt; Int {\n        var index = hashFunc(key: key)\n        var firstTombstone = -1\n        // Linear probing, break when encountering an empty bucket\n        while buckets[index] != nil {\n            // If key is encountered, return the corresponding bucket index\n            if buckets[index]!.key == key {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                if firstTombstone != -1 {\n                    buckets[firstTombstone] = buckets[index]\n                    buckets[index] = TOMBSTONE\n                    return firstTombstone // Return the moved bucket index\n                }\n                return index // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE {\n                firstTombstone = index\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % capacity\n        }\n        // If key does not exist, return the index for insertion\n        return firstTombstone == -1 ? index : firstTombstone\n    }\n\n    /* Query operation */\n    func get(key: Int) -&gt; String? {\n        // Search for bucket index corresponding to key\n        let index = findBucket(key: key)\n        // If key-value pair is found, return corresponding val\n        if buckets[index] != nil, buckets[index] != TOMBSTONE {\n            return buckets[index]!.val\n        }\n        // If key-value pair does not exist, return null\n        return nil\n    }\n\n    /* Add operation */\n    func put(key: Int, val: String) {\n        // When load factor exceeds threshold, perform expansion\n        if loadFactor() &gt; loadThres {\n            extend()\n        }\n        // Search for bucket index corresponding to key\n        let index = findBucket(key: key)\n        // If key-value pair is found, overwrite val and return\n        if buckets[index] != nil, buckets[index] != TOMBSTONE {\n            buckets[index]!.val = val\n            return\n        }\n        // If key-value pair does not exist, add the key-value pair\n        buckets[index] = Pair(key: key, val: val)\n        size += 1\n    }\n\n    /* Remove operation */\n    func remove(key: Int) {\n        // Search for bucket index corresponding to key\n        let index = findBucket(key: key)\n        // If key-value pair is found, overwrite it with removal marker\n        if buckets[index] != nil, buckets[index] != TOMBSTONE {\n            buckets[index] = TOMBSTONE\n            size -= 1\n        }\n    }\n\n    /* Expand hash table */\n    func extend() {\n        // Temporarily store the original hash table\n        let bucketsTmp = buckets\n        // Initialize expanded new hash table\n        capacity *= extendRatio\n        buckets = Array(repeating: nil, count: capacity)\n        size = 0\n        // Move key-value pairs from original hash table to new hash table\n        for pair in bucketsTmp {\n            if let pair, pair != TOMBSTONE {\n                put(key: pair.key, val: pair.val)\n            }\n        }\n    }\n\n    /* Print hash table */\n    func print() {\n        for pair in buckets {\n            if pair == nil {\n                Swift.print(\"null\")\n            } else if pair == TOMBSTONE {\n                Swift.print(\"TOMBSTONE\")\n            } else {\n                Swift.print(\"\\(pair!.key) -&gt; \\(pair!.val)\")\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.js<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n    #size; // Number of key-value pairs\n    #capacity; // Hash table capacity\n    #loadThres; // Load factor threshold for triggering expansion\n    #extendRatio; // Expansion multiplier\n    #buckets; // Bucket array\n    #TOMBSTONE; // Removal marker\n\n    /* Constructor */\n    constructor() {\n        this.#size = 0; // Number of key-value pairs\n        this.#capacity = 4; // Hash table capacity\n        this.#loadThres = 2.0 / 3.0; // Load factor threshold for triggering expansion\n        this.#extendRatio = 2; // Expansion multiplier\n        this.#buckets = Array(this.#capacity).fill(null); // Bucket array\n        this.#TOMBSTONE = new Pair(-1, '-1'); // Removal marker\n    }\n\n    /* Hash function */\n    #hashFunc(key) {\n        return key % this.#capacity;\n    }\n\n    /* Load factor */\n    #loadFactor() {\n        return this.#size / this.#capacity;\n    }\n\n    /* Search for bucket index corresponding to key */\n    #findBucket(key) {\n        let index = this.#hashFunc(key);\n        let firstTombstone = -1;\n        // Linear probing, break when encountering an empty bucket\n        while (this.#buckets[index] !== null) {\n            // If key is encountered, return the corresponding bucket index\n            if (this.#buckets[index].key === key) {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                if (firstTombstone !== -1) {\n                    this.#buckets[firstTombstone] = this.#buckets[index];\n                    this.#buckets[index] = this.#TOMBSTONE;\n                    return firstTombstone; // Return the moved bucket index\n                }\n                return index; // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if (\n                firstTombstone === -1 &amp;&amp;\n                this.#buckets[index] === this.#TOMBSTONE\n            ) {\n                firstTombstone = index;\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % this.#capacity;\n        }\n        // If key does not exist, return the index for insertion\n        return firstTombstone === -1 ? index : firstTombstone;\n    }\n\n    /* Query operation */\n    get(key) {\n        // Search for bucket index corresponding to key\n        const index = this.#findBucket(key);\n        // If key-value pair is found, return corresponding val\n        if (\n            this.#buckets[index] !== null &amp;&amp;\n            this.#buckets[index] !== this.#TOMBSTONE\n        ) {\n            return this.#buckets[index].val;\n        }\n        // If key-value pair does not exist, return null\n        return null;\n    }\n\n    /* Add operation */\n    put(key, val) {\n        // When load factor exceeds threshold, perform expansion\n        if (this.#loadFactor() &gt; this.#loadThres) {\n            this.#extend();\n        }\n        // Search for bucket index corresponding to key\n        const index = this.#findBucket(key);\n        // If key-value pair is found, overwrite val and return\n        if (\n            this.#buckets[index] !== null &amp;&amp;\n            this.#buckets[index] !== this.#TOMBSTONE\n        ) {\n            this.#buckets[index].val = val;\n            return;\n        }\n        // If key-value pair does not exist, add the key-value pair\n        this.#buckets[index] = new Pair(key, val);\n        this.#size++;\n    }\n\n    /* Remove operation */\n    remove(key) {\n        // Search for bucket index corresponding to key\n        const index = this.#findBucket(key);\n        // If key-value pair is found, overwrite it with removal marker\n        if (\n            this.#buckets[index] !== null &amp;&amp;\n            this.#buckets[index] !== this.#TOMBSTONE\n        ) {\n            this.#buckets[index] = this.#TOMBSTONE;\n            this.#size--;\n        }\n    }\n\n    /* Expand hash table */\n    #extend() {\n        // Temporarily store the original hash table\n        const bucketsTmp = this.#buckets;\n        // Initialize expanded new hash table\n        this.#capacity *= this.#extendRatio;\n        this.#buckets = Array(this.#capacity).fill(null);\n        this.#size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (const pair of bucketsTmp) {\n            if (pair !== null &amp;&amp; pair !== this.#TOMBSTONE) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    print() {\n        for (const pair of this.#buckets) {\n            if (pair === null) {\n                console.log('null');\n            } else if (pair === this.#TOMBSTONE) {\n                console.log('TOMBSTONE');\n            } else {\n                console.log(pair.key + ' -&gt; ' + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.ts<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n    private size: number; // Number of key-value pairs\n    private capacity: number; // Hash table capacity\n    private loadThres: number; // Load factor threshold for triggering expansion\n    private extendRatio: number; // Expansion multiplier\n    private buckets: Array&lt;Pair | null&gt;; // Bucket array\n    private TOMBSTONE: Pair; // Removal marker\n\n    /* Constructor */\n    constructor() {\n        this.size = 0; // Number of key-value pairs\n        this.capacity = 4; // Hash table capacity\n        this.loadThres = 2.0 / 3.0; // Load factor threshold for triggering expansion\n        this.extendRatio = 2; // Expansion multiplier\n        this.buckets = Array(this.capacity).fill(null); // Bucket array\n        this.TOMBSTONE = new Pair(-1, '-1'); // Removal marker\n    }\n\n    /* Hash function */\n    private hashFunc(key: number): number {\n        return key % this.capacity;\n    }\n\n    /* Load factor */\n    private loadFactor(): number {\n        return this.size / this.capacity;\n    }\n\n    /* Search for bucket index corresponding to key */\n    private findBucket(key: number): number {\n        let index = this.hashFunc(key);\n        let firstTombstone = -1;\n        // Linear probing, break when encountering an empty bucket\n        while (this.buckets[index] !== null) {\n            // If key is encountered, return the corresponding bucket index\n            if (this.buckets[index]!.key === key) {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                if (firstTombstone !== -1) {\n                    this.buckets[firstTombstone] = this.buckets[index];\n                    this.buckets[index] = this.TOMBSTONE;\n                    return firstTombstone; // Return the moved bucket index\n                }\n                return index; // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if (\n                firstTombstone === -1 &amp;&amp;\n                this.buckets[index] === this.TOMBSTONE\n            ) {\n                firstTombstone = index;\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % this.capacity;\n        }\n        // If key does not exist, return the index for insertion\n        return firstTombstone === -1 ? index : firstTombstone;\n    }\n\n    /* Query operation */\n    get(key: number): string | null {\n        // Search for bucket index corresponding to key\n        const index = this.findBucket(key);\n        // If key-value pair is found, return corresponding val\n        if (\n            this.buckets[index] !== null &amp;&amp;\n            this.buckets[index] !== this.TOMBSTONE\n        ) {\n            return this.buckets[index]!.val;\n        }\n        // If key-value pair does not exist, return null\n        return null;\n    }\n\n    /* Add operation */\n    put(key: number, val: string): void {\n        // When load factor exceeds threshold, perform expansion\n        if (this.loadFactor() &gt; this.loadThres) {\n            this.extend();\n        }\n        // Search for bucket index corresponding to key\n        const index = this.findBucket(key);\n        // If key-value pair is found, overwrite val and return\n        if (\n            this.buckets[index] !== null &amp;&amp;\n            this.buckets[index] !== this.TOMBSTONE\n        ) {\n            this.buckets[index]!.val = val;\n            return;\n        }\n        // If key-value pair does not exist, add the key-value pair\n        this.buckets[index] = new Pair(key, val);\n        this.size++;\n    }\n\n    /* Remove operation */\n    remove(key: number): void {\n        // Search for bucket index corresponding to key\n        const index = this.findBucket(key);\n        // If key-value pair is found, overwrite it with removal marker\n        if (\n            this.buckets[index] !== null &amp;&amp;\n            this.buckets[index] !== this.TOMBSTONE\n        ) {\n            this.buckets[index] = this.TOMBSTONE;\n            this.size--;\n        }\n    }\n\n    /* Expand hash table */\n    private extend(): void {\n        // Temporarily store the original hash table\n        const bucketsTmp = this.buckets;\n        // Initialize expanded new hash table\n        this.capacity *= this.extendRatio;\n        this.buckets = Array(this.capacity).fill(null);\n        this.size = 0;\n        // Move key-value pairs from original hash table to new hash table\n        for (const pair of bucketsTmp) {\n            if (pair !== null &amp;&amp; pair !== this.TOMBSTONE) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* Print hash table */\n    print(): void {\n        for (const pair of this.buckets) {\n            if (pair === null) {\n                console.log('null');\n            } else if (pair === this.TOMBSTONE) {\n                console.log('TOMBSTONE');\n            } else {\n                console.log(pair.key + ' -&gt; ' + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.dart<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n  late int _size; // Number of key-value pairs\n  int _capacity = 4; // Hash table capacity\n  double _loadThres = 2.0 / 3.0; // Load factor threshold for triggering expansion\n  int _extendRatio = 2; // Expansion multiplier\n  late List&lt;Pair?&gt; _buckets; // Bucket array\n  Pair _TOMBSTONE = Pair(-1, \"-1\"); // Removal marker\n\n  /* Constructor */\n  HashMapOpenAddressing() {\n    _size = 0;\n    _buckets = List.generate(_capacity, (index) =&gt; null);\n  }\n\n  /* Hash function */\n  int hashFunc(int key) {\n    return key % _capacity;\n  }\n\n  /* Load factor */\n  double loadFactor() {\n    return _size / _capacity;\n  }\n\n  /* Search for bucket index corresponding to key */\n  int findBucket(int key) {\n    int index = hashFunc(key);\n    int firstTombstone = -1;\n    // Linear probing, break when encountering an empty bucket\n    while (_buckets[index] != null) {\n      // If key is encountered, return the corresponding bucket index\n      if (_buckets[index]!.key == key) {\n        // If a removal marker was encountered before, move the key-value pair to that index\n        if (firstTombstone != -1) {\n          _buckets[firstTombstone] = _buckets[index];\n          _buckets[index] = _TOMBSTONE;\n          return firstTombstone; // Return the moved bucket index\n        }\n        return index; // Return bucket index\n      }\n      // Record the first removal marker encountered\n      if (firstTombstone == -1 &amp;&amp; _buckets[index] == _TOMBSTONE) {\n        firstTombstone = index;\n      }\n      // Calculate bucket index, wrap around to the head if past the tail\n      index = (index + 1) % _capacity;\n    }\n    // If key does not exist, return the index for insertion\n    return firstTombstone == -1 ? index : firstTombstone;\n  }\n\n  /* Query operation */\n  String? get(int key) {\n    // Search for bucket index corresponding to key\n    int index = findBucket(key);\n    // If key-value pair is found, return corresponding val\n    if (_buckets[index] != null &amp;&amp; _buckets[index] != _TOMBSTONE) {\n      return _buckets[index]!.val;\n    }\n    // If key-value pair does not exist, return null\n    return null;\n  }\n\n  /* Add operation */\n  void put(int key, String val) {\n    // When load factor exceeds threshold, perform expansion\n    if (loadFactor() &gt; _loadThres) {\n      extend();\n    }\n    // Search for bucket index corresponding to key\n    int index = findBucket(key);\n    // If key-value pair is found, overwrite val and return\n    if (_buckets[index] != null &amp;&amp; _buckets[index] != _TOMBSTONE) {\n      _buckets[index]!.val = val;\n      return;\n    }\n    // If key-value pair does not exist, add the key-value pair\n    _buckets[index] = new Pair(key, val);\n    _size++;\n  }\n\n  /* Remove operation */\n  void remove(int key) {\n    // Search for bucket index corresponding to key\n    int index = findBucket(key);\n    // If key-value pair is found, overwrite it with removal marker\n    if (_buckets[index] != null &amp;&amp; _buckets[index] != _TOMBSTONE) {\n      _buckets[index] = _TOMBSTONE;\n      _size--;\n    }\n  }\n\n  /* Expand hash table */\n  void extend() {\n    // Temporarily store the original hash table\n    List&lt;Pair?&gt; bucketsTmp = _buckets;\n    // Initialize expanded new hash table\n    _capacity *= _extendRatio;\n    _buckets = List.generate(_capacity, (index) =&gt; null);\n    _size = 0;\n    // Move key-value pairs from original hash table to new hash table\n    for (Pair? pair in bucketsTmp) {\n      if (pair != null &amp;&amp; pair != _TOMBSTONE) {\n        put(pair.key, pair.val);\n      }\n    }\n  }\n\n  /* Print hash table */\n  void printHashMap() {\n    for (Pair? pair in _buckets) {\n      if (pair == null) {\n        print(\"null\");\n      } else if (pair == _TOMBSTONE) {\n        print(\"TOMBSTONE\");\n      } else {\n        print(\"${pair.key} -&gt; ${pair.val}\");\n      }\n    }\n  }\n}\n</code></pre> hash_map_open_addressing.rs<pre><code>/* Hash table with open addressing */\nstruct HashMapOpenAddressing {\n    size: usize,                // Number of key-value pairs\n    capacity: usize,            // Hash table capacity\n    load_thres: f64,            // Load factor threshold for triggering expansion\n    extend_ratio: usize,        // Expansion multiplier\n    buckets: Vec&lt;Option&lt;Pair&gt;&gt;, // Bucket array\n    TOMBSTONE: Option&lt;Pair&gt;,    // Removal marker\n}\n\nimpl HashMapOpenAddressing {\n    /* Constructor */\n    fn new() -&gt; Self {\n        Self {\n            size: 0,\n            capacity: 4,\n            load_thres: 2.0 / 3.0,\n            extend_ratio: 2,\n            buckets: vec![None; 4],\n            TOMBSTONE: Some(Pair {\n                key: -1,\n                val: \"-1\".to_string(),\n            }),\n        }\n    }\n\n    /* Hash function */\n    fn hash_func(&amp;self, key: i32) -&gt; usize {\n        (key % self.capacity as i32) as usize\n    }\n\n    /* Load factor */\n    fn load_factor(&amp;self) -&gt; f64 {\n        self.size as f64 / self.capacity as f64\n    }\n\n    /* Search for bucket index corresponding to key */\n    fn find_bucket(&amp;mut self, key: i32) -&gt; usize {\n        let mut index = self.hash_func(key);\n        let mut first_tombstone = -1;\n        // Linear probing, break when encountering an empty bucket\n        while self.buckets[index].is_some() {\n            // If key is found, return corresponding bucket index\n            if self.buckets[index].as_ref().unwrap().key == key {\n                // If deletion marker was encountered before, move key-value pair to that index\n                if first_tombstone != -1 {\n                    self.buckets[first_tombstone as usize] = self.buckets[index].take();\n                    self.buckets[index] = self.TOMBSTONE.clone();\n                    return first_tombstone as usize; // Return the moved bucket index\n                }\n                return index; // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if first_tombstone == -1 &amp;&amp; self.buckets[index] == self.TOMBSTONE {\n                first_tombstone = index as i32;\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % self.capacity;\n        }\n        // If key does not exist, return the index for insertion\n        if first_tombstone == -1 {\n            index\n        } else {\n            first_tombstone as usize\n        }\n    }\n\n    /* Query operation */\n    fn get(&amp;mut self, key: i32) -&gt; Option&lt;&amp;str&gt; {\n        // Search for bucket index corresponding to key\n        let index = self.find_bucket(key);\n        // If key-value pair is found, return corresponding val\n        if self.buckets[index].is_some() &amp;&amp; self.buckets[index] != self.TOMBSTONE {\n            return self.buckets[index].as_ref().map(|pair| &amp;pair.val as &amp;str);\n        }\n        // If key-value pair does not exist, return null\n        None\n    }\n\n    /* Add operation */\n    fn put(&amp;mut self, key: i32, val: String) {\n        // When load factor exceeds threshold, perform expansion\n        if self.load_factor() &gt; self.load_thres {\n            self.extend();\n        }\n        // Search for bucket index corresponding to key\n        let index = self.find_bucket(key);\n        // If key-value pair is found, overwrite val and return\n        if self.buckets[index].is_some() &amp;&amp; self.buckets[index] != self.TOMBSTONE {\n            self.buckets[index].as_mut().unwrap().val = val;\n            return;\n        }\n        // If key-value pair does not exist, add the key-value pair\n        self.buckets[index] = Some(Pair { key, val });\n        self.size += 1;\n    }\n\n    /* Remove operation */\n    fn remove(&amp;mut self, key: i32) {\n        // Search for bucket index corresponding to key\n        let index = self.find_bucket(key);\n        // If key-value pair is found, overwrite it with removal marker\n        if self.buckets[index].is_some() &amp;&amp; self.buckets[index] != self.TOMBSTONE {\n            self.buckets[index] = self.TOMBSTONE.clone();\n            self.size -= 1;\n        }\n    }\n\n    /* Expand hash table */\n    fn extend(&amp;mut self) {\n        // Temporarily store the original hash table\n        let buckets_tmp = self.buckets.clone();\n        // Initialize expanded new hash table\n        self.capacity *= self.extend_ratio;\n        self.buckets = vec![None; self.capacity];\n        self.size = 0;\n\n        // Move key-value pairs from original hash table to new hash table\n        for pair in buckets_tmp {\n            if pair.is_none() || pair == self.TOMBSTONE {\n                continue;\n            }\n            let pair = pair.unwrap();\n\n            self.put(pair.key, pair.val);\n        }\n    }\n    /* Print hash table */\n    fn print(&amp;self) {\n        for pair in &amp;self.buckets {\n            if pair.is_none() {\n                println!(\"null\");\n            } else if pair == &amp;self.TOMBSTONE {\n                println!(\"TOMBSTONE\");\n            } else {\n                let pair = pair.as_ref().unwrap();\n                println!(\"{} -&gt; {}\", pair.key, pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.c<pre><code>/* Hash table with open addressing */\ntypedef struct {\n    int size;         // Number of key-value pairs\n    int capacity;     // Hash table capacity\n    double loadThres; // Load factor threshold for triggering expansion\n    int extendRatio;  // Expansion multiplier\n    Pair **buckets;   // Bucket array\n    Pair *TOMBSTONE;  // Removal marker\n} HashMapOpenAddressing;\n\n/* Constructor */\nHashMapOpenAddressing *newHashMapOpenAddressing() {\n    HashMapOpenAddressing *hashMap = (HashMapOpenAddressing *)malloc(sizeof(HashMapOpenAddressing));\n    hashMap-&gt;size = 0;\n    hashMap-&gt;capacity = 4;\n    hashMap-&gt;loadThres = 2.0 / 3.0;\n    hashMap-&gt;extendRatio = 2;\n    hashMap-&gt;buckets = (Pair **)calloc(hashMap-&gt;capacity, sizeof(Pair *));\n    hashMap-&gt;TOMBSTONE = (Pair *)malloc(sizeof(Pair));\n    hashMap-&gt;TOMBSTONE-&gt;key = -1;\n    hashMap-&gt;TOMBSTONE-&gt;val = \"-1\";\n\n    return hashMap;\n}\n\n/* Destructor */\nvoid delHashMapOpenAddressing(HashMapOpenAddressing *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Pair *pair = hashMap-&gt;buckets[i];\n        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {\n            free(pair-&gt;val);\n            free(pair);\n        }\n    }\n    free(hashMap-&gt;buckets);\n    free(hashMap-&gt;TOMBSTONE);\n    free(hashMap);\n}\n\n/* Hash function */\nint hashFunc(HashMapOpenAddressing *hashMap, int key) {\n    return key % hashMap-&gt;capacity;\n}\n\n/* Load factor */\ndouble loadFactor(HashMapOpenAddressing *hashMap) {\n    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;\n}\n\n/* Search for bucket index corresponding to key */\nint findBucket(HashMapOpenAddressing *hashMap, int key) {\n    int index = hashFunc(hashMap, key);\n    int firstTombstone = -1;\n    // Linear probing, break when encountering an empty bucket\n    while (hashMap-&gt;buckets[index] != NULL) {\n        // If key is encountered, return the corresponding bucket index\n        if (hashMap-&gt;buckets[index]-&gt;key == key) {\n            // If a removal marker was encountered before, move the key-value pair to that index\n            if (firstTombstone != -1) {\n                hashMap-&gt;buckets[firstTombstone] = hashMap-&gt;buckets[index];\n                hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;\n                return firstTombstone; // Return the moved bucket index\n            }\n            return index; // Return bucket index\n        }\n        // Record the first removal marker encountered\n        if (firstTombstone == -1 &amp;&amp; hashMap-&gt;buckets[index] == hashMap-&gt;TOMBSTONE) {\n            firstTombstone = index;\n        }\n        // Calculate bucket index, wrap around to the head if past the tail\n        index = (index + 1) % hashMap-&gt;capacity;\n    }\n    // If key does not exist, return the index for insertion\n    return firstTombstone == -1 ? index : firstTombstone;\n}\n\n/* Query operation */\nchar *get(HashMapOpenAddressing *hashMap, int key) {\n    // Search for bucket index corresponding to key\n    int index = findBucket(hashMap, key);\n    // If key-value pair is found, return corresponding val\n    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {\n        return hashMap-&gt;buckets[index]-&gt;val;\n    }\n    // Return empty string if key-value pair does not exist\n    return \"\";\n}\n\n/* Add operation */\nvoid put(HashMapOpenAddressing *hashMap, int key, char *val) {\n    // When load factor exceeds threshold, perform expansion\n    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {\n        extend(hashMap);\n    }\n    // Search for bucket index corresponding to key\n    int index = findBucket(hashMap, key);\n    // If key-value pair is found, overwrite val and return\n    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {\n        free(hashMap-&gt;buckets[index]-&gt;val);\n        hashMap-&gt;buckets[index]-&gt;val = (char *)malloc(sizeof(strlen(val) + 1));\n        strcpy(hashMap-&gt;buckets[index]-&gt;val, val);\n        hashMap-&gt;buckets[index]-&gt;val[strlen(val)] = '\\0';\n        return;\n    }\n    // If key-value pair does not exist, add the key-value pair\n    Pair *pair = (Pair *)malloc(sizeof(Pair));\n    pair-&gt;key = key;\n    pair-&gt;val = (char *)malloc(sizeof(strlen(val) + 1));\n    strcpy(pair-&gt;val, val);\n    pair-&gt;val[strlen(val)] = '\\0';\n\n    hashMap-&gt;buckets[index] = pair;\n    hashMap-&gt;size++;\n}\n\n/* Remove operation */\nvoid removeItem(HashMapOpenAddressing *hashMap, int key) {\n    // Search for bucket index corresponding to key\n    int index = findBucket(hashMap, key);\n    // If key-value pair is found, overwrite it with removal marker\n    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {\n        Pair *pair = hashMap-&gt;buckets[index];\n        free(pair-&gt;val);\n        free(pair);\n        hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;\n        hashMap-&gt;size--;\n    }\n}\n\n/* Expand hash table */\nvoid extend(HashMapOpenAddressing *hashMap) {\n    // Temporarily store the original hash table\n    Pair **bucketsTmp = hashMap-&gt;buckets;\n    int oldCapacity = hashMap-&gt;capacity;\n    // Initialize expanded new hash table\n    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;\n    hashMap-&gt;buckets = (Pair **)calloc(hashMap-&gt;capacity, sizeof(Pair *));\n    hashMap-&gt;size = 0;\n    // Move key-value pairs from original hash table to new hash table\n    for (int i = 0; i &lt; oldCapacity; i++) {\n        Pair *pair = bucketsTmp[i];\n        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {\n            put(hashMap, pair-&gt;key, pair-&gt;val);\n            free(pair-&gt;val);\n            free(pair);\n        }\n    }\n    free(bucketsTmp);\n}\n\n/* Print hash table */\nvoid print(HashMapOpenAddressing *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Pair *pair = hashMap-&gt;buckets[i];\n        if (pair == NULL) {\n            printf(\"NULL\\n\");\n        } else if (pair == hashMap-&gt;TOMBSTONE) {\n            printf(\"TOMBSTONE\\n\");\n        } else {\n            printf(\"%d -&gt; %s\\n\", pair-&gt;key, pair-&gt;val);\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.kt<pre><code>/* Hash table with open addressing */\nclass HashMapOpenAddressing {\n    private var size: Int               // Number of key-value pairs\n    private var capacity: Int           // Hash table capacity\n    private val loadThres: Double       // Load factor threshold for triggering expansion\n    private val extendRatio: Int        // Expansion multiplier\n    private var buckets: Array&lt;Pair?&gt;   // Bucket array\n    private val TOMBSTONE: Pair         // Removal marker\n\n    /* Constructor */\n    init {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = arrayOfNulls(capacity)\n        TOMBSTONE = Pair(-1, \"-1\")\n    }\n\n    /* Hash function */\n    fun hashFunc(key: Int): Int {\n        return key % capacity\n    }\n\n    /* Load factor */\n    fun loadFactor(): Double {\n        return (size / capacity).toDouble()\n    }\n\n    /* Search for bucket index corresponding to key */\n    fun findBucket(key: Int): Int {\n        var index = hashFunc(key)\n        var firstTombstone = -1\n        // Linear probing, break when encountering an empty bucket\n        while (buckets[index] != null) {\n            // If key is encountered, return the corresponding bucket index\n            if (buckets[index]?.key == key) {\n                // If a removal marker was encountered before, move the key-value pair to that index\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index]\n                    buckets[index] = TOMBSTONE\n                    return firstTombstone // Return the moved bucket index\n                }\n                return index // Return bucket index\n            }\n            // Record the first removal marker encountered\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index\n            }\n            // Calculate bucket index, wrap around to the head if past the tail\n            index = (index + 1) % capacity\n        }\n        // If key does not exist, return the index for insertion\n        return if (firstTombstone == -1) index else firstTombstone\n    }\n\n    /* Query operation */\n    fun get(key: Int): String? {\n        // Search for bucket index corresponding to key\n        val index = findBucket(key)\n        // If key-value pair is found, return corresponding val\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index]?._val\n        }\n        // If key-value pair does not exist, return null\n        return null\n    }\n\n    /* Add operation */\n    fun put(key: Int, _val: String) {\n        // When load factor exceeds threshold, perform expansion\n        if (loadFactor() &gt; loadThres) {\n            extend()\n        }\n        // Search for bucket index corresponding to key\n        val index = findBucket(key)\n        // If key-value pair is found, overwrite val and return\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index]!!._val = _val\n            return\n        }\n        // If key-value pair does not exist, add the key-value pair\n        buckets[index] = Pair(key, _val)\n        size++\n    }\n\n    /* Remove operation */\n    fun remove(key: Int) {\n        // Search for bucket index corresponding to key\n        val index = findBucket(key)\n        // If key-value pair is found, overwrite it with removal marker\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index] = TOMBSTONE\n            size--\n        }\n    }\n\n    /* Expand hash table */\n    fun extend() {\n        // Temporarily store the original hash table\n        val bucketsTmp = buckets\n        // Initialize expanded new hash table\n        capacity *= extendRatio\n        buckets = arrayOfNulls(capacity)\n        size = 0\n        // Move key-value pairs from original hash table to new hash table\n        for (pair in bucketsTmp) {\n            if (pair != null &amp;&amp; pair != TOMBSTONE) {\n                put(pair.key, pair._val)\n            }\n        }\n    }\n\n    /* Print hash table */\n    fun print() {\n        for (pair in buckets) {\n            if (pair == null) {\n                println(\"null\")\n            } else if (pair == TOMBSTONE) {\n                println(\"TOMESTOME\")\n            } else {\n                println(\"${pair.key} -&gt; ${pair._val}\")\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.rb<pre><code>### Hash map with open addressing ###\nclass HashMapOpenAddressing\n  TOMBSTONE = Pair.new(-1, '-1') # Removal marker\n\n  ### Constructor ###\n  def initialize\n    @size = 0 # Number of key-value pairs\n    @capacity = 4 # Hash table capacity\n    @load_thres = 2.0 / 3.0 # Load factor threshold for triggering expansion\n    @extend_ratio = 2 # Expansion multiplier\n    @buckets = Array.new(@capacity) # Bucket array\n  end\n\n  ### Hash function ###\n  def hash_func(key)\n    key % @capacity\n  end\n\n  ### Load factor ###\n  def load_factor\n    @size / @capacity\n  end\n\n  ### Search bucket index for key ###\n  def find_bucket(key)\n    index = hash_func(key)\n    first_tombstone = -1\n    # Linear probing, break when encountering an empty bucket\n    while !@buckets[index].nil?\n      # If key is encountered, return the corresponding bucket index\n      if @buckets[index].key == key\n        # If a removal marker was encountered before, move the key-value pair to that index\n        if first_tombstone != -1\n          @buckets[first_tombstone] = @buckets[index]\n          @buckets[index] = TOMBSTONE\n          return first_tombstone # Return the moved bucket index\n        end\n        return index # Return bucket index\n      end\n      # Record the first removal marker encountered\n      first_tombstone = index if first_tombstone == -1 &amp;&amp; @buckets[index] == TOMBSTONE\n      # Calculate bucket index, wrap around to the head if past the tail\n      index = (index + 1) % @capacity\n    end\n    # If key does not exist, return the index for insertion\n    first_tombstone == -1 ? index : first_tombstone\n  end\n\n  ### Query operation ###\n  def get(key)\n    # Search for bucket index corresponding to key\n    index = find_bucket(key)\n    # If key-value pair is found, return corresponding val\n    return @buckets[index].val unless [nil, TOMBSTONE].include?(@buckets[index])\n    # Return nil if key-value pair does not exist\n    nil\n  end\n\n  ### Add operation ###\n  def put(key, val)\n    # When load factor exceeds threshold, perform expansion\n    extend if load_factor &gt; @load_thres\n    # Search for bucket index corresponding to key\n    index = find_bucket(key)\n    # If key-value pair found, overwrite val and return\n    unless [nil, TOMBSTONE].include?(@buckets[index])\n      @buckets[index].val = val\n      return\n    end\n    # If key-value pair does not exist, add the key-value pair\n    @buckets[index] = Pair.new(key, val)\n    @size += 1\n  end\n\n  ### Delete operation ###\n  def remove(key)\n    # Search for bucket index corresponding to key\n    index = find_bucket(key)\n    # If key-value pair is found, overwrite it with removal marker\n    unless [nil, TOMBSTONE].include?(@buckets[index])\n      @buckets[index] = TOMBSTONE\n      @size -= 1\n    end\n  end\n\n  ### Expand hash table ###\n  def extend\n    # Temporarily store the original hash table\n    buckets_tmp = @buckets\n    # Initialize expanded new hash table\n    @capacity *= @extend_ratio\n    @buckets = Array.new(@capacity)\n    @size = 0\n    # Move key-value pairs from original hash table to new hash table\n    for pair in buckets_tmp\n      put(pair.key, pair.val) unless [nil, TOMBSTONE].include?(pair)\n    end\n  end\n\n  ### Print hash table ###\n  def print\n    for pair in @buckets\n      if pair.nil?\n        puts \"Nil\"\n      elsif pair == TOMBSTONE\n        puts \"TOMBSTONE\"\n      else\n        puts \"#{pair.key} -&gt; #{pair.val}\"\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"chapter_hashing/hash_collision/#2-quadratic-probing","title":"2. \u00a0 Quadratic Probing","text":"<p>Quadratic probing is similar to linear probing and is one of the common strategies for open addressing. When a collision occurs, quadratic probing does not simply skip a fixed number of steps but skips a number of steps equal to the \"square of the number of probes\", i.e., \\(1, 4, 9, \\dots\\) steps.</p> <p>Quadratic probing has the following advantages:</p> <ul> <li>Quadratic probing attempts to alleviate the clustering effect of linear probing by skipping distances equal to the square of the probe count.</li> <li>Quadratic probing skips larger distances to find empty positions, which helps to distribute data more evenly.</li> </ul> <p>However, quadratic probing is not perfect:</p> <ul> <li>Clustering still exists, i.e., some positions are more likely to be occupied than others.</li> <li>Due to the growth of squares, quadratic probing may not probe the entire hash table, meaning that even if there are empty buckets in the hash table, quadratic probing may not be able to access them.</li> </ul>"},{"location":"chapter_hashing/hash_collision/#3-double-hashing","title":"3. \u00a0 Double Hashing","text":"<p>As the name suggests, the double hashing method uses multiple hash functions \\(f_1(x)\\), \\(f_2(x)\\), \\(f_3(x)\\), \\(\\dots\\) for probing.</p> <ul> <li>Inserting elements: If hash function \\(f_1(x)\\) encounters a conflict, try \\(f_2(x)\\), and so on, until an empty position is found and the element is inserted.</li> <li>Searching for elements: Search in the same order of hash functions until the target element is found and return it; if an empty position is encountered or all hash functions have been tried, it indicates the element is not in the hash table, then return <code>None</code>.</li> </ul> <p>Compared to linear probing, the double hashing method is less prone to clustering, but multiple hash functions introduce additional computational overhead.</p> <p>Tip</p> <p>Please note that open addressing (linear probing, quadratic probing, and double hashing) hash tables all have the problem of \"cannot directly delete elements\".</p>"},{"location":"chapter_hashing/hash_collision/#623-choice-of-programming-languages","title":"6.2.3 \u00a0 Choice of Programming Languages","text":"<p>Different programming languages adopt different hash table implementation strategies. Here are a few examples:</p> <ul> <li>Python uses open addressing. The <code>dict</code> dictionary uses pseudo-random numbers for probing.</li> <li>Java uses separate chaining. Since JDK 1.8, when the array length in <code>HashMap</code> reaches 64 and the length of a linked list reaches 8, the linked list is converted to a red-black tree to improve search performance.</li> <li>Go uses separate chaining. Go stipulates that each bucket can store up to 8 key-value pairs, and if the capacity is exceeded, an overflow bucket is linked; when there are too many overflow buckets, a special equal-capacity expansion operation is performed to ensure performance.</li> </ul>"},{"location":"chapter_hashing/hash_map/","title":"6.1 \u00a0 Hash Table","text":"<p>A hash table, also known as a hash map, establishes a mapping between keys <code>key</code> and values <code>value</code>, enabling efficient element retrieval. Specifically, when we input a key <code>key</code> into a hash table, we can retrieve the corresponding value <code>value</code> in \\(O(1)\\) time.</p> <p>As shown in Figure 6-1, given \\(n\\) students, each with two pieces of data: \"name\" and \"student ID\". If we want to implement a query function that \"inputs a student ID and returns the corresponding name\", we can use the hash table shown below.</p> <p></p> <p> Figure 6-1 \u00a0 Abstract representation of a hash table </p> <p>In addition to hash tables, arrays and linked lists can also implement query functionality. Their efficiency comparison is shown in the following table.</p> <ul> <li>Adding elements: Simply add elements to the end of the array (linked list), using \\(O(1)\\) time.</li> <li>Querying elements: Since the array (linked list) is unordered, all elements need to be traversed, using \\(O(n)\\) time.</li> <li>Deleting elements: The element must first be located, then deleted from the array (linked list), using \\(O(n)\\) time.</li> </ul> <p> Table 6-1 \u00a0 Comparison of element query efficiency </p> Array Linked List Hash Table Find element \\(O(n)\\) \\(O(n)\\) \\(O(1)\\) Add element \\(O(1)\\) \\(O(1)\\) \\(O(1)\\) Delete element \\(O(n)\\) \\(O(n)\\) \\(O(1)\\) <p>As observed, the time complexity for insertion, deletion, search, and modification operations in a hash table is \\(O(1)\\), which is very efficient.</p>"},{"location":"chapter_hashing/hash_map/#611-common-hash-table-operations","title":"6.1.1 \u00a0 Common Hash Table Operations","text":"<p>Common operations on hash tables include: initialization, query operations, adding key-value pairs, and deleting key-value pairs. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby hash_map.py<pre><code># Initialize hash table\nhmap: dict = {}\n\n# Add operation\n# Add key-value pair (key, value) to hash table\nhmap[12836] = \"XiaoHa\"\nhmap[15937] = \"XiaoLuo\"\nhmap[16750] = \"XiaoSuan\"\nhmap[13276] = \"XiaoFa\"\nhmap[10583] = \"XiaoYa\"\n\n# Query operation\n# Input key into hash table to get value\nname: str = hmap[15937]\n\n# Delete operation\n# Delete key-value pair (key, value) from hash table\nhmap.pop(10583)\n</code></pre> hash_map.cpp<pre><code>/* Initialize hash table */\nunordered_map&lt;int, string&gt; map;\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap[12836] = \"XiaoHa\";\nmap[15937] = \"XiaoLuo\";\nmap[16750] = \"XiaoSuan\";\nmap[13276] = \"XiaoFa\";\nmap[10583] = \"XiaoYa\";\n\n/* Query operation */\n// Input key into hash table to get value\nstring name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.erase(10583);\n</code></pre> hash_map.java<pre><code>/* Initialize hash table */\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap.put(12836, \"XiaoHa\");\nmap.put(15937, \"XiaoLuo\");\nmap.put(16750, \"XiaoSuan\");\nmap.put(13276, \"XiaoFa\");\nmap.put(10583, \"XiaoYa\");\n\n/* Query operation */\n// Input key into hash table to get value\nString name = map.get(15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.remove(10583);\n</code></pre> hash_map.cs<pre><code>/* Initialize hash table */\nDictionary&lt;int, string&gt; map = new() {\n    /* Add operation */\n    // Add key-value pair (key, value) to hash table\n    { 12836, \"XiaoHa\" },\n    { 15937, \"XiaoLuo\" },\n    { 16750, \"XiaoSuan\" },\n    { 13276, \"XiaoFa\" },\n    { 10583, \"XiaoYa\" }\n};\n\n/* Query operation */\n// Input key into hash table to get value\nstring name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.Remove(10583);\n</code></pre> hash_map_test.go<pre><code>/* Initialize hash table */\nhmap := make(map[int]string)\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nhmap[12836] = \"XiaoHa\"\nhmap[15937] = \"XiaoLuo\"\nhmap[16750] = \"XiaoSuan\"\nhmap[13276] = \"XiaoFa\"\nhmap[10583] = \"XiaoYa\"\n\n/* Query operation */\n// Input key into hash table to get value\nname := hmap[15937]\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\ndelete(hmap, 10583)\n</code></pre> hash_map.swift<pre><code>/* Initialize hash table */\nvar map: [Int: String] = [:]\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap[12836] = \"XiaoHa\"\nmap[15937] = \"XiaoLuo\"\nmap[16750] = \"XiaoSuan\"\nmap[13276] = \"XiaoFa\"\nmap[10583] = \"XiaoYa\"\n\n/* Query operation */\n// Input key into hash table to get value\nlet name = map[15937]!\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.removeValue(forKey: 10583)\n</code></pre> hash_map.js<pre><code>/* Initialize hash table */\nconst map = new Map();\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap.set(12836, 'XiaoHa');\nmap.set(15937, 'XiaoLuo');\nmap.set(16750, 'XiaoSuan');\nmap.set(13276, 'XiaoFa');\nmap.set(10583, 'XiaoYa');\n\n/* Query operation */\n// Input key into hash table to get value\nlet name = map.get(15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.delete(10583);\n</code></pre> hash_map.ts<pre><code>/* Initialize hash table */\nconst map = new Map&lt;number, string&gt;();\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap.set(12836, 'XiaoHa');\nmap.set(15937, 'XiaoLuo');\nmap.set(16750, 'XiaoSuan');\nmap.set(13276, 'XiaoFa');\nmap.set(10583, 'XiaoYa');\nconsole.info('\\nAfter adding, hash table is\\nKey -&gt; Value');\nconsole.info(map);\n\n/* Query operation */\n// Input key into hash table to get value\nlet name = map.get(15937);\nconsole.info('\\nInput student ID 15937, queried name ' + name);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.delete(10583);\nconsole.info('\\nAfter deleting 10583, hash table is\\nKey -&gt; Value');\nconsole.info(map);\n</code></pre> hash_map.dart<pre><code>/* Initialize hash table */\nMap&lt;int, String&gt; map = {};\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap[12836] = \"XiaoHa\";\nmap[15937] = \"XiaoLuo\";\nmap[16750] = \"XiaoSuan\";\nmap[13276] = \"XiaoFa\";\nmap[10583] = \"XiaoYa\";\n\n/* Query operation */\n// Input key into hash table to get value\nString name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.remove(10583);\n</code></pre> hash_map.rs<pre><code>use std::collections::HashMap;\n\n/* Initialize hash table */\nlet mut map: HashMap&lt;i32, String&gt; = HashMap::new();\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap.insert(12836, \"XiaoHa\".to_string());\nmap.insert(15937, \"XiaoLuo\".to_string());\nmap.insert(16750, \"XiaoSuan\".to_string());\nmap.insert(13279, \"XiaoFa\".to_string());\nmap.insert(10583, \"XiaoYa\".to_string());\n\n/* Query operation */\n// Input key into hash table to get value\nlet _name: Option&lt;&amp;String&gt; = map.get(&amp;15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nlet _removed_value: Option&lt;String&gt; = map.remove(&amp;10583);\n</code></pre> hash_map.c<pre><code>// C does not provide a built-in hash table\n</code></pre> hash_map.kt<pre><code>/* Initialize hash table */\nval map = HashMap&lt;Int,String&gt;()\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap[12836] = \"XiaoHa\"\nmap[15937] = \"XiaoLuo\"\nmap[16750] = \"XiaoSuan\"\nmap[13276] = \"XiaoFa\"\nmap[10583] = \"XiaoYa\"\n\n/* Query operation */\n// Input key into hash table to get value\nval name = map[15937]\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.remove(10583)\n</code></pre> hash_map.rb<pre><code># Initialize hash table\nhmap = {}\n\n# Add operation\n# Add key-value pair (key, value) to hash table\nhmap[12836] = \"XiaoHa\"\nhmap[15937] = \"XiaoLuo\"\nhmap[16750] = \"XiaoSuan\"\nhmap[13276] = \"XiaoFa\"\nhmap[10583] = \"XiaoYa\"\n\n# Query operation\n# Input key into hash table to get value\nname = hmap[15937]\n\n# Delete operation\n# Delete key-value pair (key, value) from hash table\nhmap.delete(10583)\n</code></pre> Visualized Execution <p>https://pythontutor.com/render.html#code=%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%93%88%E5%B8%8C%E8%A1%A8%0A%20%20%20%20hmap%20%3D%20%7B%7D%0A%20%20%20%20%0A%20%20%20%20%23%20%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%9C%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9%20%28key,%20value%29%0A%20%20%20%20hmap%5B12836%5D%20%3D%20%22%E5%B0%8F%E5%93%88%22%0A%20%20%20%20hmap%5B15937%5D%20%3D%20%22%E5%B0%8F%E5%95%B0%22%0A%20%20%20%20hmap%5B16750%5D%20%3D%20%22%E5%B0%8F%E7%AE%97%22%0A%20%20%20%20hmap%5B13276%5D%20%3D%20%22%E5%B0%8F%E6%B3%95%22%0A%20%20%20%20hmap%5B10583%5D%20%3D%20%22%E5%B0%8F%E9%B8%AD%22%0A%20%20%20%20%0A%20%20%20%20%23%20%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%90%91%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E9%94%AE%20key%20%EF%BC%8C%E5%BE%97%E5%88%B0%E5%80%BC%20value%0A%20%20%20%20name%20%3D%20hmap%5B15937%5D%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%9C%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9%20%28key,%20value%29%0A%20%20%20%20hmap.pop%2810583%29&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p> <p>There are three common ways to traverse a hash table: traversing key-value pairs, traversing keys, and traversing values. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby hash_map.py<pre><code># Traverse hash table\n# Traverse key-value pairs key-&gt;value\nfor key, value in hmap.items():\n    print(key, \"-&gt;\", value)\n# Traverse keys only\nfor key in hmap.keys():\n    print(key)\n# Traverse values only\nfor value in hmap.values():\n    print(value)\n</code></pre> hash_map.cpp<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor (auto kv: map) {\n    cout &lt;&lt; kv.first &lt;&lt; \" -&gt; \" &lt;&lt; kv.second &lt;&lt; endl;\n}\n// Traverse using iterator key-&gt;value\nfor (auto iter = map.begin(); iter != map.end(); iter++) {\n    cout &lt;&lt; iter-&gt;first &lt;&lt; \"-&gt;\" &lt;&lt; iter-&gt;second &lt;&lt; endl;\n}\n</code></pre> hash_map.java<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor (Map.Entry&lt;Integer, String&gt; kv: map.entrySet()) {\n    System.out.println(kv.getKey() + \" -&gt; \" + kv.getValue());\n}\n// Traverse keys only\nfor (int key: map.keySet()) {\n    System.out.println(key);\n}\n// Traverse values only\nfor (String val: map.values()) {\n    System.out.println(val);\n}\n</code></pre> hash_map.cs<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nforeach (var kv in map) {\n    Console.WriteLine(kv.Key + \" -&gt; \" + kv.Value);\n}\n// Traverse keys only\nforeach (int key in map.Keys) {\n    Console.WriteLine(key);\n}\n// Traverse values only\nforeach (string val in map.Values) {\n    Console.WriteLine(val);\n}\n</code></pre> hash_map_test.go<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor key, value := range hmap {\n    fmt.Println(key, \"-&gt;\", value)\n}\n// Traverse keys only\nfor key := range hmap {\n    fmt.Println(key)\n}\n// Traverse values only\nfor _, value := range hmap {\n    fmt.Println(value)\n}\n</code></pre> hash_map.swift<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nfor (key, value) in map {\n    print(\"\\(key) -&gt; \\(value)\")\n}\n// Traverse keys only\nfor key in map.keys {\n    print(key)\n}\n// Traverse values only\nfor value in map.values {\n    print(value)\n}\n</code></pre> hash_map.js<pre><code>/* Traverse hash table */\nconsole.info('\\nTraverse key-value pairs Key-&gt;Value');\nfor (const [k, v] of map.entries()) {\n    console.info(k + ' -&gt; ' + v);\n}\nconsole.info('\\nTraverse keys only Key');\nfor (const k of map.keys()) {\n    console.info(k);\n}\nconsole.info('\\nTraverse values only Value');\nfor (const v of map.values()) {\n    console.info(v);\n}\n</code></pre> hash_map.ts<pre><code>/* Traverse hash table */\nconsole.info('\\nTraverse key-value pairs Key-&gt;Value');\nfor (const [k, v] of map.entries()) {\n    console.info(k + ' -&gt; ' + v);\n}\nconsole.info('\\nTraverse keys only Key');\nfor (const k of map.keys()) {\n    console.info(k);\n}\nconsole.info('\\nTraverse values only Value');\nfor (const v of map.values()) {\n    console.info(v);\n}\n</code></pre> hash_map.dart<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nmap.forEach((key, value) {\n  print('$key -&gt; $value');\n});\n\n// Traverse keys only\nmap.keys.forEach((key) {\n  print(key);\n});\n\n// Traverse values only\nmap.values.forEach((value) {\n  print(value);\n});\n</code></pre> hash_map.rs<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nfor (key, value) in &amp;map {\n    println!(\"{key} -&gt; {value}\");\n}\n\n// Traverse keys only\nfor key in map.keys() {\n    println!(\"{key}\");\n}\n\n// Traverse values only\nfor value in map.values() {\n    println!(\"{value}\");\n}\n</code></pre> hash_map.c<pre><code>// C does not provide a built-in hash table\n</code></pre> hash_map.kt<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor ((key, value) in map) {\n    println(\"$key -&gt; $value\")\n}\n// Traverse keys only\nfor (key in map.keys) {\n    println(key)\n}\n// Traverse values only\nfor (_val in map.values) {\n    println(_val)\n}\n</code></pre> hash_map.rb<pre><code># Traverse hash table\n# Traverse key-value pairs key-&gt;value\nhmap.entries.each { |key, value| puts \"#{key} -&gt; #{value}\" }\n\n# Traverse keys only\nhmap.keys.each { |key| puts key }\n\n# Traverse values only\nhmap.values.each { |val| puts val }\n</code></pre> Visualized Execution <p>https://pythontutor.com/render.html#code=%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%93%88%E5%B8%8C%E8%A1%A8%0A%20%20%20%20hmap%20%3D%20%7B%7D%0A%20%20%20%20%0A%20%20%20%20%23%20%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%9C%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9%20%28key,%20value%29%0A%20%20%20%20hmap%5B12836%5D%20%3D%20%22%E5%B0%8F%E5%93%88%22%0A%20%20%20%20hmap%5B15937%5D%20%3D%20%22%E5%B0%8F%E5%95%B0%22%0A%20%20%20%20hmap%5B16750%5D%20%3D%20%22%E5%B0%8F%E7%AE%97%22%0A%20%20%20%20hmap%5B13276%5D%20%3D%20%22%E5%B0%8F%E6%B3%95%22%0A%20%20%20%20hmap%5B10583%5D%20%3D%20%22%E5%B0%8F%E9%B8%AD%22%0A%20%20%20%20%0A%20%20%20%20%23%20%E9%81%8D%E5%8E%86%E5%93%88%E5%B8%8C%E8%A1%A8%0A%20%20%20%20%23%20%E9%81%8D%E5%8E%86%E9%94%AE%E5%80%BC%E5%AF%B9%20key-%3Evalue%0A%20%20%20%20for%20key,%20value%20in%20hmap.items%28%29%3A%0A%20%20%20%20%20%20%20%20print%28key,%20%22-%3E%22,%20value%29%0A%20%20%20%20%23%20%E5%8D%95%E7%8B%AC%E9%81%8D%E5%8E%86%E9%94%AE%20key%0A%20%20%20%20for%20key%20in%20hmap.keys%28%29%3A%0A%20%20%20%20%20%20%20%20print%28key%29%0A%20%20%20%20%23%20%E5%8D%95%E7%8B%AC%E9%81%8D%E5%8E%86%E5%80%BC%20value%0A%20%20%20%20for%20value%20in%20hmap.values%28%29%3A%0A%20%20%20%20%20%20%20%20print%28value%29&amp;cumulative=false&amp;curInstr=8&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_hashing/hash_map/#612-simple-hash-table-implementation","title":"6.1.2 \u00a0 Simple Hash Table Implementation","text":"<p>Let's first consider the simplest case: implementing a hash table using only an array. In a hash table, each empty position in the array is called a bucket, and each bucket can store a key-value pair. Therefore, the query operation is to find the bucket corresponding to <code>key</code> and retrieve the <code>value</code> from the bucket.</p> <p>So how do we locate the corresponding bucket based on <code>key</code>? This is achieved through a hash function. The role of the hash function is to map a larger input space to a smaller output space. In a hash table, the input space is all <code>key</code>s, and the output space is all buckets (array indices). In other words, given a <code>key</code>, we can use the hash function to obtain the storage location of the key-value pair corresponding to that <code>key</code> in the array.</p> <p>When inputting a <code>key</code>, the hash function's calculation process consists of the following two steps:</p> <ol> <li>Calculate the hash value through a hash algorithm <code>hash()</code>.</li> <li>Take the modulo of the hash value by the number of buckets (array length) <code>capacity</code> to obtain the bucket (array index) <code>index</code> corresponding to that <code>key</code>.</li> </ol> <pre><code>index = hash(key) % capacity\n</code></pre> <p>Subsequently, we can use <code>index</code> to access the corresponding bucket in the hash table and retrieve the <code>value</code>.</p> <p>Assuming the array length is <code>capacity = 100</code> and the hash algorithm is <code>hash(key) = key</code>, the hash function becomes <code>key % 100</code>. Figure 6-2 shows the working principle of the hash function using <code>key</code> as student ID and <code>value</code> as name.</p> <p></p> <p> Figure 6-2 \u00a0 Working principle of hash function </p> <p>The following code implements a simple hash table. Here, we encapsulate <code>key</code> and <code>value</code> into a class <code>Pair</code> to represent a key-value pair.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array_hash_map.py<pre><code>class Pair:\n    \"\"\"Key-value pair\"\"\"\n\n    def __init__(self, key: int, val: str):\n        self.key = key\n        self.val = val\n\nclass ArrayHashMap:\n    \"\"\"Hash table based on array implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        # Initialize array with 100 buckets\n        self.buckets: list[Pair | None] = [None] * 100\n\n    def hash_func(self, key: int) -&gt; int:\n        \"\"\"Hash function\"\"\"\n        index = key % 100\n        return index\n\n    def get(self, key: int) -&gt; str | None:\n        \"\"\"Query operation\"\"\"\n        index: int = self.hash_func(key)\n        pair: Pair = self.buckets[index]\n        if pair is None:\n            return None\n        return pair.val\n\n    def put(self, key: int, val: str):\n        \"\"\"Add and update operation\"\"\"\n        pair = Pair(key, val)\n        index: int = self.hash_func(key)\n        self.buckets[index] = pair\n\n    def remove(self, key: int):\n        \"\"\"Remove operation\"\"\"\n        index: int = self.hash_func(key)\n        # Set to None to represent removal\n        self.buckets[index] = None\n\n    def entry_set(self) -&gt; list[Pair]:\n        \"\"\"Get all key-value pairs\"\"\"\n        result: list[Pair] = []\n        for pair in self.buckets:\n            if pair is not None:\n                result.append(pair)\n        return result\n\n    def key_set(self) -&gt; list[int]:\n        \"\"\"Get all keys\"\"\"\n        result = []\n        for pair in self.buckets:\n            if pair is not None:\n                result.append(pair.key)\n        return result\n\n    def value_set(self) -&gt; list[str]:\n        \"\"\"Get all values\"\"\"\n        result = []\n        for pair in self.buckets:\n            if pair is not None:\n                result.append(pair.val)\n        return result\n\n    def print(self):\n        \"\"\"Print hash table\"\"\"\n        for pair in self.buckets:\n            if pair is not None:\n                print(pair.key, \"-&gt;\", pair.val)\n</code></pre> array_hash_map.cpp<pre><code>/* Key-value pair */\nstruct Pair {\n  public:\n    int key;\n    string val;\n    Pair(int key, string val) {\n        this-&gt;key = key;\n        this-&gt;val = val;\n    }\n};\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n  private:\n    vector&lt;Pair *&gt; buckets;\n\n  public:\n    ArrayHashMap() {\n        // Initialize array with 100 buckets\n        buckets = vector&lt;Pair *&gt;(100);\n    }\n\n    ~ArrayHashMap() {\n        // Free memory\n        for (const auto &amp;bucket : buckets) {\n            delete bucket;\n        }\n        buckets.clear();\n    }\n\n    /* Hash function */\n    int hashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* Query operation */\n    string get(int key) {\n        int index = hashFunc(key);\n        Pair *pair = buckets[index];\n        if (pair == nullptr)\n            return \"\";\n        return pair-&gt;val;\n    }\n\n    /* Add operation */\n    void put(int key, string val) {\n        Pair *pair = new Pair(key, val);\n        int index = hashFunc(key);\n        buckets[index] = pair;\n    }\n\n    /* Remove operation */\n    void remove(int key) {\n        int index = hashFunc(key);\n        // Free memory and set to nullptr\n        delete buckets[index];\n        buckets[index] = nullptr;\n    }\n\n    /* Get all key-value pairs */\n    vector&lt;Pair *&gt; pairSet() {\n        vector&lt;Pair *&gt; pairSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                pairSet.push_back(pair);\n            }\n        }\n        return pairSet;\n    }\n\n    /* Get all keys */\n    vector&lt;int&gt; keySet() {\n        vector&lt;int&gt; keySet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                keySet.push_back(pair-&gt;key);\n            }\n        }\n        return keySet;\n    }\n\n    /* Get all values */\n    vector&lt;string&gt; valueSet() {\n        vector&lt;string&gt; valueSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                valueSet.push_back(pair-&gt;val);\n            }\n        }\n        return valueSet;\n    }\n\n    /* Print hash table */\n    void print() {\n        for (Pair *kv : pairSet()) {\n            cout &lt;&lt; kv-&gt;key &lt;&lt; \" -&gt; \" &lt;&lt; kv-&gt;val &lt;&lt; endl;\n        }\n    }\n};\n</code></pre> array_hash_map.java<pre><code>/* Key-value pair */\nclass Pair {\n    public int key;\n    public String val;\n\n    public Pair(int key, String val) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n    private List&lt;Pair&gt; buckets;\n\n    public ArrayHashMap() {\n        // Initialize array with 100 buckets\n        buckets = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 100; i++) {\n            buckets.add(null);\n        }\n    }\n\n    /* Hash function */\n    private int hashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* Query operation */\n    public String get(int key) {\n        int index = hashFunc(key);\n        Pair pair = buckets.get(index);\n        if (pair == null)\n            return null;\n        return pair.val;\n    }\n\n    /* Add operation */\n    public void put(int key, String val) {\n        Pair pair = new Pair(key, val);\n        int index = hashFunc(key);\n        buckets.set(index, pair);\n    }\n\n    /* Remove operation */\n    public void remove(int key) {\n        int index = hashFunc(key);\n        // Set to null to represent deletion\n        buckets.set(index, null);\n    }\n\n    /* Get all key-value pairs */\n    public List&lt;Pair&gt; pairSet() {\n        List&lt;Pair&gt; pairSet = new ArrayList&lt;&gt;();\n        for (Pair pair : buckets) {\n            if (pair != null)\n                pairSet.add(pair);\n        }\n        return pairSet;\n    }\n\n    /* Get all keys */\n    public List&lt;Integer&gt; keySet() {\n        List&lt;Integer&gt; keySet = new ArrayList&lt;&gt;();\n        for (Pair pair : buckets) {\n            if (pair != null)\n                keySet.add(pair.key);\n        }\n        return keySet;\n    }\n\n    /* Get all values */\n    public List&lt;String&gt; valueSet() {\n        List&lt;String&gt; valueSet = new ArrayList&lt;&gt;();\n        for (Pair pair : buckets) {\n            if (pair != null)\n                valueSet.add(pair.val);\n        }\n        return valueSet;\n    }\n\n    /* Print hash table */\n    public void print() {\n        for (Pair kv : pairSet()) {\n            System.out.println(kv.key + \" -&gt; \" + kv.val);\n        }\n    }\n}\n</code></pre> array_hash_map.cs<pre><code>/* Key-value pair int-&gt;string */\nclass Pair(int key, string val) {\n    public int key = key;\n    public string val = val;\n}\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n    List&lt;Pair?&gt; buckets;\n    public ArrayHashMap() {\n        // Initialize array with 100 buckets\n        buckets = [];\n        for (int i = 0; i &lt; 100; i++) {\n            buckets.Add(null);\n        }\n    }\n\n    /* Hash function */\n    int HashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* Query operation */\n    public string? Get(int key) {\n        int index = HashFunc(key);\n        Pair? pair = buckets[index];\n        if (pair == null) return null;\n        return pair.val;\n    }\n\n    /* Add operation */\n    public void Put(int key, string val) {\n        Pair pair = new(key, val);\n        int index = HashFunc(key);\n        buckets[index] = pair;\n    }\n\n    /* Remove operation */\n    public void Remove(int key) {\n        int index = HashFunc(key);\n        // Set to null to represent deletion\n        buckets[index] = null;\n    }\n\n    /* Get all key-value pairs */\n    public List&lt;Pair&gt; PairSet() {\n        List&lt;Pair&gt; pairSet = [];\n        foreach (Pair? pair in buckets) {\n            if (pair != null)\n                pairSet.Add(pair);\n        }\n        return pairSet;\n    }\n\n    /* Get all keys */\n    public List&lt;int&gt; KeySet() {\n        List&lt;int&gt; keySet = [];\n        foreach (Pair? pair in buckets) {\n            if (pair != null)\n                keySet.Add(pair.key);\n        }\n        return keySet;\n    }\n\n    /* Get all values */\n    public List&lt;string&gt; ValueSet() {\n        List&lt;string&gt; valueSet = [];\n        foreach (Pair? pair in buckets) {\n            if (pair != null)\n                valueSet.Add(pair.val);\n        }\n        return valueSet;\n    }\n\n    /* Print hash table */\n    public void Print() {\n        foreach (Pair kv in PairSet()) {\n            Console.WriteLine(kv.key + \" -&gt; \" + kv.val);\n        }\n    }\n}\n</code></pre> array_hash_map.go<pre><code>/* Key-value pair */\ntype pair struct {\n    key int\n    val string\n}\n\n/* Hash table based on array implementation */\ntype arrayHashMap struct {\n    buckets []*pair\n}\n\n/* Initialize hash table */\nfunc newArrayHashMap() *arrayHashMap {\n    // Initialize array with 100 buckets\n    buckets := make([]*pair, 100)\n    return &amp;arrayHashMap{buckets: buckets}\n}\n\n/* Hash function */\nfunc (a *arrayHashMap) hashFunc(key int) int {\n    index := key % 100\n    return index\n}\n\n/* Query operation */\nfunc (a *arrayHashMap) get(key int) string {\n    index := a.hashFunc(key)\n    pair := a.buckets[index]\n    if pair == nil {\n        return \"Not Found\"\n    }\n    return pair.val\n}\n\n/* Add operation */\nfunc (a *arrayHashMap) put(key int, val string) {\n    pair := &amp;pair{key: key, val: val}\n    index := a.hashFunc(key)\n    a.buckets[index] = pair\n}\n\n/* Remove operation */\nfunc (a *arrayHashMap) remove(key int) {\n    index := a.hashFunc(key)\n    // Set to nil to delete\n    a.buckets[index] = nil\n}\n\n/* Get all key pairs */\nfunc (a *arrayHashMap) pairSet() []*pair {\n    var pairs []*pair\n    for _, pair := range a.buckets {\n        if pair != nil {\n            pairs = append(pairs, pair)\n        }\n    }\n    return pairs\n}\n\n/* Get all keys */\nfunc (a *arrayHashMap) keySet() []int {\n    var keys []int\n    for _, pair := range a.buckets {\n        if pair != nil {\n            keys = append(keys, pair.key)\n        }\n    }\n    return keys\n}\n\n/* Get all values */\nfunc (a *arrayHashMap) valueSet() []string {\n    var values []string\n    for _, pair := range a.buckets {\n        if pair != nil {\n            values = append(values, pair.val)\n        }\n    }\n    return values\n}\n\n/* Print hash table */\nfunc (a *arrayHashMap) print() {\n    for _, pair := range a.buckets {\n        if pair != nil {\n            fmt.Println(pair.key, \"-&gt;\", pair.val)\n        }\n    }\n}\n</code></pre> array_hash_map.swift<pre><code>/* Key-value pair */\nclass Pair: Equatable {\n    public var key: Int\n    public var val: String\n\n    public init(key: Int, val: String) {\n        self.key = key\n        self.val = val\n    }\n\n    public static func == (lhs: Pair, rhs: Pair) -&gt; Bool {\n        lhs.key == rhs.key &amp;&amp; lhs.val == rhs.val\n    }\n}\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n    private var buckets: [Pair?]\n\n    init() {\n        // Initialize array with 100 buckets\n        buckets = Array(repeating: nil, count: 100)\n    }\n\n    /* Hash function */\n    private func hashFunc(key: Int) -&gt; Int {\n        let index = key % 100\n        return index\n    }\n\n    /* Query operation */\n    func get(key: Int) -&gt; String? {\n        let index = hashFunc(key: key)\n        let pair = buckets[index]\n        return pair?.val\n    }\n\n    /* Add operation */\n    func put(key: Int, val: String) {\n        let pair = Pair(key: key, val: val)\n        let index = hashFunc(key: key)\n        buckets[index] = pair\n    }\n\n    /* Remove operation */\n    func remove(key: Int) {\n        let index = hashFunc(key: key)\n        // Set to nil to delete\n        buckets[index] = nil\n    }\n\n    /* Get all key-value pairs */\n    func pairSet() -&gt; [Pair] {\n        buckets.compactMap { $0 }\n    }\n\n    /* Get all keys */\n    func keySet() -&gt; [Int] {\n        buckets.compactMap { $0?.key }\n    }\n\n    /* Get all values */\n    func valueSet() -&gt; [String] {\n        buckets.compactMap { $0?.val }\n    }\n\n    /* Print hash table */\n    func print() {\n        for pair in pairSet() {\n            Swift.print(\"\\(pair.key) -&gt; \\(pair.val)\")\n        }\n    }\n}\n</code></pre> array_hash_map.js<pre><code>/* Key-value pair Number -&gt; String */\nclass Pair {\n    constructor(key, val) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n    #buckets;\n    constructor() {\n        // Initialize array with 100 buckets\n        this.#buckets = new Array(100).fill(null);\n    }\n\n    /* Hash function */\n    #hashFunc(key) {\n        return key % 100;\n    }\n\n    /* Query operation */\n    get(key) {\n        let index = this.#hashFunc(key);\n        let pair = this.#buckets[index];\n        if (pair === null) return null;\n        return pair.val;\n    }\n\n    /* Add operation */\n    set(key, val) {\n        let index = this.#hashFunc(key);\n        this.#buckets[index] = new Pair(key, val);\n    }\n\n    /* Remove operation */\n    delete(key) {\n        let index = this.#hashFunc(key);\n        // Set to null to represent deletion\n        this.#buckets[index] = null;\n    }\n\n    /* Get all key-value pairs */\n    entries() {\n        let arr = [];\n        for (let i = 0; i &lt; this.#buckets.length; i++) {\n            if (this.#buckets[i]) {\n                arr.push(this.#buckets[i]);\n            }\n        }\n        return arr;\n    }\n\n    /* Get all keys */\n    keys() {\n        let arr = [];\n        for (let i = 0; i &lt; this.#buckets.length; i++) {\n            if (this.#buckets[i]) {\n                arr.push(this.#buckets[i].key);\n            }\n        }\n        return arr;\n    }\n\n    /* Get all values */\n    values() {\n        let arr = [];\n        for (let i = 0; i &lt; this.#buckets.length; i++) {\n            if (this.#buckets[i]) {\n                arr.push(this.#buckets[i].val);\n            }\n        }\n        return arr;\n    }\n\n    /* Print hash table */\n    print() {\n        let pairSet = this.entries();\n        for (const pair of pairSet) {\n            console.info(`${pair.key} -&gt; ${pair.val}`);\n        }\n    }\n}\n</code></pre> array_hash_map.ts<pre><code>/* Key-value pair Number -&gt; String */\nclass Pair {\n    public key: number;\n    public val: string;\n\n    constructor(key: number, val: string) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n    private readonly buckets: (Pair | null)[];\n\n    constructor() {\n        // Initialize array with 100 buckets\n        this.buckets = new Array(100).fill(null);\n    }\n\n    /* Hash function */\n    private hashFunc(key: number): number {\n        return key % 100;\n    }\n\n    /* Query operation */\n    public get(key: number): string | null {\n        let index = this.hashFunc(key);\n        let pair = this.buckets[index];\n        if (pair === null) return null;\n        return pair.val;\n    }\n\n    /* Add operation */\n    public set(key: number, val: string) {\n        let index = this.hashFunc(key);\n        this.buckets[index] = new Pair(key, val);\n    }\n\n    /* Remove operation */\n    public delete(key: number) {\n        let index = this.hashFunc(key);\n        // Set to null to represent deletion\n        this.buckets[index] = null;\n    }\n\n    /* Get all key-value pairs */\n    public entries(): (Pair | null)[] {\n        let arr: (Pair | null)[] = [];\n        for (let i = 0; i &lt; this.buckets.length; i++) {\n            if (this.buckets[i]) {\n                arr.push(this.buckets[i]);\n            }\n        }\n        return arr;\n    }\n\n    /* Get all keys */\n    public keys(): (number | undefined)[] {\n        let arr: (number | undefined)[] = [];\n        for (let i = 0; i &lt; this.buckets.length; i++) {\n            if (this.buckets[i]) {\n                arr.push(this.buckets[i].key);\n            }\n        }\n        return arr;\n    }\n\n    /* Get all values */\n    public values(): (string | undefined)[] {\n        let arr: (string | undefined)[] = [];\n        for (let i = 0; i &lt; this.buckets.length; i++) {\n            if (this.buckets[i]) {\n                arr.push(this.buckets[i].val);\n            }\n        }\n        return arr;\n    }\n\n    /* Print hash table */\n    public print() {\n        let pairSet = this.entries();\n        for (const pair of pairSet) {\n            console.info(`${pair.key} -&gt; ${pair.val}`);\n        }\n    }\n}\n</code></pre> array_hash_map.dart<pre><code>/* Key-value pair */\nclass Pair {\n  int key;\n  String val;\n  Pair(this.key, this.val);\n}\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n  late List&lt;Pair?&gt; _buckets;\n\n  ArrayHashMap() {\n    // Initialize array with 100 buckets\n    _buckets = List.filled(100, null);\n  }\n\n  /* Hash function */\n  int _hashFunc(int key) {\n    final int index = key % 100;\n    return index;\n  }\n\n  /* Query operation */\n  String? get(int key) {\n    final int index = _hashFunc(key);\n    final Pair? pair = _buckets[index];\n    if (pair == null) {\n      return null;\n    }\n    return pair.val;\n  }\n\n  /* Add operation */\n  void put(int key, String val) {\n    final Pair pair = Pair(key, val);\n    final int index = _hashFunc(key);\n    _buckets[index] = pair;\n  }\n\n  /* Remove operation */\n  void remove(int key) {\n    final int index = _hashFunc(key);\n    _buckets[index] = null;\n  }\n\n  /* Get all key-value pairs */\n  List&lt;Pair&gt; pairSet() {\n    List&lt;Pair&gt; pairSet = [];\n    for (final Pair? pair in _buckets) {\n      if (pair != null) {\n        pairSet.add(pair);\n      }\n    }\n    return pairSet;\n  }\n\n  /* Get all keys */\n  List&lt;int&gt; keySet() {\n    List&lt;int&gt; keySet = [];\n    for (final Pair? pair in _buckets) {\n      if (pair != null) {\n        keySet.add(pair.key);\n      }\n    }\n    return keySet;\n  }\n\n  /* Get all values */\n  List&lt;String&gt; values() {\n    List&lt;String&gt; valueSet = [];\n    for (final Pair? pair in _buckets) {\n      if (pair != null) {\n        valueSet.add(pair.val);\n      }\n    }\n    return valueSet;\n  }\n\n  /* Print hash table */\n  void printHashMap() {\n    for (final Pair kv in pairSet()) {\n      print(\"${kv.key} -&gt; ${kv.val}\");\n    }\n  }\n}\n</code></pre> array_hash_map.rs<pre><code>/* Key-value pair */\n#[derive(Debug, Clone, PartialEq)]\npub struct Pair {\n    pub key: i32,\n    pub val: String,\n}\n\n/* Hash table based on array implementation */\npub struct ArrayHashMap {\n    buckets: Vec&lt;Option&lt;Pair&gt;&gt;,\n}\n\nimpl ArrayHashMap {\n    pub fn new() -&gt; ArrayHashMap {\n        // Initialize array with 100 buckets\n        Self {\n            buckets: vec![None; 100],\n        }\n    }\n\n    /* Hash function */\n    fn hash_func(&amp;self, key: i32) -&gt; usize {\n        key as usize % 100\n    }\n\n    /* Query operation */\n    pub fn get(&amp;self, key: i32) -&gt; Option&lt;&amp;String&gt; {\n        let index = self.hash_func(key);\n        self.buckets[index].as_ref().map(|pair| &amp;pair.val)\n    }\n\n    /* Add operation */\n    pub fn put(&amp;mut self, key: i32, val: &amp;str) {\n        let index = self.hash_func(key);\n        self.buckets[index] = Some(Pair {\n            key,\n            val: val.to_string(),\n        });\n    }\n\n    /* Remove operation */\n    pub fn remove(&amp;mut self, key: i32) {\n        let index = self.hash_func(key);\n        // Set to None to represent removal\n        self.buckets[index] = None;\n    }\n\n    /* Get all key-value pairs */\n    pub fn entry_set(&amp;self) -&gt; Vec&lt;&amp;Pair&gt; {\n        self.buckets\n            .iter()\n            .filter_map(|pair| pair.as_ref())\n            .collect()\n    }\n\n    /* Get all keys */\n    pub fn key_set(&amp;self) -&gt; Vec&lt;&amp;i32&gt; {\n        self.buckets\n            .iter()\n            .filter_map(|pair| pair.as_ref().map(|pair| &amp;pair.key))\n            .collect()\n    }\n\n    /* Get all values */\n    pub fn value_set(&amp;self) -&gt; Vec&lt;&amp;String&gt; {\n        self.buckets\n            .iter()\n            .filter_map(|pair| pair.as_ref().map(|pair| &amp;pair.val))\n            .collect()\n    }\n\n    /* Print hash table */\n    pub fn print(&amp;self) {\n        for pair in self.entry_set() {\n            println!(\"{} -&gt; {}\", pair.key, pair.val);\n        }\n    }\n}\n</code></pre> array_hash_map.c<pre><code>/* Key-value pair int-&gt;string */\ntypedef struct {\n    int key;\n    char *val;\n} Pair;\n\n/* Hash table based on array implementation */\ntypedef struct {\n    Pair *buckets[MAX_SIZE];\n} ArrayHashMap;\n\n/* Constructor */\nArrayHashMap *newArrayHashMap() {\n    ArrayHashMap *hmap = malloc(sizeof(ArrayHashMap));\n    for (int i=0; i &lt; MAX_SIZE; i++) {\n        hmap-&gt;buckets[i] = NULL;\n    }\n    return hmap;\n}\n\n/* Destructor */\nvoid delArrayHashMap(ArrayHashMap *hmap) {\n    for (int i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            free(hmap-&gt;buckets[i]-&gt;val);\n            free(hmap-&gt;buckets[i]);\n        }\n    }\n    free(hmap);\n}\n\n/* Add operation */\nvoid put(ArrayHashMap *hmap, const int key, const char *val) {\n    Pair *Pair = malloc(sizeof(Pair));\n    Pair-&gt;key = key;\n    Pair-&gt;val = malloc(strlen(val) + 1);\n    strcpy(Pair-&gt;val, val);\n\n    int index = hashFunc(key);\n    hmap-&gt;buckets[index] = Pair;\n}\n\n/* Remove operation */\nvoid removeItem(ArrayHashMap *hmap, const int key) {\n    int index = hashFunc(key);\n    free(hmap-&gt;buckets[index]-&gt;val);\n    free(hmap-&gt;buckets[index]);\n    hmap-&gt;buckets[index] = NULL;\n}\n\n/* Get all key-value pairs */\nvoid pairSet(ArrayHashMap *hmap, MapSet *set) {\n    Pair *entries;\n    int i = 0, index = 0;\n    int total = 0;\n    /* Count valid key-value pairs */\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            total++;\n        }\n    }\n    entries = malloc(sizeof(Pair) * total);\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            entries[index].key = hmap-&gt;buckets[i]-&gt;key;\n            entries[index].val = malloc(strlen(hmap-&gt;buckets[i]-&gt;val) + 1);\n            strcpy(entries[index].val, hmap-&gt;buckets[i]-&gt;val);\n            index++;\n        }\n    }\n    set-&gt;set = entries;\n    set-&gt;len = total;\n}\n\n/* Get all keys */\nvoid keySet(ArrayHashMap *hmap, MapSet *set) {\n    int *keys;\n    int i = 0, index = 0;\n    int total = 0;\n    /* Count valid key-value pairs */\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            total++;\n        }\n    }\n    keys = malloc(total * sizeof(int));\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            keys[index] = hmap-&gt;buckets[i]-&gt;key;\n            index++;\n        }\n    }\n    set-&gt;set = keys;\n    set-&gt;len = total;\n}\n\n/* Get all values */\nvoid valueSet(ArrayHashMap *hmap, MapSet *set) {\n    char **vals;\n    int i = 0, index = 0;\n    int total = 0;\n    /* Count valid key-value pairs */\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            total++;\n        }\n    }\n    vals = malloc(total * sizeof(char *));\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            vals[index] = hmap-&gt;buckets[i]-&gt;val;\n            index++;\n        }\n    }\n    set-&gt;set = vals;\n    set-&gt;len = total;\n}\n\n/* Print hash table */\nvoid print(ArrayHashMap *hmap) {\n    int i;\n    MapSet set;\n    pairSet(hmap, &amp;set);\n    Pair *entries = (Pair *)set.set;\n    for (i = 0; i &lt; set.len; i++) {\n        printf(\"%d -&gt; %s\\n\", entries[i].key, entries[i].val);\n    }\n    free(set.set);\n}\n</code></pre> array_hash_map.kt<pre><code>/* Key-value pair */\nclass Pair(\n    var key: Int,\n    var _val: String\n)\n\n/* Hash table based on array implementation */\nclass ArrayHashMap {\n    // Initialize array with 100 buckets\n    private val buckets = arrayOfNulls&lt;Pair&gt;(100)\n\n    /* Hash function */\n    fun hashFunc(key: Int): Int {\n        val index = key % 100\n        return index\n    }\n\n    /* Query operation */\n    fun get(key: Int): String? {\n        val index = hashFunc(key)\n        val pair = buckets[index] ?: return null\n        return pair._val\n    }\n\n    /* Add operation */\n    fun put(key: Int, _val: String) {\n        val pair = Pair(key, _val)\n        val index = hashFunc(key)\n        buckets[index] = pair\n    }\n\n    /* Remove operation */\n    fun remove(key: Int) {\n        val index = hashFunc(key)\n        // Set to null to represent deletion\n        buckets[index] = null\n    }\n\n    /* Get all key-value pairs */\n    fun pairSet(): MutableList&lt;Pair&gt; {\n        val pairSet = mutableListOf&lt;Pair&gt;()\n        for (pair in buckets) {\n            if (pair != null)\n                pairSet.add(pair)\n        }\n        return pairSet\n    }\n\n    /* Get all keys */\n    fun keySet(): MutableList&lt;Int&gt; {\n        val keySet = mutableListOf&lt;Int&gt;()\n        for (pair in buckets) {\n            if (pair != null)\n                keySet.add(pair.key)\n        }\n        return keySet\n    }\n\n    /* Get all values */\n    fun valueSet(): MutableList&lt;String&gt; {\n        val valueSet = mutableListOf&lt;String&gt;()\n        for (pair in buckets) {\n            if (pair != null)\n                valueSet.add(pair._val)\n        }\n        return valueSet\n    }\n\n    /* Print hash table */\n    fun print() {\n        for (kv in pairSet()) {\n            val key = kv.key\n            val _val = kv._val\n            println(\"$key -&gt; $_val\")\n        }\n    }\n}\n</code></pre> array_hash_map.rb<pre><code>### Key-value pair ###\nclass Pair\n  attr_accessor :key, :val\n\n  def initialize(key, val)\n    @key = key\n    @val = val\n  end\nend\n\n### Hash map based on array ###\nclass ArrayHashMap\n  ### Constructor ###\n  def initialize\n    # Initialize array with 100 buckets\n    @buckets = Array.new(100)\n  end\n\n  ### Hash function ###\n  def hash_func(key)\n    index = key % 100\n  end\n\n  ### Query operation ###\n  def get(key)\n    index = hash_func(key)\n    pair = @buckets[index]\n\n    return if pair.nil?\n    pair.val\n  end\n\n  ### Add operation ###\n  def put(key, val)\n    pair = Pair.new(key, val)\n    index = hash_func(key)\n    @buckets[index] = pair\n  end\n\n  ### Delete operation ###\n  def remove(key)\n    index = hash_func(key)\n    # Set to nil to delete\n    @buckets[index] = nil\n  end\n\n  ### Get all key-value pairs ###\n  def entry_set\n    result = []\n    @buckets.each { |pair| result &lt;&lt; pair unless pair.nil? }\n    result\n  end\n\n  ### Get all keys ###\n  def key_set\n    result = []\n    @buckets.each { |pair| result &lt;&lt; pair.key unless pair.nil? }\n    result\n  end\n\n  ### Get all values ###\n  def value_set\n    result = []\n    @buckets.each { |pair| result &lt;&lt; pair.val unless pair.nil? }\n    result\n  end\n\n  ### Print hash table ###\n  def print\n    @buckets.each { |pair| puts \"#{pair.key} -&gt; #{pair.val}\" unless pair.nil? }\n  end\nend\n</code></pre>"},{"location":"chapter_hashing/hash_map/#613-hash-collision-and-resizing","title":"6.1.3 \u00a0 Hash Collision and Resizing","text":"<p>Fundamentally, the role of a hash function is to map the input space consisting of all <code>key</code>s to the output space consisting of all array indices, and the input space is often much larger than the output space. Therefore, theoretically there must be cases where \"multiple inputs correspond to the same output\".</p> <p>For the hash function in the above example, when the input <code>key</code>s have the same last two digits, the hash function produces the same output. For example, when querying two students with IDs 12836 and 20336, we get:</p> <pre><code>12836 % 100 = 36\n20336 % 100 = 36\n</code></pre> <p>As shown in Figure 6-3, two student IDs point to the same name, which is obviously incorrect. We call this situation where multiple inputs correspond to the same output a hash collision.</p> <p></p> <p> Figure 6-3 \u00a0 Hash collision example </p> <p>It's easy to see that the larger the hash table capacity \\(n\\), the lower the probability that multiple <code>key</code>s will be assigned to the same bucket, and the fewer collisions. Therefore, we can reduce hash collisions by expanding the hash table.</p> <p>As shown in Figure 6-4, before expansion, the key-value pairs <code>(136, A)</code> and <code>(236, D)</code> collided, but after expansion, the collision disappears.</p> <p></p> <p> Figure 6-4 \u00a0 Hash table resizing </p> <p>Similar to array expansion, hash table expansion requires migrating all key-value pairs from the original hash table to the new hash table, which is very time-consuming. Moreover, since the hash table capacity <code>capacity</code> changes, we need to recalculate the storage locations of all key-value pairs through the hash function, further increasing the computational overhead of the expansion process. For this reason, programming languages typically reserve a sufficiently large hash table capacity to prevent frequent expansion.</p> <p>The load factor is an important concept for hash tables. It is defined as the number of elements in the hash table divided by the number of buckets, and is used to measure the severity of hash collisions. It is also commonly used as a trigger condition for hash table expansion. For example, in Java, when the load factor exceeds \\(0.75\\), the system will expand the hash table to \\(2\\) times its original size.</p>"},{"location":"chapter_hashing/summary/","title":"6.4 \u00a0 Summary","text":""},{"location":"chapter_hashing/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Given an input <code>key</code>, a hash table can retrieve the corresponding <code>value</code> in \\(O(1)\\) time, which is highly efficient.</li> <li>Common hash table operations include querying, adding key-value pairs, deleting key-value pairs, and traversing the hash table.</li> <li>The hash function maps a <code>key</code> to an array index, allowing access to the corresponding bucket and retrieval of the <code>value</code>.</li> <li>Two different keys may end up with the same array index after hashing, leading to erroneous query results. This phenomenon is known as hash collision.</li> <li>The larger the capacity of the hash table, the lower the probability of hash collisions. Therefore, hash table expansion can mitigate hash collisions. Similar to array expansion, hash table expansion is costly.</li> <li>The load factor, defined as the number of elements divided by the number of buckets, reflects the severity of hash collisions and is often used as a condition to trigger hash table expansion.</li> <li>Separate chaining addresses hash collisions by converting each element into a linked list, storing all colliding elements in the same linked list. However, excessively long linked lists can reduce query efficiency, which can be improved by converting the linked lists into red-black trees.</li> <li>Open addressing handles hash collisions through multiple probing. Linear probing uses a fixed step size but cannot delete elements and is prone to clustering. Double hashing uses multiple hash functions for probing, which reduces clustering compared to linear probing but increases computational overhead.</li> <li>Different programming languages adopt various hash table implementations. For example, Java's <code>HashMap</code> uses separate chaining, while Python's <code>dict</code> employs open addressing.</li> <li>In hash tables, we desire hash algorithms with determinism, high efficiency, and uniform distribution. In cryptography, hash algorithms should also possess collision resistance and the avalanche effect.</li> <li>Hash algorithms typically use large prime numbers as moduli to maximize the uniform distribution of hash values and reduce hash collisions.</li> <li>Common hash algorithms include MD5, SHA-1, SHA-2, and SHA-3. MD5 is often used for file integrity checks, while SHA-2 is commonly used in secure applications and protocols.</li> <li>Programming languages usually provide built-in hash algorithms for data types to calculate bucket indices in hash tables. Generally, only immutable objects are hashable.</li> </ul>"},{"location":"chapter_hashing/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: When does the time complexity of a hash table degrade to \\(O(n)\\)?</p> <p>The time complexity of a hash table can degrade to \\(O(n)\\) when hash collisions are severe. When the hash function is well-designed, the capacity is set appropriately, and collisions are evenly distributed, the time complexity is \\(O(1)\\). We usually consider the time complexity to be \\(O(1)\\) when using built-in hash tables in programming languages.</p> <p>Q: Why not use the hash function \\(f(x) = x\\)? This would eliminate collisions.</p> <p>Under the hash function \\(f(x) = x\\), each element corresponds to a unique bucket index, which is equivalent to an array. However, the input space is usually much larger than the output space (array length), so the last step of a hash function is often to take the modulo of the array length. In other words, the goal of a hash table is to map a larger state space to a smaller one while providing \\(O(1)\\) query efficiency.</p> <p>Q: Why can hash tables be more efficient than arrays, linked lists, or binary trees, even though hash tables are implemented using these structures?</p> <p>Firstly, hash tables have higher time efficiency but lower space efficiency. A significant portion of memory in hash tables remains unused.</p> <p>Secondly, hash tables are only more time-efficient in specific use cases. If a feature can be implemented with the same time complexity using an array or a linked list, it's usually faster than using a hash table. This is because the computation of the hash function incurs overhead, making the constant factor in the time complexity larger.</p> <p>Lastly, the time complexity of hash tables can degrade. For example, in separate chaining, we perform search operations in a linked list or red-black tree, which still risks degrading to \\(O(n)\\) time.</p> <p>Q: Does double hashing also have the flaw of not being able to delete elements directly? Can space marked as deleted be reused?</p> <p>Double hashing is a form of open addressing, and all open addressing methods have the drawback of not being able to delete elements directly; they require marking elements as deleted. Marked spaces can be reused. When inserting new elements into the hash table, and the hash function points to a position marked as deleted, that position can be used by the new element. This maintains the probing sequence of the hash table while ensuring efficient use of space.</p> <p>Q: Why do hash collisions occur during the search process in linear probing?</p> <p>During the search process, the hash function points to the corresponding bucket and key-value pair. If the <code>key</code> doesn't match, it indicates a hash collision. Therefore, linear probing will search downward at a predetermined step size until the correct key-value pair is found or the search fails.</p> <p>Q: Why can expanding a hash table alleviate hash collisions?</p> <p>The last step of a hash function often involves taking the modulo of the array length \\(n\\), to keep the output within the array index range. When expanding, the array length \\(n\\) changes, and the indices corresponding to the keys may also change. Keys that were previously mapped to the same bucket might be distributed across multiple buckets after expansion, thereby mitigating hash collisions.</p>"},{"location":"chapter_heap/","title":"Chapter 8. \u00a0 Heap","text":"<p>Abstract</p> <p>Heaps are like mountain peaks, layered and undulating, each with its unique form.</p> <p>The peaks rise and fall at varying heights, yet the tallest peak always catches the eye first.</p>"},{"location":"chapter_heap/#chapter-contents","title":"Chapter contents","text":"<ul> <li>8.1 \u00a0 Heap</li> <li>8.2 \u00a0 Building a Heap</li> <li>8.3 \u00a0 Top-K Problem</li> <li>8.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_heap/build_heap/","title":"8.2 \u00a0 Heap Construction Operation","text":"<p>In some cases, we want to build a heap using all elements of a list, and this process is called \"heap construction operation.\"</p>"},{"location":"chapter_heap/build_heap/#821-implementing-with-element-insertion","title":"8.2.1 \u00a0 Implementing with Element Insertion","text":"<p>We first create an empty heap, then iterate through the list, performing the \"element insertion operation\" on each element in sequence. This means adding the element to the bottom of the heap and then performing \"bottom-to-top\" heapify on that element.</p> <p>Each time an element is inserted into the heap, the heap's length increases by one. Since nodes are added to the binary tree sequentially from top to bottom, the heap is constructed \"from top to bottom.\"</p> <p>Given \\(n\\) elements, each element's insertion operation takes \\(O(\\log{n})\\) time, so the time complexity of this heap construction method is \\(O(n \\log n)\\).</p>"},{"location":"chapter_heap/build_heap/#822-implementing-through-heapify-traversal","title":"8.2.2 \u00a0 Implementing Through Heapify Traversal","text":"<p>In fact, we can implement a more efficient heap construction method in two steps.</p> <ol> <li>Add all elements of the list as-is to the heap, at which point the heap property is not yet satisfied.</li> <li>Traverse the heap in reverse order (reverse of level-order traversal), performing \"top-to-bottom heapify\" on each non-leaf node in sequence.</li> </ol> <p>After heapifying a node, the subtree rooted at that node becomes a valid sub-heap. Since we traverse in reverse order, the heap is constructed \"from bottom to top.\"</p> <p>The reason for choosing reverse order traversal is that it ensures the subtree below the current node is already a valid sub-heap, making the heapification of the current node effective.</p> <p>It's worth noting that since leaf nodes have no children, they are naturally valid sub-heaps and do not require heapification. As shown in the code below, the last non-leaf node is the parent of the last node; we start from it and traverse in reverse order to perform heapification:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby my_heap.py<pre><code>def __init__(self, nums: list[int]):\n    \"\"\"Constructor, build heap based on input list\"\"\"\n    # Add list elements to heap as is\n    self.max_heap = nums\n    # Heapify all nodes except leaf nodes\n    for i in range(self.parent(self.size() - 1), -1, -1):\n        self.sift_down(i)\n</code></pre> my_heap.cpp<pre><code>/* Constructor, build heap based on input list */\nMaxHeap(vector&lt;int&gt; nums) {\n    // Add list elements to heap as is\n    maxHeap = nums;\n    // Heapify all nodes except leaf nodes\n    for (int i = parent(size() - 1); i &gt;= 0; i--) {\n        siftDown(i);\n    }\n}\n</code></pre> my_heap.java<pre><code>/* Constructor, build heap based on input list */\nMaxHeap(List&lt;Integer&gt; nums) {\n    // Add list elements to heap as is\n    maxHeap = new ArrayList&lt;&gt;(nums);\n    // Heapify all nodes except leaf nodes\n    for (int i = parent(size() - 1); i &gt;= 0; i--) {\n        siftDown(i);\n    }\n}\n</code></pre> my_heap.cs<pre><code>/* Constructor, build heap from input list */\nMaxHeap(IEnumerable&lt;int&gt; nums) {\n    // Add list elements to heap as is\n    maxHeap = new List&lt;int&gt;(nums);\n    // Heapify all nodes except leaf nodes\n    var size = Parent(this.Size() - 1);\n    for (int i = size; i &gt;= 0; i--) {\n        SiftDown(i);\n    }\n}\n</code></pre> my_heap.go<pre><code>/* Constructor, build heap from slice */\nfunc newMaxHeap(nums []any) *maxHeap {\n    // Add list elements to heap as is\n    h := &amp;maxHeap{data: nums}\n    for i := h.parent(len(h.data) - 1); i &gt;= 0; i-- {\n        // Heapify all nodes except leaf nodes\n        h.siftDown(i)\n    }\n    return h\n}\n</code></pre> my_heap.swift<pre><code>/* Constructor, build heap based on input list */\ninit(nums: [Int]) {\n    // Add list elements to heap as is\n    maxHeap = nums\n    // Heapify all nodes except leaf nodes\n    for i in (0 ... parent(i: size() - 1)).reversed() {\n        siftDown(i: i)\n    }\n}\n</code></pre> my_heap.js<pre><code>/* Constructor, build empty heap or build heap from input list */\nconstructor(nums) {\n    // Add list elements to heap as is\n    this.#maxHeap = nums === undefined ? [] : [...nums];\n    // Heapify all nodes except leaf nodes\n    for (let i = this.#parent(this.size() - 1); i &gt;= 0; i--) {\n        this.#siftDown(i);\n    }\n}\n</code></pre> my_heap.ts<pre><code>/* Constructor, build empty heap or build heap from input list */\nconstructor(nums?: number[]) {\n    // Add list elements to heap as is\n    this.maxHeap = nums === undefined ? [] : [...nums];\n    // Heapify all nodes except leaf nodes\n    for (let i = this.parent(this.size() - 1); i &gt;= 0; i--) {\n        this.siftDown(i);\n    }\n}\n</code></pre> my_heap.dart<pre><code>/* Constructor, build heap based on input list */\nMaxHeap(List&lt;int&gt; nums) {\n  // Add list elements to heap as is\n  _maxHeap = nums;\n  // Heapify all nodes except leaf nodes\n  for (int i = _parent(size() - 1); i &gt;= 0; i--) {\n    siftDown(i);\n  }\n}\n</code></pre> my_heap.rs<pre><code>/* Constructor, build heap based on input list */\nfn new(nums: Vec&lt;i32&gt;) -&gt; Self {\n    // Add list elements to heap as is\n    let mut heap = MaxHeap { max_heap: nums };\n    // Heapify all nodes except leaf nodes\n    for i in (0..=Self::parent(heap.size() - 1)).rev() {\n        heap.sift_down(i);\n    }\n    heap\n}\n</code></pre> my_heap.c<pre><code>/* Constructor, build heap from slice */\nMaxHeap *newMaxHeap(int nums[], int size) {\n    // Push all elements to heap\n    MaxHeap *maxHeap = (MaxHeap *)malloc(sizeof(MaxHeap));\n    maxHeap-&gt;size = size;\n    memcpy(maxHeap-&gt;data, nums, size * sizeof(int));\n    for (int i = parent(maxHeap, size - 1); i &gt;= 0; i--) {\n        // Heapify all nodes except leaf nodes\n        siftDown(maxHeap, i);\n    }\n    return maxHeap;\n}\n</code></pre> my_heap.kt<pre><code>/* Max heap */\nclass MaxHeap(nums: MutableList&lt;Int&gt;?) {\n    // Use list instead of array, no need to consider capacity expansion\n    private val maxHeap = mutableListOf&lt;Int&gt;()\n\n    /* Constructor, build heap based on input list */\n    init {\n        // Add list elements to heap as is\n        maxHeap.addAll(nums!!)\n        // Heapify all nodes except leaf nodes\n        for (i in parent(size() - 1) downTo 0) {\n            siftDown(i)\n        }\n    }\n\n    /* Get index of left child node */\n    private fun left(i: Int): Int {\n        return 2 * i + 1\n    }\n\n    /* Get index of right child node */\n    private fun right(i: Int): Int {\n        return 2 * i + 2\n    }\n\n    /* Get index of parent node */\n    private fun parent(i: Int): Int {\n        return (i - 1) / 2 // Floor division\n    }\n\n    /* Swap elements */\n    private fun swap(i: Int, j: Int) {\n        val temp = maxHeap[i]\n        maxHeap[i] = maxHeap[j]\n        maxHeap[j] = temp\n    }\n\n    /* Get heap size */\n    fun size(): Int {\n        return maxHeap.size\n    }\n\n    /* Check if heap is empty */\n    fun isEmpty(): Boolean {\n        /* Check if heap is empty */\n        return size() == 0\n    }\n\n    /* Access top element */\n    fun peek(): Int {\n        return maxHeap[0]\n    }\n\n    /* Element enters heap */\n    fun push(_val: Int) {\n        // Add node\n        maxHeap.add(_val)\n        // Heapify from bottom to top\n        siftUp(size() - 1)\n    }\n\n    /* Starting from node i, heapify from bottom to top */\n    private fun siftUp(it: Int) {\n        // Kotlin function parameters are immutable, so create temporary variable\n        var i = it\n        while (true) {\n            // Get parent node of node i\n            val p = parent(i)\n            // When \"crossing root node\" or \"node needs no repair\", end heapify\n            if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p]) break\n            // Swap two nodes\n            swap(i, p)\n            // Loop upward heapify\n            i = p\n        }\n    }\n\n    /* Element exits heap */\n    fun pop(): Int {\n        // Handle empty case\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        // Delete node\n        swap(0, size() - 1)\n        // Remove node\n        val _val = maxHeap.removeAt(size() - 1)\n        // Return top element\n        siftDown(0)\n        // Return heap top element\n        return _val\n    }\n\n    /* Starting from node i, heapify from top to bottom */\n    private fun siftDown(it: Int) {\n        // Kotlin function parameters are immutable, so create temporary variable\n        var i = it\n        while (true) {\n            // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n            val l = left(i)\n            val r = right(i)\n            var ma = i\n            if (l &lt; size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma]) ma = l\n            if (r &lt; size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma]) ma = r\n            // Swap two nodes\n            if (ma == i) break\n            // Swap two nodes\n            swap(i, ma)\n            // Loop downwards heapification\n            i = ma\n        }\n    }\n\n    /* Driver Code */\n    fun print() {\n        val queue = PriorityQueue { a: Int, b: Int -&gt; b - a }\n        queue.addAll(maxHeap)\n        printHeap(queue)\n    }\n}\n</code></pre> my_heap.rb<pre><code>### Constructor, build heap from input list ###\ndef initialize(nums)\n  # Add list elements to heap as is\n  @max_heap = nums\n  # Heapify all nodes except leaf nodes\n  parent(size - 1).downto(0) do |i|\n    sift_down(i)\n  end\nend\n</code></pre>"},{"location":"chapter_heap/build_heap/#823-complexity-analysis","title":"8.2.3 \u00a0 Complexity Analysis","text":"<p>Next, let's attempt to derive the time complexity of this second heap construction method.</p> <ul> <li>Assuming the complete binary tree has \\(n\\) nodes, then the number of leaf nodes is \\((n + 1) / 2\\), where \\(/\\) is floor division. Therefore, the number of nodes that need heapification is \\((n - 1) / 2\\).</li> <li>In the top-to-bottom heapify process, each node is heapified at most to the leaf nodes, so the maximum number of iterations is the binary tree height \\(\\log n\\).</li> </ul> <p>Multiplying these two together, we get a time complexity of \\(O(n \\log n)\\) for the heap construction process. However, this estimate is not accurate because it doesn't account for the property that binary trees have far more nodes at lower levels than at upper levels.</p> <p>Let's perform a more accurate calculation. To reduce calculation difficulty, assume a \"perfect binary tree\" with \\(n\\) nodes and height \\(h\\); this assumption does not affect the correctness of the result.</p> <p></p> <p> Figure 8-5 \u00a0 Node count at each level of a perfect binary tree </p> <p>As shown in Figure 8-5, the maximum number of iterations for a node's \"top-to-bottom heapify\" equals the distance from that node to the leaf nodes, which is precisely the \"node height.\" Therefore, we can sum the \"number of nodes \\(\\times\\) node height\" at each level to obtain the total number of heapify iterations for all nodes.</p> \\[ T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{(h-1)}\\times1 \\] <p>To simplify the above expression, we need to use sequence knowledge from high school. First, multiply \\(T(h)\\) by \\(2\\) to get:</p> \\[ \\begin{aligned} T(h) &amp; = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{h-1}\\times1 \\newline 2 T(h) &amp; = 2^1h + 2^2(h-1) + 2^3(h-2) + \\dots + 2^{h}\\times1 \\newline \\end{aligned} \\] <p>Using the method of differences, subtract the first equation \\(T(h)\\) from the second equation \\(2 T(h)\\) to get:</p> \\[ 2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \\dots + 2^{h-1} + 2^h \\] <p>Observing the above expression, we find that \\(T(h)\\) is a geometric series, which can be calculated directly using the sum formula, yielding a time complexity of:</p> \\[ \\begin{aligned} T(h) &amp; = 2 \\frac{1 - 2^h}{1 - 2} - h \\newline &amp; = 2^{h+1} - h - 2 \\newline &amp; = O(2^h) \\end{aligned} \\] <p>Furthermore, a perfect binary tree with height \\(h\\) has \\(n = 2^{h+1} - 1\\) nodes, so the complexity is \\(O(2^h) = O(n)\\). This derivation shows that the time complexity of building a heap from an input list is \\(O(n)\\), which is highly efficient.</p>"},{"location":"chapter_heap/heap/","title":"8.1 \u00a0 Heap","text":"<p>A heap is a complete binary tree that satisfies specific conditions and can be mainly categorized into two types, as shown in Figure 8-1.</p> <ul> <li>min heap: The value of any node \\(\\leq\\) the values of its child nodes.</li> <li>max heap: The value of any node \\(\\geq\\) the values of its child nodes.</li> </ul> <p></p> <p> Figure 8-1 \u00a0 Min heap and max heap </p> <p>As a special case of a complete binary tree, heaps have the following characteristics.</p> <ul> <li>The bottom layer nodes are filled from left to right, and nodes in other layers are fully filled.</li> <li>We call the root node of the binary tree the \"heap top\" and the bottom-rightmost node the \"heap bottom.\"</li> <li>For max heaps (min heaps), the value of the heap top element (root node) is the largest (smallest).</li> </ul>"},{"location":"chapter_heap/heap/#811-common-heap-operations","title":"8.1.1 \u00a0 Common Heap Operations","text":"<p>It should be noted that many programming languages provide a priority queue, which is an abstract data structure defined as a queue with priority sorting.</p> <p>In fact, heaps are typically used to implement priority queues, with max heaps corresponding to priority queues where elements are dequeued in descending order. From a usage perspective, we can regard \"priority queue\" and \"heap\" as equivalent data structures. Therefore, this book does not make a special distinction between the two and uniformly refers to them as \"heap.\"</p> <p>Common heap operations are shown in Table 8-1, and method names need to be determined based on the programming language.</p> <p> Table 8-1 \u00a0 Efficiency of Heap Operations </p> Method name Description Time complexity <code>push()</code> Insert an element into the heap \\(O(\\log n)\\) <code>pop()</code> Remove the heap top element \\(O(\\log n)\\) <code>peek()</code> Access the heap top element (max/min value for max/min heap) \\(O(1)\\) <code>size()</code> Get the number of elements in the heap \\(O(1)\\) <code>isEmpty()</code> Check if the heap is empty \\(O(1)\\) <p>In practical applications, we can directly use the heap class (or priority queue class) provided by programming languages.</p> <p>Similar to \"ascending order\" and \"descending order\" in sorting algorithms, we can implement conversion between \"min heap\" and \"max heap\" by setting a <code>flag</code> or modifying the <code>Comparator</code>. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby heap.py<pre><code># Initialize a min heap\nmin_heap, flag = [], 1\n# Initialize a max heap\nmax_heap, flag = [], -1\n\n# Python's heapq module implements a min heap by default\n# Consider negating elements before pushing them to the heap, which inverts the size relationship and thus implements a max heap\n# In this example, flag = 1 corresponds to a min heap, flag = -1 corresponds to a max heap\n\n# Push elements into the heap\nheapq.heappush(max_heap, flag * 1)\nheapq.heappush(max_heap, flag * 3)\nheapq.heappush(max_heap, flag * 2)\nheapq.heappush(max_heap, flag * 5)\nheapq.heappush(max_heap, flag * 4)\n\n# Get the heap top element\npeek: int = flag * max_heap[0] # 5\n\n# Remove the heap top element\n# The removed elements will form a descending sequence\nval = flag * heapq.heappop(max_heap) # 5\nval = flag * heapq.heappop(max_heap) # 4\nval = flag * heapq.heappop(max_heap) # 3\nval = flag * heapq.heappop(max_heap) # 2\nval = flag * heapq.heappop(max_heap) # 1\n\n# Get the heap size\nsize: int = len(max_heap)\n\n# Check if the heap is empty\nis_empty: bool = not max_heap\n\n# Build a heap from an input list\nmin_heap: list[int] = [1, 3, 2, 5, 4]\nheapq.heapify(min_heap)\n</code></pre> heap.cpp<pre><code>/* Initialize a heap */\n// Initialize a min heap\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n// Initialize a max heap\npriority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;\n\n/* Push elements into the heap */\nmaxHeap.push(1);\nmaxHeap.push(3);\nmaxHeap.push(2);\nmaxHeap.push(5);\nmaxHeap.push(4);\n\n/* Get the heap top element */\nint peek = maxHeap.top(); // 5\n\n/* Remove the heap top element */\n// The removed elements will form a descending sequence\nmaxHeap.pop(); // 5\nmaxHeap.pop(); // 4\nmaxHeap.pop(); // 3\nmaxHeap.pop(); // 2\nmaxHeap.pop(); // 1\n\n/* Get the heap size */\nint size = maxHeap.size();\n\n/* Check if the heap is empty */\nbool isEmpty = maxHeap.empty();\n\n/* Build a heap from an input list */\nvector&lt;int&gt; input{1, 3, 2, 5, 4};\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap(input.begin(), input.end());\n</code></pre> heap.java<pre><code>/* Initialize a heap */\n// Initialize a min heap\nQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();\n// Initialize a max heap (use lambda expression to modify Comparator)\nQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);\n\n/* Push elements into the heap */\nmaxHeap.offer(1);\nmaxHeap.offer(3);\nmaxHeap.offer(2);\nmaxHeap.offer(5);\nmaxHeap.offer(4);\n\n/* Get the heap top element */\nint peek = maxHeap.peek(); // 5\n\n/* Remove the heap top element */\n// The removed elements will form a descending sequence\npeek = maxHeap.poll(); // 5\npeek = maxHeap.poll(); // 4\npeek = maxHeap.poll(); // 3\npeek = maxHeap.poll(); // 2\npeek = maxHeap.poll(); // 1\n\n/* Get the heap size */\nint size = maxHeap.size();\n\n/* Check if the heap is empty */\nboolean isEmpty = maxHeap.isEmpty();\n\n/* Build a heap from an input list */\nminHeap = new PriorityQueue&lt;&gt;(Arrays.asList(1, 3, 2, 5, 4));\n</code></pre> heap.cs<pre><code>/* Initialize a heap */\n// Initialize a min heap\nPriorityQueue&lt;int, int&gt; minHeap = new();\n// Initialize a max heap (use lambda expression to modify Comparer)\nPriorityQueue&lt;int, int&gt; maxHeap = new(Comparer&lt;int&gt;.Create((x, y) =&gt; y.CompareTo(x)));\n\n/* Push elements into the heap */\nmaxHeap.Enqueue(1, 1);\nmaxHeap.Enqueue(3, 3);\nmaxHeap.Enqueue(2, 2);\nmaxHeap.Enqueue(5, 5);\nmaxHeap.Enqueue(4, 4);\n\n/* Get the heap top element */\nint peek = maxHeap.Peek();//5\n\n/* Remove the heap top element */\n// The removed elements will form a descending sequence\npeek = maxHeap.Dequeue();  // 5\npeek = maxHeap.Dequeue();  // 4\npeek = maxHeap.Dequeue();  // 3\npeek = maxHeap.Dequeue();  // 2\npeek = maxHeap.Dequeue();  // 1\n\n/* Get the heap size */\nint size = maxHeap.Count;\n\n/* Check if the heap is empty */\nbool isEmpty = maxHeap.Count == 0;\n\n/* Build a heap from an input list */\nminHeap = new PriorityQueue&lt;int, int&gt;([(1, 1), (3, 3), (2, 2), (5, 5), (4, 4)]);\n</code></pre> heap.go<pre><code>// In Go, we can construct a max heap of integers by implementing heap.Interface\n// Implementing heap.Interface also requires implementing sort.Interface\ntype intHeap []any\n\n// Push implements the heap.Interface method for pushing an element into the heap\nfunc (h *intHeap) Push(x any) {\n    // Push and Pop use pointer receiver as parameters\n    // because they not only adjust the slice contents but also modify the slice length\n    *h = append(*h, x.(int))\n}\n\n// Pop implements the heap.Interface method for popping the heap top element\nfunc (h *intHeap) Pop() any {\n    // The element to be removed is stored at the end\n    last := (*h)[len(*h)-1]\n    *h = (*h)[:len(*h)-1]\n    return last\n}\n\n// Len is a sort.Interface method\nfunc (h *intHeap) Len() int {\n    return len(*h)\n}\n\n// Less is a sort.Interface method\nfunc (h *intHeap) Less(i, j int) bool {\n    // To implement a min heap, change this to a less-than sign\n    return (*h)[i].(int) &gt; (*h)[j].(int)\n}\n\n// Swap is a sort.Interface method\nfunc (h *intHeap) Swap(i, j int) {\n    (*h)[i], (*h)[j] = (*h)[j], (*h)[i]\n}\n\n// Top gets the heap top element\nfunc (h *intHeap) Top() any {\n    return (*h)[0]\n}\n\n/* Driver Code */\nfunc TestHeap(t *testing.T) {\n    /* Initialize a heap */\n    // Initialize a max heap\n    maxHeap := &amp;intHeap{}\n    heap.Init(maxHeap)\n    /* Push elements into the heap */\n    // Call heap.Interface methods to add elements\n    heap.Push(maxHeap, 1)\n    heap.Push(maxHeap, 3)\n    heap.Push(maxHeap, 2)\n    heap.Push(maxHeap, 4)\n    heap.Push(maxHeap, 5)\n\n    /* Get the heap top element */\n    top := maxHeap.Top()\n    fmt.Printf(\"Heap top element is %d\\n\", top)\n\n    /* Remove the heap top element */\n    // Call heap.Interface methods to remove elements\n    heap.Pop(maxHeap) // 5\n    heap.Pop(maxHeap) // 4\n    heap.Pop(maxHeap) // 3\n    heap.Pop(maxHeap) // 2\n    heap.Pop(maxHeap) // 1\n\n    /* Get the heap size */\n    size := len(*maxHeap)\n    fmt.Printf(\"Number of heap elements is %d\\n\", size)\n\n    /* Check if the heap is empty */\n    isEmpty := len(*maxHeap) == 0\n    fmt.Printf(\"Is the heap empty? %t\\n\", isEmpty)\n}\n</code></pre> heap.swift<pre><code>/* Initialize a heap */\n// Swift's Heap type supports both max heaps and min heaps, and requires importing swift-collections\nvar heap = Heap&lt;Int&gt;()\n\n/* Push elements into the heap */\nheap.insert(1)\nheap.insert(3)\nheap.insert(2)\nheap.insert(5)\nheap.insert(4)\n\n/* Get the heap top element */\nvar peek = heap.max()!\n\n/* Remove the heap top element */\npeek = heap.removeMax() // 5\npeek = heap.removeMax() // 4\npeek = heap.removeMax() // 3\npeek = heap.removeMax() // 2\npeek = heap.removeMax() // 1\n\n/* Get the heap size */\nlet size = heap.count\n\n/* Check if the heap is empty */\nlet isEmpty = heap.isEmpty\n\n/* Build a heap from an input list */\nlet heap2 = Heap([1, 3, 2, 5, 4])\n</code></pre> heap.js<pre><code>// JavaScript does not provide a built-in Heap class\n</code></pre> heap.ts<pre><code>// TypeScript does not provide a built-in Heap class\n</code></pre> heap.dart<pre><code>// Dart does not provide a built-in Heap class\n</code></pre> heap.rs<pre><code>use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n/* Initialize a heap */\n// Initialize a min heap\nlet mut min_heap = BinaryHeap::&lt;Reverse&lt;i32&gt;&gt;::new();\n// Initialize a max heap\nlet mut max_heap = BinaryHeap::new();\n\n/* Push elements into the heap */\nmax_heap.push(1);\nmax_heap.push(3);\nmax_heap.push(2);\nmax_heap.push(5);\nmax_heap.push(4);\n\n/* Get the heap top element */\nlet peek = max_heap.peek().unwrap();  // 5\n\n/* Remove the heap top element */\n// The removed elements will form a descending sequence\nlet peek = max_heap.pop().unwrap();   // 5\nlet peek = max_heap.pop().unwrap();   // 4\nlet peek = max_heap.pop().unwrap();   // 3\nlet peek = max_heap.pop().unwrap();   // 2\nlet peek = max_heap.pop().unwrap();   // 1\n\n/* Get the heap size */\nlet size = max_heap.len();\n\n/* Check if the heap is empty */\nlet is_empty = max_heap.is_empty();\n\n/* Build a heap from an input list */\nlet min_heap = BinaryHeap::from(vec![Reverse(1), Reverse(3), Reverse(2), Reverse(5), Reverse(4)]);\n</code></pre> heap.c<pre><code>// C does not provide a built-in Heap class\n</code></pre> heap.kt<pre><code>/* Initialize a heap */\n// Initialize a min heap\nvar minHeap = PriorityQueue&lt;Int&gt;()\n// Initialize a max heap (use lambda expression to modify Comparator)\nval maxHeap = PriorityQueue { a: Int, b: Int -&gt; b - a }\n\n/* Push elements into the heap */\nmaxHeap.offer(1)\nmaxHeap.offer(3)\nmaxHeap.offer(2)\nmaxHeap.offer(5)\nmaxHeap.offer(4)\n\n/* Get the heap top element */\nvar peek = maxHeap.peek() // 5\n\n/* Remove the heap top element */\n// The removed elements will form a descending sequence\npeek = maxHeap.poll() // 5\npeek = maxHeap.poll() // 4\npeek = maxHeap.poll() // 3\npeek = maxHeap.poll() // 2\npeek = maxHeap.poll() // 1\n\n/* Get the heap size */\nval size = maxHeap.size\n\n/* Check if the heap is empty */\nval isEmpty = maxHeap.isEmpty()\n\n/* Build a heap from an input list */\nminHeap = PriorityQueue(mutableListOf(1, 3, 2, 5, 4))\n</code></pre> heap.rb<pre><code># Ruby does not provide a built-in Heap class\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_heap/heap/#812-implementation-of-the-heap","title":"8.1.2 \u00a0 Implementation of the Heap","text":"<p>The following implementation is of a max heap. To convert it to a min heap, simply invert all size logic comparisons (for example, replace \\(\\geq\\) with \\(\\leq\\)). Interested readers are encouraged to implement this on their own.</p>"},{"location":"chapter_heap/heap/#1-heap-storage-and-representation","title":"1. \u00a0 Heap Storage and Representation","text":"<p>As mentioned in the \"Binary Tree\" chapter, complete binary trees are well-suited for array representation. Since heaps are a type of complete binary tree, we will use arrays to store heaps.</p> <p>When representing a binary tree with an array, elements represent node values, and indexes represent node positions in the binary tree. Node pointers are implemented through index mapping formulas.</p> <p>As shown in Figure 8-2, given an index \\(i\\), the index of its left child is \\(2i + 1\\), the index of its right child is \\(2i + 2\\), and the index of its parent is \\((i - 1) / 2\\) (floor division). When an index is out of bounds, it indicates a null node or that the node does not exist.</p> <p></p> <p> Figure 8-2 \u00a0 Representation and storage of heaps </p> <p>We can encapsulate the index mapping formula into functions for convenient subsequent use:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby my_heap.py<pre><code>def left(self, i: int) -&gt; int:\n    \"\"\"Get index of left child node\"\"\"\n    return 2 * i + 1\n\ndef right(self, i: int) -&gt; int:\n    \"\"\"Get index of right child node\"\"\"\n    return 2 * i + 2\n\ndef parent(self, i: int) -&gt; int:\n    \"\"\"Get index of parent node\"\"\"\n    return (i - 1) // 2  # Floor division\n</code></pre> my_heap.cpp<pre><code>/* Get index of left child node */\nint left(int i) {\n    return 2 * i + 1;\n}\n\n/* Get index of right child node */\nint right(int i) {\n    return 2 * i + 2;\n}\n\n/* Get index of parent node */\nint parent(int i) {\n    return (i - 1) / 2; // Floor division\n}\n</code></pre> my_heap.java<pre><code>/* Get index of left child node */\nint left(int i) {\n    return 2 * i + 1;\n}\n\n/* Get index of right child node */\nint right(int i) {\n    return 2 * i + 2;\n}\n\n/* Get index of parent node */\nint parent(int i) {\n    return (i - 1) / 2; // Floor division\n}\n</code></pre> my_heap.cs<pre><code>/* Get index of left child node */\nint Left(int i) {\n    return 2 * i + 1;\n}\n\n/* Get index of right child node */\nint Right(int i) {\n    return 2 * i + 2;\n}\n\n/* Get index of parent node */\nint Parent(int i) {\n    return (i - 1) / 2; // Floor division\n}\n</code></pre> my_heap.go<pre><code>/* Get index of left child node */\nfunc (h *maxHeap) left(i int) int {\n    return 2*i + 1\n}\n\n/* Get index of right child node */\nfunc (h *maxHeap) right(i int) int {\n    return 2*i + 2\n}\n\n/* Get index of parent node */\nfunc (h *maxHeap) parent(i int) int {\n    // Floor division\n    return (i - 1) / 2\n}\n</code></pre> my_heap.swift<pre><code>/* Get index of left child node */\nfunc left(i: Int) -&gt; Int {\n    2 * i + 1\n}\n\n/* Get index of right child node */\nfunc right(i: Int) -&gt; Int {\n    2 * i + 2\n}\n\n/* Get index of parent node */\nfunc parent(i: Int) -&gt; Int {\n    (i - 1) / 2 // Floor division\n}\n</code></pre> my_heap.js<pre><code>/* Get index of left child node */\n#left(i) {\n    return 2 * i + 1;\n}\n\n/* Get index of right child node */\n#right(i) {\n    return 2 * i + 2;\n}\n\n/* Get index of parent node */\n#parent(i) {\n    return Math.floor((i - 1) / 2); // Floor division\n}\n</code></pre> my_heap.ts<pre><code>/* Get index of left child node */\nleft(i: number): number {\n    return 2 * i + 1;\n}\n\n/* Get index of right child node */\nright(i: number): number {\n    return 2 * i + 2;\n}\n\n/* Get index of parent node */\nparent(i: number): number {\n    return Math.floor((i - 1) / 2); // Floor division\n}\n</code></pre> my_heap.dart<pre><code>/* Get index of left child node */\nint _left(int i) {\n  return 2 * i + 1;\n}\n\n/* Get index of right child node */\nint _right(int i) {\n  return 2 * i + 2;\n}\n\n/* Get index of parent node */\nint _parent(int i) {\n  return (i - 1) ~/ 2; // Floor division\n}\n</code></pre> my_heap.rs<pre><code>/* Get index of left child node */\nfn left(i: usize) -&gt; usize {\n    2 * i + 1\n}\n\n/* Get index of right child node */\nfn right(i: usize) -&gt; usize {\n    2 * i + 2\n}\n\n/* Get index of parent node */\nfn parent(i: usize) -&gt; usize {\n    (i - 1) / 2 // Floor division\n}\n</code></pre> my_heap.c<pre><code>/* Get index of left child node */\nint left(MaxHeap *maxHeap, int i) {\n    return 2 * i + 1;\n}\n\n/* Get index of right child node */\nint right(MaxHeap *maxHeap, int i) {\n    return 2 * i + 2;\n}\n\n/* Get index of parent node */\nint parent(MaxHeap *maxHeap, int i) {\n    return (i - 1) / 2; // Round down\n}\n</code></pre> my_heap.kt<pre><code>/* Get index of left child node */\nfun left(i: Int): Int {\n    return 2 * i + 1\n}\n\n/* Get index of right child node */\nfun right(i: Int): Int {\n    return 2 * i + 2\n}\n\n/* Get index of parent node */\nfun parent(i: Int): Int {\n    return (i - 1) / 2 // Floor division\n}\n</code></pre> my_heap.rb<pre><code>### Get left child index ###\ndef left(i)\n  2 * i + 1\nend\n\n### Get right child index ###\ndef right(i)\n  2 * i + 2\nend\n\n### Get parent node index ###\ndef parent(i)\n  (i - 1) / 2     # Floor division\nend\n</code></pre>"},{"location":"chapter_heap/heap/#2-accessing-the-heap-top-element","title":"2. \u00a0 Accessing the Heap Top Element","text":"<p>The heap top element is the root node of the binary tree, which is also the first element of the list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby my_heap.py<pre><code>def peek(self) -&gt; int:\n    \"\"\"Access top element\"\"\"\n    return self.max_heap[0]\n</code></pre> my_heap.cpp<pre><code>/* Access top element */\nint peek() {\n    return maxHeap[0];\n}\n</code></pre> my_heap.java<pre><code>/* Access top element */\nint peek() {\n    return maxHeap.get(0);\n}\n</code></pre> my_heap.cs<pre><code>/* Access top element */\nint Peek() {\n    return maxHeap[0];\n}\n</code></pre> my_heap.go<pre><code>/* Access top element */\nfunc (h *maxHeap) peek() any {\n    return h.data[0]\n}\n</code></pre> my_heap.swift<pre><code>/* Access top element */\nfunc peek() -&gt; Int {\n    maxHeap[0]\n}\n</code></pre> my_heap.js<pre><code>/* Access top element */\npeek() {\n    return this.#maxHeap[0];\n}\n</code></pre> my_heap.ts<pre><code>/* Access top element */\npeek(): number {\n    return this.maxHeap[0];\n}\n</code></pre> my_heap.dart<pre><code>/* Access top element */\nint peek() {\n  return _maxHeap[0];\n}\n</code></pre> my_heap.rs<pre><code>/* Access top element */\nfn peek(&amp;self) -&gt; Option&lt;i32&gt; {\n    self.max_heap.first().copied()\n}\n</code></pre> my_heap.c<pre><code>/* Access top element */\nint peek(MaxHeap *maxHeap) {\n    return maxHeap-&gt;data[0];\n}\n</code></pre> my_heap.kt<pre><code>/* Access top element */\nfun peek(): Int {\n    return maxHeap[0]\n}\n</code></pre> my_heap.rb<pre><code>### Access heap top element ###\ndef peek\n  @max_heap[0]\nend\n</code></pre>"},{"location":"chapter_heap/heap/#3-inserting-an-element-into-the-heap","title":"3. \u00a0 Inserting an Element Into the Heap","text":"<p>Given an element <code>val</code>, we first add it to the bottom of the heap. After addition, since <code>val</code> may be larger than other elements in the heap, the heap's property may be violated. Therefore, it's necessary to repair the path from the inserted node to the root node. This operation is called heapify.</p> <p>Starting from the inserted node, perform heapify from bottom to top. As shown in Figure 8-3, we compare the inserted node with its parent node, and if the inserted node is larger, swap them. Then continue this operation, repairing nodes in the heap from bottom to top until we pass the root node or encounter a node that does not need swapping.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 8-3 \u00a0 Steps of inserting an element into the heap </p> <p>Given a total of \\(n\\) nodes, the tree height is \\(O(\\log n)\\). Thus, the number of loop iterations in the heapify operation is at most \\(O(\\log n)\\), making the time complexity of the element insertion operation \\(O(\\log n)\\). The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby my_heap.py<pre><code>def push(self, val: int):\n    \"\"\"Element enters heap\"\"\"\n    # Add node\n    self.max_heap.append(val)\n    # Heapify from bottom to top\n    self.sift_up(self.size() - 1)\n\ndef sift_up(self, i: int):\n    \"\"\"Starting from node i, heapify from bottom to top\"\"\"\n    while True:\n        # Get parent node of node i\n        p = self.parent(i)\n        # When \"crossing root node\" or \"node needs no repair\", end heapify\n        if p &lt; 0 or self.max_heap[i] &lt;= self.max_heap[p]:\n            break\n        # Swap two nodes\n        self.swap(i, p)\n        # Loop upward heapify\n        i = p\n</code></pre> my_heap.cpp<pre><code>/* Element enters heap */\nvoid push(int val) {\n    // Add node\n    maxHeap.push_back(val);\n    // Heapify from bottom to top\n    siftUp(size() - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\nvoid siftUp(int i) {\n    while (true) {\n        // Get parent node of node i\n        int p = parent(i);\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p])\n            break;\n        // Swap two nodes\n        swap(maxHeap[i], maxHeap[p]);\n        // Loop upward heapify\n        i = p;\n    }\n}\n</code></pre> my_heap.java<pre><code>/* Element enters heap */\nvoid push(int val) {\n    // Add node\n    maxHeap.add(val);\n    // Heapify from bottom to top\n    siftUp(size() - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\nvoid siftUp(int i) {\n    while (true) {\n        // Get parent node of node i\n        int p = parent(i);\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if (p &lt; 0 || maxHeap.get(i) &lt;= maxHeap.get(p))\n            break;\n        // Swap two nodes\n        swap(i, p);\n        // Loop upward heapify\n        i = p;\n    }\n}\n</code></pre> my_heap.cs<pre><code>/* Element enters heap */\nvoid Push(int val) {\n    // Add node\n    maxHeap.Add(val);\n    // Heapify from bottom to top\n    SiftUp(Size() - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\nvoid SiftUp(int i) {\n    while (true) {\n        // Get parent node of node i\n        int p = Parent(i);\n        // If 'past root node' or 'node needs no repair', end heapify\n        if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p])\n            break;\n        // Swap two nodes\n        Swap(i, p);\n        // Loop upward heapify\n        i = p;\n    }\n}\n</code></pre> my_heap.go<pre><code>/* Element enters heap */\nfunc (h *maxHeap) push(val any) {\n    // Add node\n    h.data = append(h.data, val)\n    // Heapify from bottom to top\n    h.siftUp(len(h.data) - 1)\n}\n\n/* Starting from node i, heapify from bottom to top */\nfunc (h *maxHeap) siftUp(i int) {\n    for true {\n        // Get parent node of node i\n        p := h.parent(i)\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if p &lt; 0 || h.data[i].(int) &lt;= h.data[p].(int) {\n            break\n        }\n        // Swap two nodes\n        h.swap(i, p)\n        // Loop upward heapify\n        i = p\n    }\n}\n</code></pre> my_heap.swift<pre><code>/* Element enters heap */\nfunc push(val: Int) {\n    // Add node\n    maxHeap.append(val)\n    // Heapify from bottom to top\n    siftUp(i: size() - 1)\n}\n\n/* Starting from node i, heapify from bottom to top */\nfunc siftUp(i: Int) {\n    var i = i\n    while true {\n        // Get parent node of node i\n        let p = parent(i: i)\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if p &lt; 0 || maxHeap[i] &lt;= maxHeap[p] {\n            break\n        }\n        // Swap two nodes\n        swap(i: i, j: p)\n        // Loop upward heapify\n        i = p\n    }\n}\n</code></pre> my_heap.js<pre><code>/* Element enters heap */\npush(val) {\n    // Add node\n    this.#maxHeap.push(val);\n    // Heapify from bottom to top\n    this.#siftUp(this.size() - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\n#siftUp(i) {\n    while (true) {\n        // Get parent node of node i\n        const p = this.#parent(i);\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if (p &lt; 0 || this.#maxHeap[i] &lt;= this.#maxHeap[p]) break;\n        // Swap two nodes\n        this.#swap(i, p);\n        // Loop upward heapify\n        i = p;\n    }\n}\n</code></pre> my_heap.ts<pre><code>/* Element enters heap */\npush(val: number): void {\n    // Add node\n    this.maxHeap.push(val);\n    // Heapify from bottom to top\n    this.siftUp(this.size() - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\nsiftUp(i: number): void {\n    while (true) {\n        // Get parent node of node i\n        const p = this.parent(i);\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if (p &lt; 0 || this.maxHeap[i] &lt;= this.maxHeap[p]) break;\n        // Swap two nodes\n        this.swap(i, p);\n        // Loop upward heapify\n        i = p;\n    }\n}\n</code></pre> my_heap.dart<pre><code>/* Element enters heap */\nvoid push(int val) {\n  // Add node\n  _maxHeap.add(val);\n  // Heapify from bottom to top\n  siftUp(size() - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\nvoid siftUp(int i) {\n  while (true) {\n    // Get parent node of node i\n    int p = _parent(i);\n    // When \"crossing root node\" or \"node needs no repair\", end heapify\n    if (p &lt; 0 || _maxHeap[i] &lt;= _maxHeap[p]) {\n      break;\n    }\n    // Swap two nodes\n    _swap(i, p);\n    // Loop upward heapify\n    i = p;\n  }\n}\n</code></pre> my_heap.rs<pre><code>/* Element enters heap */\nfn push(&amp;mut self, val: i32) {\n    // Add node\n    self.max_heap.push(val);\n    // Heapify from bottom to top\n    self.sift_up(self.size() - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\nfn sift_up(&amp;mut self, mut i: usize) {\n    loop {\n        // Node i is already the heap root, end heapification\n        if i == 0 {\n            break;\n        }\n        // Get parent node of node i\n        let p = Self::parent(i);\n        // When \"node needs no repair\", end heapification\n        if self.max_heap[i] &lt;= self.max_heap[p] {\n            break;\n        }\n        // Swap two nodes\n        self.swap(i, p);\n        // Loop upward heapify\n        i = p;\n    }\n}\n</code></pre> my_heap.c<pre><code>/* Element enters heap */\nvoid push(MaxHeap *maxHeap, int val) {\n    // By default, should not add this many nodes\n    if (maxHeap-&gt;size == MAX_SIZE) {\n        printf(\"heap is full!\");\n        return;\n    }\n    // Add node\n    maxHeap-&gt;data[maxHeap-&gt;size] = val;\n    maxHeap-&gt;size++;\n\n    // Heapify from bottom to top\n    siftUp(maxHeap, maxHeap-&gt;size - 1);\n}\n\n/* Starting from node i, heapify from bottom to top */\nvoid siftUp(MaxHeap *maxHeap, int i) {\n    while (true) {\n        // Get parent node of node i\n        int p = parent(maxHeap, i);\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if (p &lt; 0 || maxHeap-&gt;data[i] &lt;= maxHeap-&gt;data[p]) {\n            break;\n        }\n        // Swap two nodes\n        swap(maxHeap, i, p);\n        // Loop upward heapify\n        i = p;\n    }\n}\n</code></pre> my_heap.kt<pre><code>/* Element enters heap */\nfun push(_val: Int) {\n    // Add node\n    maxHeap.add(_val)\n    // Heapify from bottom to top\n    siftUp(size() - 1)\n}\n\n/* Starting from node i, heapify from bottom to top */\nfun siftUp(it: Int) {\n    // Kotlin function parameters are immutable, so create temporary variable\n    var i = it\n    while (true) {\n        // Get parent node of node i\n        val p = parent(i)\n        // When \"crossing root node\" or \"node needs no repair\", end heapify\n        if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p]) break\n        // Swap two nodes\n        swap(i, p)\n        // Loop upward heapify\n        i = p\n    }\n}\n</code></pre> my_heap.rb<pre><code>### Push element to heap ###\ndef push(val)\n  # Add node\n  @max_heap &lt;&lt; val\n  # Heapify from bottom to top\n  sift_up(size - 1)\nend\n\n### Heapify from node i, bottom to top ###\ndef sift_up(i)\n  loop do\n    # Get parent node of node i\n    p = parent(i)\n    # When \"crossing root node\" or \"node needs no repair\", end heapify\n    break if p &lt; 0 || @max_heap[i] &lt;= @max_heap[p]\n    # Swap two nodes\n    swap(i, p)\n    # Loop upward heapify\n    i = p\n  end\nend\n</code></pre>"},{"location":"chapter_heap/heap/#4-removing-the-heap-top-element","title":"4. \u00a0 Removing the Heap Top Element","text":"<p>The heap top element is the root node of the binary tree, which is the first element of the list. If we directly remove the first element from the list, all node indexes in the binary tree would change, making subsequent repair with heapify difficult. To minimize changes in element indexes, we use the following steps.</p> <ol> <li>Swap the heap top element with the heap bottom element (swap the root node with the rightmost leaf node).</li> <li>After swapping, remove the heap bottom from the list (note that since we've swapped, we're actually removing the original heap top element).</li> <li>Starting from the root node, perform heapify from top to bottom.</li> </ol> <p>As shown in Figure 8-4, the direction of \"top-to-bottom heapify\" is opposite to \"bottom-to-top heapify\". We compare the root node's value with its two children and swap it with the largest child. Then loop this operation until we pass a leaf node or encounter a node that doesn't need swapping.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 8-4 \u00a0 Steps of removing the heap top element </p> <p>Similar to the element insertion operation, the time complexity of the heap top element removal operation is also \\(O(\\log n)\\). The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby my_heap.py<pre><code>def pop(self) -&gt; int:\n    \"\"\"Element exits heap\"\"\"\n    # Handle empty case\n    if self.is_empty():\n        raise IndexError(\"Heap is empty\")\n    # Swap root node with rightmost leaf node (swap first element with last element)\n    self.swap(0, self.size() - 1)\n    # Delete node\n    val = self.max_heap.pop()\n    # Heapify from top to bottom\n    self.sift_down(0)\n    # Return top element\n    return val\n\ndef sift_down(self, i: int):\n    \"\"\"Starting from node i, heapify from top to bottom\"\"\"\n    while True:\n        # Find node with largest value among i, l, r, denoted as ma\n        l, r, ma = self.left(i), self.right(i), i\n        if l &lt; self.size() and self.max_heap[l] &gt; self.max_heap[ma]:\n            ma = l\n        if r &lt; self.size() and self.max_heap[r] &gt; self.max_heap[ma]:\n            ma = r\n        # If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        if ma == i:\n            break\n        # Swap two nodes\n        self.swap(i, ma)\n        # Loop downward heapify\n        i = ma\n</code></pre> my_heap.cpp<pre><code>/* Element exits heap */\nvoid pop() {\n    // Handle empty case\n    if (isEmpty()) {\n        throw out_of_range(\"Heap is empty\");\n    }\n    // Delete node\n    swap(maxHeap[0], maxHeap[size() - 1]);\n    // Remove node\n    maxHeap.pop_back();\n    // Return top element\n    siftDown(0);\n}\n\n/* Starting from node i, heapify from top to bottom */\nvoid siftDown(int i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        int l = left(i), r = right(i), ma = i;\n        if (l &lt; size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma])\n            ma = l;\n        if (r &lt; size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma])\n            ma = r;\n        // Swap two nodes\n        if (ma == i)\n            break;\n        swap(maxHeap[i], maxHeap[ma]);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n</code></pre> my_heap.java<pre><code>/* Element exits heap */\nint pop() {\n    // Handle empty case\n    if (isEmpty())\n        throw new IndexOutOfBoundsException();\n    // Delete node\n    swap(0, size() - 1);\n    // Remove node\n    int val = maxHeap.remove(size() - 1);\n    // Return top element\n    siftDown(0);\n    // Return heap top element\n    return val;\n}\n\n/* Starting from node i, heapify from top to bottom */\nvoid siftDown(int i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        int l = left(i), r = right(i), ma = i;\n        if (l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(ma))\n            ma = l;\n        if (r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(ma))\n            ma = r;\n        // Swap two nodes\n        if (ma == i)\n            break;\n        // Swap two nodes\n        swap(i, ma);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n</code></pre> my_heap.cs<pre><code>/* Element exits heap */\nint Pop() {\n    // Handle empty case\n    if (IsEmpty())\n        throw new IndexOutOfRangeException();\n    // Delete node\n    Swap(0, Size() - 1);\n    // Remove node\n    int val = maxHeap.Last();\n    maxHeap.RemoveAt(Size() - 1);\n    // Return top element\n    SiftDown(0);\n    // Return heap top element\n    return val;\n}\n\n/* Starting from node i, heapify from top to bottom */\nvoid SiftDown(int i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        int l = Left(i), r = Right(i), ma = i;\n        if (l &lt; Size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma])\n            ma = l;\n        if (r &lt; Size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma])\n            ma = r;\n        // If 'node i is largest' or 'past leaf node', end heapify\n        if (ma == i) break;\n        // Swap two nodes\n        Swap(i, ma);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n</code></pre> my_heap.go<pre><code>/* Element exits heap */\nfunc (h *maxHeap) pop() any {\n    // Handle empty case\n    if h.isEmpty() {\n        fmt.Println(\"error\")\n        return nil\n    }\n    // Delete node\n    h.swap(0, h.size()-1)\n    // Remove node\n    val := h.data[len(h.data)-1]\n    h.data = h.data[:len(h.data)-1]\n    // Return top element\n    h.siftDown(0)\n\n    // Return heap top element\n    return val\n}\n\n/* Starting from node i, heapify from top to bottom */\nfunc (h *maxHeap) siftDown(i int) {\n    for true {\n        // Find node with maximum value among nodes i, l, r, denoted as max\n        l, r, max := h.left(i), h.right(i), i\n        if l &lt; h.size() &amp;&amp; h.data[l].(int) &gt; h.data[max].(int) {\n            max = l\n        }\n        if r &lt; h.size() &amp;&amp; h.data[r].(int) &gt; h.data[max].(int) {\n            max = r\n        }\n        // Swap two nodes\n        if max == i {\n            break\n        }\n        // Swap two nodes\n        h.swap(i, max)\n        // Loop downwards heapification\n        i = max\n    }\n}\n</code></pre> my_heap.swift<pre><code>/* Element exits heap */\nfunc pop() -&gt; Int {\n    // Handle empty case\n    if isEmpty() {\n        fatalError(\"Heap is empty\")\n    }\n    // Delete node\n    swap(i: 0, j: size() - 1)\n    // Remove node\n    let val = maxHeap.remove(at: size() - 1)\n    // Return top element\n    siftDown(i: 0)\n    // Return heap top element\n    return val\n}\n\n/* Starting from node i, heapify from top to bottom */\nfunc siftDown(i: Int) {\n    var i = i\n    while true {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        let l = left(i: i)\n        let r = right(i: i)\n        var ma = i\n        if l &lt; size(), maxHeap[l] &gt; maxHeap[ma] {\n            ma = l\n        }\n        if r &lt; size(), maxHeap[r] &gt; maxHeap[ma] {\n            ma = r\n        }\n        // Swap two nodes\n        if ma == i {\n            break\n        }\n        // Swap two nodes\n        swap(i: i, j: ma)\n        // Loop downwards heapification\n        i = ma\n    }\n}\n</code></pre> my_heap.js<pre><code>/* Element exits heap */\npop() {\n    // Handle empty case\n    if (this.isEmpty()) throw new Error('Heap is empty');\n    // Delete node\n    this.#swap(0, this.size() - 1);\n    // Remove node\n    const val = this.#maxHeap.pop();\n    // Return top element\n    this.#siftDown(0);\n    // Return heap top element\n    return val;\n}\n\n/* Starting from node i, heapify from top to bottom */\n#siftDown(i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        const l = this.#left(i),\n            r = this.#right(i);\n        let ma = i;\n        if (l &lt; this.size() &amp;&amp; this.#maxHeap[l] &gt; this.#maxHeap[ma]) ma = l;\n        if (r &lt; this.size() &amp;&amp; this.#maxHeap[r] &gt; this.#maxHeap[ma]) ma = r;\n        // Swap two nodes\n        if (ma === i) break;\n        // Swap two nodes\n        this.#swap(i, ma);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n</code></pre> my_heap.ts<pre><code>/* Element exits heap */\npop(): number {\n    // Handle empty case\n    if (this.isEmpty()) throw new RangeError('Heap is empty.');\n    // Delete node\n    this.swap(0, this.size() - 1);\n    // Remove node\n    const val = this.maxHeap.pop();\n    // Return top element\n    this.siftDown(0);\n    // Return heap top element\n    return val;\n}\n\n/* Starting from node i, heapify from top to bottom */\nsiftDown(i: number): void {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        const l = this.left(i),\n            r = this.right(i);\n        let ma = i;\n        if (l &lt; this.size() &amp;&amp; this.maxHeap[l] &gt; this.maxHeap[ma]) ma = l;\n        if (r &lt; this.size() &amp;&amp; this.maxHeap[r] &gt; this.maxHeap[ma]) ma = r;\n        // Swap two nodes\n        if (ma === i) break;\n        // Swap two nodes\n        this.swap(i, ma);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n</code></pre> my_heap.dart<pre><code>/* Element exits heap */\nint pop() {\n  // Handle empty case\n  if (isEmpty()) throw Exception('Heap is empty');\n  // Delete node\n  _swap(0, size() - 1);\n  // Remove node\n  int val = _maxHeap.removeLast();\n  // Return top element\n  siftDown(0);\n  // Return heap top element\n  return val;\n}\n\n/* Starting from node i, heapify from top to bottom */\nvoid siftDown(int i) {\n  while (true) {\n    // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n    int l = _left(i);\n    int r = _right(i);\n    int ma = i;\n    if (l &lt; size() &amp;&amp; _maxHeap[l] &gt; _maxHeap[ma]) ma = l;\n    if (r &lt; size() &amp;&amp; _maxHeap[r] &gt; _maxHeap[ma]) ma = r;\n    // Swap two nodes\n    if (ma == i) break;\n    // Swap two nodes\n    _swap(i, ma);\n    // Loop downwards heapification\n    i = ma;\n  }\n}\n</code></pre> my_heap.rs<pre><code>/* Element exits heap */\nfn pop(&amp;mut self) -&gt; i32 {\n    // Handle empty case\n    if self.is_empty() {\n        panic!(\"index out of bounds\");\n    }\n    // Delete node\n    self.swap(0, self.size() - 1);\n    // Remove node\n    let val = self.max_heap.pop().unwrap();\n    // Return top element\n    self.sift_down(0);\n    // Return heap top element\n    val\n}\n\n/* Starting from node i, heapify from top to bottom */\nfn sift_down(&amp;mut self, mut i: usize) {\n    loop {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        let (l, r, mut ma) = (Self::left(i), Self::right(i), i);\n        if l &lt; self.size() &amp;&amp; self.max_heap[l] &gt; self.max_heap[ma] {\n            ma = l;\n        }\n        if r &lt; self.size() &amp;&amp; self.max_heap[r] &gt; self.max_heap[ma] {\n            ma = r;\n        }\n        // Swap two nodes\n        if ma == i {\n            break;\n        }\n        // Swap two nodes\n        self.swap(i, ma);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n</code></pre> my_heap.c<pre><code>/* Element exits heap */\nint pop(MaxHeap *maxHeap) {\n    // Handle empty case\n    if (isEmpty(maxHeap)) {\n        printf(\"heap is empty!\");\n        return INT_MAX;\n    }\n    // Delete node\n    swap(maxHeap, 0, size(maxHeap) - 1);\n    // Remove node\n    int val = maxHeap-&gt;data[maxHeap-&gt;size - 1];\n    maxHeap-&gt;size--;\n    // Return top element\n    siftDown(maxHeap, 0);\n\n    // Return heap top element\n    return val;\n}\n\n/* Starting from node i, heapify from top to bottom */\nvoid siftDown(MaxHeap *maxHeap, int i) {\n    while (true) {\n        // Find node with maximum value among nodes i, l, r, denoted as max\n        int l = left(maxHeap, i);\n        int r = right(maxHeap, i);\n        int max = i;\n        if (l &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[l] &gt; maxHeap-&gt;data[max]) {\n            max = l;\n        }\n        if (r &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[r] &gt; maxHeap-&gt;data[max]) {\n            max = r;\n        }\n        // Swap two nodes\n        if (max == i) {\n            break;\n        }\n        // Swap two nodes\n        swap(maxHeap, i, max);\n        // Loop downwards heapification\n        i = max;\n    }\n}\n</code></pre> my_heap.kt<pre><code>/* Element exits heap */\nfun pop(): Int {\n    // Handle empty case\n    if (isEmpty()) throw IndexOutOfBoundsException()\n    // Delete node\n    swap(0, size() - 1)\n    // Remove node\n    val _val = maxHeap.removeAt(size() - 1)\n    // Return top element\n    siftDown(0)\n    // Return heap top element\n    return _val\n}\n\n/* Starting from node i, heapify from top to bottom */\nfun siftDown(it: Int) {\n    // Kotlin function parameters are immutable, so create temporary variable\n    var i = it\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        val l = left(i)\n        val r = right(i)\n        var ma = i\n        if (l &lt; size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma]) ma = l\n        if (r &lt; size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma]) ma = r\n        // Swap two nodes\n        if (ma == i) break\n        // Swap two nodes\n        swap(i, ma)\n        // Loop downwards heapification\n        i = ma\n    }\n}\n</code></pre> my_heap.rb<pre><code>### Pop element from heap ###\ndef pop\n  # Handle empty case\n  raise IndexError, \"Heap is empty\" if is_empty?\n  # Delete node\n  swap(0, size - 1)\n  # Remove node\n  val = @max_heap.pop\n  # Return top element\n  sift_down(0)\n  # Return heap top element\n  val\nend\n\n### Heapify from node i, top to bottom ###\ndef sift_down(i)\n  loop do\n    # If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n    l, r, ma = left(i), right(i), i\n    ma = l if l &lt; size &amp;&amp; @max_heap[l] &gt; @max_heap[ma]\n    ma = r if r &lt; size &amp;&amp; @max_heap[r] &gt; @max_heap[ma]\n\n    # Swap two nodes\n    break if ma == i\n\n    # Swap two nodes\n    swap(i, ma)\n    # Loop downwards heapification\n    i = ma\n  end\nend\n</code></pre>"},{"location":"chapter_heap/heap/#813-common-applications-of-heaps","title":"8.1.3 \u00a0 Common Applications of Heaps","text":"<ul> <li>Priority queue: Heaps are typically the preferred data structure for implementing priority queues, with both enqueue and dequeue operations having a time complexity of \\(O(\\log n)\\), and the heap construction operation having \\(O(n)\\), all of which are highly efficient.</li> <li>Heap sort: Given a set of data, we can build a heap with them and then continuously perform element removal operations to obtain sorted data. However, we usually use a more elegant approach to implement heap sort, as detailed in the \"Heap Sort\" chapter.</li> <li>Getting the largest \\(k\\) elements: This is a classic algorithm problem and also a typical application, such as selecting the top 10 trending news for Weibo hot search, selecting the top 10 best-selling products, etc.</li> </ul>"},{"location":"chapter_heap/summary/","title":"8.4 \u00a0 Summary","text":""},{"location":"chapter_heap/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>A heap is a complete binary tree that can be categorized as a max heap or min heap based on its property. The heap top element of a max heap (min heap) is the largest (smallest).</li> <li>A priority queue is defined as a queue with priority sorting, typically implemented using heaps.</li> <li>Common heap operations and their corresponding time complexities include: element insertion \\(O(\\log n)\\), heap top element removal \\(O(\\log n)\\), and accessing the heap top element \\(O(1)\\).</li> <li>Complete binary trees are well-suited for array representation, so we typically use arrays to store heaps.</li> <li>Heapify operations are used to maintain the heap property and are employed in both element insertion and removal operations.</li> <li>The time complexity of building a heap with \\(n\\) input elements can be optimized to \\(O(n)\\), which is highly efficient.</li> <li>Top-k is a classic algorithm problem that can be efficiently solved using the heap data structure, with a time complexity of \\(O(n \\log k)\\).</li> </ul>"},{"location":"chapter_heap/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Are the \"heap\" in data structures and the \"heap\" in memory management the same concept?</p> <p>The two are not the same concept; they just happen to share the name \"heap.\" The heap in computer system memory is part of dynamic memory allocation, where programs can use it to store data during runtime. Programs can request a certain amount of heap memory to store complex structures such as objects and arrays. When this data is no longer needed, the program needs to release this memory to prevent memory leaks. Compared to stack memory, heap memory management and usage require more caution, as improper use can lead to issues such as memory leaks and dangling pointers.</p>"},{"location":"chapter_heap/top_k/","title":"8.3 \u00a0 Top-K Problem","text":"<p>Question</p> <p>Given an unordered array <code>nums</code> of length \\(n\\), return the largest \\(k\\) elements in the array.</p> <p>For this problem, we'll first introduce two solutions with relatively straightforward approaches, then introduce a more efficient heap-based solution.</p>"},{"location":"chapter_heap/top_k/#831-method-1-iterative-selection","title":"8.3.1 \u00a0 Method 1: Iterative Selection","text":"<p>We can perform \\(k\\) rounds of traversal as shown in Figure 8-6, extracting the \\(1^{st}\\), \\(2^{nd}\\), \\(\\dots\\), \\(k^{th}\\) largest elements in each round, with a time complexity of \\(O(nk)\\).</p> <p>This method is only suitable when \\(k \\ll n\\), because when \\(k\\) is close to \\(n\\), the time complexity approaches \\(O(n^2)\\), which is very time-consuming.</p> <p></p> <p> Figure 8-6 \u00a0 Traversing to find the largest k elements </p> <p>Tip</p> <p>When \\(k = n\\), we can obtain a complete sorted sequence, which is equivalent to the \"selection sort\" algorithm.</p>"},{"location":"chapter_heap/top_k/#832-method-2-sorting","title":"8.3.2 \u00a0 Method 2: Sorting","text":"<p>As shown in Figure 8-7, we can first sort the array <code>nums</code>, then return the rightmost \\(k\\) elements, with a time complexity of \\(O(n \\log n)\\).</p> <p>Clearly, this method \"overachieves\" the task, as we only need to find the largest \\(k\\) elements, without needing to sort the other elements.</p> <p></p> <p> Figure 8-7 \u00a0 Sorting to find the largest k elements </p>"},{"location":"chapter_heap/top_k/#833-method-3-heap","title":"8.3.3 \u00a0 Method 3: Heap","text":"<p>We can solve the Top-k problem more efficiently using heaps, with the process shown in Figure 8-8.</p> <ol> <li>Initialize a min heap, where the heap top element is the smallest.</li> <li>First, insert the first \\(k\\) elements of the array into the heap in sequence.</li> <li>Starting from the \\((k + 1)^{th}\\) element, if the current element is greater than the heap top element, remove the heap top element and insert the current element into the heap.</li> <li>After traversal is complete, the heap contains the largest \\(k\\) elements.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 8-8 \u00a0 Finding the largest k elements using a heap </p> <p>Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby top_k.py<pre><code>def top_k_heap(nums: list[int], k: int) -&gt; list[int]:\n    \"\"\"Find the largest k elements in array based on heap\"\"\"\n    # Initialize min heap\n    heap = []\n    # Enter the first k elements of array into heap\n    for i in range(k):\n        heapq.heappush(heap, nums[i])\n    # Starting from the (k+1)th element, maintain heap length as k\n    for i in range(k, len(nums)):\n        # If current element is greater than top element, top element exits heap, current element enters heap\n        if nums[i] &gt; heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, nums[i])\n    return heap\n</code></pre> top_k.cpp<pre><code>/* Find the largest k elements in array based on heap */\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; topKHeap(vector&lt;int&gt; &amp;nums, int k) {\n    // Python's heapq module implements min heap by default\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\n    // Enter the first k elements of array into heap\n    for (int i = 0; i &lt; k; i++) {\n        heap.push(nums[i]);\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for (int i = k; i &lt; nums.size(); i++) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if (nums[i] &gt; heap.top()) {\n            heap.pop();\n            heap.push(nums[i]);\n        }\n    }\n    return heap;\n}\n</code></pre> top_k.java<pre><code>/* Find the largest k elements in array based on heap */\nQueue&lt;Integer&gt; topKHeap(int[] nums, int k) {\n    // Python's heapq module implements min heap by default\n    Queue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;();\n    // Enter the first k elements of array into heap\n    for (int i = 0; i &lt; k; i++) {\n        heap.offer(nums[i]);\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for (int i = k; i &lt; nums.length; i++) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if (nums[i] &gt; heap.peek()) {\n            heap.poll();\n            heap.offer(nums[i]);\n        }\n    }\n    return heap;\n}\n</code></pre> top_k.cs<pre><code>/* Find the largest k elements in array based on heap */\nPriorityQueue&lt;int, int&gt; TopKHeap(int[] nums, int k) {\n    // Python's heapq module implements min heap by default\n    PriorityQueue&lt;int, int&gt; heap = new();\n    // Enter the first k elements of array into heap\n    for (int i = 0; i &lt; k; i++) {\n        heap.Enqueue(nums[i], nums[i]);\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for (int i = k; i &lt; nums.Length; i++) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if (nums[i] &gt; heap.Peek()) {\n            heap.Dequeue();\n            heap.Enqueue(nums[i], nums[i]);\n        }\n    }\n    return heap;\n}\n</code></pre> top_k.go<pre><code>/* Find the largest k elements in array based on heap */\nfunc topKHeap(nums []int, k int) *minHeap {\n    // Python's heapq module implements min heap by default\n    h := &amp;minHeap{}\n    heap.Init(h)\n    // Enter the first k elements of array into heap\n    for i := 0; i &lt; k; i++ {\n        heap.Push(h, nums[i])\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for i := k; i &lt; len(nums); i++ {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if nums[i] &gt; h.Top().(int) {\n            heap.Pop(h)\n            heap.Push(h, nums[i])\n        }\n    }\n    return h\n}\n</code></pre> top_k.swift<pre><code>/* Find the largest k elements in array based on heap */\nfunc topKHeap(nums: [Int], k: Int) -&gt; [Int] {\n    // Initialize min heap and build heap with first k elements\n    var heap = Heap(nums.prefix(k))\n    // Starting from the (k+1)th element, maintain heap length as k\n    for i in nums.indices.dropFirst(k) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if nums[i] &gt; heap.min()! {\n            _ = heap.removeMin()\n            heap.insert(nums[i])\n        }\n    }\n    return heap.unordered\n}\n</code></pre> top_k.js<pre><code>/* Element enters heap */\nfunction pushMinHeap(maxHeap, val) {\n    // Negate element\n    maxHeap.push(-val);\n}\n\n/* Element exits heap */\nfunction popMinHeap(maxHeap) {\n    // Negate element\n    return -maxHeap.pop();\n}\n\n/* Access top element */\nfunction peekMinHeap(maxHeap) {\n    // Negate element\n    return -maxHeap.peek();\n}\n\n/* Extract elements from heap */\nfunction getMinHeap(maxHeap) {\n    // Negate element\n    return maxHeap.getMaxHeap().map((num) =&gt; -num);\n}\n\n/* Find the largest k elements in array based on heap */\nfunction topKHeap(nums, k) {\n    // Python's heapq module implements min heap by default\n    // Note: We negate all heap elements to simulate min heap using max heap\n    const maxHeap = new MaxHeap([]);\n    // Enter the first k elements of array into heap\n    for (let i = 0; i &lt; k; i++) {\n        pushMinHeap(maxHeap, nums[i]);\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for (let i = k; i &lt; nums.length; i++) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if (nums[i] &gt; peekMinHeap(maxHeap)) {\n            popMinHeap(maxHeap);\n            pushMinHeap(maxHeap, nums[i]);\n        }\n    }\n    // Return elements in heap\n    return getMinHeap(maxHeap);\n}\n</code></pre> top_k.ts<pre><code>/* Element enters heap */\nfunction pushMinHeap(maxHeap: MaxHeap, val: number): void {\n    // Negate element\n    maxHeap.push(-val);\n}\n\n/* Element exits heap */\nfunction popMinHeap(maxHeap: MaxHeap): number {\n    // Negate element\n    return -maxHeap.pop();\n}\n\n/* Access top element */\nfunction peekMinHeap(maxHeap: MaxHeap): number {\n    // Negate element\n    return -maxHeap.peek();\n}\n\n/* Extract elements from heap */\nfunction getMinHeap(maxHeap: MaxHeap): number[] {\n    // Negate element\n    return maxHeap.getMaxHeap().map((num: number) =&gt; -num);\n}\n\n/* Find the largest k elements in array based on heap */\nfunction topKHeap(nums: number[], k: number): number[] {\n    // Python's heapq module implements min heap by default\n    // Note: We negate all heap elements to simulate min heap using max heap\n    const maxHeap = new MaxHeap([]);\n    // Enter the first k elements of array into heap\n    for (let i = 0; i &lt; k; i++) {\n        pushMinHeap(maxHeap, nums[i]);\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for (let i = k; i &lt; nums.length; i++) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if (nums[i] &gt; peekMinHeap(maxHeap)) {\n            popMinHeap(maxHeap);\n            pushMinHeap(maxHeap, nums[i]);\n        }\n    }\n    // Return elements in heap\n    return getMinHeap(maxHeap);\n}\n</code></pre> top_k.dart<pre><code>/* Find the largest k elements in array based on heap */\nMinHeap topKHeap(List&lt;int&gt; nums, int k) {\n  // Initialize min heap, push first k elements of array to heap\n  MinHeap heap = MinHeap(nums.sublist(0, k));\n  // Starting from the (k+1)th element, maintain heap length as k\n  for (int i = k; i &lt; nums.length; i++) {\n    // If current element is greater than top element, top element exits heap, current element enters heap\n    if (nums[i] &gt; heap.peek()) {\n      heap.pop();\n      heap.push(nums[i]);\n    }\n  }\n  return heap;\n}\n</code></pre> top_k.rs<pre><code>/* Find the largest k elements in array based on heap */\nfn top_k_heap(nums: Vec&lt;i32&gt;, k: usize) -&gt; BinaryHeap&lt;Reverse&lt;i32&gt;&gt; {\n    // BinaryHeap is a max heap, use Reverse to negate elements to implement min heap\n    let mut heap = BinaryHeap::&lt;Reverse&lt;i32&gt;&gt;::new();\n    // Enter the first k elements of array into heap\n    for &amp;num in nums.iter().take(k) {\n        heap.push(Reverse(num));\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for &amp;num in nums.iter().skip(k) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if num &gt; heap.peek().unwrap().0 {\n            heap.pop();\n            heap.push(Reverse(num));\n        }\n    }\n    heap\n}\n</code></pre> top_k.c<pre><code>/* Element enters heap */\nvoid pushMinHeap(MaxHeap *maxHeap, int val) {\n    // Negate element\n    push(maxHeap, -val);\n}\n\n/* Element exits heap */\nint popMinHeap(MaxHeap *maxHeap) {\n    // Negate element\n    return -pop(maxHeap);\n}\n\n/* Access top element */\nint peekMinHeap(MaxHeap *maxHeap) {\n    // Negate element\n    return -peek(maxHeap);\n}\n\n/* Extract elements from heap */\nint *getMinHeap(MaxHeap *maxHeap) {\n    // Negate all heap elements and store in res array\n    int *res = (int *)malloc(maxHeap-&gt;size * sizeof(int));\n    for (int i = 0; i &lt; maxHeap-&gt;size; i++) {\n        res[i] = -maxHeap-&gt;data[i];\n    }\n    return res;\n}\n\n/* Extract elements from heap */\nint *getMinHeap(MaxHeap *maxHeap) {\n    // Negate all heap elements and store in res array\n    int *res = (int *)malloc(maxHeap-&gt;size * sizeof(int));\n    for (int i = 0; i &lt; maxHeap-&gt;size; i++) {\n        res[i] = -maxHeap-&gt;data[i];\n    }\n    return res;\n}\n\n// Function to find k largest elements in array using heap\nint *topKHeap(int *nums, int sizeNums, int k) {\n    // Python's heapq module implements min heap by default\n    // Note: We negate all heap elements to simulate min heap using max heap\n    int *empty = (int *)malloc(0);\n    MaxHeap *maxHeap = newMaxHeap(empty, 0);\n    // Enter the first k elements of array into heap\n    for (int i = 0; i &lt; k; i++) {\n        pushMinHeap(maxHeap, nums[i]);\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for (int i = k; i &lt; sizeNums; i++) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if (nums[i] &gt; peekMinHeap(maxHeap)) {\n            popMinHeap(maxHeap);\n            pushMinHeap(maxHeap, nums[i]);\n        }\n    }\n    int *res = getMinHeap(maxHeap);\n    // Free memory\n    delMaxHeap(maxHeap);\n    return res;\n}\n</code></pre> top_k.kt<pre><code>/* Find the largest k elements in array based on heap */\nfun topKHeap(nums: IntArray, k: Int): Queue&lt;Int&gt; {\n    // Python's heapq module implements min heap by default\n    val heap = PriorityQueue&lt;Int&gt;()\n    // Enter the first k elements of array into heap\n    for (i in 0..&lt;k) {\n        heap.offer(nums[i])\n    }\n    // Starting from the (k+1)th element, maintain heap length as k\n    for (i in k..&lt;nums.size) {\n        // If current element is greater than top element, top element exits heap, current element enters heap\n        if (nums[i] &gt; heap.peek()) {\n            heap.poll()\n            heap.offer(nums[i])\n        }\n    }\n    return heap\n}\n</code></pre> top_k.rb<pre><code>### Find largest k elements in array using heap ###\ndef top_k_heap(nums, k)\n  # Python's heapq module implements min heap by default\n  # Note: We negate all heap elements to simulate min heap using max heap\n  max_heap = MaxHeap.new([])\n\n  # Enter the first k elements of array into heap\n  for i in 0...k\n    push_min_heap(max_heap, nums[i])\n  end\n\n  # Starting from the (k+1)th element, maintain heap length as k\n  for i in k...nums.length\n    # If current element is greater than top element, top element exits heap, current element enters heap\n    if nums[i] &gt; peek_min_heap(max_heap)\n      pop_min_heap(max_heap)\n      push_min_heap(max_heap, nums[i])\n    end\n  end\n\n  get_min_heap(max_heap)\nend\n</code></pre> <p>A total of \\(n\\) rounds of heap insertions and removals are performed, with the heap's maximum length being \\(k\\), so the time complexity is \\(O(n \\log k)\\). This method is very efficient; when \\(k\\) is small, the time complexity approaches \\(O(n)\\); when \\(k\\) is large, the time complexity does not exceed \\(O(n \\log n)\\).</p> <p>Additionally, this method is suitable for dynamic data stream scenarios. By continuously adding data, we can maintain the elements in the heap, thus achieving dynamic updates of the largest \\(k\\) elements.</p>"},{"location":"chapter_hello_algo/","title":"Before Starting","text":"<p>A few years ago, I shared the \"Sword for Offer\" problem solutions on LeetCode, receiving encouragement and support from many readers. During interactions with readers, the most frequently asked question I encountered was \"how to get started with algorithms.\" Gradually, I developed a keen interest in this question.</p> <p>Diving straight into problem-solving seems to be the most popular approach\u2014it's simple, direct, and effective. However, problem-solving is like playing Minesweeper: those with strong self-learning abilities can successfully defuse the mines one by one, while those with insufficient foundations may end up bruised and battered, retreating step by step in frustration. Reading through textbooks is also a common practice, but for job seekers, graduation theses, resume submissions, and preparations for written tests and interviews have already consumed most of their energy, making working through thick books an arduous challenge.</p> <p>If you're facing similar struggles, then it's fortunate that this book has \"found\" you. This book is my answer to this question\u2014even if it may not be the optimal solution, it is at least a positive attempt. While this book alone won't directly land you a job offer, it will guide you to explore the \"knowledge map\" of data structures and algorithms, help you understand the shapes, sizes, and distributions of different \"mines,\" and enable you to master various \"mine-clearing methods.\" With these skills, I believe you can tackle problems and read technical literature more confidently, gradually building a complete knowledge system.</p> <p>I deeply agree with Professor Feynman's words: \"Knowledge isn't free. You have to pay attention.\" In this sense, this book is not entirely \"free.\" In order to live up to the precious \"attention\" you invest in this book, I will do my utmost and devote my greatest \"attention\" to completing this work.</p> <p>I'm acutely aware of my limited knowledge and shallow expertise. Although the content of this book has been refined over a period of time, there are certainly still many errors, and I sincerely welcome critiques and corrections from teachers and fellow students.</p> <p></p> Hello, Algorithms! <p>The advent of computers has brought tremendous changes to the world. With their high-speed computing capabilities and excellent programmability, they have become the ideal medium for executing algorithms and processing data. Whether it's the realistic graphics in video games, the intelligent decision-making in autonomous driving, AlphaGo's brilliant Go matches, or ChatGPT's natural interactions, these applications are all exquisite interpretations of algorithms on computers.</p> <p>In fact, before the advent of computers, algorithms and data structures already existed in every corner of the world. Early algorithms were relatively simple, such as ancient counting methods and tool-making procedures. As civilization progressed, algorithms gradually became more refined and complex. From the ingenious craftsmanship of master artisans, to industrial products that liberate productive forces, to the scientific laws governing the operation of the universe, behind almost every ordinary or astonishing thing lies ingenious algorithmic thinking.</p> <p>Similarly, data structures are everywhere: from large-scale social networks to small subway systems, many systems can be modeled as \"graphs\"; from a nation to a family, the primary organizational forms of society exhibit characteristics of \"trees\"; winter clothing is like a \"stack,\" where the first item put on is the last to be taken off; a badminton tube is like a \"queue,\" with items inserted at one end and retrieved from the other; a dictionary is like a \"hash table,\" enabling quick lookup of target entries.</p> <p>This book aims to help readers understand the core concepts of algorithms and data structures through clear and accessible animated illustrations and runnable code examples, and to implement them through programming. Building on this foundation, the book endeavors to reveal the vivid manifestations of algorithms in the complex world and showcase the beauty of algorithms. I hope this book can be of help to you!</p>"},{"location":"chapter_introduction/","title":"Chapter 1. \u00a0 Encounter with Algorithms","text":"<p>Abstract</p> <p>A young girl dances gracefully, intertwined with data, her skirt flowing with the melody of algorithms.</p> <p>She invites you to dance with her. Follow her steps closely and enter the world of algorithms, full of logic and beauty.</p>"},{"location":"chapter_introduction/#chapter-contents","title":"Chapter contents","text":"<ul> <li>1.1 \u00a0 Algorithms Are Everywhere</li> <li>1.2 \u00a0 What Is an Algorithm</li> <li>1.3 \u00a0 Summary</li> </ul>"},{"location":"chapter_introduction/algorithms_are_everywhere/","title":"1.1 \u00a0 Algorithms Are Everywhere","text":"<p>When we hear the term \"algorithm,\" we naturally think of mathematics. However, many algorithms do not involve complex mathematics but rely more on basic logic, which can be seen everywhere in our daily lives.</p> <p>Before we start discussing about algorithms officially, there's an interesting fact worth sharing: you've learned many algorithms unconsciously and are used to applying them in your daily life. Here, I will give a few specific examples to prove this point.</p> <p>Example 1: Looking Up a Dictionary. In an English dictionary, words are listed alphabetically. Assuming we're searching for a word that starts with the letter \\(r\\), this is typically done in the following way:</p> <ol> <li>Open the dictionary to about halfway and check the first vocabulary of the page, let's say the letter starts with \\(m\\).</li> <li>Since \\(r\\) comes after \\(m\\) in the alphabet, the first half can be ignored and the search space is narrowed down to the second half.</li> <li>Repeat steps <code>1.</code> and <code>2.</code> until you find the page where the word starts with \\(r\\).</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 1-1 \u00a0 Process of looking up a dictionary </p> <p>Looking up a dictionary, an essential skill for elementary school students is actually the famous \"Binary Search\" algorithm. From a data structure perspective, we can consider the dictionary as a sorted \"array\"; from an algorithmic perspective, the series of actions taken to look up a word in the dictionary can be viewed as the algorithm \"Binary Search.\"</p> <p>Example 2: Organizing Card Deck. When playing cards, we need to arrange the cards in our hands in ascending order, as shown in the following process.</p> <ol> <li>Divide the playing cards into \"ordered\" and \"unordered\" sections, assuming initially the leftmost card is already in order.</li> <li>Take out a card from the unordered section and insert it into the correct position in the ordered section; after this, the leftmost two cards are in order.</li> <li>Repeat step <code>2</code> until all cards are in order.</li> </ol> <p></p> <p> Figure 1-2 \u00a0 Process of sorting a deck of cards </p> <p>The above method of organizing playing cards is practically the \"Insertion Sort\" algorithm, which is very efficient for small datasets. Many programming languages' sorting functions include the insertion sort.</p> <p>Example 3: Making Change. Assume making a purchase of \\(69\\) at a supermarket. If you give the cashier \\(100\\), they will need to provide you with \\(31\\) in change. This process can be clearly understood as illustrated in Figure 1-3.</p> <ol> <li>The options are currencies valued below \\(31\\), including \\(1\\), \\(5\\), \\(10\\), and \\(20\\).</li> <li>Take out the largest \\(20\\) from the options, leaving \\(31 - 20 = 11\\).</li> <li>Take out the largest \\(10\\) from the remaining options, leaving \\(11 - 10 = 1\\).</li> <li>Take out the largest \\(1\\) from the remaining options, leaving \\(1 - 1 = 0\\).</li> <li>Complete change-making, the solution is \\(20 + 10 + 1 = 31\\).</li> </ol> <p></p> <p> Figure 1-3 \u00a0 Process of making change </p> <p>In the steps described, we choose the best option at each stage by utilizing the largest denomination available, which leads to an effective change-making strategy. From a data structures and algorithms perspective, this approach is known as a \"Greedy\" algorithm.</p> <p>From cooking a meal to interstellar travel, almost all problem-solving involves algorithms. The advent of computers allows us to store data structures in memory and write code to call the CPU and GPU to execute algorithms. In this way, we can transfer real-life problems to computers and solve various complex issues in a more efficient way.</p> <p>Tip</p> <p>If you are still confused about concepts like data structures, algorithms, arrays, and binary searches, I encourage you to keep reading. This book will gently guide you into the realm of understanding data structures and algorithms.</p>"},{"location":"chapter_introduction/summary/","title":"1.3 \u00a0 Summary","text":""},{"location":"chapter_introduction/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Algorithms are ubiquitous in daily life and are not distant, esoteric knowledge. In fact, we have already learned many algorithms unconsciously and use them to solve problems big and small in life.</li> <li>The principle of looking up a dictionary is consistent with the binary search algorithm. Binary search embodies the important algorithmic idea of divide and conquer.</li> <li>The process of organizing playing cards is very similar to the insertion sort algorithm. Insertion sort is suitable for sorting small datasets.</li> <li>The steps of making change are essentially a greedy algorithm, where the best choice is made at each step based on the current situation.</li> <li>An algorithm is a set of instructions or operational steps that solves a specific problem within a finite amount of time, while a data structure is the way computers organize and store data.</li> <li>Data structures and algorithms are closely connected. Data structures are the foundation of algorithms, and algorithms breathe life into data structures.</li> <li>We can compare data structures and algorithms to assembling building blocks. The blocks represent data, the shape and connection method of the blocks represent the data structure, and the steps to assemble the blocks correspond to the algorithm.</li> </ul>"},{"location":"chapter_introduction/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: As a programmer, I have never used algorithms to solve problems in my daily work. Common algorithms are already encapsulated by programming languages and can be used directly. Does this mean that the problems in our work have not yet reached the level where algorithms are needed?</p> <p>If we compare specific work skills to \"techniques\" in martial arts, then fundamental subjects should be more like \"internal skills\".</p> <p>I believe the significance of learning algorithms (and other fundamental subjects) is not to implement them from scratch at work, but rather to be able to make professional reactions and judgments when solving problems based on the knowledge learned, thereby improving the overall quality of work. Here is a simple example. Every programming language has a built-in sorting function:</p> <ul> <li>If we have not studied data structures and algorithms, we might simply feed any given data to this sorting function. It runs smoothly with good performance, and there doesn't seem to be any problem.</li> <li>But if we have studied algorithms, we would know that the time complexity of the built-in sorting function is \\(O(n \\log n)\\). However, if the given data consists of integers with a fixed number of digits (such as student IDs), we can use the more efficient \"radix sort\", reducing the time complexity to \\(O(nk)\\), where \\(k\\) is the number of digits. When the data volume is very large, the saved running time can create significant value (reduced costs, improved experience, etc.).</li> </ul> <p>In the field of engineering, a large number of problems are difficult to reach optimal solutions, and many problems are only solved \"approximately\". The difficulty of a problem depends on one hand on the nature of the problem itself, and on the other hand on the knowledge reserve of the person observing the problem. The more complete a person's knowledge and the more experience they have, the deeper their analysis of the problem will be, and the more elegantly the problem can be solved.</p>"},{"location":"chapter_introduction/what_is_dsa/","title":"1.2 \u00a0 What Is an Algorithm","text":""},{"location":"chapter_introduction/what_is_dsa/#121-algorithm-definition","title":"1.2.1 \u00a0 Algorithm Definition","text":"<p>An algorithm is a set of instructions or operational steps that solves a specific problem within a finite amount of time. It has the following characteristics.</p> <ul> <li>The problem is well-defined, with clear input and output definitions.</li> <li>It is feasible and can be completed within a finite number of steps, time, and memory space.</li> <li>Each step has a definite meaning, and under the same input and operating conditions, the output is always the same.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#122-data-structure-definition","title":"1.2.2 \u00a0 Data Structure Definition","text":"<p>A data structure is a way of organizing and storing data, covering the data content, relationships between data, and methods for data operations. It has the following design objectives.</p> <ul> <li>Occupy as little space as possible to save computer memory.</li> <li>Data operations should be as fast as possible, covering data access, addition, deletion, update, etc.</li> <li>Provide a concise data representation and logical information so that algorithms can run efficiently.</li> </ul> <p>Data structure design is a process full of trade-offs. If we want to achieve improvements in one aspect, we often need to make compromises in another aspect. Here are two examples.</p> <ul> <li>Compared to arrays, linked lists are more convenient for data addition and deletion operations but sacrifice data access speed.</li> <li>Compared to linked lists, graphs provide richer logical information but require larger memory space.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#123-the-relationship-between-data-structures-and-algorithms","title":"1.2.3 \u00a0 The Relationship Between Data Structures and Algorithms","text":"<p>As shown in Figure 1-4, data structures and algorithms are highly related and tightly coupled, specifically manifested in the following three aspects.</p> <ul> <li>Data structures are the foundation of algorithms. Data structures provide algorithms with structured storage of data and methods for operating on data.</li> <li>Algorithms breathe life into data structures. Data structures themselves only store data information; combined with algorithms, they can solve specific problems.</li> <li>Algorithms can usually be implemented based on different data structures, but execution efficiency may vary greatly. Choosing the appropriate data structure is key.</li> </ul> <p></p> <p> Figure 1-4 \u00a0 The relationship between data structures and algorithms </p> <p>Data structures and algorithms are like assembling building blocks as shown in Figure 1-5. A set of building blocks, in addition to containing many parts, also comes with detailed assembly instructions. By following the instructions step by step, we can assemble an exquisite building block model.</p> <p></p> <p> Figure 1-5 \u00a0 Assembling blocks </p> <p>The detailed correspondence between the two is shown in Table 1-1.</p> <p> Table 1-1 \u00a0 Comparing data structures and algorithms to assembling building blocks </p> Data structures and algorithms Assembling building blocks Input data Unassembled building blocks Data structure Organization form of building blocks, including shape, size, connection method, etc. Algorithm A series of operational steps to assemble the blocks into the target form Output data Building block model <p>It is worth noting that data structures and algorithms are independent of programming languages. For this reason, this book is able to provide implementations based on multiple programming languages.</p> <p>Conventional abbreviation</p> <p>In actual discussions, we usually abbreviate \"data structures and algorithms\" as \"algorithms\". For example, the well-known LeetCode algorithm problems actually examine knowledge of both data structures and algorithms.</p>"},{"location":"chapter_preface/","title":"Chapter 0. \u00a0 Preface","text":"<p>Abstract</p> <p>Algorithms are like a beautiful symphony, each line of code flows like a melody.</p> <p>May this book gently resonate in your mind, leaving a unique and profound melody.</p>"},{"location":"chapter_preface/#chapter-contents","title":"Chapter contents","text":"<ul> <li>0.1 \u00a0 About This Book</li> <li>0.2 \u00a0 How to Use This Book</li> <li>0.3 \u00a0 Summary</li> </ul>"},{"location":"chapter_preface/about_the_book/","title":"0.1 \u00a0 About This Book","text":"<p>This project aims to create an open-source, free, beginner-friendly introductory tutorial on data structures and algorithms.</p> <ul> <li>The entire book uses animated illustrations, with clear and easy-to-understand content and a smooth learning curve, guiding beginners to explore the knowledge map of data structures and algorithms.</li> <li>The source code can be run with one click, helping readers improve their programming skills through practice and understand how algorithms work and the underlying implementation of data structures.</li> <li>We encourage readers to learn from each other, and everyone is welcome to ask questions and share insights in the comments section, making progress together through discussion and exchange.</li> </ul>"},{"location":"chapter_preface/about_the_book/#011-target-audience","title":"0.1.1 \u00a0 Target Audience","text":"<p>If you are an algorithm beginner who has never been exposed to algorithms, or if you already have some problem-solving experience and have a vague understanding of data structures and algorithms, oscillating between knowing and not knowing, then this book is tailor-made for you!</p> <p>If you have already accumulated a certain amount of problem-solving experience and are familiar with most question types, this book can help you review and organize your algorithm knowledge system, and the repository's source code can be used as a \"problem-solving toolkit\" or \"algorithm dictionary.\"</p> <p>If you are an algorithm \"expert,\" we look forward to receiving your valuable suggestions, or participating in creation together.</p> <p>Prerequisites</p> <p>You need to have at least a programming foundation in any language, and be able to read and write simple code.</p>"},{"location":"chapter_preface/about_the_book/#012-content-structure","title":"0.1.2 \u00a0 Content Structure","text":"<p>The main content of this book is shown in Figure 0-1.</p> <ul> <li>Complexity analysis: Evaluation dimensions and methods for data structures and algorithms. Methods for calculating time complexity and space complexity, common types, examples, etc.</li> <li>Data structures: Classification methods for basic data types and data structures. The definition, advantages and disadvantages, common operations, common types, typical applications, implementation methods, etc. of data structures such as arrays, linked lists, stacks, queues, hash tables, trees, heaps, and graphs.</li> <li>Algorithms: The definition, advantages and disadvantages, efficiency, application scenarios, problem-solving steps, and example problems of algorithms such as searching, sorting, divide and conquer, backtracking, dynamic programming, and greedy algorithms.</li> </ul> <p></p> <p> Figure 0-1 \u00a0 Main content of this book </p>"},{"location":"chapter_preface/about_the_book/#013-acknowledgements","title":"0.1.3 \u00a0 Acknowledgements","text":"<p>This book has been continuously improved through the joint efforts of many contributors in the open-source community. Thanks to every contributor who invested time and effort, they are (in the order automatically generated by GitHub): krahets, coderonion, Gonglja, nuomi1, Reanon, justin-tse, hpstory, danielsss, curtishd, night-cruise, S-N-O-R-L-A-X, rongyi, msk397, gvenusleo, khoaxuantu, rivertwilight, K3v123, gyt95, zhuoqinyue, yuelinxin, Zuoxun, mingXta, Phoenix0415, FangYuan33, GN-Yu, longsizhuo, IsChristina, xBLACKICEx, guowei-gong, Cathay-Chen, pengchzn, QiLOL, magentaqin, hello-ikun, JoseHung, qualifier1024, thomasq0, sunshinesDL, L-Super, Guanngxu, Transmigration-zhou, WSL0809, Slone123c, lhxsm, yuan0221, what-is-me, Shyam-Chen, theNefelibatas, longranger2, codeberg-user, xiongsp, JeffersonHuang, prinpal, seven1240, Wonderdch, malone6, xiaomiusa87, gaofer, bluebean-cloud, a16su, SamJin98, hongyun-robot, nanlei, XiaChuerwu, yd-j, iron-irax, mgisr, steventimes, junminhong, heshuyue, danny900714, MolDuM, Nigh, Dr-XYZ, XC-Zero, reeswell, PXG-XPG, NI-SW, Horbin-Magician, Enlightenus, YangXuanyi, beatrix-chan, DullSword, xjr7670, jiaxianhua, qq909244296, iStig, boloboloda, hts0000, gledfish, wenjianmin, keshida, kilikilikid, lclc6, lwbaptx, linyejoe2, liuxjerry, llql1211, fbigm, echo1937, szu17dmy, dshlstarr, Yucao-cy, coderlef, czruby, bongbongbakudan, beintentional, ZongYangL, ZhongYuuu, ZhongGuanbin, hezhizhen, linzeyan, ZJKung, luluxia, xb534, ztkuaikuai, yw-1021, ElaBosak233, baagod, zhouLion, yishangzhang, yi427, yanedie, yabo083, weibk, wangwang105, th1nk3r-ing, tao363, 4yDX3906, syd168, sslmj2020, smilelsb, siqyka, selear, sdshaoda, Xi-Row, popozhu, nuquist19, noobcodemaker, XiaoK29, chadyi, lyl625760, lucaswangdev, 0130w, shanghai-Jerry, EJackYang, Javesun99, eltociear, lipusheng, KNChiu, BlindTerran, ShiMaRing, lovelock, FreddieLi, FloranceYeh, fanchenggang, gltianwen, goerll, nedchu, curly210102, CuB3y0nd, KraHsu, CarrotDLaw, youshaoXG, bubble9um, Asashishi, Asa0oo0o0o, fanenr, eagleanurag, akshiterate, 52coder, foursevenlove, KorsChen, GaochaoZhu, hopkings2008, yang-le, realwujing, Evilrabbit520, Umer-Jahangir, Turing-1024-Lee, Suremotoo, paoxiaomooo, Chieko-Seren, Allen-Scai, ymmmas, Risuntsy, Richard-Zhang1019, RafaelCaso, qingpeng9802, primexiao, Urbaner3, zhongfq, nidhoggfgg, MwumLi, CreatorMetaSky, martinx, ZnYang2018, hugtyftg, logan-qiu, psychelzh, Keynman, KeiichiKasai, and KawaiiAsh.</p> <p>The code review work for this book was completed by coderonion, curtishd, Gonglja, gvenusleo, hpstory, justin-tse, khoaxuantu, krahets, night-cruise, nuomi1, Reanon and rongyi (in alphabetical order). Thanks to them for the time and effort they put in, it is they who ensure the standardization and unity of code in various languages.</p> <p>The Traditional Chinese version of this book was reviewed by Shyam-Chen and Dr-XYZ, and the English version was reviewed by yuelinxin, K3v123, QiLOL, Phoenix0415, SamJin98, yanedie, RafaelCaso, pengchzn, thomasq0 and magentaqin. It is because of their continuous contributions that this book can serve a wider readership, and we thank them.</p> <p>During the creation of this book, I received help from many people.</p> <ul> <li>Thanks to my mentor at the company, Dr. Li Xi, who encouraged me to \"take action quickly\" during a conversation, strengthening my determination to write this book;</li> <li>Thanks to my girlfriend Bubble as the first reader of this book, who provided many valuable suggestions from the perspective of an algorithm beginner, making this book more suitable for novices to read;</li> <li>Thanks to Tengbao, Qibao, and Feibao for coming up with a creative name for this book, evoking everyone's fond memories of writing their first line of code \"Hello World!\";</li> <li>Thanks to Xiaoquan for providing professional help in intellectual property rights, which played an important role in the improvement of this open-source book;</li> <li>Thanks to Sutong for designing the beautiful cover and logo for this book, and for patiently making revisions multiple times driven by my obsessive-compulsive disorder;</li> <li>Thanks to @squidfunk for the typesetting suggestions, as well as for developing the open-source documentation theme Material-for-MkDocs.</li> </ul> <p>During the writing process, I read many textbooks and articles on data structures and algorithms. These works provided excellent examples for this book and ensured the accuracy and quality of the book's content. I would like to thank all the teachers and predecessors for their outstanding contributions!</p> <p>This book advocates a learning method that combines hands and brain, and in this regard I was deeply inspired by Dive into Deep Learning. I highly recommend this excellent work to all readers.</p> <p>Heartfelt thanks to my parents, it is your support and encouragement that has given me the opportunity to do this interesting thing.</p>"},{"location":"chapter_preface/suggestions/","title":"0.2 \u00a0 How to Use This Book","text":"<p>Tip</p> <p>For the best reading experience, it is recommended that you read through this section.</p>"},{"location":"chapter_preface/suggestions/#021-writing-style-conventions","title":"0.2.1 \u00a0 Writing Style Conventions","text":"<ul> <li>Titles marked with <code>*</code> are optional sections with relatively difficult content. If you have limited time, you can skip them first.</li> <li>Technical terms will be in bold (in paper and PDF versions) or underlined (in web versions), such as array. It is recommended to memorize them for reading literature.</li> <li>Key content and summary statements will be bolded, and such text deserves special attention.</li> <li>Words and phrases with specific meanings will be marked with \"quotation marks\" to avoid ambiguity.</li> <li>When it comes to nouns that are inconsistent between programming languages, this book uses Python as the standard, for example, using <code>None</code> to represent \"null\".</li> <li>This book partially abandons the comment conventions of programming languages in favor of more compact content layout. Comments are mainly divided into three types: title comments, content comments, and multi-line comments.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>\"\"\"Title comment, used to label functions, classes, test cases, etc.\"\"\"\n\n# Content comment, used to explain code in detail\n\n\"\"\"\nMulti-line\ncomment\n\"\"\"\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>/* Title comment, used to label functions, classes, test cases, etc. */\n\n// Content comment, used to explain code in detail\n\n/**\n * Multi-line\n * comment\n */\n</code></pre> <pre><code>### Title comment, used to label functions, classes, test cases, etc. ###\n\n# Content comment, used to explain code in detail\n\n# Multi-line\n# comment\n</code></pre>"},{"location":"chapter_preface/suggestions/#022-learning-efficiently-with-animated-illustrations","title":"0.2.2 \u00a0 Learning Efficiently with Animated Illustrations","text":"<p>Compared to text, videos and images have higher information density and structural organization, making them easier to understand. In this book, key and difficult knowledge will mainly be presented in the form of animated illustrations, with text serving as explanation and supplement.</p> <p>If you find that a section of content provides animated illustrations as shown in Figure 0-2 while reading this book, please focus on the illustrations first, with text as a supplement, and combine the two to understand the content.</p> <p></p> <p> Figure 0-2 \u00a0 Example of animated illustrations </p>"},{"location":"chapter_preface/suggestions/#023-deepening-understanding-through-code-practice","title":"0.2.3 \u00a0 Deepening Understanding Through Code Practice","text":"<p>The accompanying code for this book is hosted in the GitHub repository. As shown in Figure 0-3, the source code comes with test cases and can be run with one click.</p> <p>If time permits, it is recommended that you type out the code yourself. If you have limited study time, please at least read through and run all the code.</p> <p>Compared to reading code, the process of writing code often brings more rewards. Learning by doing is the real learning.</p> <p></p> <p> Figure 0-3 \u00a0 Example of running code </p> <p>The preliminary work for running code is mainly divided into three steps.</p> <p>Step 1: Install the local programming environment. Please follow the tutorial shown in the appendix for installation. If already installed, you can skip this step.</p> <p>Step 2: Clone or download the code repository. Visit the GitHub repository. If you have already installed Git, you can clone this repository with the following command:</p> <pre><code>git clone https://github.com/krahets/hello-algo.git\n</code></pre> <p>Of course, you can also click the \"Download ZIP\" button at the location shown in Figure 0-4 to directly download the code compressed package, and then extract it locally.</p> <p></p> <p> Figure 0-4 \u00a0 Clone repository and download code </p> <p>Step 3: Run the source code. As shown in Figure 0-5, for code blocks with file names at the top, we can find the corresponding source code files in the <code>codes</code> folder of the repository. The source code files can be run with one click, which will help you save unnecessary debugging time and allow you to focus on learning content.</p> <p></p> <p> Figure 0-5 \u00a0 Code blocks and corresponding source code files </p> <p>In addition to running code locally, the web version also supports visual running of Python code (implemented based on pythontutor). As shown in Figure 0-6, you can click \"Visual Run\" below the code block to expand the view and observe the execution process of the algorithm code; you can also click \"Full Screen View\" for a better viewing experience.</p> <p></p> <p> Figure 0-6 \u00a0 Visual running of Python code </p>"},{"location":"chapter_preface/suggestions/#024-growing-together-through-questions-and-discussions","title":"0.2.4 \u00a0 Growing Together Through Questions and Discussions","text":"<p>When reading this book, please do not easily skip knowledge points that you have not learned well. Feel free to ask your questions in the comments section, and my friends and I will do our best to answer you, and generally reply within two days.</p> <p>As shown in Figure 0-7, the web version has a comments section at the bottom of each chapter. I hope you will pay more attention to the content of the comments section. On the one hand, you can learn about the problems that everyone encounters, thus checking for omissions and stimulating deeper thinking. On the other hand, I hope you can generously answer other friends' questions, share your insights, and help others progress.</p> <p></p> <p> Figure 0-7 \u00a0 Example of comments section </p>"},{"location":"chapter_preface/suggestions/#025-algorithm-learning-roadmap","title":"0.2.5 \u00a0 Algorithm Learning Roadmap","text":"<p>From an overall perspective, we can divide the process of learning data structures and algorithms into three stages.</p> <ol> <li>Stage 1: Algorithm introduction. We need to familiarize ourselves with the characteristics and usage of various data structures, and learn the principles, processes, uses, and efficiency of different algorithms.</li> <li>Stage 2: Practice algorithm problems. It is recommended to start with popular problems, and accumulate at least 100 problems first, to familiarize yourself with mainstream algorithm problems. When first practicing problems, \"knowledge forgetting\" may be a challenge, but rest assured, this is very normal. We can review problems according to the \"Ebbinghaus forgetting curve\", and usually after 3-5 rounds of repetition, we can firmly remember them. For recommended problem lists and practice plans, please see this GitHub repository.</li> <li>Stage 3: Building a knowledge system. In terms of learning, we can read algorithm column articles, problem-solving frameworks, and algorithm textbooks to continuously enrich our knowledge system. In terms of practicing problems, we can try advanced problem-solving strategies, such as categorization by topic, one problem multiple solutions, one solution multiple problems, etc. Related problem-solving insights can be found in various communities.</li> </ol> <p>As shown in Figure 0-8, the content of this book mainly covers \"Stage 1\", aiming to help you more efficiently carry out Stage 2 and Stage 3 learning.</p> <p></p> <p> Figure 0-8 \u00a0 Algorithm learning roadmap </p>"},{"location":"chapter_preface/summary/","title":"0.3 \u00a0 Summary","text":""},{"location":"chapter_preface/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>The main audience of this book is algorithm beginners. If you already have a certain foundation, this book can help you systematically review algorithm knowledge, and the source code in the book can also be used as a \"problem-solving toolkit.\"</li> <li>The content of the book mainly includes three parts: complexity analysis, data structures, and algorithms, covering most topics in this field.</li> <li>For algorithm novices, reading an introductory book during the initial learning stage is crucial, as it can help you avoid many detours.</li> <li>The animated illustrations in the book are usually used to introduce key and difficult knowledge. When reading this book, you should pay more attention to these contents.</li> <li>Practice is the best way to learn programming. It is strongly recommended to run the source code and type the code yourself.</li> <li>The web version of this book has a comments section for each chapter, where you are welcome to share your questions and insights at any time.</li> </ul>"},{"location":"chapter_reference/","title":"References","text":"<p>[1] Thomas H. Cormen, et al. Introduction to Algorithms (3<sup>rd</sup> Edition).</p> <p>[2] Aditya Bhargava. Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People (1<sup>st</sup> Edition).</p> <p>[3] Robert Sedgewick, et al. Algorithms (4<sup>th</sup> Edition).</p> <p>[4] Yan Weimin. Data Structures (C Language Version).</p> <p>[5] Deng Junhui. Data Structures (C++ Language Version, Third Edition).</p> <p>[6] Mark Allen Weiss, translated by Chen Yue. Data Structures and Algorithm Analysis in Java (Third Edition).</p> <p>[7] Cheng Jie. Conversational Data Structures.</p> <p>[8] Wang Zheng. The Beauty of Data Structures and Algorithms.</p> <p>[9] Gayle Laakmann McDowell. Cracking the Coding Interview: 189 Programming Questions and Solutions (6<sup>th</sup> Edition).</p> <p>[10] Aston Zhang, et al. Dive into Deep Learning.</p>"},{"location":"chapter_searching/","title":"Chapter 10. \u00a0 Searching","text":"<p>Abstract</p> <p>Searching is an adventure into the unknown, where we may need to traverse every corner of the mysterious space, or we may be able to quickly lock onto the target.</p> <p>In this journey of discovery, each exploration may yield an unexpected answer.</p>"},{"location":"chapter_searching/#chapter-contents","title":"Chapter contents","text":"<ul> <li>10.1 \u00a0 Binary Search</li> <li>10.2 \u00a0 Binary Search Insertion</li> <li>10.3 \u00a0 Binary Search Edge Cases</li> <li>10.4 \u00a0 Hash Optimization Strategy</li> <li>10.5 \u00a0 Search Algorithms Revisited</li> <li>10.6 \u00a0 Summary</li> </ul>"},{"location":"chapter_searching/binary_search/","title":"10.1 \u00a0 Binary Search","text":"<p>Binary search is an efficient searching algorithm based on the divide-and-conquer strategy. It leverages the orderliness of data to reduce the search range by half in each round until the target element is found or the search interval becomes empty.</p> <p>Question</p> <p>Given an array <code>nums</code> of length \\(n\\) with elements arranged in ascending order and no duplicates, search for and return the index of element <code>target</code> in the array. If the array does not contain the element, return \\(-1\\). An example is shown in Figure 10-1.</p> <p></p> <p> Figure 10-1 \u00a0 Binary search example data </p> <p>As shown in Figure 10-2, we first initialize pointers \\(i = 0\\) and \\(j = n - 1\\), pointing to the first and last elements of the array respectively, representing the search interval \\([0, n - 1]\\). Note that square brackets denote a closed interval, which includes the boundary values themselves.</p> <p>Next, perform the following two steps in a loop:</p> <ol> <li>Calculate the midpoint index \\(m = \\lfloor {(i + j) / 2} \\rfloor\\), where \\(\\lfloor \\: \\rfloor\\) denotes the floor operation.</li> <li>Compare <code>nums[m]</code> and <code>target</code>, which results in three cases:<ol> <li>When <code>nums[m] &lt; target</code>, it indicates that <code>target</code> is in the interval \\([m + 1, j]\\), so execute \\(i = m + 1\\).</li> <li>When <code>nums[m] &gt; target</code>, it indicates that <code>target</code> is in the interval \\([i, m - 1]\\), so execute \\(j = m - 1\\).</li> <li>When <code>nums[m] = target</code>, it indicates that <code>target</code> has been found, so return index \\(m\\).</li> </ol> </li> </ol> <p>If the array does not contain the target element, the search interval will eventually shrink to empty. In this case, return \\(-1\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 10-2 \u00a0 Binary search process </p> <p>It's worth noting that since both \\(i\\) and \\(j\\) are of <code>int</code> type, \\(i + j\\) may exceed the range of the <code>int</code> type. To avoid large number overflow, we typically use the formula \\(m = \\lfloor {i + (j - i) / 2} \\rfloor\\) to calculate the midpoint.</p> <p>The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search.py<pre><code>def binary_search(nums: list[int], target: int) -&gt; int:\n    \"\"\"Binary search (closed interval)\"\"\"\n    # Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    i, j = 0, len(nums) - 1\n    # Loop, exit when the search interval is empty (empty when i &gt; j)\n    while i &lt;= j:\n        # In theory, Python numbers can be infinitely large (depending on memory size), no need to consider large number overflow\n        m = (i + j) // 2  # Calculate midpoint index m\n        if nums[m] &lt; target:\n            i = m + 1  # This means target is in the interval [m+1, j]\n        elif nums[m] &gt; target:\n            j = m - 1  # This means target is in the interval [i, m-1]\n        else:\n            return m  # Found the target element, return its index\n    return -1  # Target element not found, return -1\n</code></pre> binary_search.cpp<pre><code>/* Binary search (closed interval on both sides) */\nint binarySearch(vector&lt;int&gt; &amp;nums, int target) {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    int i = 0, j = nums.size() - 1;\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target)    // This means target is in the interval [m+1, j]\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m-1]\n            j = m - 1;\n        else // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.java<pre><code>/* Binary search (closed interval on both sides) */\nint binarySearch(int[] nums, int target) {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    int i = 0, j = nums.length - 1;\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) // This means target is in the interval [m+1, j]\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m-1]\n            j = m - 1;\n        else // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.cs<pre><code>/* Binary search (closed interval on both sides) */\nint BinarySearch(int[] nums, int target) {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    int i = 0, j = nums.Length - 1;\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2;   // Calculate the midpoint index m\n        if (nums[m] &lt; target)      // This means target is in the interval [m+1, j]\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m-1]\n            j = m - 1;\n        else                       // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.go<pre><code>/* Binary search (closed interval on both sides) */\nfunc binarySearch(nums []int, target int) int {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    i, j := 0, len(nums)-1\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    for i &lt;= j {\n        m := i + (j-i)/2      // Calculate the midpoint index m\n        if nums[m] &lt; target { // This means target is in the interval [m+1, j]\n            i = m + 1\n        } else if nums[m] &gt; target { // This means target is in the interval [i, m-1]\n            j = m - 1\n        } else { // Found the target element, return its index\n            return m\n        }\n    }\n    // Target element not found, return -1\n    return -1\n}\n</code></pre> binary_search.swift<pre><code>/* Binary search (closed interval on both sides) */\nfunc binarySearch(nums: [Int], target: Int) -&gt; Int {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    var i = nums.startIndex\n    var j = nums.endIndex - 1\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while i &lt;= j {\n        let m = i + (j - i) / 2 // Calculate the midpoint index m\n        if nums[m] &lt; target { // This means target is in the interval [m+1, j]\n            i = m + 1\n        } else if nums[m] &gt; target { // This means target is in the interval [i, m-1]\n            j = m - 1\n        } else { // Found the target element, return its index\n            return m\n        }\n    }\n    // Target element not found, return -1\n    return -1\n}\n</code></pre> binary_search.js<pre><code>/* Binary search (closed interval on both sides) */\nfunction binarySearch(nums, target) {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    let i = 0,\n        j = nums.length - 1;\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while (i &lt;= j) {\n        // Calculate midpoint index m, use parseInt() to round down\n        const m = parseInt(i + (j - i) / 2);\n        if (nums[m] &lt; target)\n            // This means target is in the interval [m+1, j]\n            i = m + 1;\n        else if (nums[m] &gt; target)\n            // This means target is in the interval [i, m-1]\n            j = m - 1;\n        else return m; // Found the target element, return its index\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.ts<pre><code>/* Binary search (closed interval on both sides) */\nfunction binarySearch(nums: number[], target: number): number {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    let i = 0,\n        j = nums.length - 1;\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while (i &lt;= j) {\n        // Calculate the midpoint index m\n        const m = Math.floor(i + (j - i) / 2);\n        if (nums[m] &lt; target) {\n            // This means target is in the interval [m+1, j]\n            i = m + 1;\n        } else if (nums[m] &gt; target) {\n            // This means target is in the interval [i, m-1]\n            j = m - 1;\n        } else {\n            // Found the target element, return its index\n            return m;\n        }\n    }\n    return -1; // Target element not found, return -1\n}\n</code></pre> binary_search.dart<pre><code>/* Binary search (closed interval on both sides) */\nint binarySearch(List&lt;int&gt; nums, int target) {\n  // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n  int i = 0, j = nums.length - 1;\n  // Loop, exit when the search interval is empty (empty when i &gt; j)\n  while (i &lt;= j) {\n    int m = i + (j - i) ~/ 2; // Calculate the midpoint index m\n    if (nums[m] &lt; target) {\n      // This means target is in the interval [m+1, j]\n      i = m + 1;\n    } else if (nums[m] &gt; target) {\n      // This means target is in the interval [i, m-1]\n      j = m - 1;\n    } else {\n      // Found the target element, return its index\n      return m;\n    }\n  }\n  // Target element not found, return -1\n  return -1;\n}\n</code></pre> binary_search.rs<pre><code>/* Binary search (closed interval on both sides) */\nfn binary_search(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    let mut i = 0;\n    let mut j = nums.len() as i32 - 1;\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while i &lt;= j {\n        let m = i + (j - i) / 2; // Calculate the midpoint index m\n        if nums[m as usize] &lt; target {\n            // This means target is in the interval [m+1, j]\n            i = m + 1;\n        } else if nums[m as usize] &gt; target {\n            // This means target is in the interval [i, m-1]\n            j = m - 1;\n        } else {\n            // Found the target element, return its index\n            return m;\n        }\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.c<pre><code>/* Binary search (closed interval on both sides) */\nint binarySearch(int *nums, int len, int target) {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    int i = 0, j = len - 1;\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target)    // This means target is in the interval [m+1, j]\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m-1]\n            j = m - 1;\n        else // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.kt<pre><code>/* Binary search (closed interval on both sides) */\nfun binarySearch(nums: IntArray, target: Int): Int {\n    // Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n    var i = 0\n    var j = nums.size - 1\n    // Loop, exit when the search interval is empty (empty when i &gt; j)\n    while (i &lt;= j) {\n        val m = i + (j - i) / 2 // Calculate the midpoint index m\n        if (nums[m] &lt; target) // This means target is in the interval [m+1, j]\n            i = m + 1\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m-1]\n            j = m - 1\n        else  // Found the target element, return its index\n            return m\n    }\n    // Target element not found, return -1\n    return -1\n}\n</code></pre> binary_search.rb<pre><code>### Binary search (closed interval) ###\ndef binary_search(nums, target)\n  # Initialize closed interval [0, n-1], i.e., i, j point to the first and last elements of the array\n  i, j = 0, nums.length - 1\n\n  # Loop, exit when the search interval is empty (empty when i &gt; j)\n  while i &lt;= j\n    # In theory, Ruby numbers can be infinitely large (limited by memory), no need to consider overflow\n    m = (i + j) / 2   # Calculate the midpoint index m\n\n    if nums[m] &lt; target\n      i = m + 1 # This means target is in the interval [m+1, j]\n    elsif nums[m] &gt; target\n      j = m - 1 # This means target is in the interval [i, m-1]\n    else\n      return m  # Found the target element, return its index\n    end\n  end\n\n  -1  # Target element not found, return -1\nend\n</code></pre> <p>Time complexity is \\(O(\\log n)\\): In the binary loop, the interval is reduced by half each round, so the number of loops is \\(\\log_2 n\\).</p> <p>Space complexity is \\(O(1)\\): Pointers \\(i\\) and \\(j\\) use constant-size space.</p>"},{"location":"chapter_searching/binary_search/#1011-interval-representation-methods","title":"10.1.1 \u00a0 Interval Representation Methods","text":"<p>In addition to the closed interval mentioned above, another common interval representation is the \"left-closed right-open\" interval, defined as \\([0, n)\\), meaning the left boundary includes itself while the right boundary does not. Under this representation, the interval \\([i, j)\\) is empty when \\(i = j\\).</p> <p>We can implement a binary search algorithm with the same functionality based on this representation:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search.py<pre><code>def binary_search_lcro(nums: list[int], target: int) -&gt; int:\n    \"\"\"Binary search (left-closed right-open interval)\"\"\"\n    # Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    i, j = 0, len(nums)\n    # Loop, exit when the search interval is empty (empty when i = j)\n    while i &lt; j:\n        m = (i + j) // 2  # Calculate midpoint index m\n        if nums[m] &lt; target:\n            i = m + 1  # This means target is in the interval [m+1, j)\n        elif nums[m] &gt; target:\n            j = m  # This means target is in the interval [i, m)\n        else:\n            return m  # Found the target element, return its index\n    return -1  # Target element not found, return -1\n</code></pre> binary_search.cpp<pre><code>/* Binary search (left-closed right-open interval) */\nint binarySearchLCRO(vector&lt;int&gt; &amp;nums, int target) {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    int i = 0, j = nums.size();\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while (i &lt; j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target)    // This means target is in the interval [m+1, j)\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m)\n            j = m;\n        else // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.java<pre><code>/* Binary search (left-closed right-open interval) */\nint binarySearchLCRO(int[] nums, int target) {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    int i = 0, j = nums.length;\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while (i &lt; j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) // This means target is in the interval [m+1, j)\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m)\n            j = m;\n        else // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.cs<pre><code>/* Binary search (left-closed right-open interval) */\nint BinarySearchLCRO(int[] nums, int target) {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    int i = 0, j = nums.Length;\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while (i &lt; j) {\n        int m = i + (j - i) / 2;   // Calculate the midpoint index m\n        if (nums[m] &lt; target)      // This means target is in the interval [m+1, j)\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m)\n            j = m;\n        else                       // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.go<pre><code>/* Binary search (left-closed right-open interval) */\nfunc binarySearchLCRO(nums []int, target int) int {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    i, j := 0, len(nums)\n    // Loop, exit when the search interval is empty (empty when i = j)\n    for i &lt; j {\n        m := i + (j-i)/2      // Calculate the midpoint index m\n        if nums[m] &lt; target { // This means target is in the interval [m+1, j)\n            i = m + 1\n        } else if nums[m] &gt; target { // This means target is in the interval [i, m)\n            j = m\n        } else { // Found the target element, return its index\n            return m\n        }\n    }\n    // Target element not found, return -1\n    return -1\n}\n</code></pre> binary_search.swift<pre><code>/* Binary search (left-closed right-open interval) */\nfunc binarySearchLCRO(nums: [Int], target: Int) -&gt; Int {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    var i = nums.startIndex\n    var j = nums.endIndex\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while i &lt; j {\n        let m = i + (j - i) / 2 // Calculate the midpoint index m\n        if nums[m] &lt; target { // This means target is in the interval [m+1, j)\n            i = m + 1\n        } else if nums[m] &gt; target { // This means target is in the interval [i, m)\n            j = m\n        } else { // Found the target element, return its index\n            return m\n        }\n    }\n    // Target element not found, return -1\n    return -1\n}\n</code></pre> binary_search.js<pre><code>/* Binary search (left-closed right-open interval) */\nfunction binarySearchLCRO(nums, target) {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    let i = 0,\n        j = nums.length;\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while (i &lt; j) {\n        // Calculate midpoint index m, use parseInt() to round down\n        const m = parseInt(i + (j - i) / 2);\n        if (nums[m] &lt; target)\n            // This means target is in the interval [m+1, j)\n            i = m + 1;\n        else if (nums[m] &gt; target)\n            // This means target is in the interval [i, m)\n            j = m;\n        // Found the target element, return its index\n        else return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.ts<pre><code>/* Binary search (left-closed right-open interval) */\nfunction binarySearchLCRO(nums: number[], target: number): number {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    let i = 0,\n        j = nums.length;\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while (i &lt; j) {\n        // Calculate the midpoint index m\n        const m = Math.floor(i + (j - i) / 2);\n        if (nums[m] &lt; target) {\n            // This means target is in the interval [m+1, j)\n            i = m + 1;\n        } else if (nums[m] &gt; target) {\n            // This means target is in the interval [i, m)\n            j = m;\n        } else {\n            // Found the target element, return its index\n            return m;\n        }\n    }\n    return -1; // Target element not found, return -1\n}\n</code></pre> binary_search.dart<pre><code>/* Binary search (left-closed right-open interval) */\nint binarySearchLCRO(List&lt;int&gt; nums, int target) {\n  // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n  int i = 0, j = nums.length;\n  // Loop, exit when the search interval is empty (empty when i = j)\n  while (i &lt; j) {\n    int m = i + (j - i) ~/ 2; // Calculate the midpoint index m\n    if (nums[m] &lt; target) {\n      // This means target is in the interval [m+1, j)\n      i = m + 1;\n    } else if (nums[m] &gt; target) {\n      // This means target is in the interval [i, m)\n      j = m;\n    } else {\n      // Found the target element, return its index\n      return m;\n    }\n  }\n  // Target element not found, return -1\n  return -1;\n}\n</code></pre> binary_search.rs<pre><code>/* Binary search (left-closed right-open interval) */\nfn binary_search_lcro(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    let mut i = 0;\n    let mut j = nums.len() as i32;\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while i &lt; j {\n        let m = i + (j - i) / 2; // Calculate the midpoint index m\n        if nums[m as usize] &lt; target {\n            // This means target is in the interval [m+1, j)\n            i = m + 1;\n        } else if nums[m as usize] &gt; target {\n            // This means target is in the interval [i, m)\n            j = m;\n        } else {\n            // Found the target element, return its index\n            return m;\n        }\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.c<pre><code>/* Binary search (left-closed right-open interval) */\nint binarySearchLCRO(int *nums, int len, int target) {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    int i = 0, j = len;\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while (i &lt; j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target)    // This means target is in the interval [m+1, j)\n            i = m + 1;\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m)\n            j = m;\n        else // Found the target element, return its index\n            return m;\n    }\n    // Target element not found, return -1\n    return -1;\n}\n</code></pre> binary_search.kt<pre><code>/* Binary search (left-closed right-open interval) */\nfun binarySearchLCRO(nums: IntArray, target: Int): Int {\n    // Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n    var i = 0\n    var j = nums.size\n    // Loop, exit when the search interval is empty (empty when i = j)\n    while (i &lt; j) {\n        val m = i + (j - i) / 2 // Calculate the midpoint index m\n        if (nums[m] &lt; target) // This means target is in the interval [m+1, j)\n            i = m + 1\n        else if (nums[m] &gt; target) // This means target is in the interval [i, m)\n            j = m\n        else  // Found the target element, return its index\n            return m\n    }\n    // Target element not found, return -1\n    return -1\n}\n</code></pre> binary_search.rb<pre><code>### Binary search (left-closed right-open interval) ###\ndef binary_search_lcro(nums, target)\n  # Initialize left-closed right-open interval [0, n), i.e., i, j point to the first element and last element+1\n  i, j = 0, nums.length\n\n  # Loop, exit when the search interval is empty (empty when i = j)\n  while i &lt; j\n    # Calculate the midpoint index m\n    m = (i + j) / 2\n\n    if nums[m] &lt; target\n      i = m + 1 # This means target is in the interval [m+1, j)\n    elsif nums[m] &gt; target\n      j = m - 1 # This means target is in the interval [i, m)\n    else\n      return m  # Found the target element, return its index\n    end\n  end\n\n  -1  # Target element not found, return -1\nend\n</code></pre> <p>As shown in Figure 10-3, under the two interval representations, the initialization, loop condition, and interval narrowing operations of the binary search algorithm are all different.</p> <p>Since both the left and right boundaries in the \"closed interval\" representation are defined as closed, the operations to narrow the interval through pointers \\(i\\) and \\(j\\) are also symmetric. This makes it less error-prone, so the \"closed interval\" approach is generally recommended.</p> <p></p> <p> Figure 10-3 \u00a0 Two interval definitions </p>"},{"location":"chapter_searching/binary_search/#1012-advantages-and-limitations","title":"10.1.2 \u00a0 Advantages and Limitations","text":"<p>Binary search performs well in both time and space aspects.</p> <ul> <li>Binary search has high time efficiency. With large data volumes, the logarithmic time complexity has significant advantages. For example, when the data size \\(n = 2^{20}\\), linear search requires \\(2^{20} = 1048576\\) loop rounds, while binary search only needs \\(\\log_2 2^{20} = 20\\) rounds.</li> <li>Binary search requires no extra space. Compared to searching algorithms that require additional space (such as hash-based search), binary search is more space-efficient.</li> </ul> <p>However, binary search is not suitable for all situations, mainly for the following reasons:</p> <ul> <li>Binary search is only applicable to sorted data. If the input data is unsorted, sorting specifically to use binary search would be counterproductive, as sorting algorithms typically have a time complexity of \\(O(n \\log n)\\), which is higher than both linear search and binary search. For scenarios with frequent element insertions, maintaining array orderliness requires inserting elements at specific positions with a time complexity of \\(O(n)\\), which is also very expensive.</li> <li>Binary search is only applicable to arrays. Binary search requires jump-style (non-contiguous) element access, and jump-style access has low efficiency in linked lists, making it unsuitable for linked lists or data structures based on linked list implementations.</li> <li>For small data volumes, linear search performs better. In linear search, each round requires only 1 comparison operation; while in binary search, it requires 1 addition, 1 division, 1-3 comparison operations, and 1 addition (subtraction), totaling 4-6 unit operations. Therefore, when the data volume \\(n\\) is small, linear search is actually faster than binary search.</li> </ul>"},{"location":"chapter_searching/binary_search_edge/","title":"10.3 \u00a0 Binary Search Edge Cases","text":""},{"location":"chapter_searching/binary_search_edge/#1031-finding-the-left-boundary","title":"10.3.1 \u00a0 Finding the Left Boundary","text":"<p>Question</p> <p>Given a sorted array <code>nums</code> of length \\(n\\) that may contain duplicate elements, return the index of the leftmost element <code>target</code> in the array. If the array does not contain the element, return \\(-1\\).</p> <p>Recall the method for finding the insertion point with binary search. After the search completes, \\(i\\) points to the leftmost <code>target</code>, so finding the insertion point is essentially finding the index of the leftmost <code>target</code>.</p> <p>Consider implementing the left boundary search using the insertion point finding function. Note that the array may not contain <code>target</code>, which could result in the following two cases:</p> <ul> <li>The insertion point index \\(i\\) is out of bounds.</li> <li>The element <code>nums[i]</code> is not equal to <code>target</code>.</li> </ul> <p>When either of these situations occurs, simply return \\(-1\\). The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_edge.py<pre><code>def binary_search_left_edge(nums: list[int], target: int) -&gt; int:\n    \"\"\"Binary search for the leftmost target\"\"\"\n    # Equivalent to finding the insertion point of target\n    i = binary_search_insertion(nums, target)\n    # Target not found, return -1\n    if i == len(nums) or nums[i] != target:\n        return -1\n    # Found target, return index i\n    return i\n</code></pre> binary_search_edge.cpp<pre><code>/* Binary search for the leftmost target */\nint binarySearchLeftEdge(vector&lt;int&gt; &amp;nums, int target) {\n    // Equivalent to finding the insertion point of target\n    int i = binarySearchInsertion(nums, target);\n    // Target not found, return -1\n    if (i == nums.size() || nums[i] != target) {\n        return -1;\n    }\n    // Found target, return index i\n    return i;\n}\n</code></pre> binary_search_edge.java<pre><code>/* Binary search for the leftmost target */\nint binarySearchLeftEdge(int[] nums, int target) {\n    // Equivalent to finding the insertion point of target\n    int i = binary_search_insertion.binarySearchInsertion(nums, target);\n    // Target not found, return -1\n    if (i == nums.length || nums[i] != target) {\n        return -1;\n    }\n    // Found target, return index i\n    return i;\n}\n</code></pre> binary_search_edge.cs<pre><code>/* Binary search for the leftmost target */\nint BinarySearchLeftEdge(int[] nums, int target) {\n    // Equivalent to finding the insertion point of target\n    int i = binary_search_insertion.BinarySearchInsertion(nums, target);\n    // Target not found, return -1\n    if (i == nums.Length || nums[i] != target) {\n        return -1;\n    }\n    // Found target, return index i\n    return i;\n}\n</code></pre> binary_search_edge.go<pre><code>/* Binary search for the leftmost target */\nfunc binarySearchLeftEdge(nums []int, target int) int {\n    // Equivalent to finding the insertion point of target\n    i := binarySearchInsertion(nums, target)\n    // Target not found, return -1\n    if i == len(nums) || nums[i] != target {\n        return -1\n    }\n    // Found target, return index i\n    return i\n}\n</code></pre> binary_search_edge.swift<pre><code>/* Binary search for the leftmost target */\nfunc binarySearchLeftEdge(nums: [Int], target: Int) -&gt; Int {\n    // Equivalent to finding the insertion point of target\n    let i = binarySearchInsertion(nums: nums, target: target)\n    // Target not found, return -1\n    if i == nums.endIndex || nums[i] != target {\n        return -1\n    }\n    // Found target, return index i\n    return i\n}\n</code></pre> binary_search_edge.js<pre><code>/* Binary search for the leftmost target */\nfunction binarySearchLeftEdge(nums, target) {\n    // Equivalent to finding the insertion point of target\n    const i = binarySearchInsertion(nums, target);\n    // Target not found, return -1\n    if (i === nums.length || nums[i] !== target) {\n        return -1;\n    }\n    // Found target, return index i\n    return i;\n}\n</code></pre> binary_search_edge.ts<pre><code>/* Binary search for the leftmost target */\nfunction binarySearchLeftEdge(nums: Array&lt;number&gt;, target: number): number {\n    // Equivalent to finding the insertion point of target\n    const i = binarySearchInsertion(nums, target);\n    // Target not found, return -1\n    if (i === nums.length || nums[i] !== target) {\n        return -1;\n    }\n    // Found target, return index i\n    return i;\n}\n</code></pre> binary_search_edge.dart<pre><code>/* Binary search for the leftmost target */\nint binarySearchLeftEdge(List&lt;int&gt; nums, int target) {\n  // Equivalent to finding the insertion point of target\n  int i = binarySearchInsertion(nums, target);\n  // Target not found, return -1\n  if (i == nums.length || nums[i] != target) {\n    return -1;\n  }\n  // Found target, return index i\n  return i;\n}\n</code></pre> binary_search_edge.rs<pre><code>/* Binary search for the leftmost target */\nfn binary_search_left_edge(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // Equivalent to finding the insertion point of target\n    let i = binary_search_insertion(nums, target);\n    // Target not found, return -1\n    if i == nums.len() as i32 || nums[i as usize] != target {\n        return -1;\n    }\n    // Found target, return index i\n    i\n}\n</code></pre> binary_search_edge.c<pre><code>/* Binary search for the leftmost target */\nint binarySearchLeftEdge(int *nums, int numSize, int target) {\n    // Equivalent to finding the insertion point of target\n    int i = binarySearchInsertion(nums, numSize, target);\n    // Target not found, return -1\n    if (i == numSize || nums[i] != target) {\n        return -1;\n    }\n    // Found target, return index i\n    return i;\n}\n</code></pre> binary_search_edge.kt<pre><code>/* Binary search for the leftmost target */\nfun binarySearchLeftEdge(nums: IntArray, target: Int): Int {\n    // Equivalent to finding the insertion point of target\n    val i = binarySearchInsertion(nums, target)\n    // Target not found, return -1\n    if (i == nums.size || nums[i] != target) {\n        return -1\n    }\n    // Found target, return index i\n    return i\n}\n</code></pre> binary_search_edge.rb<pre><code>### Binary search leftmost target ###\ndef binary_search_left_edge(nums, target)\n  # Equivalent to finding the insertion point of target\n  i = binary_search_insertion(nums, target)\n\n  # Target not found, return -1\n  return -1 if i == nums.length || nums[i] != target\n\n  i # Found target, return index i\nend\n</code></pre>"},{"location":"chapter_searching/binary_search_edge/#1032-finding-the-right-boundary","title":"10.3.2 \u00a0 Finding the Right Boundary","text":"<p>So how do we find the rightmost <code>target</code>? The most direct approach is to modify the code and replace the pointer shrinking operation in the <code>nums[m] == target</code> case. The code is omitted here; interested readers can implement it themselves.</p> <p>Below we introduce two more clever methods.</p>"},{"location":"chapter_searching/binary_search_edge/#1-reusing-left-boundary-search","title":"1. \u00a0 Reusing Left Boundary Search","text":"<p>In fact, we can use the function for finding the leftmost element to find the rightmost element. The specific method is: Convert finding the rightmost <code>target</code> into finding the leftmost <code>target + 1</code>.</p> <p>As shown in Figure 10-7, after the search completes, pointer \\(i\\) points to the leftmost <code>target + 1</code> (if it exists), while \\(j\\) points to the rightmost <code>target</code>, so we can simply return \\(j\\).</p> <p></p> <p> Figure 10-7 \u00a0 Converting right boundary search to left boundary search </p> <p>Note that the returned insertion point is \\(i\\), so we need to subtract \\(1\\) from it to obtain \\(j\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_edge.py<pre><code>def binary_search_right_edge(nums: list[int], target: int) -&gt; int:\n    \"\"\"Binary search for the rightmost target\"\"\"\n    # Convert to finding the leftmost target + 1\n    i = binary_search_insertion(nums, target + 1)\n    # j points to the rightmost target, i points to the first element greater than target\n    j = i - 1\n    # Target not found, return -1\n    if j == -1 or nums[j] != target:\n        return -1\n    # Found target, return index j\n    return j\n</code></pre> binary_search_edge.cpp<pre><code>/* Binary search for the rightmost target */\nint binarySearchRightEdge(vector&lt;int&gt; &amp;nums, int target) {\n    // Convert to finding the leftmost target + 1\n    int i = binarySearchInsertion(nums, target + 1);\n    // j points to the rightmost target, i points to the first element greater than target\n    int j = i - 1;\n    // Target not found, return -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // Found target, return index j\n    return j;\n}\n</code></pre> binary_search_edge.java<pre><code>/* Binary search for the rightmost target */\nint binarySearchRightEdge(int[] nums, int target) {\n    // Convert to finding the leftmost target + 1\n    int i = binary_search_insertion.binarySearchInsertion(nums, target + 1);\n    // j points to the rightmost target, i points to the first element greater than target\n    int j = i - 1;\n    // Target not found, return -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // Found target, return index j\n    return j;\n}\n</code></pre> binary_search_edge.cs<pre><code>/* Binary search for the rightmost target */\nint BinarySearchRightEdge(int[] nums, int target) {\n    // Convert to finding the leftmost target + 1\n    int i = binary_search_insertion.BinarySearchInsertion(nums, target + 1);\n    // j points to the rightmost target, i points to the first element greater than target\n    int j = i - 1;\n    // Target not found, return -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // Found target, return index j\n    return j;\n}\n</code></pre> binary_search_edge.go<pre><code>/* Binary search for the rightmost target */\nfunc binarySearchRightEdge(nums []int, target int) int {\n    // Convert to finding the leftmost target + 1\n    i := binarySearchInsertion(nums, target+1)\n    // j points to the rightmost target, i points to the first element greater than target\n    j := i - 1\n    // Target not found, return -1\n    if j == -1 || nums[j] != target {\n        return -1\n    }\n    // Found target, return index j\n    return j\n}\n</code></pre> binary_search_edge.swift<pre><code>/* Binary search for the rightmost target */\nfunc binarySearchRightEdge(nums: [Int], target: Int) -&gt; Int {\n    // Convert to finding the leftmost target + 1\n    let i = binarySearchInsertion(nums: nums, target: target + 1)\n    // j points to the rightmost target, i points to the first element greater than target\n    let j = i - 1\n    // Target not found, return -1\n    if j == -1 || nums[j] != target {\n        return -1\n    }\n    // Found target, return index j\n    return j\n}\n</code></pre> binary_search_edge.js<pre><code>/* Binary search for the rightmost target */\nfunction binarySearchRightEdge(nums, target) {\n    // Convert to finding the leftmost target + 1\n    const i = binarySearchInsertion(nums, target + 1);\n    // j points to the rightmost target, i points to the first element greater than target\n    const j = i - 1;\n    // Target not found, return -1\n    if (j === -1 || nums[j] !== target) {\n        return -1;\n    }\n    // Found target, return index j\n    return j;\n}\n</code></pre> binary_search_edge.ts<pre><code>/* Binary search for the rightmost target */\nfunction binarySearchRightEdge(nums: Array&lt;number&gt;, target: number): number {\n    // Convert to finding the leftmost target + 1\n    const i = binarySearchInsertion(nums, target + 1);\n    // j points to the rightmost target, i points to the first element greater than target\n    const j = i - 1;\n    // Target not found, return -1\n    if (j === -1 || nums[j] !== target) {\n        return -1;\n    }\n    // Found target, return index j\n    return j;\n}\n</code></pre> binary_search_edge.dart<pre><code>/* Binary search for the rightmost target */\nint binarySearchRightEdge(List&lt;int&gt; nums, int target) {\n  // Convert to finding the leftmost target + 1\n  int i = binarySearchInsertion(nums, target + 1);\n  // j points to the rightmost target, i points to the first element greater than target\n  int j = i - 1;\n  // Target not found, return -1\n  if (j == -1 || nums[j] != target) {\n    return -1;\n  }\n  // Found target, return index j\n  return j;\n}\n</code></pre> binary_search_edge.rs<pre><code>/* Binary search for the rightmost target */\nfn binary_search_right_edge(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // Convert to finding the leftmost target + 1\n    let i = binary_search_insertion(nums, target + 1);\n    // j points to the rightmost target, i points to the first element greater than target\n    let j = i - 1;\n    // Target not found, return -1\n    if j == -1 || nums[j as usize] != target {\n        return -1;\n    }\n    // Found target, return index j\n    j\n}\n</code></pre> binary_search_edge.c<pre><code>/* Binary search for the rightmost target */\nint binarySearchRightEdge(int *nums, int numSize, int target) {\n    // Convert to finding the leftmost target + 1\n    int i = binarySearchInsertion(nums, numSize, target + 1);\n    // j points to the rightmost target, i points to the first element greater than target\n    int j = i - 1;\n    // Target not found, return -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // Found target, return index j\n    return j;\n}\n</code></pre> binary_search_edge.kt<pre><code>/* Binary search for the rightmost target */\nfun binarySearchRightEdge(nums: IntArray, target: Int): Int {\n    // Convert to finding the leftmost target + 1\n    val i = binarySearchInsertion(nums, target + 1)\n    // j points to the rightmost target, i points to the first element greater than target\n    val j = i - 1\n    // Target not found, return -1\n    if (j == -1 || nums[j] != target) {\n        return -1\n    }\n    // Found target, return index j\n    return j\n}\n</code></pre> binary_search_edge.rb<pre><code>### Binary search rightmost target ###\ndef binary_search_right_edge(nums, target)\n  # Convert to finding the leftmost target + 1\n  i = binary_search_insertion(nums, target + 1)\n\n  # j points to the rightmost target, i points to the first element greater than target\n  j = i - 1\n\n  # Target not found, return -1\n  return -1 if j == -1 || nums[j] != target\n\n  j # Found target, return index j\nend\n</code></pre>"},{"location":"chapter_searching/binary_search_edge/#2-converting-to-element-search","title":"2. \u00a0 Converting to Element Search","text":"<p>We know that when the array does not contain <code>target</code>, \\(i\\) and \\(j\\) will eventually point to the first elements greater than and less than <code>target</code>, respectively.</p> <p>Therefore, as shown in Figure 10-8, we can construct an element that does not exist in the array to find the left and right boundaries.</p> <ul> <li>Finding the leftmost <code>target</code>: Can be converted to finding <code>target - 0.5</code> and returning pointer \\(i\\).</li> <li>Finding the rightmost <code>target</code>: Can be converted to finding <code>target + 0.5</code> and returning pointer \\(j\\).</li> </ul> <p></p> <p> Figure 10-8 \u00a0 Converting boundary search to element search </p> <p>The code is omitted here, but the following two points are worth noting:</p> <ul> <li>Since the given array does not contain decimals, we don't need to worry about how to handle equal cases.</li> <li>Because this method introduces decimals, the variable <code>target</code> in the function needs to be changed to a floating-point type (Python does not require this change).</li> </ul>"},{"location":"chapter_searching/binary_search_insertion/","title":"10.2 \u00a0 Binary Search Insertion Point","text":"<p>Binary search can not only be used to search for target elements but also to solve many variant problems, such as searching for the insertion position of a target element.</p>"},{"location":"chapter_searching/binary_search_insertion/#1021-case-without-duplicate-elements","title":"10.2.1 \u00a0 Case Without Duplicate Elements","text":"<p>Question</p> <p>Given a sorted array <code>nums</code> of length \\(n\\) and an element <code>target</code>, where the array contains no duplicate elements. Insert <code>target</code> into the array <code>nums</code> while maintaining its sorted order. If the array already contains the element <code>target</code>, insert it to its left. Return the index of <code>target</code> in the array after insertion. An example is shown in Figure 10-4.</p> <p></p> <p> Figure 10-4 \u00a0 Binary search insertion point example data </p> <p>If we want to reuse the binary search code from the previous section, we need to answer the following two questions.</p> <p>Question 1: When the array contains <code>target</code>, is the insertion point index the same as that element's index?</p> <p>The problem requires inserting <code>target</code> to the left of equal elements, which means the newly inserted <code>target</code> replaces the position of the original <code>target</code>. In other words, when the array contains <code>target</code>, the insertion point index is the index of that <code>target</code>.</p> <p>Question 2: When the array does not contain <code>target</code>, what is the insertion point index?</p> <p>Further consider the binary search process: When <code>nums[m] &lt; target</code>, \\(i\\) moves, which means pointer \\(i\\) is approaching elements greater than or equal to <code>target</code>. Similarly, pointer \\(j\\) is always approaching elements less than or equal to <code>target</code>.</p> <p>Therefore, when the binary search ends, we must have: \\(i\\) points to the first element greater than <code>target</code>, and \\(j\\) points to the first element less than <code>target</code>. It's easy to see that when the array does not contain <code>target</code>, the insertion index is \\(i\\). The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_insertion.py<pre><code>def binary_search_insertion_simple(nums: list[int], target: int) -&gt; int:\n    \"\"\"Binary search for insertion point (no duplicate elements)\"\"\"\n    i, j = 0, len(nums) - 1  # Initialize closed interval [0, n-1]\n    while i &lt;= j:\n        m = (i + j) // 2  # Calculate midpoint index m\n        if nums[m] &lt; target:\n            i = m + 1  # target is in the interval [m+1, j]\n        elif nums[m] &gt; target:\n            j = m - 1  # target is in the interval [i, m-1]\n        else:\n            return m  # Found target, return insertion point m\n    # Target not found, return insertion point i\n    return i\n</code></pre> binary_search_insertion.cpp<pre><code>/* Binary search for insertion point (no duplicate elements) */\nint binarySearchInsertionSimple(vector&lt;int&gt; &amp;nums, int target) {\n    int i = 0, j = nums.size() - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            return m; // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.java<pre><code>/* Binary search for insertion point (no duplicate elements) */\nint binarySearchInsertionSimple(int[] nums, int target) {\n    int i = 0, j = nums.length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            return m; // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.cs<pre><code>/* Binary search for insertion point (no duplicate elements) */\nint BinarySearchInsertionSimple(int[] nums, int target) {\n    int i = 0, j = nums.Length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            return m; // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.go<pre><code>/* Binary search for insertion point (no duplicate elements) */\nfunc binarySearchInsertionSimple(nums []int, target int) int {\n    // Initialize closed interval [0, n-1]\n    i, j := 0, len(nums)-1\n    for i &lt;= j {\n        // Calculate the midpoint index m\n        m := i + (j-i)/2\n        if nums[m] &lt; target {\n            // target is in the interval [m+1, j]\n            i = m + 1\n        } else if nums[m] &gt; target {\n            // target is in the interval [i, m-1]\n            j = m - 1\n        } else {\n            // Found target, return insertion point m\n            return m\n        }\n    }\n    // Target not found, return insertion point i\n    return i\n}\n</code></pre> binary_search_insertion.swift<pre><code>/* Binary search for insertion point (no duplicate elements) */\nfunc binarySearchInsertionSimple(nums: [Int], target: Int) -&gt; Int {\n    // Initialize closed interval [0, n-1]\n    var i = nums.startIndex\n    var j = nums.endIndex - 1\n    while i &lt;= j {\n        let m = i + (j - i) / 2 // Calculate the midpoint index m\n        if nums[m] &lt; target {\n            i = m + 1 // target is in the interval [m+1, j]\n        } else if nums[m] &gt; target {\n            j = m - 1 // target is in the interval [i, m-1]\n        } else {\n            return m // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i\n}\n</code></pre> binary_search_insertion.js<pre><code>/* Binary search for insertion point (no duplicate elements) */\nfunction binarySearchInsertionSimple(nums, target) {\n    let i = 0,\n        j = nums.length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // Calculate midpoint index m, use Math.floor() to round down\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            return m; // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.ts<pre><code>/* Binary search for insertion point (no duplicate elements) */\nfunction binarySearchInsertionSimple(\n    nums: Array&lt;number&gt;,\n    target: number\n): number {\n    let i = 0,\n        j = nums.length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // Calculate midpoint index m, use Math.floor() to round down\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            return m; // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.dart<pre><code>/* Binary search for insertion point (no duplicate elements) */\nint binarySearchInsertionSimple(List&lt;int&gt; nums, int target) {\n  int i = 0, j = nums.length - 1; // Initialize closed interval [0, n-1]\n  while (i &lt;= j) {\n    int m = i + (j - i) ~/ 2; // Calculate the midpoint index m\n    if (nums[m] &lt; target) {\n      i = m + 1; // target is in the interval [m+1, j]\n    } else if (nums[m] &gt; target) {\n      j = m - 1; // target is in the interval [i, m-1]\n    } else {\n      return m; // Found target, return insertion point m\n    }\n  }\n  // Target not found, return insertion point i\n  return i;\n}\n</code></pre> binary_search_insertion.rs<pre><code>/* Binary search for insertion point (no duplicate elements) */\nfn binary_search_insertion_simple(nums: &amp;[i32], target: i32) -&gt; i32 {\n    let (mut i, mut j) = (0, nums.len() as i32 - 1); // Initialize closed interval [0, n-1]\n    while i &lt;= j {\n        let m = i + (j - i) / 2; // Calculate the midpoint index m\n        if nums[m as usize] &lt; target {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if nums[m as usize] &gt; target {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            return m;\n        }\n    }\n    // Target not found, return insertion point i\n    i\n}\n</code></pre> binary_search_insertion.c<pre><code>/* Binary search for insertion point (no duplicate elements) */\nint binarySearchInsertionSimple(int *nums, int numSize, int target) {\n    int i = 0, j = numSize - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            return m; // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.kt<pre><code>/* Binary search for insertion point (no duplicate elements) */\nfun binarySearchInsertionSimple(nums: IntArray, target: Int): Int {\n    var i = 0\n    var j = nums.size - 1 // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        val m = i + (j - i) / 2 // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1 // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1 // target is in the interval [i, m-1]\n        } else {\n            return m // Found target, return insertion point m\n        }\n    }\n    // Target not found, return insertion point i\n    return i\n}\n</code></pre> binary_search_insertion.rb<pre><code>### Binary search insertion point (no duplicates) ###\ndef binary_search_insertion_simple(nums, target)\n  # Initialize closed interval [0, n-1]\n  i, j = 0, nums.length - 1\n\n  while i &lt;= j\n    # Calculate the midpoint index m\n    m = (i + j) / 2\n\n    if nums[m] &lt; target\n      i = m + 1 # target is in the interval [m+1, j]\n    elsif nums[m] &gt; target\n      j = m - 1 # target is in the interval [i, m-1]\n    else\n      return m  # Found target, return insertion point m\n    end\n  end\n\n  i # Target not found, return insertion point i\nend\n</code></pre>"},{"location":"chapter_searching/binary_search_insertion/#1022-case-with-duplicate-elements","title":"10.2.2 \u00a0 Case with Duplicate Elements","text":"<p>Question</p> <p>Based on the previous problem, assume the array may contain duplicate elements, with everything else remaining the same.</p> <p>Suppose there are multiple <code>target</code> elements in the array. Ordinary binary search can only return the index of one <code>target</code>, and cannot determine how many <code>target</code> elements are to the left and right of that element.</p> <p>The problem requires inserting the target element at the leftmost position, so we need to find the index of the leftmost <code>target</code> in the array. Initially, consider implementing this through the steps shown in Figure 10-5:</p> <ol> <li>Perform binary search to obtain the index of any <code>target</code>, denoted as \\(k\\).</li> <li>Starting from index \\(k\\), perform linear traversal to the left, and return when the leftmost <code>target</code> is found.</li> </ol> <p></p> <p> Figure 10-5 \u00a0 Linear search for insertion point of duplicate elements </p> <p>Although this method works, it includes linear search, resulting in a time complexity of \\(O(n)\\). When the array contains many duplicate <code>target</code> elements, this method is very inefficient.</p> <p>Now consider extending the binary search code. As shown in Figure 10-6, the overall process remains unchanged: calculate the midpoint index \\(m\\) in each round, then compare <code>target</code> with <code>nums[m]</code>, divided into the following cases:</p> <ul> <li>When <code>nums[m] &lt; target</code> or <code>nums[m] &gt; target</code>, it means <code>target</code> has not been found yet, so use the ordinary binary search interval narrowing operation to make pointers \\(i\\) and \\(j\\) approach <code>target</code>.</li> <li>When <code>nums[m] == target</code>, it means elements less than <code>target</code> are in the interval \\([i, m - 1]\\), so use \\(j = m - 1\\) to narrow the interval, thereby making pointer \\(j\\) approach elements less than <code>target</code>.</li> </ul> <p>After the loop completes, \\(i\\) points to the leftmost <code>target</code>, and \\(j\\) points to the first element less than <code>target</code>, so index \\(i\\) is the insertion point.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 10-6 \u00a0 Steps for binary search insertion point of duplicate elements </p> <p>Observe the following code: the operations for branches <code>nums[m] &gt; target</code> and <code>nums[m] == target</code> are the same, so the two can be merged.</p> <p>Even so, we can still keep the conditional branches expanded, as the logic is clearer and more readable.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_insertion.py<pre><code>def binary_search_insertion(nums: list[int], target: int) -&gt; int:\n    \"\"\"Binary search for insertion point (with duplicate elements)\"\"\"\n    i, j = 0, len(nums) - 1  # Initialize closed interval [0, n-1]\n    while i &lt;= j:\n        m = (i + j) // 2  # Calculate midpoint index m\n        if nums[m] &lt; target:\n            i = m + 1  # target is in the interval [m+1, j]\n        elif nums[m] &gt; target:\n            j = m - 1  # target is in the interval [i, m-1]\n        else:\n            j = m - 1  # The first element less than target is in the interval [i, m-1]\n    # Return insertion point i\n    return i\n</code></pre> binary_search_insertion.cpp<pre><code>/* Binary search for insertion point (with duplicate elements) */\nint binarySearchInsertion(vector&lt;int&gt; &amp;nums, int target) {\n    int i = 0, j = nums.size() - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            j = m - 1; // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.java<pre><code>/* Binary search for insertion point (with duplicate elements) */\nint binarySearchInsertion(int[] nums, int target) {\n    int i = 0, j = nums.length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            j = m - 1; // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.cs<pre><code>/* Binary search for insertion point (with duplicate elements) */\nint BinarySearchInsertion(int[] nums, int target) {\n    int i = 0, j = nums.Length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            j = m - 1; // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.go<pre><code>/* Binary search for insertion point (with duplicate elements) */\nfunc binarySearchInsertion(nums []int, target int) int {\n    // Initialize closed interval [0, n-1]\n    i, j := 0, len(nums)-1\n    for i &lt;= j {\n        // Calculate the midpoint index m\n        m := i + (j-i)/2\n        if nums[m] &lt; target {\n            // target is in the interval [m+1, j]\n            i = m + 1\n        } else if nums[m] &gt; target {\n            // target is in the interval [i, m-1]\n            j = m - 1\n        } else {\n            // The first element less than target is in the interval [i, m-1]\n            j = m - 1\n        }\n    }\n    // Return insertion point i\n    return i\n}\n</code></pre> binary_search_insertion.swift<pre><code>/* Binary search for insertion point (with duplicate elements) */\nfunc binarySearchInsertion(nums: [Int], target: Int) -&gt; Int {\n    // Initialize closed interval [0, n-1]\n    var i = nums.startIndex\n    var j = nums.endIndex - 1\n    while i &lt;= j {\n        let m = i + (j - i) / 2 // Calculate the midpoint index m\n        if nums[m] &lt; target {\n            i = m + 1 // target is in the interval [m+1, j]\n        } else if nums[m] &gt; target {\n            j = m - 1 // target is in the interval [i, m-1]\n        } else {\n            j = m - 1 // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i\n}\n</code></pre> binary_search_insertion.js<pre><code>/* Binary search for insertion point (with duplicate elements) */\nfunction binarySearchInsertion(nums, target) {\n    let i = 0,\n        j = nums.length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // Calculate midpoint index m, use Math.floor() to round down\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            j = m - 1; // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.ts<pre><code>/* Binary search for insertion point (with duplicate elements) */\nfunction binarySearchInsertion(nums: Array&lt;number&gt;, target: number): number {\n    let i = 0,\n        j = nums.length - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // Calculate midpoint index m, use Math.floor() to round down\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            j = m - 1; // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.dart<pre><code>/* Binary search for insertion point (with duplicate elements) */\nint binarySearchInsertion(List&lt;int&gt; nums, int target) {\n  int i = 0, j = nums.length - 1; // Initialize closed interval [0, n-1]\n  while (i &lt;= j) {\n    int m = i + (j - i) ~/ 2; // Calculate the midpoint index m\n    if (nums[m] &lt; target) {\n      i = m + 1; // target is in the interval [m+1, j]\n    } else if (nums[m] &gt; target) {\n      j = m - 1; // target is in the interval [i, m-1]\n    } else {\n      j = m - 1; // The first element less than target is in the interval [i, m-1]\n    }\n  }\n  // Return insertion point i\n  return i;\n}\n</code></pre> binary_search_insertion.rs<pre><code>/* Binary search for insertion point (with duplicate elements) */\npub fn binary_search_insertion(nums: &amp;[i32], target: i32) -&gt; i32 {\n    let (mut i, mut j) = (0, nums.len() as i32 - 1); // Initialize closed interval [0, n-1]\n    while i &lt;= j {\n        let m = i + (j - i) / 2; // Calculate the midpoint index m\n        if nums[m as usize] &lt; target {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if nums[m as usize] &gt; target {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            j = m - 1; // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    i\n}\n</code></pre> binary_search_insertion.c<pre><code>/* Binary search for insertion point (with duplicate elements) */\nint binarySearchInsertion(int *nums, int numSize, int target) {\n    int i = 0, j = numSize - 1; // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target is in the interval [i, m-1]\n        } else {\n            j = m - 1; // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i;\n}\n</code></pre> binary_search_insertion.kt<pre><code>/* Binary search for insertion point (with duplicate elements) */\nfun binarySearchInsertion(nums: IntArray, target: Int): Int {\n    var i = 0\n    var j = nums.size - 1 // Initialize closed interval [0, n-1]\n    while (i &lt;= j) {\n        val m = i + (j - i) / 2 // Calculate the midpoint index m\n        if (nums[m] &lt; target) {\n            i = m + 1 // target is in the interval [m+1, j]\n        } else if (nums[m] &gt; target) {\n            j = m - 1 // target is in the interval [i, m-1]\n        } else {\n            j = m - 1 // The first element less than target is in the interval [i, m-1]\n        }\n    }\n    // Return insertion point i\n    return i\n}\n</code></pre> binary_search_insertion.rb<pre><code>### Binary search insertion point (with duplicates) ###\ndef binary_search_insertion(nums, target)\n  # Initialize closed interval [0, n-1]\n  i, j = 0, nums.length - 1\n\n  while i &lt;= j\n    # Calculate the midpoint index m\n    m = (i + j) / 2\n\n    if nums[m] &lt; target\n      i = m + 1 # target is in the interval [m+1, j]\n    elsif nums[m] &gt; target\n      j = m - 1 # target is in the interval [i, m-1]\n    else\n      j = m - 1 # The first element less than target is in the interval [i, m-1]\n    end\n  end\n\n  i # Return insertion point i\nend\n</code></pre> <p>Tip</p> <p>The code in this section all uses the \"closed interval\" approach. Interested readers can implement the \"left-closed right-open\" approach themselves.</p> <p>Overall, binary search is simply about setting search targets for pointers \\(i\\) and \\(j\\) separately. The target could be a specific element (such as <code>target</code>) or a range of elements (such as elements less than <code>target</code>).</p> <p>Through continuous binary iterations, both pointers \\(i\\) and \\(j\\) gradually approach their preset targets. Ultimately, they either successfully find the answer or stop after crossing the boundaries.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/","title":"10.4 \u00a0 Hash Optimization Strategy","text":"<p>In algorithm problems, we often reduce the time complexity of algorithms by replacing linear search with hash-based search. Let's use an algorithm problem to deepen our understanding.</p> <p>Question</p> <p>Given an integer array <code>nums</code> and a target element <code>target</code>, search for two elements in the array whose \"sum\" equals <code>target</code>, and return their array indices. Any solution will do.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/#1041-linear-search-trading-time-for-space","title":"10.4.1 \u00a0 Linear Search: Trading Time for Space","text":"<p>Consider directly traversing all possible combinations. As shown in Figure 10-9, we open a two-layer loop and judge in each round whether the sum of two integers equals <code>target</code>. If so, return their indices.</p> <p></p> <p> Figure 10-9 \u00a0 Linear search solution for two sum </p> <p>The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby two_sum.py<pre><code>def two_sum_brute_force(nums: list[int], target: int) -&gt; list[int]:\n    \"\"\"Method 1: Brute force enumeration\"\"\"\n    # Two nested loops, time complexity is O(n^2)\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n</code></pre> two_sum.cpp<pre><code>/* Method 1: Brute force enumeration */\nvector&lt;int&gt; twoSumBruteForce(vector&lt;int&gt; &amp;nums, int target) {\n    int size = nums.size();\n    // Two nested loops, time complexity is O(n^2)\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = i + 1; j &lt; size; j++) {\n            if (nums[i] + nums[j] == target)\n                return {i, j};\n        }\n    }\n    return {};\n}\n</code></pre> two_sum.java<pre><code>/* Method 1: Brute force enumeration */\nint[] twoSumBruteForce(int[] nums, int target) {\n    int size = nums.length;\n    // Two nested loops, time complexity is O(n^2)\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = i + 1; j &lt; size; j++) {\n            if (nums[i] + nums[j] == target)\n                return new int[] { i, j };\n        }\n    }\n    return new int[0];\n}\n</code></pre> two_sum.cs<pre><code>/* Method 1: Brute force enumeration */\nint[] TwoSumBruteForce(int[] nums, int target) {\n    int size = nums.Length;\n    // Two nested loops, time complexity is O(n^2)\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = i + 1; j &lt; size; j++) {\n            if (nums[i] + nums[j] == target)\n                return [i, j];\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.go<pre><code>/* Method 1: Brute force enumeration */\nfunc twoSumBruteForce(nums []int, target int) []int {\n    size := len(nums)\n    // Two nested loops, time complexity is O(n^2)\n    for i := 0; i &lt; size-1; i++ {\n        for j := i + 1; j &lt; size; j++ {\n            if nums[i]+nums[j] == target {\n                return []int{i, j}\n            }\n        }\n    }\n    return nil\n}\n</code></pre> two_sum.swift<pre><code>/* Method 1: Brute force enumeration */\nfunc twoSumBruteForce(nums: [Int], target: Int) -&gt; [Int] {\n    // Two nested loops, time complexity is O(n^2)\n    for i in nums.indices.dropLast() {\n        for j in nums.indices.dropFirst(i + 1) {\n            if nums[i] + nums[j] == target {\n                return [i, j]\n            }\n        }\n    }\n    return [0]\n}\n</code></pre> two_sum.js<pre><code>/* Method 1: Brute force enumeration */\nfunction twoSumBruteForce(nums, target) {\n    const n = nums.length;\n    // Two nested loops, time complexity is O(n^2)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.ts<pre><code>/* Method 1: Brute force enumeration */\nfunction twoSumBruteForce(nums: number[], target: number): number[] {\n    const n = nums.length;\n    // Two nested loops, time complexity is O(n^2)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.dart<pre><code>/* Method 1: Brute force enumeration */\nList&lt;int&gt; twoSumBruteForce(List&lt;int&gt; nums, int target) {\n  int size = nums.length;\n  // Two nested loops, time complexity is O(n^2)\n  for (var i = 0; i &lt; size - 1; i++) {\n    for (var j = i + 1; j &lt; size; j++) {\n      if (nums[i] + nums[j] == target) return [i, j];\n    }\n  }\n  return [0];\n}\n</code></pre> two_sum.rs<pre><code>/* Method 1: Brute force enumeration */\npub fn two_sum_brute_force(nums: &amp;Vec&lt;i32&gt;, target: i32) -&gt; Option&lt;Vec&lt;i32&gt;&gt; {\n    let size = nums.len();\n    // Two nested loops, time complexity is O(n^2)\n    for i in 0..size - 1 {\n        for j in i + 1..size {\n            if nums[i] + nums[j] == target {\n                return Some(vec![i as i32, j as i32]);\n            }\n        }\n    }\n    None\n}\n</code></pre> two_sum.c<pre><code>/* Method 1: Brute force enumeration */\nint *twoSumBruteForce(int *nums, int numsSize, int target, int *returnSize) {\n    for (int i = 0; i &lt; numsSize; ++i) {\n        for (int j = i + 1; j &lt; numsSize; ++j) {\n            if (nums[i] + nums[j] == target) {\n                int *res = malloc(sizeof(int) * 2);\n                res[0] = i, res[1] = j;\n                *returnSize = 2;\n                return res;\n            }\n        }\n    }\n    *returnSize = 0;\n    return NULL;\n}\n</code></pre> two_sum.kt<pre><code>/* Method 1: Brute force enumeration */\nfun twoSumBruteForce(nums: IntArray, target: Int): IntArray {\n    val size = nums.size\n    // Two nested loops, time complexity is O(n^2)\n    for (i in 0..&lt;size - 1) {\n        for (j in i + 1..&lt;size) {\n            if (nums[i] + nums[j] == target) return intArrayOf(i, j)\n        }\n    }\n    return IntArray(0)\n}\n</code></pre> two_sum.rb<pre><code>### Method 1: Brute force enumeration ###\ndef two_sum_brute_force(nums, target)\n  # Two nested loops, time complexity is O(n^2)\n  for i in 0...(nums.length - 1)\n    for j in (i + 1)...nums.length\n      return [i, j] if nums[i] + nums[j] == target\n    end\n  end\n\n  []\nend\n</code></pre> <p>This method has a time complexity of \\(O(n^2)\\) and a space complexity of \\(O(1)\\), which is very time-consuming with large data volumes.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/#1042-hash-based-search-trading-space-for-time","title":"10.4.2 \u00a0 Hash-Based Search: Trading Space for Time","text":"<p>Consider using a hash table where key-value pairs are array elements and element indices respectively. Loop through the array, performing the steps shown in Figure 10-10 in each round:</p> <ol> <li>Check if the number <code>target - nums[i]</code> is in the hash table. If so, directly return the indices of these two elements.</li> <li>Add the key-value pair <code>nums[i]</code> and index <code>i</code> to the hash table.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt; <p></p> <p></p> <p></p> <p> Figure 10-10 \u00a0 Hash table solution for two sum </p> <p>The implementation code is shown below, requiring only a single loop:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby two_sum.py<pre><code>def two_sum_hash_table(nums: list[int], target: int) -&gt; list[int]:\n    \"\"\"Method 2: Auxiliary hash table\"\"\"\n    # Auxiliary hash table, space complexity is O(n)\n    dic = {}\n    # Single loop, time complexity is O(n)\n    for i in range(len(nums)):\n        if target - nums[i] in dic:\n            return [dic[target - nums[i]], i]\n        dic[nums[i]] = i\n    return []\n</code></pre> two_sum.cpp<pre><code>/* Method 2: Auxiliary hash table */\nvector&lt;int&gt; twoSumHashTable(vector&lt;int&gt; &amp;nums, int target) {\n    int size = nums.size();\n    // Auxiliary hash table, space complexity is O(n)\n    unordered_map&lt;int, int&gt; dic;\n    // Single loop, time complexity is O(n)\n    for (int i = 0; i &lt; size; i++) {\n        if (dic.find(target - nums[i]) != dic.end()) {\n            return {dic[target - nums[i]], i};\n        }\n        dic.emplace(nums[i], i);\n    }\n    return {};\n}\n</code></pre> two_sum.java<pre><code>/* Method 2: Auxiliary hash table */\nint[] twoSumHashTable(int[] nums, int target) {\n    int size = nums.length;\n    // Auxiliary hash table, space complexity is O(n)\n    Map&lt;Integer, Integer&gt; dic = new HashMap&lt;&gt;();\n    // Single loop, time complexity is O(n)\n    for (int i = 0; i &lt; size; i++) {\n        if (dic.containsKey(target - nums[i])) {\n            return new int[] { dic.get(target - nums[i]), i };\n        }\n        dic.put(nums[i], i);\n    }\n    return new int[0];\n}\n</code></pre> two_sum.cs<pre><code>/* Method 2: Auxiliary hash table */\nint[] TwoSumHashTable(int[] nums, int target) {\n    int size = nums.Length;\n    // Auxiliary hash table, space complexity is O(n)\n    Dictionary&lt;int, int&gt; dic = [];\n    // Single loop, time complexity is O(n)\n    for (int i = 0; i &lt; size; i++) {\n        if (dic.ContainsKey(target - nums[i])) {\n            return [dic[target - nums[i]], i];\n        }\n        dic.Add(nums[i], i);\n    }\n    return [];\n}\n</code></pre> two_sum.go<pre><code>/* Method 2: Auxiliary hash table */\nfunc twoSumHashTable(nums []int, target int) []int {\n    // Auxiliary hash table, space complexity is O(n)\n    hashTable := map[int]int{}\n    // Single loop, time complexity is O(n)\n    for idx, val := range nums {\n        if preIdx, ok := hashTable[target-val]; ok {\n            return []int{preIdx, idx}\n        }\n        hashTable[val] = idx\n    }\n    return nil\n}\n</code></pre> two_sum.swift<pre><code>/* Method 2: Auxiliary hash table */\nfunc twoSumHashTable(nums: [Int], target: Int) -&gt; [Int] {\n    // Auxiliary hash table, space complexity is O(n)\n    var dic: [Int: Int] = [:]\n    // Single loop, time complexity is O(n)\n    for i in nums.indices {\n        if let j = dic[target - nums[i]] {\n            return [j, i]\n        }\n        dic[nums[i]] = i\n    }\n    return [0]\n}\n</code></pre> two_sum.js<pre><code>/* Method 2: Auxiliary hash table */\nfunction twoSumHashTable(nums, target) {\n    // Auxiliary hash table, space complexity is O(n)\n    let m = {};\n    // Single loop, time complexity is O(n)\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (m[target - nums[i]] !== undefined) {\n            return [m[target - nums[i]], i];\n        } else {\n            m[nums[i]] = i;\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.ts<pre><code>/* Method 2: Auxiliary hash table */\nfunction twoSumHashTable(nums: number[], target: number): number[] {\n    // Auxiliary hash table, space complexity is O(n)\n    let m: Map&lt;number, number&gt; = new Map();\n    // Single loop, time complexity is O(n)\n    for (let i = 0; i &lt; nums.length; i++) {\n        let index = m.get(target - nums[i]);\n        if (index !== undefined) {\n            return [index, i];\n        } else {\n            m.set(nums[i], i);\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.dart<pre><code>/* Method 2: Auxiliary hash table */\nList&lt;int&gt; twoSumHashTable(List&lt;int&gt; nums, int target) {\n  int size = nums.length;\n  // Auxiliary hash table, space complexity is O(n)\n  Map&lt;int, int&gt; dic = HashMap();\n  // Single loop, time complexity is O(n)\n  for (var i = 0; i &lt; size; i++) {\n    if (dic.containsKey(target - nums[i])) {\n      return [dic[target - nums[i]]!, i];\n    }\n    dic.putIfAbsent(nums[i], () =&gt; i);\n  }\n  return [0];\n}\n</code></pre> two_sum.rs<pre><code>/* Method 2: Auxiliary hash table */\npub fn two_sum_hash_table(nums: &amp;Vec&lt;i32&gt;, target: i32) -&gt; Option&lt;Vec&lt;i32&gt;&gt; {\n    // Auxiliary hash table, space complexity is O(n)\n    let mut dic = HashMap::new();\n    // Single loop, time complexity is O(n)\n    for (i, num) in nums.iter().enumerate() {\n        match dic.get(&amp;(target - num)) {\n            Some(v) =&gt; return Some(vec![*v as i32, i as i32]),\n            None =&gt; dic.insert(num, i as i32),\n        };\n    }\n    None\n}\n</code></pre> two_sum.c<pre><code>/* Hash table */\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh; // Implemented using uthash.h\n} HashTable;\n\n/* Hash table lookup */\nHashTable *find(HashTable *h, int key) {\n    HashTable *tmp;\n    HASH_FIND_INT(h, &amp;key, tmp);\n    return tmp;\n}\n\n/* Hash table element insertion */\nvoid insert(HashTable **h, int key, int val) {\n    HashTable *t = find(*h, key);\n    if (t == NULL) {\n        HashTable *tmp = malloc(sizeof(HashTable));\n        tmp-&gt;key = key, tmp-&gt;val = val;\n        HASH_ADD_INT(*h, key, tmp);\n    } else {\n        t-&gt;val = val;\n    }\n}\n\n/* Method 2: Auxiliary hash table */\nint *twoSumHashTable(int *nums, int numsSize, int target, int *returnSize) {\n    HashTable *hashtable = NULL;\n    for (int i = 0; i &lt; numsSize; i++) {\n        HashTable *t = find(hashtable, target - nums[i]);\n        if (t != NULL) {\n            int *res = malloc(sizeof(int) * 2);\n            res[0] = t-&gt;val, res[1] = i;\n            *returnSize = 2;\n            return res;\n        }\n        insert(&amp;hashtable, nums[i], i);\n    }\n    *returnSize = 0;\n    return NULL;\n}\n</code></pre> two_sum.kt<pre><code>/* Method 2: Auxiliary hash table */\nfun twoSumHashTable(nums: IntArray, target: Int): IntArray {\n    val size = nums.size\n    // Auxiliary hash table, space complexity is O(n)\n    val dic = HashMap&lt;Int, Int&gt;()\n    // Single loop, time complexity is O(n)\n    for (i in 0..&lt;size) {\n        if (dic.containsKey(target - nums[i])) {\n            return intArrayOf(dic[target - nums[i]]!!, i)\n        }\n        dic[nums[i]] = i\n    }\n    return IntArray(0)\n}\n</code></pre> two_sum.rb<pre><code>### Method 2: Auxiliary hash table ###\ndef two_sum_hash_table(nums, target)\n  # Auxiliary hash table, space complexity is O(n)\n  dic = {}\n  # Single loop, time complexity is O(n)\n  for i in 0...nums.length\n    return [dic[target - nums[i]], i] if dic.has_key?(target - nums[i])\n\n    dic[nums[i]] = i\n  end\n\n  []\nend\n</code></pre> <p>This method reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) through hash-based search, greatly improving runtime efficiency.</p> <p>Since an additional hash table needs to be maintained, the space complexity is \\(O(n)\\). Nevertheless, this method achieves a more balanced overall time-space efficiency, making it the optimal solution for this problem.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/","title":"10.5 \u00a0 Searching Algorithms Revisited","text":"<p>Searching algorithms are used to search for one or a group of elements that meet specific conditions in data structures (such as arrays, linked lists, trees, or graphs).</p> <p>Searching algorithms can be divided into the following two categories based on their implementation approach:</p> <ul> <li>Locating target elements by traversing the data structure, such as traversing arrays, linked lists, trees, and graphs.</li> <li>Achieving efficient element search by utilizing data organization structure or prior information contained in the data, such as binary search, hash-based search, and binary search tree search.</li> </ul> <p>It's not hard to see that these topics have all been covered in previous chapters, so searching algorithms are not unfamiliar to us. In this section, we will approach from a more systematic perspective and re-examine searching algorithms.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#1051-brute-force-search","title":"10.5.1 \u00a0 Brute-Force Search","text":"<p>Brute-force search locates target elements by traversing each element of the data structure.</p> <ul> <li>\"Linear search\" is applicable to linear data structures such as arrays and linked lists. It starts from one end of the data structure and accesses elements one by one until the target element is found or the other end is reached without finding the target element.</li> <li>\"Breadth-first search\" and \"depth-first search\" are two traversal strategies for graphs and trees. Breadth-first search starts from the initial node and searches layer by layer, visiting nodes from near to far. Depth-first search starts from the initial node, follows a path to the end, then backtracks and tries other paths until the entire data structure is traversed.</li> </ul> <p>The advantage of brute-force search is that it is simple and has good generality, requiring no data preprocessing or additional data structures.</p> <p>However, the time complexity of such algorithms is \\(O(n)\\), where \\(n\\) is the number of elements, so performance is poor when dealing with large amounts of data.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#1052-adaptive-search","title":"10.5.2 \u00a0 Adaptive Search","text":"<p>Adaptive search utilizes the unique properties of data (such as orderliness) to optimize the search process, thereby locating target elements more efficiently.</p> <ul> <li>\"Binary search\" uses the orderliness of data to achieve efficient searching, applicable only to arrays.</li> <li>\"Hash-based search\" uses hash tables to establish key-value pair mappings between search data and target data, thereby achieving query operations.</li> <li>\"Tree search\" in specific tree structures (such as binary search trees), quickly eliminates nodes based on comparing node values to locate target elements.</li> </ul> <p>The advantage of such algorithms is high efficiency, with time complexity reaching \\(O(\\log n)\\) or even \\(O(1)\\).</p> <p>However, using these algorithms often requires data preprocessing. For example, binary search requires pre-sorting the array, while hash-based search and tree search both require additional data structures, and maintaining these data structures also requires extra time and space overhead.</p> <p>Tip</p> <p>Adaptive search algorithms are often called lookup algorithms, mainly used to quickly retrieve target elements in specific data structures.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#1053-search-method-selection","title":"10.5.3 \u00a0 Search Method Selection","text":"<p>Given a dataset of size \\(n\\), we can use linear search, binary search, tree search, hash-based search, and other methods to search for the target element. The working principles of each method are shown in Figure 10-11.</p> <p></p> <p> Figure 10-11 \u00a0 Multiple search strategies </p> <p>The operational efficiency and characteristics of the above methods are as follows:</p> <p> Table 10-1 \u00a0 Comparison of search algorithm efficiency </p> Linear search Binary search Tree search Hash-based search Search element \\(O(n)\\) \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(1)\\) Insert element \\(O(1)\\) \\(O(n)\\) \\(O(\\log n)\\) \\(O(1)\\) Delete element \\(O(n)\\) \\(O(n)\\) \\(O(\\log n)\\) \\(O(1)\\) Extra space \\(O(1)\\) \\(O(1)\\) \\(O(n)\\) \\(O(n)\\) Data preprocessing / Sorting \\(O(n \\log n)\\) Tree building \\(O(n \\log n)\\) Hash table building \\(O(n)\\) Data ordered Unordered Ordered Ordered Unordered <p>The choice of search algorithm also depends on data volume, search performance requirements, data query and update frequency, etc.</p> <p>Linear search</p> <ul> <li>Good generality, requiring no data preprocessing operations. If we only need to query the data once, the data preprocessing time for the other three methods would be longer than linear search.</li> <li>Suitable for small data volumes, where time complexity has less impact on efficiency.</li> <li>Suitable for scenarios with high data update frequency, as this method does not require any additional data maintenance.</li> </ul> <p>Binary search</p> <ul> <li>Suitable for large data volumes with stable efficiency performance, worst-case time complexity of \\(O(\\log n)\\).</li> <li>Data volume cannot be too large, as storing arrays requires contiguous memory space.</li> <li>Not suitable for scenarios with frequent data insertion and deletion, as maintaining a sorted array has high overhead.</li> </ul> <p>Hash-based search</p> <ul> <li>Suitable for scenarios with high query performance requirements, with an average time complexity of \\(O(1)\\).</li> <li>Not suitable for scenarios requiring ordered data or range searches, as hash tables cannot maintain data orderliness.</li> <li>High dependence on hash functions and hash collision handling strategies, with significant risk of performance degradation.</li> <li>Not suitable for excessively large data volumes, as hash tables require extra space to minimize collisions and thus provide good query performance.</li> </ul> <p>Tree search</p> <ul> <li>Suitable for massive data, as tree nodes are stored dispersedly in memory.</li> <li>Suitable for scenarios requiring maintained ordered data or range searches.</li> <li>During continuous node insertion and deletion, binary search trees may become skewed, degrading time complexity to \\(O(n)\\).</li> <li>If using AVL trees or red-black trees, all operations can run stably at \\(O(\\log n)\\) efficiency, but operations to maintain tree balance add extra overhead.</li> </ul>"},{"location":"chapter_searching/summary/","title":"10.6 \u00a0 Summary","text":""},{"location":"chapter_searching/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Binary search relies on data orderliness and progressively reduces the search interval by half through loops. It requires input data to be sorted and is only applicable to arrays or data structures based on array implementations.</li> <li>Brute-force search locates data by traversing the data structure. Linear search is applicable to arrays and linked lists, while breadth-first search and depth-first search are applicable to graphs and trees. Such algorithms have good generality and require no data preprocessing, but have a relatively high time complexity of \\(O(n)\\).</li> <li>Hash-based search, tree search, and binary search are efficient search methods that can quickly locate target elements in specific data structures. Such algorithms are highly efficient with time complexity reaching \\(O(\\log n)\\) or even \\(O(1)\\), but typically require additional data structures.</li> <li>In practice, we need to analyze factors such as data scale, search performance requirements, and data query and update frequency to choose the appropriate search method.</li> <li>Linear search is suitable for small-scale or frequently updated data; binary search is suitable for large-scale, sorted data; hash-based search is suitable for data with high query efficiency requirements and no need for range queries; tree search is suitable for large-scale dynamic data that needs to maintain order and support range queries.</li> <li>Replacing linear search with hash-based search is a commonly used strategy to optimize runtime, reducing time complexity from \\(O(n)\\) to \\(O(1)\\).</li> </ul>"},{"location":"chapter_sorting/","title":"Chapter 11. \u00a0 Sorting","text":"<p>Abstract</p> <p>Sorting is like a magic key that transforms chaos into order, enabling us to understand and process data more efficiently.</p> <p>Whether it's simple ascending order or complex categorized arrangements, sorting demonstrates the harmonious beauty of data.</p>"},{"location":"chapter_sorting/#chapter-contents","title":"Chapter contents","text":"<ul> <li>11.1 \u00a0 Sorting Algorithms</li> <li>11.2 \u00a0 Selection Sort</li> <li>11.3 \u00a0 Bubble Sort</li> <li>11.4 \u00a0 Insertion Sort</li> <li>11.5 \u00a0 Quick Sort</li> <li>11.6 \u00a0 Merge Sort</li> <li>11.7 \u00a0 Heap Sort</li> <li>11.8 \u00a0 Bucket Sort</li> <li>11.9 \u00a0 Counting Sort</li> <li>11.10 \u00a0 Radix Sort</li> <li>11.11 \u00a0 Summary</li> </ul>"},{"location":"chapter_sorting/bubble_sort/","title":"11.3 \u00a0 Bubble Sort","text":"<p>Bubble sort (bubble sort) achieves sorting by continuously comparing and swapping adjacent elements. This process is like bubbles rising from the bottom to the top, hence the name bubble sort.</p> <p>As shown in Figure 11-4, the bubbling process can be simulated using element swap operations: starting from the leftmost end of the array and traversing to the right, compare the size of adjacent elements, and if \"left element &gt; right element\", swap them. After completing the traversal, the largest element will be moved to the rightmost end of the array.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-4 \u00a0 Simulating bubble using element swap operation </p>"},{"location":"chapter_sorting/bubble_sort/#1131-algorithm-flow","title":"11.3.1 \u00a0 Algorithm Flow","text":"<p>Assume the array has length \\(n\\). The steps of bubble sort are shown in Figure 11-5.</p> <ol> <li>First, perform \"bubbling\" on \\(n\\) elements, swapping the largest element of the array to its correct position.</li> <li>Next, perform \"bubbling\" on the remaining \\(n - 1\\) elements, swapping the second largest element to its correct position.</li> <li>And so on. After \\(n - 1\\) rounds of \"bubbling\", the largest \\(n - 1\\) elements have all been swapped to their correct positions.</li> <li>The only remaining element must be the smallest element, requiring no sorting, so the array sorting is complete.</li> </ol> <p></p> <p> Figure 11-5 \u00a0 Bubble sort flow </p> <p>Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby bubble_sort.py<pre><code>def bubble_sort(nums: list[int]):\n    \"\"\"Bubble sort\"\"\"\n    n = len(nums)\n    # Outer loop: unsorted interval is [0, i]\n    for i in range(n - 1, 0, -1):\n        # Inner loop: swap the largest element in the unsorted interval [0, i] to the rightmost end of the interval\n        for j in range(i):\n            if nums[j] &gt; nums[j + 1]:\n                # Swap nums[j] and nums[j + 1]\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n</code></pre> bubble_sort.cpp<pre><code>/* Bubble sort */\nvoid bubbleSort(vector&lt;int&gt; &amp;nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.size() - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                // Using std::swap() function here\n                swap(nums[j], nums[j + 1]);\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.java<pre><code>/* Bubble sort */\nvoid bubbleSort(int[] nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.cs<pre><code>/* Bubble sort */\nvoid BubbleSort(int[] nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                (nums[j + 1], nums[j]) = (nums[j], nums[j + 1]);\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.go<pre><code>/* Bubble sort */\nfunc bubbleSort(nums []int) {\n    // Outer loop: unsorted range is [0, i]\n    for i := len(nums) - 1; i &gt; 0; i-- {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j := 0; j &lt; i; j++ {\n            if nums[j] &gt; nums[j+1] {\n                // Swap nums[j] and nums[j + 1]\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.swift<pre><code>/* Bubble sort */\nfunc bubbleSort(nums: inout [Int]) {\n    // Outer loop: unsorted range is [0, i]\n    for i in nums.indices.dropFirst().reversed() {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j in 0 ..&lt; i {\n            if nums[j] &gt; nums[j + 1] {\n                // Swap nums[j] and nums[j + 1]\n                nums.swapAt(j, j + 1)\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.js<pre><code>/* Bubble sort */\nfunction bubbleSort(nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.ts<pre><code>/* Bubble sort */\nfunction bubbleSort(nums: number[]): void {\n    // Outer loop: unsorted range is [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.dart<pre><code>/* Bubble sort */\nvoid bubbleSort(List&lt;int&gt; nums) {\n  // Outer loop: unsorted range is [0, i]\n  for (int i = nums.length - 1; i &gt; 0; i--) {\n    // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n    for (int j = 0; j &lt; i; j++) {\n      if (nums[j] &gt; nums[j + 1]) {\n        // Swap nums[j] and nums[j + 1]\n        int tmp = nums[j];\n        nums[j] = nums[j + 1];\n        nums[j + 1] = tmp;\n      }\n    }\n  }\n}\n</code></pre> bubble_sort.rs<pre><code>/* Bubble sort */\nfn bubble_sort(nums: &amp;mut [i32]) {\n    // Outer loop: unsorted range is [0, i]\n    for i in (1..nums.len()).rev() {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j in 0..i {\n            if nums[j] &gt; nums[j + 1] {\n                // Swap nums[j] and nums[j + 1]\n                nums.swap(j, j + 1);\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.c<pre><code>/* Bubble sort */\nvoid bubbleSort(int nums[], int size) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = size - 1; i &gt; 0; i--) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                int temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.kt<pre><code>/* Bubble sort */\nfun bubbleSort(nums: IntArray) {\n    // Outer loop: unsorted range is [0, i]\n    for (i in nums.size - 1 downTo 1) {\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (j in 0..&lt;i) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                val temp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = temp\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.rb<pre><code>### Bubble sort ###\ndef bubble_sort(nums)\n  n = nums.length\n  # Outer loop: unsorted range is [0, i]\n  for i in (n - 1).downto(1)\n    # Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n    for j in 0...i\n      if nums[j] &gt; nums[j + 1]\n        # Swap nums[j] and nums[j + 1]\n        nums[j], nums[j + 1] = nums[j + 1], nums[j]\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"chapter_sorting/bubble_sort/#1132-efficiency-optimization","title":"11.3.2 \u00a0 Efficiency Optimization","text":"<p>We notice that if no swap operations are performed during a certain round of \"bubbling\", it means the array has already completed sorting and can directly return the result. Therefore, we can add a flag <code>flag</code> to monitor this situation and return immediately once it occurs.</p> <p>After optimization, the worst-case time complexity and average time complexity of bubble sort remain \\(O(n^2)\\); but when the input array is completely ordered, the best-case time complexity can reach \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby bubble_sort.py<pre><code>def bubble_sort_with_flag(nums: list[int]):\n    \"\"\"Bubble sort (flag optimization)\"\"\"\n    n = len(nums)\n    # Outer loop: unsorted interval is [0, i]\n    for i in range(n - 1, 0, -1):\n        flag = False  # Initialize flag\n        # Inner loop: swap the largest element in the unsorted interval [0, i] to the rightmost end of the interval\n        for j in range(i):\n            if nums[j] &gt; nums[j + 1]:\n                # Swap nums[j] and nums[j + 1]\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                flag = True  # Record element swap\n        if not flag:\n            break  # No elements were swapped in this round of \"bubbling\", exit directly\n</code></pre> bubble_sort.cpp<pre><code>/* Bubble sort (flag optimization)*/\nvoid bubbleSortWithFlag(vector&lt;int&gt; &amp;nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.size() - 1; i &gt; 0; i--) {\n        bool flag = false; // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                // Using std::swap() function here\n                swap(nums[j], nums[j + 1]);\n                flag = true; // Record element swap\n            }\n        }\n        if (!flag)\n            break; // No elements were swapped in this round of \"bubbling\", exit directly\n    }\n}\n</code></pre> bubble_sort.java<pre><code>/* Bubble sort (flag optimization) */\nvoid bubbleSortWithFlag(int[] nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        boolean flag = false; // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true; // Record element swap\n            }\n        }\n        if (!flag)\n            break; // No elements were swapped in this round of \"bubbling\", exit directly\n    }\n}\n</code></pre> bubble_sort.cs<pre><code>/* Bubble sort (flag optimization) */\nvoid BubbleSortWithFlag(int[] nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        bool flag = false; // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                (nums[j + 1], nums[j]) = (nums[j], nums[j + 1]);\n                flag = true;  // Record element swap\n            }\n        }\n        if (!flag) break;     // No elements were swapped in this round of \"bubbling\", exit directly\n    }\n}\n</code></pre> bubble_sort.go<pre><code>/* Bubble sort (flag optimization) */\nfunc bubbleSortWithFlag(nums []int) {\n    // Outer loop: unsorted range is [0, i]\n    for i := len(nums) - 1; i &gt; 0; i-- {\n        flag := false // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j := 0; j &lt; i; j++ {\n            if nums[j] &gt; nums[j+1] {\n                // Swap nums[j] and nums[j + 1]\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n                flag = true // Record element swap\n            }\n        }\n        if flag == false { // No elements were swapped in this round of \"bubbling\", exit directly\n            break\n        }\n    }\n}\n</code></pre> bubble_sort.swift<pre><code>/* Bubble sort (flag optimization) */\nfunc bubbleSortWithFlag(nums: inout [Int]) {\n    // Outer loop: unsorted range is [0, i]\n    for i in nums.indices.dropFirst().reversed() {\n        var flag = false // Initialize flag\n        for j in 0 ..&lt; i {\n            if nums[j] &gt; nums[j + 1] {\n                // Swap nums[j] and nums[j + 1]\n                nums.swapAt(j, j + 1)\n                flag = true // Record element swap\n            }\n        }\n        if !flag { // No elements were swapped in this round of \"bubbling\", exit directly\n            break\n        }\n    }\n}\n</code></pre> bubble_sort.js<pre><code>/* Bubble sort (flag optimization) */\nfunction bubbleSortWithFlag(nums) {\n    // Outer loop: unsorted range is [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        let flag = false; // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true; // Record element swap\n            }\n        }\n        if (!flag) break; // No elements were swapped in this round of \"bubbling\", exit directly\n    }\n}\n</code></pre> bubble_sort.ts<pre><code>/* Bubble sort (flag optimization) */\nfunction bubbleSortWithFlag(nums: number[]): void {\n    // Outer loop: unsorted range is [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        let flag = false; // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true; // Record element swap\n            }\n        }\n        if (!flag) break; // No elements were swapped in this round of \"bubbling\", exit directly\n    }\n}\n</code></pre> bubble_sort.dart<pre><code>/* Bubble sort (flag optimization) */\nvoid bubbleSortWithFlag(List&lt;int&gt; nums) {\n  // Outer loop: unsorted range is [0, i]\n  for (int i = nums.length - 1; i &gt; 0; i--) {\n    bool flag = false; // Initialize flag\n    // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n    for (int j = 0; j &lt; i; j++) {\n      if (nums[j] &gt; nums[j + 1]) {\n        // Swap nums[j] and nums[j + 1]\n        int tmp = nums[j];\n        nums[j] = nums[j + 1];\n        nums[j + 1] = tmp;\n        flag = true; // Record element swap\n      }\n    }\n    if (!flag) break; // No elements were swapped in this round of \"bubbling\", exit directly\n  }\n}\n</code></pre> bubble_sort.rs<pre><code>/* Bubble sort (flag optimization) */\nfn bubble_sort_with_flag(nums: &amp;mut [i32]) {\n    // Outer loop: unsorted range is [0, i]\n    for i in (1..nums.len()).rev() {\n        let mut flag = false; // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for j in 0..i {\n            if nums[j] &gt; nums[j + 1] {\n                // Swap nums[j] and nums[j + 1]\n                nums.swap(j, j + 1);\n                flag = true; // Record element swap\n            }\n        }\n        if !flag {\n            break; // No elements were swapped in this round of \"bubbling\", exit directly\n        };\n    }\n}\n</code></pre> bubble_sort.c<pre><code>/* Bubble sort (flag optimization) */\nvoid bubbleSortWithFlag(int nums[], int size) {\n    // Outer loop: unsorted range is [0, i]\n    for (int i = size - 1; i &gt; 0; i--) {\n        bool flag = false;\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                int temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n                flag = true;\n            }\n        }\n        if (!flag)\n            break;\n    }\n}\n</code></pre> bubble_sort.kt<pre><code>/* Bubble sort (flag optimization) */\nfun bubbleSortWithFlag(nums: IntArray) {\n    // Outer loop: unsorted range is [0, i]\n    for (i in nums.size - 1 downTo 1) {\n        var flag = false // Initialize flag\n        // Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n        for (j in 0..&lt;i) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // Swap nums[j] and nums[j + 1]\n                val temp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = temp\n                flag = true // Record element swap\n            }\n        }\n        if (!flag) break // No elements were swapped in this round of \"bubbling\", exit directly\n    }\n}\n</code></pre> bubble_sort.rb<pre><code>### Bubble sort (flag optimization) ###\ndef bubble_sort_with_flag(nums)\n  n = nums.length\n  # Outer loop: unsorted range is [0, i]\n  for i in (n - 1).downto(1)\n    flag = false # Initialize flag\n\n    # Inner loop: swap the largest element in the unsorted range [0, i] to the rightmost end of that range\n    for j in 0...i\n      if nums[j] &gt; nums[j + 1]\n        # Swap nums[j] and nums[j + 1]\n        nums[j], nums[j + 1] = nums[j + 1], nums[j]\n        flag = true # Record element swap\n      end\n    end\n\n    break unless flag # No elements were swapped in this round of \"bubbling\", exit directly\n  end\nend\n</code></pre>"},{"location":"chapter_sorting/bubble_sort/#1133-algorithm-characteristics","title":"11.3.3 \u00a0 Algorithm Characteristics","text":"<ul> <li>Time complexity of \\(O(n^2)\\), adaptive sorting: The array lengths traversed in each round of \"bubbling\" are \\(n - 1\\), \\(n - 2\\), \\(\\dots\\), \\(2\\), \\(1\\), totaling \\((n - 1) n / 2\\). After introducing the <code>flag</code> optimization, the best-case time complexity can reach \\(O(n)\\).</li> <li>Space complexity of \\(O(1)\\), in-place sorting: Pointers \\(i\\) and \\(j\\) use a constant amount of extra space.</li> <li>Stable sorting: Since equal elements are not swapped during \"bubbling\".</li> </ul>"},{"location":"chapter_sorting/bucket_sort/","title":"11.8 \u00a0 Bucket Sort","text":"<p>The several sorting algorithms mentioned earlier all belong to \"comparison-based sorting algorithms\", which achieve sorting by comparing the size of elements. The time complexity of such sorting algorithms cannot exceed \\(O(n \\log n)\\). Next, we will explore several \"non-comparison sorting algorithms\", whose time complexity can reach linear order.</p> <p>Bucket sort (bucket sort) is a typical application of the divide-and-conquer strategy. It works by setting up buckets with size order, each bucket corresponding to a data range, evenly distributing data to each bucket; then, sorting within each bucket separately; finally, merging all data in the order of the buckets.</p>"},{"location":"chapter_sorting/bucket_sort/#1181-algorithm-flow","title":"11.8.1 \u00a0 Algorithm Flow","text":"<p>Consider an array of length \\(n\\), whose elements are floating-point numbers in the range \\([0, 1)\\). The flow of bucket sort is shown in Figure 11-13.</p> <ol> <li>Initialize \\(k\\) buckets and distribute the \\(n\\) elements into the \\(k\\) buckets.</li> <li>Sort each bucket separately (here we use the built-in sorting function of the programming language).</li> <li>Merge the results in order from smallest to largest bucket.</li> </ol> <p></p> <p> Figure 11-13 \u00a0 Bucket sort algorithm flow </p> <p>The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby bucket_sort.py<pre><code>def bucket_sort(nums: list[float]):\n    \"\"\"Bucket sort\"\"\"\n    # Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    k = len(nums) // 2\n    buckets = [[] for _ in range(k)]\n    # 1. Distribute array elements into various buckets\n    for num in nums:\n        # Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        i = int(num * k)\n        # Add num to bucket i\n        buckets[i].append(num)\n    # 2. Sort each bucket\n    for bucket in buckets:\n        # Use built-in sorting function, can also replace with other sorting algorithms\n        bucket.sort()\n    # 3. Traverse buckets to merge results\n    i = 0\n    for bucket in buckets:\n        for num in bucket:\n            nums[i] = num\n            i += 1\n</code></pre> bucket_sort.cpp<pre><code>/* Bucket sort */\nvoid bucketSort(vector&lt;float&gt; &amp;nums) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    int k = nums.size() / 2;\n    vector&lt;vector&lt;float&gt;&gt; buckets(k);\n    // 1. Distribute array elements into various buckets\n    for (float num : nums) {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        int i = num * k;\n        // Add num to bucket bucket_idx\n        buckets[i].push_back(num);\n    }\n    // 2. Sort each bucket\n    for (vector&lt;float&gt; &amp;bucket : buckets) {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        sort(bucket.begin(), bucket.end());\n    }\n    // 3. Traverse buckets to merge results\n    int i = 0;\n    for (vector&lt;float&gt; &amp;bucket : buckets) {\n        for (float num : bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.java<pre><code>/* Bucket sort */\nvoid bucketSort(float[] nums) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    int k = nums.length / 2;\n    List&lt;List&lt;Float&gt;&gt; buckets = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; k; i++) {\n        buckets.add(new ArrayList&lt;&gt;());\n    }\n    // 1. Distribute array elements into various buckets\n    for (float num : nums) {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        int i = (int) (num * k);\n        // Add num to bucket i\n        buckets.get(i).add(num);\n    }\n    // 2. Sort each bucket\n    for (List&lt;Float&gt; bucket : buckets) {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        Collections.sort(bucket);\n    }\n    // 3. Traverse buckets to merge results\n    int i = 0;\n    for (List&lt;Float&gt; bucket : buckets) {\n        for (float num : bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.cs<pre><code>/* Bucket sort */\nvoid BucketSort(float[] nums) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    int k = nums.Length / 2;\n    List&lt;List&lt;float&gt;&gt; buckets = [];\n    for (int i = 0; i &lt; k; i++) {\n        buckets.Add([]);\n    }\n    // 1. Distribute array elements into various buckets\n    foreach (float num in nums) {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        int i = (int)(num * k);\n        // Add num to bucket i\n        buckets[i].Add(num);\n    }\n    // 2. Sort each bucket\n    foreach (List&lt;float&gt; bucket in buckets) {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        bucket.Sort();\n    }\n    // 3. Traverse buckets to merge results\n    int j = 0;\n    foreach (List&lt;float&gt; bucket in buckets) {\n        foreach (float num in bucket) {\n            nums[j++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.go<pre><code>/* Bucket sort */\nfunc bucketSort(nums []float64) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    k := len(nums) / 2\n    buckets := make([][]float64, k)\n    for i := 0; i &lt; k; i++ {\n        buckets[i] = make([]float64, 0)\n    }\n    // 1. Distribute array elements into various buckets\n    for _, num := range nums {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        i := int(num * float64(k))\n        // Add num to bucket i\n        buckets[i] = append(buckets[i], num)\n    }\n    // 2. Sort each bucket\n    for i := 0; i &lt; k; i++ {\n        // Use built-in slice sorting function, can also be replaced with other sorting algorithms\n        sort.Float64s(buckets[i])\n    }\n    // 3. Traverse buckets to merge results\n    i := 0\n    for _, bucket := range buckets {\n        for _, num := range bucket {\n            nums[i] = num\n            i++\n        }\n    }\n}\n</code></pre> bucket_sort.swift<pre><code>/* Bucket sort */\nfunc bucketSort(nums: inout [Double]) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    let k = nums.count / 2\n    var buckets = (0 ..&lt; k).map { _ in [Double]() }\n    // 1. Distribute array elements into various buckets\n    for num in nums {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        let i = Int(num * Double(k))\n        // Add num to bucket i\n        buckets[i].append(num)\n    }\n    // 2. Sort each bucket\n    for i in buckets.indices {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        buckets[i].sort()\n    }\n    // 3. Traverse buckets to merge results\n    var i = nums.startIndex\n    for bucket in buckets {\n        for num in bucket {\n            nums[i] = num\n            i += 1\n        }\n    }\n}\n</code></pre> bucket_sort.js<pre><code>/* Bucket sort */\nfunction bucketSort(nums) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    const k = nums.length / 2;\n    const buckets = [];\n    for (let i = 0; i &lt; k; i++) {\n        buckets.push([]);\n    }\n    // 1. Distribute array elements into various buckets\n    for (const num of nums) {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        const i = Math.floor(num * k);\n        // Add num to bucket i\n        buckets[i].push(num);\n    }\n    // 2. Sort each bucket\n    for (const bucket of buckets) {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        bucket.sort((a, b) =&gt; a - b);\n    }\n    // 3. Traverse buckets to merge results\n    let i = 0;\n    for (const bucket of buckets) {\n        for (const num of bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.ts<pre><code>/* Bucket sort */\nfunction bucketSort(nums: number[]): void {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    const k = nums.length / 2;\n    const buckets: number[][] = [];\n    for (let i = 0; i &lt; k; i++) {\n        buckets.push([]);\n    }\n    // 1. Distribute array elements into various buckets\n    for (const num of nums) {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        const i = Math.floor(num * k);\n        // Add num to bucket i\n        buckets[i].push(num);\n    }\n    // 2. Sort each bucket\n    for (const bucket of buckets) {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        bucket.sort((a, b) =&gt; a - b);\n    }\n    // 3. Traverse buckets to merge results\n    let i = 0;\n    for (const bucket of buckets) {\n        for (const num of bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.dart<pre><code>/* Bucket sort */\nvoid bucketSort(List&lt;double&gt; nums) {\n  // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n  int k = nums.length ~/ 2;\n  List&lt;List&lt;double&gt;&gt; buckets = List.generate(k, (index) =&gt; []);\n\n  // 1. Distribute array elements into various buckets\n  for (double _num in nums) {\n    // Input data range is [0, 1), use _num * k to map to index range [0, k-1]\n    int i = (_num * k).toInt();\n    // Add _num to bucket bucket_idx\n    buckets[i].add(_num);\n  }\n  // 2. Sort each bucket\n  for (List&lt;double&gt; bucket in buckets) {\n    bucket.sort();\n  }\n  // 3. Traverse buckets to merge results\n  int i = 0;\n  for (List&lt;double&gt; bucket in buckets) {\n    for (double _num in bucket) {\n      nums[i++] = _num;\n    }\n  }\n}\n</code></pre> bucket_sort.rs<pre><code>/* Bucket sort */\nfn bucket_sort(nums: &amp;mut [f64]) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    let k = nums.len() / 2;\n    let mut buckets = vec![vec![]; k];\n    // 1. Distribute array elements into various buckets\n    for &amp;num in nums.iter() {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        let i = (num * k as f64) as usize;\n        // Add num to bucket i\n        buckets[i].push(num);\n    }\n    // 2. Sort each bucket\n    for bucket in &amp;mut buckets {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        bucket.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    }\n    // 3. Traverse buckets to merge results\n    let mut i = 0;\n    for bucket in buckets.iter() {\n        for &amp;num in bucket.iter() {\n            nums[i] = num;\n            i += 1;\n        }\n    }\n}\n</code></pre> bucket_sort.c<pre><code>/* Bucket sort */\nvoid bucketSort(float nums[], int n) {\n    int k = n / 2;                                 // Initialize k = n/2 buckets\n    int *sizes = malloc(k * sizeof(int));          // Record each bucket's size\n    float **buckets = malloc(k * sizeof(float *)); // Array of dynamic arrays (buckets)\n    // Pre-allocate sufficient space for each bucket\n    for (int i = 0; i &lt; k; ++i) {\n        buckets[i] = (float *)malloc(n * sizeof(float));\n        sizes[i] = 0;\n    }\n    // 1. Distribute array elements into various buckets\n    for (int i = 0; i &lt; n; ++i) {\n        int idx = (int)(nums[i] * k);\n        buckets[idx][sizes[idx]++] = nums[i];\n    }\n    // 2. Sort each bucket\n    for (int i = 0; i &lt; k; ++i) {\n        qsort(buckets[i], sizes[i], sizeof(float), compare);\n    }\n    // 3. Merge sorted buckets\n    int idx = 0;\n    for (int i = 0; i &lt; k; ++i) {\n        for (int j = 0; j &lt; sizes[i]; ++j) {\n            nums[idx++] = buckets[i][j];\n        }\n        // Free memory\n        free(buckets[i]);\n    }\n}\n</code></pre> bucket_sort.kt<pre><code>/* Bucket sort */\nfun bucketSort(nums: FloatArray) {\n    // Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n    val k = nums.size / 2\n    val buckets = mutableListOf&lt;MutableList&lt;Float&gt;&gt;()\n    for (i in 0..&lt;k) {\n        buckets.add(mutableListOf())\n    }\n    // 1. Distribute array elements into various buckets\n    for (num in nums) {\n        // Input data range is [0, 1), use num * k to map to index range [0, k-1]\n        val i = (num * k).toInt()\n        // Add num to bucket i\n        buckets[i].add(num)\n    }\n    // 2. Sort each bucket\n    for (bucket in buckets) {\n        // Use built-in sorting function, can also replace with other sorting algorithms\n        bucket.sort()\n    }\n    // 3. Traverse buckets to merge results\n    var i = 0\n    for (bucket in buckets) {\n        for (num in bucket) {\n            nums[i++] = num\n        }\n    }\n}\n</code></pre> bucket_sort.rb<pre><code>### Bucket sort ###\ndef bucket_sort(nums)\n  # Initialize k = n/2 buckets, expected to allocate 2 elements per bucket\n  k = nums.length / 2\n  buckets = Array.new(k) { [] }\n\n  # 1. Distribute array elements into various buckets\n  nums.each do |num|\n    # Input data range is [0, 1), use num * k to map to index range [0, k-1]\n    i = (num * k).to_i\n    # Add num to bucket i\n    buckets[i] &lt;&lt; num\n  end\n\n  # 2. Sort each bucket\n  buckets.each do |bucket|\n    # Use built-in sorting function, can also replace with other sorting algorithms\n    bucket.sort!\n  end\n\n  # 3. Traverse buckets to merge results\n  i = 0\n  buckets.each do |bucket|\n    bucket.each do |num|\n      nums[i] = num\n      i += 1\n    end\n  end\nend\n</code></pre>"},{"location":"chapter_sorting/bucket_sort/#1182-algorithm-characteristics","title":"11.8.2 \u00a0 Algorithm Characteristics","text":"<p>Bucket sort is suitable for processing very large data volumes. For example, if the input data contains 1 million elements and system memory cannot load all the data at once, the data can be divided into 1000 buckets, each bucket sorted separately, and then the results merged.</p> <ul> <li>Time complexity of \\(O(n + k)\\): Assuming the elements are evenly distributed among the buckets, then the number of elements in each bucket is \\(\\frac{n}{k}\\). Assuming sorting a single bucket uses \\(O(\\frac{n}{k} \\log\\frac{n}{k})\\) time, then sorting all buckets uses \\(O(n \\log\\frac{n}{k})\\) time. When the number of buckets \\(k\\) is relatively large, the time complexity approaches \\(O(n)\\). Merging results requires traversing all buckets and elements, taking \\(O(n + k)\\) time. In the worst case, all data is distributed into one bucket, and sorting that bucket uses \\(O(n^2)\\) time.</li> <li>Space complexity of \\(O(n + k)\\), non-in-place sorting: Additional space is required for \\(k\\) buckets and a total of \\(n\\) elements.</li> <li>Whether bucket sort is stable depends on whether the algorithm for sorting elements within buckets is stable.</li> </ul>"},{"location":"chapter_sorting/bucket_sort/#1183-how-to-achieve-even-distribution","title":"11.8.3 \u00a0 How to Achieve Even Distribution","text":"<p>Theoretically, bucket sort can achieve \\(O(n)\\) time complexity. The key is to evenly distribute elements to each bucket, because real data is often not evenly distributed. For example, if we want to evenly distribute all products on Taobao into 10 buckets by price range, there may be very many products below 100 yuan and very few above 1000 yuan. If the price intervals are evenly divided into 10, the difference in the number of products in each bucket will be very large.</p> <p>To achieve even distribution, we can first set an approximate dividing line to roughly divide the data into 3 buckets. After distribution is complete, continue dividing buckets with more products into 3 buckets until the number of elements in all buckets is roughly equal.</p> <p>As shown in Figure 11-14, this method essentially creates a recursion tree, with the goal of making the values of leaf nodes as even as possible. Of course, it is not necessary to divide the data into 3 buckets every round; the specific division method can be flexibly chosen according to data characteristics.</p> <p></p> <p> Figure 11-14 \u00a0 Recursively dividing buckets </p> <p>If we know the probability distribution of product prices in advance, we can set the price dividing line for each bucket based on the data probability distribution. It is worth noting that the data distribution does not necessarily need to be specifically calculated, but can also be approximated using a certain probability model based on data characteristics.</p> <p>As shown in Figure 11-15, we assume that product prices follow a normal distribution, which allows us to reasonably set price intervals to evenly distribute products to each bucket.</p> <p></p> <p> Figure 11-15 \u00a0 Dividing buckets based on probability distribution </p>"},{"location":"chapter_sorting/counting_sort/","title":"11.9 \u00a0 Counting Sort","text":"<p>Counting sort (counting sort) achieves sorting by counting the number of elements, typically applied to integer arrays.</p>"},{"location":"chapter_sorting/counting_sort/#1191-simple-implementation","title":"11.9.1 \u00a0 Simple Implementation","text":"<p>Let's start with a simple example. Given an array <code>nums</code> of length \\(n\\), where the elements are all \"non-negative integers\", the overall flow of counting sort is shown in Figure 11-16.</p> <ol> <li>Traverse the array to find the largest number, denoted as \\(m\\), and then create an auxiliary array <code>counter</code> of length \\(m + 1\\).</li> <li>Use <code>counter</code> to count the number of occurrences of each number in <code>nums</code>, where <code>counter[num]</code> corresponds to the number of occurrences of the number <code>num</code>. The counting method is simple: just traverse <code>nums</code> (let the current number be <code>num</code>), and increase <code>counter[num]</code> by \\(1\\) in each round.</li> <li>Since each index of <code>counter</code> is naturally ordered, this is equivalent to all numbers being sorted. Next, we traverse <code>counter</code> and fill in <code>nums</code> in ascending order based on the number of occurrences of each number.</li> </ol> <p></p> <p> Figure 11-16 \u00a0 Counting sort flow </p> <p>The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby counting_sort.py<pre><code>def counting_sort_naive(nums: list[int]):\n    \"\"\"Counting sort\"\"\"\n    # Simple implementation, cannot be used for sorting objects\n    # 1. Count the maximum element m in the array\n    m = 0\n    for num in nums:\n        m = max(m, num)\n    # 2. Count the occurrence of each number\n    # counter[num] represents the occurrence of num\n    counter = [0] * (m + 1)\n    for num in nums:\n        counter[num] += 1\n    # 3. Traverse counter, filling each element back into the original array nums\n    i = 0\n    for num in range(m + 1):\n        for _ in range(counter[num]):\n            nums[i] = num\n            i += 1\n</code></pre> counting_sort.cpp<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nvoid countingSortNaive(vector&lt;int&gt; &amp;nums) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    for (int num : nums) {\n        m = max(m, num);\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    vector&lt;int&gt; counter(m + 1, 0);\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.java<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nvoid countingSortNaive(int[] nums) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    for (int num : nums) {\n        m = Math.max(m, num);\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    int[] counter = new int[m + 1];\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.cs<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nvoid CountingSortNaive(int[] nums) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    foreach (int num in nums) {\n        m = Math.Max(m, num);\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    int[] counter = new int[m + 1];\n    foreach (int num in nums) {\n        counter[num]++;\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.go<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nfunc countingSortNaive(nums []int) {\n    // 1. Count the maximum element m in the array\n    m := 0\n    for _, num := range nums {\n        if num &gt; m {\n            m = num\n        }\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    counter := make([]int, m+1)\n    for _, num := range nums {\n        counter[num]++\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    for i, num := 0, 0; num &lt; m+1; num++ {\n        for j := 0; j &lt; counter[num]; j++ {\n            nums[i] = num\n            i++\n        }\n    }\n}\n</code></pre> counting_sort.swift<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nfunc countingSortNaive(nums: inout [Int]) {\n    // 1. Count the maximum element m in the array\n    let m = nums.max()!\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    var counter = Array(repeating: 0, count: m + 1)\n    for num in nums {\n        counter[num] += 1\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    var i = 0\n    for num in 0 ..&lt; m + 1 {\n        for _ in 0 ..&lt; counter[num] {\n            nums[i] = num\n            i += 1\n        }\n    }\n}\n</code></pre> counting_sort.js<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nfunction countingSortNaive(nums) {\n    // 1. Count the maximum element m in the array\n    let m = Math.max(...nums);\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    const counter = new Array(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    let i = 0;\n    for (let num = 0; num &lt; m + 1; num++) {\n        for (let j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.ts<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nfunction countingSortNaive(nums: number[]): void {\n    // 1. Count the maximum element m in the array\n    let m: number = Math.max(...nums);\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    const counter: number[] = new Array&lt;number&gt;(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    let i = 0;\n    for (let num = 0; num &lt; m + 1; num++) {\n        for (let j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.dart<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nvoid countingSortNaive(List&lt;int&gt; nums) {\n  // 1. Count the maximum element m in the array\n  int m = 0;\n  for (int _num in nums) {\n    m = max(m, _num);\n  }\n  // 2. Count the occurrence of each number\n  // counter[_num] represents occurrence count of _num\n  List&lt;int&gt; counter = List.filled(m + 1, 0);\n  for (int _num in nums) {\n    counter[_num]++;\n  }\n  // 3. Traverse counter, filling each element back into the original array nums\n  int i = 0;\n  for (int _num = 0; _num &lt; m + 1; _num++) {\n    for (int j = 0; j &lt; counter[_num]; j++, i++) {\n      nums[i] = _num;\n    }\n  }\n}\n</code></pre> counting_sort.rs<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nfn counting_sort_naive(nums: &amp;mut [i32]) {\n    // 1. Count the maximum element m in the array\n    let m = *nums.iter().max().unwrap();\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    let mut counter = vec![0; m as usize + 1];\n    for &amp;num in nums.iter() {\n        counter[num as usize] += 1;\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    let mut i = 0;\n    for num in 0..m + 1 {\n        for _ in 0..counter[num as usize] {\n            nums[i] = num;\n            i += 1;\n        }\n    }\n}\n</code></pre> counting_sort.c<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nvoid countingSortNaive(int nums[], int size) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] &gt; m) {\n            m = nums[i];\n        }\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    int *counter = calloc(m + 1, sizeof(int));\n    for (int i = 0; i &lt; size; i++) {\n        counter[nums[i]]++;\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n    // 4. Free memory\n    free(counter);\n}\n</code></pre> counting_sort.kt<pre><code>/* Counting sort */\n// Simple implementation, cannot be used for sorting objects\nfun countingSortNaive(nums: IntArray) {\n    // 1. Count the maximum element m in the array\n    var m = 0\n    for (num in nums) {\n        m = max(m, num)\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    val counter = IntArray(m + 1)\n    for (num in nums) {\n        counter[num]++\n    }\n    // 3. Traverse counter, filling each element back into the original array nums\n    var i = 0\n    for (num in 0..&lt;m + 1) {\n        var j = 0\n        while (j &lt; counter[num]) {\n            nums[i] = num\n            j++\n            i++\n        }\n    }\n}\n</code></pre> counting_sort.rb<pre><code>### Counting sort ###\ndef counting_sort_naive(nums)\n  # Simple implementation, cannot be used for sorting objects\n  # 1. Count the maximum element m in the array\n  m = 0\n  nums.each { |num| m = [m, num].max }\n  # 2. Count the occurrence of each number\n  # counter[num] represents the occurrence of num\n  counter = Array.new(m + 1, 0)\n  nums.each { |num| counter[num] += 1 }\n  # 3. Traverse counter, filling each element back into the original array nums\n  i = 0\n  for num in 0...(m + 1)\n    (0...counter[num]).each do\n      nums[i] = num\n      i += 1\n    end\n  end\nend\n</code></pre> <p>Connection between counting sort and bucket sort</p> <p>From the perspective of bucket sort, we can regard each index of the counting array <code>counter</code> in counting sort as a bucket, and the process of counting quantities as distributing each element to the corresponding bucket. Essentially, counting sort is a special case of bucket sort for integer data.</p>"},{"location":"chapter_sorting/counting_sort/#1192-complete-implementation","title":"11.9.2 \u00a0 Complete Implementation","text":"<p>Observant readers may have noticed that if the input data is objects, step <code>3.</code> above becomes invalid. Suppose the input data is product objects, and we want to sort the products by price (a member variable of the class), but the above algorithm can only give the sorting result of prices.</p> <p>So how can we obtain the sorting result of the original data? We first calculate the \"prefix sum\" of <code>counter</code>. As the name suggests, the prefix sum at index <code>i</code>, <code>prefix[i]</code>, equals the sum of the first <code>i</code> elements of the array:</p> \\[ \\text{prefix}[i] = \\sum_{j=0}^i \\text{counter[j]} \\] <p>The prefix sum has a clear meaning: <code>prefix[num] - 1</code> represents the index of the last occurrence of element <code>num</code> in the result array <code>res</code>. This information is very critical because it tells us where each element should appear in the result array. Next, we traverse each element <code>num</code> of the original array <code>nums</code> in reverse order, performing the following two steps in each iteration.</p> <ol> <li>Fill <code>num</code> into the array <code>res</code> at index <code>prefix[num] - 1</code>.</li> <li>Decrease the prefix sum <code>prefix[num]</code> by \\(1\\) to get the index for the next placement of <code>num</code>.</li> </ol> <p>After the traversal is complete, the array <code>res</code> contains the sorted result, and finally <code>res</code> is used to overwrite the original array <code>nums</code>. The complete counting sort flow is shown in Figure 11-17.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-17 \u00a0 Counting sort steps </p> <p>The implementation code of counting sort is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby counting_sort.py<pre><code>def counting_sort(nums: list[int]):\n    \"\"\"Counting sort\"\"\"\n    # Complete implementation, can sort objects and is a stable sort\n    # 1. Count the maximum element m in the array\n    m = max(nums)\n    # 2. Count the occurrence of each number\n    # counter[num] represents the occurrence of num\n    counter = [0] * (m + 1)\n    for num in nums:\n        counter[num] += 1\n    # 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    # counter[num]-1 is the last index where num appears in res\n    for i in range(m):\n        counter[i + 1] += counter[i]\n    # 4. Traverse nums in reverse order, placing each element into the result array res\n    # Initialize the array res to record results\n    n = len(nums)\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        num = nums[i]\n        res[counter[num] - 1] = num  # Place num at the corresponding index\n        counter[num] -= 1  # Decrement the prefix sum by 1, getting the next index to place num\n    # Use result array res to overwrite the original array nums\n    for i in range(n):\n        nums[i] = res[i]\n</code></pre> counting_sort.cpp<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nvoid countingSort(vector&lt;int&gt; &amp;nums) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    for (int num : nums) {\n        m = max(m, num);\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    vector&lt;int&gt; counter(m + 1, 0);\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    int n = nums.size();\n    vector&lt;int&gt; res(n);\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // Place num at the corresponding index\n        counter[num]--;              // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    nums = res;\n}\n</code></pre> counting_sort.java<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nvoid countingSort(int[] nums) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    for (int num : nums) {\n        m = Math.max(m, num);\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    int[] counter = new int[m + 1];\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    int n = nums.length;\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // Place num at the corresponding index\n        counter[num]--; // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.cs<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nvoid CountingSort(int[] nums) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    foreach (int num in nums) {\n        m = Math.Max(m, num);\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    int[] counter = new int[m + 1];\n    foreach (int num in nums) {\n        counter[num]++;\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    int n = nums.Length;\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // Place num at the corresponding index\n        counter[num]--; // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.go<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nfunc countingSort(nums []int) {\n    // 1. Count the maximum element m in the array\n    m := 0\n    for _, num := range nums {\n        if num &gt; m {\n            m = num\n        }\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    counter := make([]int, m+1)\n    for _, num := range nums {\n        counter[num]++\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for i := 0; i &lt; m; i++ {\n        counter[i+1] += counter[i]\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    n := len(nums)\n    res := make([]int, n)\n    for i := n - 1; i &gt;= 0; i-- {\n        num := nums[i]\n        // Place num at the corresponding index\n        res[counter[num]-1] = num\n        // Decrement the prefix sum by 1, getting the next index to place num\n        counter[num]--\n    }\n    // Use result array res to overwrite the original array nums\n    copy(nums, res)\n}\n</code></pre> counting_sort.swift<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nfunc countingSort(nums: inout [Int]) {\n    // 1. Count the maximum element m in the array\n    let m = nums.max()!\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    var counter = Array(repeating: 0, count: m + 1)\n    for num in nums {\n        counter[num] += 1\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for i in 0 ..&lt; m {\n        counter[i + 1] += counter[i]\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    var res = Array(repeating: 0, count: nums.count)\n    for i in nums.indices.reversed() {\n        let num = nums[i]\n        res[counter[num] - 1] = num // Place num at the corresponding index\n        counter[num] -= 1 // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    for i in nums.indices {\n        nums[i] = res[i]\n    }\n}\n</code></pre> counting_sort.js<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nfunction countingSort(nums) {\n    // 1. Count the maximum element m in the array\n    let m = Math.max(...nums);\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    const counter = new Array(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for (let i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    const n = nums.length;\n    const res = new Array(n);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const num = nums[i];\n        res[counter[num] - 1] = num; // Place num at the corresponding index\n        counter[num]--; // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.ts<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nfunction countingSort(nums: number[]): void {\n    // 1. Count the maximum element m in the array\n    let m: number = Math.max(...nums);\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    const counter: number[] = new Array&lt;number&gt;(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for (let i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    const n = nums.length;\n    const res: number[] = new Array&lt;number&gt;(n);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const num = nums[i];\n        res[counter[num] - 1] = num; // Place num at the corresponding index\n        counter[num]--; // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.dart<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nvoid countingSort(List&lt;int&gt; nums) {\n  // 1. Count the maximum element m in the array\n  int m = 0;\n  for (int _num in nums) {\n    m = max(m, _num);\n  }\n  // 2. Count the occurrence of each number\n  // counter[_num] represents occurrence count of _num\n  List&lt;int&gt; counter = List.filled(m + 1, 0);\n  for (int _num in nums) {\n    counter[_num]++;\n  }\n  // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n  // That is, counter[_num]-1 is the last occurrence index of _num in res\n  for (int i = 0; i &lt; m; i++) {\n    counter[i + 1] += counter[i];\n  }\n  // 4. Traverse nums in reverse order, placing each element into the result array res\n  // Initialize the array res to record results\n  int n = nums.length;\n  List&lt;int&gt; res = List.filled(n, 0);\n  for (int i = n - 1; i &gt;= 0; i--) {\n    int _num = nums[i];\n    res[counter[_num] - 1] = _num; // Place _num at corresponding index\n    counter[_num]--; // Decrement prefix sum by 1 to get next placement index for _num\n  }\n  // Use result array res to overwrite the original array nums\n  nums.setAll(0, res);\n}\n</code></pre> counting_sort.rs<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nfn counting_sort(nums: &amp;mut [i32]) {\n    // 1. Count the maximum element m in the array\n    let m = *nums.iter().max().unwrap() as usize;\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    let mut counter = vec![0; m + 1];\n    for &amp;num in nums.iter() {\n        counter[num as usize] += 1;\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for i in 0..m {\n        counter[i + 1] += counter[i];\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    let n = nums.len();\n    let mut res = vec![0; n];\n    for i in (0..n).rev() {\n        let num = nums[i];\n        res[counter[num as usize] - 1] = num; // Place num at the corresponding index\n        counter[num as usize] -= 1; // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    nums.copy_from_slice(&amp;res)\n}\n</code></pre> counting_sort.c<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nvoid countingSort(int nums[], int size) {\n    // 1. Count the maximum element m in the array\n    int m = 0;\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] &gt; m) {\n            m = nums[i];\n        }\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    int *counter = calloc(m, sizeof(int));\n    for (int i = 0; i &lt; size; i++) {\n        counter[nums[i]]++;\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    int *res = malloc(sizeof(int) * size);\n    for (int i = size - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // Place num at the corresponding index\n        counter[num]--;              // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    memcpy(nums, res, size * sizeof(int));\n    // 5. Free memory\n    free(res);\n    free(counter);\n}\n</code></pre> counting_sort.kt<pre><code>/* Counting sort */\n// Complete implementation, can sort objects and is a stable sort\nfun countingSort(nums: IntArray) {\n    // 1. Count the maximum element m in the array\n    var m = 0\n    for (num in nums) {\n        m = max(m, num)\n    }\n    // 2. Count the occurrence of each number\n    // counter[num] represents the occurrence of num\n    val counter = IntArray(m + 1)\n    for (num in nums) {\n        counter[num]++\n    }\n    // 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n    // counter[num]-1 is the last index where num appears in res\n    for (i in 0..&lt;m) {\n        counter[i + 1] += counter[i]\n    }\n    // 4. Traverse nums in reverse order, placing each element into the result array res\n    // Initialize the array res to record results\n    val n = nums.size\n    val res = IntArray(n)\n    for (i in n - 1 downTo 0) {\n        val num = nums[i]\n        res[counter[num] - 1] = num // Place num at the corresponding index\n        counter[num]-- // Decrement the prefix sum by 1, getting the next index to place num\n    }\n    // Use result array res to overwrite the original array nums\n    for (i in 0..&lt;n) {\n        nums[i] = res[i]\n    }\n}\n</code></pre> counting_sort.rb<pre><code>### Counting sort ###\ndef counting_sort(nums)\n  # Complete implementation, can sort objects and is a stable sort\n  # 1. Count the maximum element m in the array\n  m = nums.max\n  # 2. Count the occurrence of each number\n  # counter[num] represents the occurrence of num\n  counter = Array.new(m + 1, 0)\n  nums.each { |num| counter[num] += 1 }\n  # 3. Calculate the prefix sum of counter, converting \"occurrence count\" to \"tail index\"\n  # counter[num]-1 is the last index where num appears in res\n  (0...m).each { |i| counter[i + 1] += counter[i] }\n  # 4. Traverse nums in reverse, fill elements into result array res\n  # Initialize the array res to record results\n  n = nums.length\n  res = Array.new(n, 0)\n  (n - 1).downto(0).each do |i|\n    num = nums[i]\n    res[counter[num] - 1] = num # Place num at the corresponding index\n    counter[num] -= 1 # Decrement the prefix sum by 1, getting the next index to place num\n  end\n  # Use result array res to overwrite the original array nums\n  (0...n).each { |i| nums[i] = res[i] }\nend\n</code></pre>"},{"location":"chapter_sorting/counting_sort/#1193-algorithm-characteristics","title":"11.9.3 \u00a0 Algorithm Characteristics","text":"<ul> <li>Time complexity of \\(O(n + m)\\), non-adaptive sorting: Involves traversing <code>nums</code> and traversing <code>counter</code>, both using linear time. Generally, \\(n \\gg m\\), and time complexity tends toward \\(O(n)\\).</li> <li>Space complexity of \\(O(n + m)\\), non-in-place sorting: Uses arrays <code>res</code> and <code>counter</code> of lengths \\(n\\) and \\(m\\) respectively.</li> <li>Stable sorting: Since elements are filled into <code>res</code> in a \"right-to-left\" order, traversing <code>nums</code> in reverse can avoid changing the relative positions of equal elements, thereby achieving stable sorting. In fact, traversing <code>nums</code> in forward order can also yield correct sorting results, but the result would be unstable.</li> </ul>"},{"location":"chapter_sorting/counting_sort/#1194-limitations","title":"11.9.4 \u00a0 Limitations","text":"<p>By this point, you might think counting sort is very clever, as it can achieve efficient sorting just by counting quantities. However, the prerequisites for using counting sort are relatively strict.</p> <p>Counting sort is only suitable for non-negative integers. If you want to apply it to other types of data, you need to ensure that the data can be converted to non-negative integers without changing the relative size relationships between elements. For example, for an integer array containing negative numbers, you can first add a constant to all numbers to convert them all to positive numbers, and then convert them back after sorting is complete.</p> <p>Counting sort is suitable for situations where the data volume is large but the data range is small. For example, in the above example, \\(m\\) cannot be too large, otherwise it will occupy too much space. And when \\(n \\ll m\\), counting sort uses \\(O(m)\\) time, which may be slower than \\(O(n \\log n)\\) sorting algorithms.</p>"},{"location":"chapter_sorting/heap_sort/","title":"11.7 \u00a0 Heap Sort","text":"<p>Tip</p> <p>Before reading this section, please ensure you have completed the \"Heap\" chapter.</p> <p>Heap sort (heap sort) is an efficient sorting algorithm based on the heap data structure. We can use the \"build heap operation\" and \"element out-heap operation\" that we have already learned to implement heap sort.</p> <ol> <li>Input the array and build a min-heap, at which point the smallest element is at the heap top.</li> <li>Continuously perform the out-heap operation, record the out-heap elements in sequence, and an ascending sorted sequence can be obtained.</li> </ol> <p>Although the above method is feasible, it requires an additional array to save the popped elements, which is quite wasteful of space. In practice, we usually use a more elegant implementation method.</p>"},{"location":"chapter_sorting/heap_sort/#1171-algorithm-flow","title":"11.7.1 \u00a0 Algorithm Flow","text":"<p>Assume the array length is \\(n\\). The flow of heap sort is shown in Figure 11-12.</p> <ol> <li>Input the array and build a max-heap. After completion, the largest element is at the heap top.</li> <li>Swap the heap top element (first element) with the heap bottom element (last element). After the swap is complete, reduce the heap length by \\(1\\) and increase the count of sorted elements by \\(1\\).</li> <li>Starting from the heap top element, perform top-to-bottom heapify operation (sift down). After heapify is complete, the heap property is restored.</li> <li>Loop through steps <code>2.</code> and <code>3.</code> After looping \\(n - 1\\) rounds, the array sorting can be completed.</li> </ol> <p>Tip</p> <p>In fact, the element out-heap operation also includes steps <code>2.</code> and <code>3.</code>, with just an additional step to pop the element.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-12 \u00a0 Heap sort steps </p> <p>In the code implementation, we use the same top-to-bottom heapify function <code>sift_down()</code> from the \"Heap\" chapter. It is worth noting that since the heap length will decrease as the largest element is extracted, we need to add a length parameter \\(n\\) to the <code>sift_down()</code> function to specify the current effective length of the heap. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby heap_sort.py<pre><code>def sift_down(nums: list[int], n: int, i: int):\n    \"\"\"Heap length is n, start heapifying node i, from top to bottom\"\"\"\n    while True:\n        # Determine the largest node among i, l, r, noted as ma\n        l = 2 * i + 1\n        r = 2 * i + 2\n        ma = i\n        if l &lt; n and nums[l] &gt; nums[ma]:\n            ma = l\n        if r &lt; n and nums[r] &gt; nums[ma]:\n            ma = r\n        # If node i is the largest or indices l, r are out of bounds, no further heapification needed, break\n        if ma == i:\n            break\n        # Swap two nodes\n        nums[i], nums[ma] = nums[ma], nums[i]\n        # Loop downwards heapification\n        i = ma\n\ndef heap_sort(nums: list[int]):\n    \"\"\"Heap sort\"\"\"\n    # Build heap operation: heapify all nodes except leaves\n    for i in range(len(nums) // 2 - 1, -1, -1):\n        sift_down(nums, len(nums), i)\n    # Extract the largest element from the heap and repeat for n-1 rounds\n    for i in range(len(nums) - 1, 0, -1):\n        # Swap the root node with the rightmost leaf node (swap the first element with the last element)\n        nums[0], nums[i] = nums[i], nums[0]\n        # Start heapifying the root node, from top to bottom\n        sift_down(nums, i, 0)\n</code></pre> heap_sort.cpp<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nvoid siftDown(vector&lt;int&gt; &amp;nums, int n, int i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // Swap two nodes\n        if (ma == i) {\n            break;\n        }\n        // Swap two nodes\n        swap(nums[i], nums[ma]);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n\n/* Heap sort */\nvoid heapSort(vector&lt;int&gt; &amp;nums) {\n    // Build heap operation: heapify all nodes except leaves\n    for (int i = nums.size() / 2 - 1; i &gt;= 0; --i) {\n        siftDown(nums, nums.size(), i);\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for (int i = nums.size() - 1; i &gt; 0; --i) {\n        // Delete node\n        swap(nums[0], nums[i]);\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.java<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nvoid siftDown(int[] nums, int n, int i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // Swap two nodes\n        if (ma == i)\n            break;\n        // Swap two nodes\n        int temp = nums[i];\n        nums[i] = nums[ma];\n        nums[ma] = temp;\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n\n/* Heap sort */\nvoid heapSort(int[] nums) {\n    // Build heap operation: heapify all nodes except leaves\n    for (int i = nums.length / 2 - 1; i &gt;= 0; i--) {\n        siftDown(nums, nums.length, i);\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        // Delete node\n        int tmp = nums[0];\n        nums[0] = nums[i];\n        nums[i] = tmp;\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.cs<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nvoid SiftDown(int[] nums, int n, int i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // Swap two nodes\n        if (ma == i)\n            break;\n        // Swap two nodes\n        (nums[ma], nums[i]) = (nums[i], nums[ma]);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n\n/* Heap sort */\nvoid HeapSort(int[] nums) {\n    // Build heap operation: heapify all nodes except leaves\n    for (int i = nums.Length / 2 - 1; i &gt;= 0; i--) {\n        SiftDown(nums, nums.Length, i);\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        // Delete node\n        (nums[i], nums[0]) = (nums[0], nums[i]);\n        // Start heapifying the root node, from top to bottom\n        SiftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.go<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nfunc siftDown(nums *[]int, n, i int) {\n    for true {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        l := 2*i + 1\n        r := 2*i + 2\n        ma := i\n        if l &lt; n &amp;&amp; (*nums)[l] &gt; (*nums)[ma] {\n            ma = l\n        }\n        if r &lt; n &amp;&amp; (*nums)[r] &gt; (*nums)[ma] {\n            ma = r\n        }\n        // Swap two nodes\n        if ma == i {\n            break\n        }\n        // Swap two nodes\n        (*nums)[i], (*nums)[ma] = (*nums)[ma], (*nums)[i]\n        // Loop downwards heapification\n        i = ma\n    }\n}\n\n/* Heap sort */\nfunc heapSort(nums *[]int) {\n    // Build heap operation: heapify all nodes except leaves\n    for i := len(*nums)/2 - 1; i &gt;= 0; i-- {\n        siftDown(nums, len(*nums), i)\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for i := len(*nums) - 1; i &gt; 0; i-- {\n        // Delete node\n        (*nums)[0], (*nums)[i] = (*nums)[i], (*nums)[0]\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums, i, 0)\n    }\n}\n</code></pre> heap_sort.swift<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nfunc siftDown(nums: inout [Int], n: Int, i: Int) {\n    var i = i\n    while true {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        let l = 2 * i + 1\n        let r = 2 * i + 2\n        var ma = i\n        if l &lt; n, nums[l] &gt; nums[ma] {\n            ma = l\n        }\n        if r &lt; n, nums[r] &gt; nums[ma] {\n            ma = r\n        }\n        // Swap two nodes\n        if ma == i {\n            break\n        }\n        // Swap two nodes\n        nums.swapAt(i, ma)\n        // Loop downwards heapification\n        i = ma\n    }\n}\n\n/* Heap sort */\nfunc heapSort(nums: inout [Int]) {\n    // Build heap operation: heapify all nodes except leaves\n    for i in stride(from: nums.count / 2 - 1, through: 0, by: -1) {\n        siftDown(nums: &amp;nums, n: nums.count, i: i)\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for i in nums.indices.dropFirst().reversed() {\n        // Delete node\n        nums.swapAt(0, i)\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums: &amp;nums, n: i, i: 0)\n    }\n}\n</code></pre> heap_sort.js<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nfunction siftDown(nums, n, i) {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        let l = 2 * i + 1;\n        let r = 2 * i + 2;\n        let ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) {\n            ma = l;\n        }\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) {\n            ma = r;\n        }\n        // Swap two nodes\n        if (ma === i) {\n            break;\n        }\n        // Swap two nodes\n        [nums[i], nums[ma]] = [nums[ma], nums[i]];\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n\n/* Heap sort */\nfunction heapSort(nums) {\n    // Build heap operation: heapify all nodes except leaves\n    for (let i = Math.floor(nums.length / 2) - 1; i &gt;= 0; i--) {\n        siftDown(nums, nums.length, i);\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // Delete node\n        [nums[0], nums[i]] = [nums[i], nums[0]];\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.ts<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nfunction siftDown(nums: number[], n: number, i: number): void {\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        let l = 2 * i + 1;\n        let r = 2 * i + 2;\n        let ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) {\n            ma = l;\n        }\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) {\n            ma = r;\n        }\n        // Swap two nodes\n        if (ma === i) {\n            break;\n        }\n        // Swap two nodes\n        [nums[i], nums[ma]] = [nums[ma], nums[i]];\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n\n/* Heap sort */\nfunction heapSort(nums: number[]): void {\n    // Build heap operation: heapify all nodes except leaves\n    for (let i = Math.floor(nums.length / 2) - 1; i &gt;= 0; i--) {\n        siftDown(nums, nums.length, i);\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // Delete node\n        [nums[0], nums[i]] = [nums[i], nums[0]];\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.dart<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nvoid siftDown(List&lt;int&gt; nums, int n, int i) {\n  while (true) {\n    // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    int ma = i;\n    if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) ma = l;\n    if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) ma = r;\n    // Swap two nodes\n    if (ma == i) break;\n    // Swap two nodes\n    int temp = nums[i];\n    nums[i] = nums[ma];\n    nums[ma] = temp;\n    // Loop downwards heapification\n    i = ma;\n  }\n}\n\n/* Heap sort */\nvoid heapSort(List&lt;int&gt; nums) {\n  // Build heap operation: heapify all nodes except leaves\n  for (int i = nums.length ~/ 2 - 1; i &gt;= 0; i--) {\n    siftDown(nums, nums.length, i);\n  }\n  // Extract the largest element from the heap and repeat for n-1 rounds\n  for (int i = nums.length - 1; i &gt; 0; i--) {\n    // Delete node\n    int tmp = nums[0];\n    nums[0] = nums[i];\n    nums[i] = tmp;\n    // Start heapifying the root node, from top to bottom\n    siftDown(nums, i, 0);\n  }\n}\n</code></pre> heap_sort.rs<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nfn sift_down(nums: &amp;mut [i32], n: usize, mut i: usize) {\n    loop {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        let l = 2 * i + 1;\n        let r = 2 * i + 2;\n        let mut ma = i;\n        if l &lt; n &amp;&amp; nums[l] &gt; nums[ma] {\n            ma = l;\n        }\n        if r &lt; n &amp;&amp; nums[r] &gt; nums[ma] {\n            ma = r;\n        }\n        // Swap two nodes\n        if ma == i {\n            break;\n        }\n        // Swap two nodes\n        nums.swap(i, ma);\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n\n/* Heap sort */\nfn heap_sort(nums: &amp;mut [i32]) {\n    // Build heap operation: heapify all nodes except leaves\n    for i in (0..nums.len() / 2).rev() {\n        sift_down(nums, nums.len(), i);\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for i in (1..nums.len()).rev() {\n        // Delete node\n        nums.swap(0, i);\n        // Start heapifying the root node, from top to bottom\n        sift_down(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.c<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nvoid siftDown(int nums[], int n, int i) {\n    while (1) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // Swap two nodes\n        if (ma == i) {\n            break;\n        }\n        // Swap two nodes\n        int temp = nums[i];\n        nums[i] = nums[ma];\n        nums[ma] = temp;\n        // Loop downwards heapification\n        i = ma;\n    }\n}\n\n/* Heap sort */\nvoid heapSort(int nums[], int n) {\n    // Build heap operation: heapify all nodes except leaves\n    for (int i = n / 2 - 1; i &gt;= 0; --i) {\n        siftDown(nums, n, i);\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for (int i = n - 1; i &gt; 0; --i) {\n        // Delete node\n        int tmp = nums[0];\n        nums[0] = nums[i];\n        nums[i] = tmp;\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.kt<pre><code>/* Heap length is n, start heapifying node i, from top to bottom */\nfun siftDown(nums: IntArray, n: Int, li: Int) {\n    var i = li\n    while (true) {\n        // If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n        val l = 2 * i + 1\n        val r = 2 * i + 2\n        var ma = i\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) \n            ma = l\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) \n            ma = r\n        // Swap two nodes\n        if (ma == i) \n            break\n        // Swap two nodes\n        val temp = nums[i]\n        nums[i] = nums[ma]\n        nums[ma] = temp\n        // Loop downwards heapification\n        i = ma\n    }\n}\n\n/* Heap sort */\nfun heapSort(nums: IntArray) {\n    // Build heap operation: heapify all nodes except leaves\n    for (i in nums.size / 2 - 1 downTo 0) {\n        siftDown(nums, nums.size, i)\n    }\n    // Extract the largest element from the heap and repeat for n-1 rounds\n    for (i in nums.size - 1 downTo 1) {\n        // Delete node\n        val temp = nums[0]\n        nums[0] = nums[i]\n        nums[i] = temp\n        // Start heapifying the root node, from top to bottom\n        siftDown(nums, i, 0)\n    }\n}\n</code></pre> heap_sort.rb<pre><code>### Heap length is n, heapify from node i, top to bottom ###\ndef sift_down(nums, n, i)\n  while true\n    # If node i is largest or indices l, r are out of bounds, no need to continue heapify, break\n    l = 2 * i + 1\n    r = 2 * i + 2\n    ma = i\n    ma = l if l &lt; n &amp;&amp; nums[l] &gt; nums[ma]\n    ma = r if r &lt; n &amp;&amp; nums[r] &gt; nums[ma]\n    # Swap two nodes\n    break if ma == i\n    # Swap two nodes\n    nums[i], nums[ma] = nums[ma], nums[i]\n    # Loop downwards heapification\n    i = ma\n  end\nend\n\n### Heap sort ###\ndef heap_sort(nums)\n  # Build heap operation: heapify all nodes except leaves\n  (nums.length / 2 - 1).downto(0) do |i|\n    sift_down(nums, nums.length, i)\n  end\n  # Extract the largest element from the heap and repeat for n-1 rounds\n  (nums.length - 1).downto(1) do |i|\n    # Delete node\n    nums[0], nums[i] = nums[i], nums[0]\n    # Start heapifying the root node, from top to bottom\n    sift_down(nums, i, 0)\n  end\nend\n</code></pre>"},{"location":"chapter_sorting/heap_sort/#1172-algorithm-characteristics","title":"11.7.2 \u00a0 Algorithm Characteristics","text":"<ul> <li>Time complexity of \\(O(n \\log n)\\), non-adaptive sorting: The build heap operation uses \\(O(n)\\) time. Extracting the largest element from the heap has a time complexity of \\(O(\\log n)\\), looping a total of \\(n - 1\\) rounds.</li> <li>Space complexity of \\(O(1)\\), in-place sorting: A few pointer variables use \\(O(1)\\) space. Element swapping and heapify operations are both performed on the original array.</li> <li>Non-stable sorting: When swapping the heap top element and heap bottom element, the relative positions of equal elements may change.</li> </ul>"},{"location":"chapter_sorting/insertion_sort/","title":"11.4 \u00a0 Insertion Sort","text":"<p>Insertion sort (insertion sort) is a simple sorting algorithm that works very similarly to the process of manually organizing a deck of cards.</p> <p>Specifically, we select a base element from the unsorted interval, compare the element with elements in the sorted interval to its left one by one, and insert the element into the correct position.</p> <p>Figure 11-6 shows the operation flow of inserting an element into the array. Let the base element be <code>base</code>. We need to move all elements from the target index to <code>base</code> one position to the right, and then assign <code>base</code> to the target index.</p> <p></p> <p> Figure 11-6 \u00a0 Single insertion operation </p>"},{"location":"chapter_sorting/insertion_sort/#1141-algorithm-flow","title":"11.4.1 \u00a0 Algorithm Flow","text":"<p>The overall flow of insertion sort is shown in Figure 11-7.</p> <ol> <li>Initially, the first element of the array has completed sorting.</li> <li>Select the second element of the array as <code>base</code>, and after inserting it into the correct position, the first 2 elements of the array are sorted.</li> <li>Select the third element as <code>base</code>, and after inserting it into the correct position, the first 3 elements of the array are sorted.</li> <li>And so on. In the last round, select the last element as <code>base</code>, and after inserting it into the correct position, all elements are sorted.</li> </ol> <p></p> <p> Figure 11-7 \u00a0 Insertion sort flow </p> <p>Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby insertion_sort.py<pre><code>def insertion_sort(nums: list[int]):\n    \"\"\"Insertion sort\"\"\"\n    # Outer loop: sorted interval is [0, i-1]\n    for i in range(1, len(nums)):\n        base = nums[i]\n        j = i - 1\n        # Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while j &gt;= 0 and nums[j] &gt; base:\n            nums[j + 1] = nums[j]  # Move nums[j] to the right by one position\n            j -= 1\n        nums[j + 1] = base  # Assign base to the correct position\n</code></pre> insertion_sort.cpp<pre><code>/* Insertion sort */\nvoid insertionSort(vector&lt;int&gt; &amp;nums) {\n    // Outer loop: sorted interval is [0, i-1]\n    for (int i = 1; i &lt; nums.size(); i++) {\n        int base = nums[i], j = i - 1;\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // Move nums[j] to the right by one position\n            j--;\n        }\n        nums[j + 1] = base; // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.java<pre><code>/* Insertion sort */\nvoid insertionSort(int[] nums) {\n    // Outer loop: sorted interval is [0, i-1]\n    for (int i = 1; i &lt; nums.length; i++) {\n        int base = nums[i], j = i - 1;\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // Move nums[j] to the right by one position\n            j--;\n        }\n        nums[j + 1] = base;        // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.cs<pre><code>/* Insertion sort */\nvoid InsertionSort(int[] nums) {\n    // Outer loop: sorted interval is [0, i-1]\n    for (int i = 1; i &lt; nums.Length; i++) {\n        int bas = nums[i], j = i - 1;\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; bas) {\n            nums[j + 1] = nums[j]; // Move nums[j] to the right by one position\n            j--;\n        }\n        nums[j + 1] = bas;         // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.go<pre><code>/* Insertion sort */\nfunc insertionSort(nums []int) {\n    // Outer loop: sorted interval is [0, i-1]\n    for i := 1; i &lt; len(nums); i++ {\n        base := nums[i]\n        j := i - 1\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        for j &gt;= 0 &amp;&amp; nums[j] &gt; base {\n            nums[j+1] = nums[j] // Move nums[j] to the right by one position\n            j--\n        }\n        nums[j+1] = base // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.swift<pre><code>/* Insertion sort */\nfunc insertionSort(nums: inout [Int]) {\n    // Outer loop: sorted interval is [0, i-1]\n    for i in nums.indices.dropFirst() {\n        let base = nums[i]\n        var j = i - 1\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while j &gt;= 0, nums[j] &gt; base {\n            nums[j + 1] = nums[j] // Move nums[j] to the right by one position\n            j -= 1\n        }\n        nums[j + 1] = base // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.js<pre><code>/* Insertion sort */\nfunction insertionSort(nums) {\n    // Outer loop: sorted interval is [0, i-1]\n    for (let i = 1; i &lt; nums.length; i++) {\n        let base = nums[i],\n            j = i - 1;\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // Move nums[j] to the right by one position\n            j--;\n        }\n        nums[j + 1] = base; // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.ts<pre><code>/* Insertion sort */\nfunction insertionSort(nums: number[]): void {\n    // Outer loop: sorted interval is [0, i-1]\n    for (let i = 1; i &lt; nums.length; i++) {\n        const base = nums[i];\n        let j = i - 1;\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // Move nums[j] to the right by one position\n            j--;\n        }\n        nums[j + 1] = base; // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.dart<pre><code>/* Insertion sort */\nvoid insertionSort(List&lt;int&gt; nums) {\n  // Outer loop: sorted interval is [0, i-1]\n  for (int i = 1; i &lt; nums.length; i++) {\n    int base = nums[i], j = i - 1;\n    // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n    while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n      nums[j + 1] = nums[j]; // Move nums[j] to the right by one position\n      j--;\n    }\n    nums[j + 1] = base; // Assign base to the correct position\n  }\n}\n</code></pre> insertion_sort.rs<pre><code>/* Insertion sort */\nfn insertion_sort(nums: &amp;mut [i32]) {\n    // Outer loop: sorted interval is [0, i-1]\n    for i in 1..nums.len() {\n        let (base, mut j) = (nums[i], (i - 1) as i32);\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while j &gt;= 0 &amp;&amp; nums[j as usize] &gt; base {\n            nums[(j + 1) as usize] = nums[j as usize]; // Move nums[j] to the right by one position\n            j -= 1;\n        }\n        nums[(j + 1) as usize] = base; // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.c<pre><code>/* Insertion sort */\nvoid insertionSort(int nums[], int size) {\n    // Outer loop: sorted interval is [0, i-1]\n    for (int i = 1; i &lt; size; i++) {\n        int base = nums[i], j = i - 1;\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            // Move nums[j] to the right by one position\n            nums[j + 1] = nums[j];\n            j--;\n        }\n        // Assign base to the correct position\n        nums[j + 1] = base;\n    }\n}\n</code></pre> insertion_sort.kt<pre><code>/* Insertion sort */\nfun insertionSort(nums: IntArray) {\n    // Outer loop: sorted elements are 1, 2, ..., n\n    for (i in nums.indices) {\n        val base = nums[i]\n        var j = i - 1\n        // Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j] // Move nums[j] to the right by one position\n            j--\n        }\n        nums[j + 1] = base        // Assign base to the correct position\n    }\n}\n</code></pre> insertion_sort.rb<pre><code>### Insertion sort ###\ndef insertion_sort(nums)\n  n = nums.length\n  # Outer loop: sorted interval is [0, i-1]\n  for i in 1...n\n    base = nums[i]\n    j = i - 1\n    # Inner loop: insert base into the correct position within the sorted interval [0, i-1]\n    while j &gt;= 0 &amp;&amp; nums[j] &gt; base\n      nums[j + 1] = nums[j] # Move nums[j] to the right by one position\n      j -= 1\n    end\n    nums[j + 1] = base # Assign base to the correct position\n  end\nend\n</code></pre>"},{"location":"chapter_sorting/insertion_sort/#1142-algorithm-characteristics","title":"11.4.2 \u00a0 Algorithm Characteristics","text":"<ul> <li>Time complexity of \\(O(n^2)\\), adaptive sorting: In the worst case, each insertion operation requires loops of \\(n - 1\\), \\(n-2\\), \\(\\dots\\), \\(2\\), \\(1\\), summing to \\((n - 1) n / 2\\), so the time complexity is \\(O(n^2)\\). When encountering ordered data, the insertion operation will terminate early. When the input array is completely ordered, insertion sort achieves the best-case time complexity of \\(O(n)\\).</li> <li>Space complexity of \\(O(1)\\), in-place sorting: Pointers \\(i\\) and \\(j\\) use a constant amount of extra space.</li> <li>Stable sorting: During the insertion operation process, we insert elements to the right of equal elements, without changing their order.</li> </ul>"},{"location":"chapter_sorting/insertion_sort/#1143-advantages-of-insertion-sort","title":"11.4.3 \u00a0 Advantages of Insertion Sort","text":"<p>The time complexity of insertion sort is \\(O(n^2)\\), while the time complexity of quick sort, which we will learn about next, is \\(O(n \\log n)\\). Although insertion sort has a higher time complexity, insertion sort is usually faster for smaller data volumes.</p> <p>This conclusion is similar to the applicable situations of linear search and binary search. Algorithms like quick sort with \\(O(n \\log n)\\) complexity are sorting algorithms based on divide-and-conquer strategy and often contain more unit computation operations. When the data volume is small, \\(n^2\\) and \\(n \\log n\\) are numerically close, and complexity does not dominate; the number of unit operations per round plays a decisive role.</p> <p>In fact, the built-in sorting functions in many programming languages (such as Java) adopt insertion sort. The general approach is: for long arrays, use sorting algorithms based on divide-and-conquer strategy, such as quick sort; for short arrays, directly use insertion sort.</p> <p>Although bubble sort, selection sort, and insertion sort all have a time complexity of \\(O(n^2)\\), in actual situations, insertion sort is used significantly more frequently than bubble sort and selection sort, mainly for the following reasons.</p> <ul> <li>Bubble sort is based on element swapping, requiring the use of a temporary variable, involving 3 unit operations; insertion sort is based on element assignment, requiring only 1 unit operation. Therefore, the computational overhead of bubble sort is usually higher than that of insertion sort.</li> <li>Selection sort has a time complexity of \\(O(n^2)\\) in any case. If given a set of partially ordered data, insertion sort is usually more efficient than selection sort.</li> <li>Selection sort is unstable and cannot be applied to multi-level sorting.</li> </ul>"},{"location":"chapter_sorting/merge_sort/","title":"11.6 \u00a0 Merge Sort","text":"<p>Merge sort (merge sort) is a sorting algorithm based on the divide-and-conquer strategy, which includes the \"divide\" and \"merge\" phases shown in Figure 11-10.</p> <ol> <li>Divide phase: Recursively split the array from the midpoint, transforming the sorting problem of a long array into the sorting problems of shorter arrays.</li> <li>Merge phase: When the sub-array length is 1, terminate the division and start merging, continuously merging two shorter sorted arrays into one longer sorted array until the process is complete.</li> </ol> <p></p> <p> Figure 11-10 \u00a0 Divide and merge phases of merge sort </p>"},{"location":"chapter_sorting/merge_sort/#1161-algorithm-flow","title":"11.6.1 \u00a0 Algorithm Flow","text":"<p>As shown in Figure 11-11, the \"divide phase\" recursively splits the array from the midpoint into two sub-arrays from top to bottom.</p> <ol> <li>Calculate the array midpoint <code>mid</code>, recursively divide the left sub-array (interval <code>[left, mid]</code>) and right sub-array (interval <code>[mid + 1, right]</code>).</li> <li>Recursively execute step <code>1.</code> until the sub-array interval length is 1, then terminate.</li> </ol> <p>The \"merge phase\" merges the left sub-array and right sub-array into a sorted array from bottom to top. Note that merging starts from sub-arrays of length 1, and each sub-array in the merge phase is sorted.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-11 \u00a0 Merge sort steps </p> <p>It can be observed that the recursive order of merge sort is consistent with the post-order traversal of a binary tree.</p> <ul> <li>Post-order traversal: First recursively traverse the left subtree, then recursively traverse the right subtree, and finally process the root node.</li> <li>Merge sort: First recursively process the left sub-array, then recursively process the right sub-array, and finally perform the merge.</li> </ul> <p>The implementation of merge sort is shown in the code below. Note that the interval to be merged in <code>nums</code> is <code>[left, right]</code>, while the corresponding interval in <code>tmp</code> is <code>[0, right - left]</code>.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby merge_sort.py<pre><code>def merge(nums: list[int], left: int, mid: int, right: int):\n    \"\"\"Merge left subarray and right subarray\"\"\"\n    # Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    # Create a temporary array tmp to store the merged results\n    tmp = [0] * (right - left + 1)\n    # Initialize the start indices of the left and right subarrays\n    i, j, k = left, mid + 1, 0\n    # While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while i &lt;= mid and j &lt;= right:\n        if nums[i] &lt;= nums[j]:\n            tmp[k] = nums[i]\n            i += 1\n        else:\n            tmp[k] = nums[j]\n            j += 1\n        k += 1\n    # Copy the remaining elements of the left and right subarrays into the temporary array\n    while i &lt;= mid:\n        tmp[k] = nums[i]\n        i += 1\n        k += 1\n    while j &lt;= right:\n        tmp[k] = nums[j]\n        j += 1\n        k += 1\n    # Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for k in range(0, len(tmp)):\n        nums[left + k] = tmp[k]\n\ndef merge_sort(nums: list[int], left: int, right: int):\n    \"\"\"Merge sort\"\"\"\n    # Termination condition\n    if left &gt;= right:\n        return  # Terminate recursion when subarray length is 1\n    # Divide and conquer stage\n    mid = (left + right) // 2  # Calculate midpoint\n    merge_sort(nums, left, mid)  # Recursively process the left subarray\n    merge_sort(nums, mid + 1, right)  # Recursively process the right subarray\n    # Merge stage\n    merge(nums, left, mid, right)\n</code></pre> merge_sort.cpp<pre><code>/* Merge left subarray and right subarray */\nvoid merge(vector&lt;int&gt; &amp;nums, int left, int mid, int right) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    vector&lt;int&gt; tmp(right - left + 1);\n    // Initialize the start indices of the left and right subarrays\n    int i = left, j = mid + 1, k = 0;\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for (k = 0; k &lt; tmp.size(); k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* Merge sort */\nvoid mergeSort(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // Termination condition\n    if (left &gt;= right)\n        return; // Terminate recursion when subarray length is 1\n    // Divide and conquer stage\n    int mid = left + (right - left) / 2;    // Calculate midpoint\n    mergeSort(nums, left, mid);      // Recursively process the left subarray\n    mergeSort(nums, mid + 1, right); // Recursively process the right subarray\n    // Merge stage\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.java<pre><code>/* Merge left subarray and right subarray */\nvoid merge(int[] nums, int left, int mid, int right) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    int[] tmp = new int[right - left + 1];\n    // Initialize the start indices of the left and right subarrays\n    int i = left, j = mid + 1, k = 0;\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for (k = 0; k &lt; tmp.length; k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* Merge sort */\nvoid mergeSort(int[] nums, int left, int right) {\n    // Termination condition\n    if (left &gt;= right)\n        return; // Terminate recursion when subarray length is 1\n    // Divide and conquer stage\n    int mid = left + (right - left) / 2; // Calculate midpoint\n    mergeSort(nums, left, mid); // Recursively process the left subarray\n    mergeSort(nums, mid + 1, right); // Recursively process the right subarray\n    // Merge stage\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.cs<pre><code>/* Merge left subarray and right subarray */\nvoid Merge(int[] nums, int left, int mid, int right) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    int[] tmp = new int[right - left + 1];\n    // Initialize the start indices of the left and right subarrays\n    int i = left, j = mid + 1, k = 0;\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for (k = 0; k &lt; tmp.Length; ++k) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* Merge sort */\nvoid MergeSort(int[] nums, int left, int right) {\n    // Termination condition\n    if (left &gt;= right) return;       // Terminate recursion when subarray length is 1\n    // Divide and conquer stage\n    int mid = left + (right - left) / 2;    // Calculate midpoint\n    MergeSort(nums, left, mid);      // Recursively process the left subarray\n    MergeSort(nums, mid + 1, right); // Recursively process the right subarray\n    // Merge stage\n    Merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.go<pre><code>/* Merge left subarray and right subarray */\nfunc merge(nums []int, left, mid, right int) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    tmp := make([]int, right-left+1)\n    // Initialize the start indices of the left and right subarrays\n    i, j, k := left, mid+1, 0\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    for i &lt;= mid &amp;&amp; j &lt;= right {\n        if nums[i] &lt;= nums[j] {\n            tmp[k] = nums[i]\n            i++\n        } else {\n            tmp[k] = nums[j]\n            j++\n        }\n        k++\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    for i &lt;= mid {\n        tmp[k] = nums[i]\n        i++\n        k++\n    }\n    for j &lt;= right {\n        tmp[k] = nums[j]\n        j++\n        k++\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for k := 0; k &lt; len(tmp); k++ {\n        nums[left+k] = tmp[k]\n    }\n}\n\n/* Merge sort */\nfunc mergeSort(nums []int, left, right int) {\n    // Termination condition\n    if left &gt;= right {\n        return\n    }\n    // Divide and conquer stage\n    mid := left + (right - left) / 2\n    mergeSort(nums, left, mid)\n    mergeSort(nums, mid+1, right)\n    // Merge stage\n    merge(nums, left, mid, right)\n}\n</code></pre> merge_sort.swift<pre><code>/* Merge left subarray and right subarray */\nfunc merge(nums: inout [Int], left: Int, mid: Int, right: Int) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    var tmp = Array(repeating: 0, count: right - left + 1)\n    // Initialize the start indices of the left and right subarrays\n    var i = left, j = mid + 1, k = 0\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while i &lt;= mid, j &lt;= right {\n        if nums[i] &lt;= nums[j] {\n            tmp[k] = nums[i]\n            i += 1\n        } else {\n            tmp[k] = nums[j]\n            j += 1\n        }\n        k += 1\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while i &lt;= mid {\n        tmp[k] = nums[i]\n        i += 1\n        k += 1\n    }\n    while j &lt;= right {\n        tmp[k] = nums[j]\n        j += 1\n        k += 1\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for k in tmp.indices {\n        nums[left + k] = tmp[k]\n    }\n}\n\n/* Merge sort */\nfunc mergeSort(nums: inout [Int], left: Int, right: Int) {\n    // Termination condition\n    if left &gt;= right { // Terminate recursion when subarray length is 1\n        return\n    }\n    // Divide and conquer stage\n    let mid = left + (right - left) / 2 // Calculate midpoint\n    mergeSort(nums: &amp;nums, left: left, right: mid) // Recursively process the left subarray\n    mergeSort(nums: &amp;nums, left: mid + 1, right: right) // Recursively process the right subarray\n    // Merge stage\n    merge(nums: &amp;nums, left: left, mid: mid, right: right)\n}\n</code></pre> merge_sort.js<pre><code>/* Merge left subarray and right subarray */\nfunction merge(nums, left, mid, right) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    const tmp = new Array(right - left + 1);\n    // Initialize the start indices of the left and right subarrays\n    let i = left,\n        j = mid + 1,\n        k = 0;\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j]) {\n            tmp[k++] = nums[i++];\n        } else {\n            tmp[k++] = nums[j++];\n        }\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for (k = 0; k &lt; tmp.length; k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* Merge sort */\nfunction mergeSort(nums, left, right) {\n    // Termination condition\n    if (left &gt;= right) return; // Terminate recursion when subarray length is 1\n    // Divide and conquer stage\n    let mid = Math.floor(left + (right - left) / 2); // Calculate midpoint\n    mergeSort(nums, left, mid); // Recursively process the left subarray\n    mergeSort(nums, mid + 1, right); // Recursively process the right subarray\n    // Merge stage\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.ts<pre><code>/* Merge left subarray and right subarray */\nfunction merge(nums: number[], left: number, mid: number, right: number): void {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    const tmp = new Array(right - left + 1);\n    // Initialize the start indices of the left and right subarrays\n    let i = left,\n        j = mid + 1,\n        k = 0;\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j]) {\n            tmp[k++] = nums[i++];\n        } else {\n            tmp[k++] = nums[j++];\n        }\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for (k = 0; k &lt; tmp.length; k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* Merge sort */\nfunction mergeSort(nums: number[], left: number, right: number): void {\n    // Termination condition\n    if (left &gt;= right) return; // Terminate recursion when subarray length is 1\n    // Divide and conquer stage\n    let mid = Math.floor(left + (right - left) / 2); // Calculate midpoint\n    mergeSort(nums, left, mid); // Recursively process the left subarray\n    mergeSort(nums, mid + 1, right); // Recursively process the right subarray\n    // Merge stage\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.dart<pre><code>/* Merge left subarray and right subarray */\nvoid merge(List&lt;int&gt; nums, int left, int mid, int right) {\n  // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n  // Create a temporary array tmp to store the merged results\n  List&lt;int&gt; tmp = List.filled(right - left + 1, 0);\n  // Initialize the start indices of the left and right subarrays\n  int i = left, j = mid + 1, k = 0;\n  // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n  while (i &lt;= mid &amp;&amp; j &lt;= right) {\n    if (nums[i] &lt;= nums[j])\n      tmp[k++] = nums[i++];\n    else\n      tmp[k++] = nums[j++];\n  }\n  // Copy the remaining elements of the left and right subarrays into the temporary array\n  while (i &lt;= mid) {\n    tmp[k++] = nums[i++];\n  }\n  while (j &lt;= right) {\n    tmp[k++] = nums[j++];\n  }\n  // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n  for (k = 0; k &lt; tmp.length; k++) {\n    nums[left + k] = tmp[k];\n  }\n}\n\n/* Merge sort */\nvoid mergeSort(List&lt;int&gt; nums, int left, int right) {\n  // Termination condition\n  if (left &gt;= right) return; // Terminate recursion when subarray length is 1\n  // Divide and conquer stage\n  int mid = left + (right - left) ~/ 2; // Calculate midpoint\n  mergeSort(nums, left, mid); // Recursively process the left subarray\n  mergeSort(nums, mid + 1, right); // Recursively process the right subarray\n  // Merge stage\n  merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.rs<pre><code>/* Merge left subarray and right subarray */\nfn merge(nums: &amp;mut [i32], left: usize, mid: usize, right: usize) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    let tmp_size = right - left + 1;\n    let mut tmp = vec![0; tmp_size];\n    // Initialize the start indices of the left and right subarrays\n    let (mut i, mut j, mut k) = (left, mid + 1, 0);\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while i &lt;= mid &amp;&amp; j &lt;= right {\n        if nums[i] &lt;= nums[j] {\n            tmp[k] = nums[i];\n            i += 1;\n        } else {\n            tmp[k] = nums[j];\n            j += 1;\n        }\n        k += 1;\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while i &lt;= mid {\n        tmp[k] = nums[i];\n        k += 1;\n        i += 1;\n    }\n    while j &lt;= right {\n        tmp[k] = nums[j];\n        k += 1;\n        j += 1;\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for k in 0..tmp_size {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* Merge sort */\nfn merge_sort(nums: &amp;mut [i32], left: usize, right: usize) {\n    // Termination condition\n    if left &gt;= right {\n        return; // Terminate recursion when subarray length is 1\n    }\n\n    // Divide and conquer stage\n    let mid = left + (right - left) / 2; // Calculate midpoint\n    merge_sort(nums, left, mid); // Recursively process the left subarray\n    merge_sort(nums, mid + 1, right); // Recursively process the right subarray\n\n    // Merge stage\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.c<pre><code>/* Merge left subarray and right subarray */\nvoid merge(int *nums, int left, int mid, int right) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    int tmpSize = right - left + 1;\n    int *tmp = (int *)malloc(tmpSize * sizeof(int));\n    // Initialize the start indices of the left and right subarrays\n    int i = left, j = mid + 1, k = 0;\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j]) {\n            tmp[k++] = nums[i++];\n        } else {\n            tmp[k++] = nums[j++];\n        }\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for (k = 0; k &lt; tmpSize; ++k) {\n        nums[left + k] = tmp[k];\n    }\n    // Free memory\n    free(tmp);\n}\n\n/* Merge sort */\nvoid mergeSort(int *nums, int left, int right) {\n    // Termination condition\n    if (left &gt;= right)\n        return; // Terminate recursion when subarray length is 1\n    // Divide and conquer stage\n    int mid = left + (right - left) / 2;    // Calculate midpoint\n    mergeSort(nums, left, mid);      // Recursively process the left subarray\n    mergeSort(nums, mid + 1, right); // Recursively process the right subarray\n    // Merge stage\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.kt<pre><code>/* Merge left subarray and right subarray */\nfun merge(nums: IntArray, left: Int, mid: Int, right: Int) {\n    // Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n    // Create a temporary array tmp to store the merged results\n    val tmp = IntArray(right - left + 1)\n    // Initialize the start indices of the left and right subarrays\n    var i = left\n    var j = mid + 1\n    var k = 0\n    // While both subarrays still have elements, compare and copy the smaller element into the temporary array\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++]\n        else\n            tmp[k++] = nums[j++]\n    }\n    // Copy the remaining elements of the left and right subarrays into the temporary array\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++]\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++]\n    }\n    // Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n    for (l in tmp.indices) {\n        nums[left + l] = tmp[l]\n    }\n}\n\n/* Merge sort */\nfun mergeSort(nums: IntArray, left: Int, right: Int) {\n    // Termination condition\n    if (left &gt;= right) return  // Terminate recursion when subarray length is 1\n    // Divide and conquer stage\n    val mid = left + (right - left) / 2 // Calculate midpoint\n    mergeSort(nums, left, mid) // Recursively process the left subarray\n    mergeSort(nums, mid + 1, right) // Recursively process the right subarray\n    // Merge stage\n    merge(nums, left, mid, right)\n}\n</code></pre> merge_sort.rb<pre><code>### Merge left and right subarrays ###\ndef merge(nums, left, mid, right)\n  # Left subarray interval is [left, mid], right subarray interval is [mid+1, right]\n  # Create temporary array tmp to store merged result\n  tmp = Array.new(right - left + 1, 0)\n  # Initialize the start indices of the left and right subarrays\n  i, j, k = left, mid + 1, 0\n  # While both subarrays still have elements, compare and copy the smaller element into the temporary array\n  while i &lt;= mid &amp;&amp; j &lt;= right\n    if nums[i] &lt;= nums[j]\n      tmp[k] = nums[i]\n      i += 1\n    else\n      tmp[k] = nums[j]\n      j += 1\n    end\n    k += 1\n  end\n  # Copy the remaining elements of the left and right subarrays into the temporary array\n  while i &lt;= mid\n    tmp[k] = nums[i]\n    i += 1\n    k += 1\n  end\n  while j &lt;= right\n    tmp[k] = nums[j]\n    j += 1\n    k += 1\n  end\n  # Copy the elements from the temporary array tmp back to the original array nums at the corresponding interval\n  (0...tmp.length).each do |k|\n    nums[left + k] = tmp[k]\n  end\nend\n\n### Merge sort ###\ndef merge_sort(nums, left, right)\n  # Termination condition\n  # Terminate recursion when subarray length is 1\n  return if left &gt;= right\n  # Divide and conquer stage\n  mid = left + (right - left) / 2 # Calculate midpoint\n  merge_sort(nums, left, mid) # Recursively process the left subarray\n  merge_sort(nums, mid + 1, right) # Recursively process the right subarray\n  # Merge stage\n  merge(nums, left, mid, right)\nend\n</code></pre>"},{"location":"chapter_sorting/merge_sort/#1162-algorithm-characteristics","title":"11.6.2 \u00a0 Algorithm Characteristics","text":"<ul> <li>Time complexity of \\(O(n \\log n)\\), non-adaptive sorting: The division produces a recursion tree of height \\(\\log n\\), and the total number of merge operations at each level is \\(n\\), so the overall time complexity is \\(O(n \\log n)\\).</li> <li>Space complexity of \\(O(n)\\), non-in-place sorting: The recursion depth is \\(\\log n\\), using \\(O(\\log n)\\) size of stack frame space. The merge operation requires the aid of an auxiliary array, using \\(O(n)\\) size of additional space.</li> <li>Stable sorting: In the merge process, the order of equal elements remains unchanged.</li> </ul>"},{"location":"chapter_sorting/merge_sort/#1163-linked-list-sorting","title":"11.6.3 \u00a0 Linked List Sorting","text":"<p>For linked lists, merge sort has significant advantages over other sorting algorithms, and can optimize the space complexity of linked list sorting tasks to \\(O(1)\\).</p> <ul> <li>Divide phase: \"Iteration\" can be used instead of \"recursion\" to implement linked list division work, thus saving the stack frame space used by recursion.</li> <li>Merge phase: In linked lists, node insertion and deletion operations can be achieved by just changing references (pointers), so there is no need to create additional linked lists during the merge phase (merging two short ordered linked lists into one long ordered linked list).</li> </ul> <p>The specific implementation details are quite complex, and interested readers can consult related materials for learning.</p>"},{"location":"chapter_sorting/quick_sort/","title":"11.5 \u00a0 Quick Sort","text":"<p>Quick sort (quick sort) is a sorting algorithm based on the divide-and-conquer strategy, which operates efficiently and is widely applied.</p> <p>The core operation of quick sort is \"sentinel partitioning\", which aims to: select a certain element in the array as the \"pivot\", move all elements smaller than the pivot to its left, and move elements larger than the pivot to its right. Specifically, the flow of sentinel partitioning is shown in Figure 11-8.</p> <ol> <li>Select the leftmost element of the array as the pivot, and initialize two pointers <code>i</code> and <code>j</code> pointing to the two ends of the array.</li> <li>Set up a loop in which <code>i</code> (<code>j</code>) is used in each round to find the first element larger (smaller) than the pivot, and then swap these two elements.</li> <li>Loop through step <code>2.</code> until <code>i</code> and <code>j</code> meet, and finally swap the pivot to the boundary line of the two sub-arrays.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-8 \u00a0 Sentinel partitioning steps </p> <p>After sentinel partitioning is complete, the original array is divided into three parts: left sub-array, pivot, right sub-array, satisfying \"any element in left sub-array \\(\\leq\\) pivot \\(\\leq\\) any element in right sub-array\". Therefore, we next only need to sort these two sub-arrays.</p> <p>Divide-and-conquer strategy of quick sort</p> <p>The essence of sentinel partitioning is to simplify the sorting problem of a longer array into the sorting problems of two shorter arrays.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby quick_sort.py<pre><code>def partition(self, nums: list[int], left: int, right: int) -&gt; int:\n    \"\"\"Sentinel partition\"\"\"\n    # Use nums[left] as the pivot\n    i, j = left, right\n    while i &lt; j:\n        while i &lt; j and nums[j] &gt;= nums[left]:\n            j -= 1  # Search from right to left for the first element smaller than the pivot\n        while i &lt; j and nums[i] &lt;= nums[left]:\n            i += 1  # Search from left to right for the first element greater than the pivot\n        # Swap elements\n        nums[i], nums[j] = nums[j], nums[i]\n    # Swap the pivot to the boundary between the two subarrays\n    nums[i], nums[left] = nums[left], nums[i]\n    return i  # Return the index of the pivot\n</code></pre> quick_sort.cpp<pre><code>/* Sentinel partition */\nint partition(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;                // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;                // Search from left to right for the first element greater than the pivot\n        swap(nums[i], nums[j]); // Swap these two elements\n    }\n    swap(nums[i], nums[left]);  // Swap the pivot to the boundary between the two subarrays\n    return i;                   // Return the index of the pivot\n}\n</code></pre> quick_sort.java<pre><code>/* Swap elements */\nvoid swap(int[] nums, int i, int j) {\n    int tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* Sentinel partition */\nint partition(int[] nums, int left, int right) {\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // Search from left to right for the first element greater than the pivot\n        swap(nums, i, j); // Swap these two elements\n    }\n    swap(nums, i, left);  // Swap the pivot to the boundary between the two subarrays\n    return i;             // Return the index of the pivot\n}\n</code></pre> quick_sort.cs<pre><code>/* Swap elements */\nvoid Swap(int[] nums, int i, int j) {\n    (nums[j], nums[i]) = (nums[i], nums[j]);\n}\n\n/* Sentinel partition */\nint Partition(int[] nums, int left, int right) {\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // Search from left to right for the first element greater than the pivot\n        Swap(nums, i, j); // Swap these two elements\n    }\n    Swap(nums, i, left);  // Swap the pivot to the boundary between the two subarrays\n    return i;             // Return the index of the pivot\n}\n</code></pre> quick_sort.go<pre><code>/* Sentinel partition */\nfunc (q *quickSort) partition(nums []int, left, right int) int {\n    // Use nums[left] as the pivot\n    i, j := left, right\n    for i &lt; j {\n        for i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j-- // Search from right to left for the first element smaller than the pivot\n        }\n        for i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i++ // Search from left to right for the first element greater than the pivot\n        }\n        // Swap elements\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    // Swap the pivot to the boundary between the two subarrays\n    nums[i], nums[left] = nums[left], nums[i]\n    return i // Return the index of the pivot\n}\n</code></pre> quick_sort.swift<pre><code>/* Sentinel partition */\nfunc partition(nums: inout [Int], left: Int, right: Int) -&gt; Int {\n    // Use nums[left] as the pivot\n    var i = left\n    var j = right\n    while i &lt; j {\n        while i &lt; j, nums[j] &gt;= nums[left] {\n            j -= 1 // Search from right to left for the first element smaller than the pivot\n        }\n        while i &lt; j, nums[i] &lt;= nums[left] {\n            i += 1 // Search from left to right for the first element greater than the pivot\n        }\n        nums.swapAt(i, j) // Swap these two elements\n    }\n    nums.swapAt(i, left) // Swap the pivot to the boundary between the two subarrays\n    return i // Return the index of the pivot\n}\n</code></pre> quick_sort.js<pre><code>/* Swap elements */\nswap(nums, i, j) {\n    let tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* Sentinel partition */\npartition(nums, left, right) {\n    // Use nums[left] as the pivot\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j -= 1; // Search from right to left for the first element smaller than the pivot\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i += 1; // Search from left to right for the first element greater than the pivot\n        }\n        // Swap elements\n        this.swap(nums, i, j); // Swap these two elements\n    }\n    this.swap(nums, i, left); // Swap the pivot to the boundary between the two subarrays\n    return i; // Return the index of the pivot\n}\n</code></pre> quick_sort.ts<pre><code>/* Swap elements */\nswap(nums: number[], i: number, j: number): void {\n    let tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* Sentinel partition */\npartition(nums: number[], left: number, right: number): number {\n    // Use nums[left] as the pivot\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j -= 1; // Search from right to left for the first element smaller than the pivot\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i += 1; // Search from left to right for the first element greater than the pivot\n        }\n        // Swap elements\n        this.swap(nums, i, j); // Swap these two elements\n    }\n    this.swap(nums, i, left); // Swap the pivot to the boundary between the two subarrays\n    return i; // Return the index of the pivot\n}\n</code></pre> quick_sort.dart<pre><code>/* Swap elements */\nvoid _swap(List&lt;int&gt; nums, int i, int j) {\n  int tmp = nums[i];\n  nums[i] = nums[j];\n  nums[j] = tmp;\n}\n\n/* Sentinel partition */\nint _partition(List&lt;int&gt; nums, int left, int right) {\n  // Use nums[left] as the pivot\n  int i = left, j = right;\n  while (i &lt; j) {\n    while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--; // Search from right to left for the first element smaller than the pivot\n    while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++; // Search from left to right for the first element greater than the pivot\n    _swap(nums, i, j); // Swap these two elements\n  }\n  _swap(nums, i, left); // Swap the pivot to the boundary between the two subarrays\n  return i; // Return the index of the pivot\n}\n</code></pre> quick_sort.rs<pre><code>/* Sentinel partition */\nfn partition(nums: &amp;mut [i32], left: usize, right: usize) -&gt; usize {\n    // Use nums[left] as the pivot\n    let (mut i, mut j) = (left, right);\n    while i &lt; j {\n        while i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j -= 1; // Search from right to left for the first element smaller than the pivot\n        }\n        while i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i += 1; // Search from left to right for the first element greater than the pivot\n        }\n        nums.swap(i, j); // Swap these two elements\n    }\n    nums.swap(i, left); // Swap the pivot to the boundary between the two subarrays\n    i // Return the index of the pivot\n}\n</code></pre> quick_sort.c<pre><code>/* Swap elements */\nvoid swap(int nums[], int i, int j) {\n    int tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* Sentinel partition */\nint partition(int nums[], int left, int right) {\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j--; // Search from right to left for the first element smaller than the pivot\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i++; // Search from left to right for the first element greater than the pivot\n        }\n        // Swap these two elements\n        swap(nums, i, j);\n    }\n    // Swap the pivot to the boundary between the two subarrays\n    swap(nums, i, left);\n    // Return the index of the pivot\n    return i;\n}\n</code></pre> quick_sort.kt<pre><code>/* Swap elements */\nfun swap(nums: IntArray, i: Int, j: Int) {\n    val temp = nums[i]\n    nums[i] = nums[j]\n    nums[j] = temp\n}\n\n/* Sentinel partition */\nfun partition(nums: IntArray, left: Int, right: Int): Int {\n    // Use nums[left] as the pivot\n    var i = left\n    var j = right\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--           // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++           // Search from left to right for the first element greater than the pivot\n        swap(nums, i, j)  // Swap these two elements\n    }\n    swap(nums, i, left)   // Swap the pivot to the boundary between the two subarrays\n    return i              // Return the index of the pivot\n}\n</code></pre> quick_sort.rb<pre><code>### Sentinel partition ###\ndef partition(nums, left, right)\n  # Use nums[left] as the pivot\n  i, j = left, right\n  while i &lt; j\n    while i &lt; j &amp;&amp; nums[j] &gt;= nums[left]\n      j -= 1 # Search from right to left for the first element smaller than the pivot\n    end\n    while i &lt; j &amp;&amp; nums[i] &lt;= nums[left]\n      i += 1 # Search from left to right for the first element greater than the pivot\n    end\n    # Swap elements\n    nums[i], nums[j] = nums[j], nums[i]\n  end\n  # Swap the pivot to the boundary between the two subarrays\n  nums[i], nums[left] = nums[left], nums[i]\n  i # Return the index of the pivot\nend\n</code></pre>"},{"location":"chapter_sorting/quick_sort/#1151-algorithm-flow","title":"11.5.1 \u00a0 Algorithm Flow","text":"<p>The overall flow of quick sort is shown in Figure 11-9.</p> <ol> <li>First, perform one \"sentinel partitioning\" on the original array to obtain the unsorted left sub-array and right sub-array.</li> <li>Then, recursively perform \"sentinel partitioning\" on the left sub-array and right sub-array respectively.</li> <li>Continue recursively until the sub-array length is 1, at which point sorting of the entire array is complete.</li> </ol> <p></p> <p> Figure 11-9 \u00a0 Quick sort flow </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby quick_sort.py<pre><code>def quick_sort(self, nums: list[int], left: int, right: int):\n    \"\"\"Quick sort\"\"\"\n    # Terminate recursion when subarray length is 1\n    if left &gt;= right:\n        return\n    # Sentinel partition\n    pivot = self.partition(nums, left, right)\n    # Recursively process the left subarray and right subarray\n    self.quick_sort(nums, left, pivot - 1)\n    self.quick_sort(nums, pivot + 1, right)\n</code></pre> quick_sort.cpp<pre><code>/* Quick sort */\nvoid quickSort(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // Terminate recursion when subarray length is 1\n    if (left &gt;= right)\n        return;\n    // Sentinel partition\n    int pivot = partition(nums, left, right);\n    // Recursively process the left subarray and right subarray\n    quickSort(nums, left, pivot - 1);\n    quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.java<pre><code>/* Quick sort */\nvoid quickSort(int[] nums, int left, int right) {\n    // Terminate recursion when subarray length is 1\n    if (left &gt;= right)\n        return;\n    // Sentinel partition\n    int pivot = partition(nums, left, right);\n    // Recursively process the left subarray and right subarray\n    quickSort(nums, left, pivot - 1);\n    quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.cs<pre><code>/* Quick sort */\nvoid QuickSort(int[] nums, int left, int right) {\n    // Terminate recursion when subarray length is 1\n    if (left &gt;= right)\n        return;\n    // Sentinel partition\n    int pivot = Partition(nums, left, right);\n    // Recursively process the left subarray and right subarray\n    QuickSort(nums, left, pivot - 1);\n    QuickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.go<pre><code>/* Quick sort */\nfunc (q *quickSort) quickSort(nums []int, left, right int) {\n    // Terminate recursion when subarray length is 1\n    if left &gt;= right {\n        return\n    }\n    // Sentinel partition\n    pivot := q.partition(nums, left, right)\n    // Recursively process the left subarray and right subarray\n    q.quickSort(nums, left, pivot-1)\n    q.quickSort(nums, pivot+1, right)\n}\n</code></pre> quick_sort.swift<pre><code>/* Quick sort */\nfunc quickSort(nums: inout [Int], left: Int, right: Int) {\n    // Terminate recursion when subarray length is 1\n    if left &gt;= right {\n        return\n    }\n    // Sentinel partition\n    let pivot = partition(nums: &amp;nums, left: left, right: right)\n    // Recursively process the left subarray and right subarray\n    quickSort(nums: &amp;nums, left: left, right: pivot - 1)\n    quickSort(nums: &amp;nums, left: pivot + 1, right: right)\n}\n</code></pre> quick_sort.js<pre><code>/* Quick sort */\nquickSort(nums, left, right) {\n    // Terminate recursion when subarray length is 1\n    if (left &gt;= right) return;\n    // Sentinel partition\n    const pivot = this.partition(nums, left, right);\n    // Recursively process the left subarray and right subarray\n    this.quickSort(nums, left, pivot - 1);\n    this.quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.ts<pre><code>/* Quick sort */\nquickSort(nums: number[], left: number, right: number): void {\n    // Terminate recursion when subarray length is 1\n    if (left &gt;= right) {\n        return;\n    }\n    // Sentinel partition\n    const pivot = this.partition(nums, left, right);\n    // Recursively process the left subarray and right subarray\n    this.quickSort(nums, left, pivot - 1);\n    this.quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.dart<pre><code>/* Quick sort */\nvoid quickSort(List&lt;int&gt; nums, int left, int right) {\n  // Terminate recursion when subarray length is 1\n  if (left &gt;= right) return;\n  // Sentinel partition\n  int pivot = _partition(nums, left, right);\n  // Recursively process the left subarray and right subarray\n  quickSort(nums, left, pivot - 1);\n  quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.rs<pre><code>/* Quick sort */\npub fn quick_sort(left: i32, right: i32, nums: &amp;mut [i32]) {\n    // Terminate recursion when subarray length is 1\n    if left &gt;= right {\n        return;\n    }\n    // Sentinel partition\n    let pivot = Self::partition(nums, left as usize, right as usize) as i32;\n    // Recursively process the left subarray and right subarray\n    Self::quick_sort(left, pivot - 1, nums);\n    Self::quick_sort(pivot + 1, right, nums);\n}\n</code></pre> quick_sort.c<pre><code>/* Quick sort */\nvoid quickSort(int nums[], int left, int right) {\n    // Terminate recursion when subarray length is 1\n    if (left &gt;= right) {\n        return;\n    }\n    // Sentinel partition\n    int pivot = partition(nums, left, right);\n    // Recursively process the left subarray and right subarray\n    quickSort(nums, left, pivot - 1);\n    quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.kt<pre><code>/* Quick sort */\nfun quickSort(nums: IntArray, left: Int, right: Int) {\n    // Terminate recursion when subarray length is 1\n    if (left &gt;= right) return\n    // Sentinel partition\n    val pivot = partition(nums, left, right)\n    // Recursively process the left subarray and right subarray\n    quickSort(nums, left, pivot - 1)\n    quickSort(nums, pivot + 1, right)\n}\n</code></pre> quick_sort.rb<pre><code>### Quick sort class ###\ndef quick_sort(nums, left, right)\n  # Recurse when subarray length is not 1\n  if left &lt; right\n    # Sentinel partition\n    pivot = partition(nums, left, right)\n    # Recursively process the left subarray and right subarray\n    quick_sort(nums, left, pivot - 1)\n    quick_sort(nums, pivot + 1, right)\n  end\n  nums\nend\n</code></pre>"},{"location":"chapter_sorting/quick_sort/#1152-algorithm-characteristics","title":"11.5.2 \u00a0 Algorithm Characteristics","text":"<ul> <li>Time complexity of \\(O(n \\log n)\\), non-adaptive sorting: In the average case, the number of recursive levels of sentinel partitioning is \\(\\log n\\), and the total number of loops at each level is \\(n\\), using \\(O(n \\log n)\\) time overall. In the worst case, each round of sentinel partitioning divides an array of length \\(n\\) into two sub-arrays of length \\(0\\) and \\(n - 1\\), at which point the number of recursive levels reaches \\(n\\), the number of loops at each level is \\(n\\), and the total time used is \\(O(n^2)\\).</li> <li>Space complexity of \\(O(n)\\), in-place sorting: In the case where the input array is completely reversed, the worst recursive depth reaches \\(n\\), using \\(O(n)\\) stack frame space. The sorting operation is performed on the original array without the aid of an additional array.</li> <li>Non-stable sorting: In the last step of sentinel partitioning, the pivot may be swapped to the right of equal elements.</li> </ul>"},{"location":"chapter_sorting/quick_sort/#1153-why-is-quick-sort-fast","title":"11.5.3 \u00a0 Why Is Quick Sort Fast","text":"<p>From the name, we can see that quick sort should have certain advantages in terms of efficiency. Although the average time complexity of quick sort is the same as \"merge sort\" and \"heap sort\", quick sort is usually more efficient, mainly for the following reasons.</p> <ul> <li>The probability of the worst case occurring is very low: Although the worst-case time complexity of quick sort is \\(O(n^2)\\), which is not as stable as merge sort, in the vast majority of cases, quick sort can run with a time complexity of \\(O(n \\log n)\\).</li> <li>High cache utilization: When performing sentinel partitioning operations, the system can load the entire sub-array into the cache, so element access efficiency is relatively high. Algorithms like \"heap sort\" require jump-style access to elements, thus lacking this characteristic.</li> <li>Small constant coefficient of complexity: Among the three algorithms mentioned above, quick sort has the smallest total number of operations such as comparisons, assignments, and swaps. This is similar to the reason why \"insertion sort\" is faster than \"bubble sort\".</li> </ul>"},{"location":"chapter_sorting/quick_sort/#1154-pivot-optimization","title":"11.5.4 \u00a0 Pivot Optimization","text":"<p>Quick sort may have reduced time efficiency for certain inputs. Take an extreme example: suppose the input array is completely reversed. Since we select the leftmost element as the pivot, after sentinel partitioning is complete, the pivot is swapped to the rightmost end of the array, causing the left sub-array length to be \\(n - 1\\) and the right sub-array length to be \\(0\\). If we recurse down like this, each round of sentinel partitioning will have a sub-array length of \\(0\\), the divide-and-conquer strategy fails, and quick sort degrades to a form approximate to \"bubble sort\".</p> <p>To avoid this situation as much as possible, we can optimize the pivot selection strategy in sentinel partitioning. For example, we can randomly select an element as the pivot. However, if luck is not good and we select a non-ideal pivot every time, efficiency is still not satisfactory.</p> <p>It should be noted that programming languages usually generate \"pseudo-random numbers\". If we construct a specific test case for a pseudo-random number sequence, the efficiency of quick sort may still degrade.</p> <p>For further improvement, we can select three candidate elements in the array (usually the first, last, and middle elements of the array), and use the median of these three candidate elements as the pivot. In this way, the probability that the pivot is \"neither too small nor too large\" will be greatly increased. Of course, we can also select more candidate elements to further improve the robustness of the algorithm. After adopting this method, the probability of time complexity degrading to \\(O(n^2)\\) is greatly reduced.</p> <p>Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby quick_sort.py<pre><code>def median_three(self, nums: list[int], left: int, mid: int, right: int) -&gt; int:\n    \"\"\"Select the median of three candidate elements\"\"\"\n    l, m, r = nums[left], nums[mid], nums[right]\n    if (l &lt;= m &lt;= r) or (r &lt;= m &lt;= l):\n        return mid  # m is between l and r\n    if (m &lt;= l &lt;= r) or (r &lt;= l &lt;= m):\n        return left  # l is between m and r\n    return right\n\ndef partition(self, nums: list[int], left: int, right: int) -&gt; int:\n    \"\"\"Sentinel partition (median of three)\"\"\"\n    # Use nums[left] as the pivot\n    med = self.median_three(nums, left, (left + right) // 2, right)\n    # Swap the median to the array's leftmost position\n    nums[left], nums[med] = nums[med], nums[left]\n    # Use nums[left] as the pivot\n    i, j = left, right\n    while i &lt; j:\n        while i &lt; j and nums[j] &gt;= nums[left]:\n            j -= 1  # Search from right to left for the first element smaller than the pivot\n        while i &lt; j and nums[i] &lt;= nums[left]:\n            i += 1  # Search from left to right for the first element greater than the pivot\n        # Swap elements\n        nums[i], nums[j] = nums[j], nums[i]\n    # Swap the pivot to the boundary between the two subarrays\n    nums[i], nums[left] = nums[left], nums[i]\n    return i  # Return the index of the pivot\n</code></pre> quick_sort.cpp<pre><code>/* Select the median of three candidate elements */\nint medianThree(vector&lt;int&gt; &amp;nums, int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m is between l and r\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l is between m and r\n    return right;\n}\n\n/* Sentinel partition (median of three) */\nint partition(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // Select the median of three candidate elements\n    int med = medianThree(nums, left, (left + right) / 2, right);\n    // Swap the median to the array's leftmost position\n    swap(nums[left], nums[med]);\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;                // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;                // Search from left to right for the first element greater than the pivot\n        swap(nums[i], nums[j]); // Swap these two elements\n    }\n    swap(nums[i], nums[left]);  // Swap the pivot to the boundary between the two subarrays\n    return i;                   // Return the index of the pivot\n}\n</code></pre> quick_sort.java<pre><code>/* Select the median of three candidate elements */\nint medianThree(int[] nums, int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m is between l and r\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l is between m and r\n    return right;\n}\n\n/* Sentinel partition (median of three) */\nint partition(int[] nums, int left, int right) {\n    // Select the median of three candidate elements\n    int med = medianThree(nums, left, (left + right) / 2, right);\n    // Swap the median to the array's leftmost position\n    swap(nums, left, med);\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // Search from left to right for the first element greater than the pivot\n        swap(nums, i, j); // Swap these two elements\n    }\n    swap(nums, i, left);  // Swap the pivot to the boundary between the two subarrays\n    return i;             // Return the index of the pivot\n}\n</code></pre> quick_sort.cs<pre><code>/* Select the median of three candidate elements */\nint MedianThree(int[] nums, int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m is between l and r\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l is between m and r\n    return right;\n}\n\n/* Sentinel partition (median of three) */\nint Partition(int[] nums, int left, int right) {\n    // Select the median of three candidate elements\n    int med = MedianThree(nums, left, (left + right) / 2, right);\n    // Swap the median to the array's leftmost position\n    Swap(nums, left, med);\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // Search from left to right for the first element greater than the pivot\n        Swap(nums, i, j); // Swap these two elements\n    }\n    Swap(nums, i, left);  // Swap the pivot to the boundary between the two subarrays\n    return i;             // Return the index of the pivot\n}\n</code></pre> quick_sort.go<pre><code>/* Select the median of three candidate elements */\nfunc (q *quickSortMedian) medianThree(nums []int, left, mid, right int) int {\n    l, m, r := nums[left], nums[mid], nums[right]\n    if (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) {\n        return mid // m is between l and r\n    }\n    if (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) {\n        return left // l is between m and r\n    }\n    return right\n}\n\n/* Sentinel partition (median of three) */\nfunc (q *quickSortMedian) partition(nums []int, left, right int) int {\n    // Use nums[left] as the pivot\n    med := q.medianThree(nums, left, (left+right)/2, right)\n    // Swap the median to the array's leftmost position\n    nums[left], nums[med] = nums[med], nums[left]\n    // Use nums[left] as the pivot\n    i, j := left, right\n    for i &lt; j {\n        for i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j-- // Search from right to left for the first element smaller than the pivot\n        }\n        for i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i++ // Search from left to right for the first element greater than the pivot\n        }\n        // Swap elements\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    // Swap the pivot to the boundary between the two subarrays\n    nums[i], nums[left] = nums[left], nums[i]\n    return i // Return the index of the pivot\n}\n</code></pre> quick_sort.swift<pre><code>/* Select the median of three candidate elements */\nfunc medianThree(nums: [Int], left: Int, mid: Int, right: Int) -&gt; Int {\n    let l = nums[left]\n    let m = nums[mid]\n    let r = nums[right]\n    if (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) {\n        return mid // m is between l and r\n    }\n    if (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) {\n        return left // l is between m and r\n    }\n    return right\n}\n\n/* Sentinel partition (median of three) */\nfunc partitionMedian(nums: inout [Int], left: Int, right: Int) -&gt; Int {\n    // Select the median of three candidate elements\n    let med = medianThree(nums: nums, left: left, mid: left + (right - left) / 2, right: right)\n    // Swap the median to the array's leftmost position\n    nums.swapAt(left, med)\n    return partition(nums: &amp;nums, left: left, right: right)\n}\n</code></pre> quick_sort.js<pre><code>/* Select the median of three candidate elements */\nmedianThree(nums, left, mid, right) {\n    let l = nums[left],\n        m = nums[mid],\n        r = nums[right];\n    // m is between l and r\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) return mid;\n    // l is between m and r\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) return left;\n    return right;\n}\n\n/* Sentinel partition (median of three) */\npartition(nums, left, right) {\n    // Select the median of three candidate elements\n    let med = this.medianThree(\n        nums,\n        left,\n        Math.floor((left + right) / 2),\n        right\n    );\n    // Swap the median to the array's leftmost position\n    this.swap(nums, left, med);\n    // Use nums[left] as the pivot\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--; // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++; // Search from left to right for the first element greater than the pivot\n        this.swap(nums, i, j); // Swap these two elements\n    }\n    this.swap(nums, i, left); // Swap the pivot to the boundary between the two subarrays\n    return i; // Return the index of the pivot\n}\n</code></pre> quick_sort.ts<pre><code>/* Select the median of three candidate elements */\nmedianThree(\n    nums: number[],\n    left: number,\n    mid: number,\n    right: number\n): number {\n    let l = nums[left],\n        m = nums[mid],\n        r = nums[right];\n    // m is between l and r\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) return mid;\n    // l is between m and r\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) return left;\n    return right;\n}\n\n/* Sentinel partition (median of three) */\npartition(nums: number[], left: number, right: number): number {\n    // Select the median of three candidate elements\n    let med = this.medianThree(\n        nums,\n        left,\n        Math.floor((left + right) / 2),\n        right\n    );\n    // Swap the median to the array's leftmost position\n    this.swap(nums, left, med);\n    // Use nums[left] as the pivot\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j--; // Search from right to left for the first element smaller than the pivot\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i++; // Search from left to right for the first element greater than the pivot\n        }\n        this.swap(nums, i, j); // Swap these two elements\n    }\n    this.swap(nums, i, left); // Swap the pivot to the boundary between the two subarrays\n    return i; // Return the index of the pivot\n}\n</code></pre> quick_sort.dart<pre><code>/* Select the median of three candidate elements */\nint _medianThree(List&lt;int&gt; nums, int left, int mid, int right) {\n  int l = nums[left], m = nums[mid], r = nums[right];\n  if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n    return mid; // m is between l and r\n  if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n    return left; // l is between m and r\n  return right;\n}\n\n/* Sentinel partition (median of three) */\nint _partition(List&lt;int&gt; nums, int left, int right) {\n  // Select the median of three candidate elements\n  int med = _medianThree(nums, left, (left + right) ~/ 2, right);\n  // Swap the median to the array's leftmost position\n  _swap(nums, left, med);\n  // Use nums[left] as the pivot\n  int i = left, j = right;\n  while (i &lt; j) {\n    while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--; // Search from right to left for the first element smaller than the pivot\n    while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++; // Search from left to right for the first element greater than the pivot\n    _swap(nums, i, j); // Swap these two elements\n  }\n  _swap(nums, i, left); // Swap the pivot to the boundary between the two subarrays\n  return i; // Return the index of the pivot\n}\n</code></pre> quick_sort.rs<pre><code>/* Select the median of three candidate elements */\nfn median_three(nums: &amp;mut [i32], left: usize, mid: usize, right: usize) -&gt; usize {\n    let (l, m, r) = (nums[left], nums[mid], nums[right]);\n    if (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) {\n        return mid; // m is between l and r\n    }\n    if (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) {\n        return left; // l is between m and r\n    }\n    right\n}\n\n/* Sentinel partition (median of three) */\nfn partition(nums: &amp;mut [i32], left: usize, right: usize) -&gt; usize {\n    // Select the median of three candidate elements\n    let med = Self::median_three(nums, left, (left + right) / 2, right);\n    // Swap the median to the array's leftmost position\n    nums.swap(left, med);\n    // Use nums[left] as the pivot\n    let (mut i, mut j) = (left, right);\n    while i &lt; j {\n        while i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j -= 1; // Search from right to left for the first element smaller than the pivot\n        }\n        while i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i += 1; // Search from left to right for the first element greater than the pivot\n        }\n        nums.swap(i, j); // Swap these two elements\n    }\n    nums.swap(i, left); // Swap the pivot to the boundary between the two subarrays\n    i // Return the index of the pivot\n}\n</code></pre> quick_sort.c<pre><code>/* Select the median of three candidate elements */\nint medianThree(int nums[], int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m is between l and r\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l is between m and r\n    return right;\n}\n\n/* Sentinel partition (median of three) */\nint partitionMedian(int nums[], int left, int right) {\n    // Select the median of three candidate elements\n    int med = medianThree(nums, left, (left + right) / 2, right);\n    // Swap the median to the array's leftmost position\n    swap(nums, left, med);\n    // Use nums[left] as the pivot\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--; // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // Search from left to right for the first element greater than the pivot\n        swap(nums, i, j); // Swap these two elements\n    }\n    swap(nums, i, left); // Swap the pivot to the boundary between the two subarrays\n    return i;            // Return the index of the pivot\n}\n</code></pre> quick_sort.kt<pre><code>/* Select the median of three candidate elements */\nfun medianThree(nums: IntArray, left: Int, mid: Int, right: Int): Int {\n    val l = nums[left]\n    val m = nums[mid]\n    val r = nums[right]\n    if ((m in l..r) || (m in r..l))\n        return mid  // m is between l and r\n    if ((l in m..r) || (l in r..m))\n        return left // l is between m and r\n    return right\n}\n\n/* Sentinel partition (median of three) */\nfun partitionMedian(nums: IntArray, left: Int, right: Int): Int {\n    // Select the median of three candidate elements\n    val med = medianThree(nums, left, (left + right) / 2, right)\n    // Swap the median to the array's leftmost position\n    swap(nums, left, med)\n    // Use nums[left] as the pivot\n    var i = left\n    var j = right\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--                      // Search from right to left for the first element smaller than the pivot\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++                      // Search from left to right for the first element greater than the pivot\n        swap(nums, i, j)             // Swap these two elements\n    }\n    swap(nums, i, left)              // Swap the pivot to the boundary between the two subarrays\n    return i                         // Return the index of the pivot\n}\n</code></pre> quick_sort.rb<pre><code>### Select median of three candidate elements ###\ndef median_three(nums, left, mid, right)\n  # Select the median of three candidate elements\n  _l, _m, _r = nums[left], nums[mid], nums[right]\n  # m is between l and r\n  return mid if (_l &lt;= _m &amp;&amp; _m &lt;= _r) || (_r &lt;= _m &amp;&amp; _m &lt;= _l)\n  # l is between m and r\n  return left if (_m &lt;= _l &amp;&amp; _l &lt;= _r) || (_r &lt;= _l &amp;&amp; _l &lt;= _m)\n  return right\nend\n\n### Sentinel partition (median of three) ###\ndef partition(nums, left, right)\n  ### Use nums[left] as pivot\n  med = median_three(nums, left, (left + right) / 2, right)\n  # Swap median to leftmost position of array\n  nums[left], nums[med] = nums[med], nums[left]\n  i, j = left, right\n  while i &lt; j\n    while i &lt; j &amp;&amp; nums[j] &gt;= nums[left]\n      j -= 1 # Search from right to left for the first element smaller than the pivot\n    end\n    while i &lt; j &amp;&amp; nums[i] &lt;= nums[left]\n      i += 1 # Search from left to right for the first element greater than the pivot\n    end\n    # Swap elements\n    nums[i], nums[j] = nums[j], nums[i]\n  end\n  # Swap the pivot to the boundary between the two subarrays\n  nums[i], nums[left] = nums[left], nums[i]\n  i # Return the index of the pivot\nend\n</code></pre>"},{"location":"chapter_sorting/quick_sort/#1155-recursive-depth-optimization","title":"11.5.5 \u00a0 Recursive Depth Optimization","text":"<p>For certain inputs, quick sort may occupy more space. Taking a completely ordered input array as an example, let the length of the sub-array in recursion be \\(m\\). Each round of sentinel partitioning will produce a left sub-array of length \\(0\\) and a right sub-array of length \\(m - 1\\), which means that the problem scale reduced per recursive call is very small (only one element is reduced), and the height of the recursion tree will reach \\(n - 1\\), at which point \\(O(n)\\) size of stack frame space is required.</p> <p>To prevent the accumulation of stack frame space, we can compare the lengths of the two sub-arrays after each round of sentinel sorting is complete, and only recurse on the shorter sub-array. Since the length of the shorter sub-array will not exceed \\(n / 2\\), this method can ensure that the recursion depth does not exceed \\(\\log n\\), thus optimizing the worst-case space complexity to \\(O(\\log n)\\). The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby quick_sort.py<pre><code>def quick_sort(self, nums: list[int], left: int, right: int):\n    \"\"\"Quick sort (recursion depth optimization)\"\"\"\n    # Terminate when subarray length is 1\n    while left &lt; right:\n        # Sentinel partition operation\n        pivot = self.partition(nums, left, right)\n        # Perform quick sort on the shorter of the two subarrays\n        if pivot - left &lt; right - pivot:\n            self.quick_sort(nums, left, pivot - 1)  # Recursively sort the left subarray\n            left = pivot + 1  # Remaining unsorted interval is [pivot + 1, right]\n        else:\n            self.quick_sort(nums, pivot + 1, right)  # Recursively sort the right subarray\n            right = pivot - 1  # Remaining unsorted interval is [left, pivot - 1]\n</code></pre> quick_sort.cpp<pre><code>/* Quick sort (recursion depth optimization) */\nvoid quickSort(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // Terminate when subarray length is 1\n    while (left &lt; right) {\n        // Sentinel partition operation\n        int pivot = partition(nums, left, right);\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - left &lt; right - pivot) {\n            quickSort(nums, left, pivot - 1); // Recursively sort the left subarray\n            left = pivot + 1;                 // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            quickSort(nums, pivot + 1, right); // Recursively sort the right subarray\n            right = pivot - 1;                 // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.java<pre><code>/* Quick sort (recursion depth optimization) */\nvoid quickSort(int[] nums, int left, int right) {\n    // Terminate when subarray length is 1\n    while (left &lt; right) {\n        // Sentinel partition operation\n        int pivot = partition(nums, left, right);\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - left &lt; right - pivot) {\n            quickSort(nums, left, pivot - 1); // Recursively sort the left subarray\n            left = pivot + 1; // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            quickSort(nums, pivot + 1, right); // Recursively sort the right subarray\n            right = pivot - 1; // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.cs<pre><code>/* Quick sort (recursion depth optimization) */\nvoid QuickSort(int[] nums, int left, int right) {\n    // Terminate when subarray length is 1\n    while (left &lt; right) {\n        // Sentinel partition operation\n        int pivot = Partition(nums, left, right);\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - left &lt; right - pivot) {\n            QuickSort(nums, left, pivot - 1);  // Recursively sort the left subarray\n            left = pivot + 1;  // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            QuickSort(nums, pivot + 1, right); // Recursively sort the right subarray\n            right = pivot - 1; // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.go<pre><code>/* Quick sort (recursion depth optimization) */\nfunc (q *quickSortTailCall) quickSort(nums []int, left, right int) {\n    // Terminate when subarray length is 1\n    for left &lt; right {\n        // Sentinel partition operation\n        pivot := q.partition(nums, left, right)\n        // Perform quick sort on the shorter of the two subarrays\n        if pivot-left &lt; right-pivot {\n            q.quickSort(nums, left, pivot-1) // Recursively sort the left subarray\n            left = pivot + 1                 // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            q.quickSort(nums, pivot+1, right) // Recursively sort the right subarray\n            right = pivot - 1                 // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.swift<pre><code>/* Quick sort (recursion depth optimization) */\nfunc quickSortTailCall(nums: inout [Int], left: Int, right: Int) {\n    var left = left\n    var right = right\n    // Terminate when subarray length is 1\n    while left &lt; right {\n        // Sentinel partition operation\n        let pivot = partition(nums: &amp;nums, left: left, right: right)\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - left) &lt; (right - pivot) {\n            quickSortTailCall(nums: &amp;nums, left: left, right: pivot - 1) // Recursively sort the left subarray\n            left = pivot + 1 // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            quickSortTailCall(nums: &amp;nums, left: pivot + 1, right: right) // Recursively sort the right subarray\n            right = pivot - 1 // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.js<pre><code>/* Quick sort (recursion depth optimization) */\nquickSort(nums, left, right) {\n    // Terminate when subarray length is 1\n    while (left &lt; right) {\n        // Sentinel partition operation\n        let pivot = this.partition(nums, left, right);\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - left &lt; right - pivot) {\n            this.quickSort(nums, left, pivot - 1); // Recursively sort the left subarray\n            left = pivot + 1; // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            this.quickSort(nums, pivot + 1, right); // Recursively sort the right subarray\n            right = pivot - 1; // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.ts<pre><code>/* Quick sort (recursion depth optimization) */\nquickSort(nums: number[], left: number, right: number): void {\n    // Terminate when subarray length is 1\n    while (left &lt; right) {\n        // Sentinel partition operation\n        let pivot = this.partition(nums, left, right);\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - left &lt; right - pivot) {\n            this.quickSort(nums, left, pivot - 1); // Recursively sort the left subarray\n            left = pivot + 1; // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            this.quickSort(nums, pivot + 1, right); // Recursively sort the right subarray\n            right = pivot - 1; // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.dart<pre><code>/* Quick sort (recursion depth optimization) */\nvoid quickSort(List&lt;int&gt; nums, int left, int right) {\n  // Terminate when subarray length is 1\n  while (left &lt; right) {\n    // Sentinel partition operation\n    int pivot = _partition(nums, left, right);\n    // Perform quick sort on the shorter of the two subarrays\n    if (pivot - left &lt; right - pivot) {\n      quickSort(nums, left, pivot - 1); // Recursively sort the left subarray\n      left = pivot + 1; // Remaining unsorted interval is [pivot + 1, right]\n    } else {\n      quickSort(nums, pivot + 1, right); // Recursively sort the right subarray\n      right = pivot - 1; // Remaining unsorted interval is [left, pivot - 1]\n    }\n  }\n}\n</code></pre> quick_sort.rs<pre><code>/* Quick sort (recursion depth optimization) */\npub fn quick_sort(mut left: i32, mut right: i32, nums: &amp;mut [i32]) {\n    // Terminate when subarray length is 1\n    while left &lt; right {\n        // Sentinel partition operation\n        let pivot = Self::partition(nums, left as usize, right as usize) as i32;\n        // Perform quick sort on the shorter of the two subarrays\n        if pivot - left &lt; right - pivot {\n            Self::quick_sort(left, pivot - 1, nums); // Recursively sort the left subarray\n            left = pivot + 1; // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            Self::quick_sort(pivot + 1, right, nums); // Recursively sort the right subarray\n            right = pivot - 1; // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.c<pre><code>/* Quick sort (recursion depth optimization) */\nvoid quickSortTailCall(int nums[], int left, int right) {\n    // Terminate when subarray length is 1\n    while (left &lt; right) {\n        // Sentinel partition operation\n        int pivot = partition(nums, left, right);\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - left &lt; right - pivot) {\n            // Recursively sort the left subarray\n            quickSortTailCall(nums, left, pivot - 1);\n            // Remaining unsorted interval is [pivot + 1, right]\n            left = pivot + 1;\n        } else {\n            // Recursively sort the right subarray\n            quickSortTailCall(nums, pivot + 1, right);\n            // Remaining unsorted interval is [left, pivot - 1]\n            right = pivot - 1;\n        }\n    }\n}\n</code></pre> quick_sort.kt<pre><code>/* Quick sort (recursion depth optimization) */\nfun quickSortTailCall(nums: IntArray, left: Int, right: Int) {\n    // Terminate when subarray length is 1\n    var l = left\n    var r = right\n    while (l &lt; r) {\n        // Sentinel partition operation\n        val pivot = partition(nums, l, r)\n        // Perform quick sort on the shorter of the two subarrays\n        if (pivot - l &lt; r - pivot) {\n            quickSort(nums, l, pivot - 1) // Recursively sort the left subarray\n            l = pivot + 1 // Remaining unsorted interval is [pivot + 1, right]\n        } else {\n            quickSort(nums, pivot + 1, r) // Recursively sort the right subarray\n            r = pivot - 1 // Remaining unsorted interval is [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.rb<pre><code>### Quick sort (recursion depth optimization) ###\ndef quick_sort(nums, left, right)\n  # Recurse when subarray length is not 1\n  while left &lt; right\n    # Sentinel partition\n    pivot = partition(nums, left, right)\n    # Perform quick sort on the shorter of the two subarrays\n    if pivot - left &lt; right - pivot\n      quick_sort(nums, left, pivot - 1)\n      left = pivot + 1 # Remaining unsorted interval is [pivot + 1, right]\n    else\n      quick_sort(nums, pivot + 1, right)\n      right = pivot - 1 # Remaining unsorted interval is [left, pivot - 1]\n    end\n  end\nend\n</code></pre>"},{"location":"chapter_sorting/radix_sort/","title":"11.10 \u00a0 Radix Sort","text":"<p>The previous section introduced counting sort, which is suitable for situations where the data volume \\(n\\) is large but the data range \\(m\\) is small. Suppose we need to sort \\(n = 10^6\\) student IDs, and the student ID is an 8-digit number, which means the data range \\(m = 10^8\\) is very large. Using counting sort would require allocating a large amount of memory space, whereas radix sort can avoid this situation.</p> <p>Radix sort (radix sort) has a core idea consistent with counting sort, which also achieves sorting by counting quantities. Building on this, radix sort utilizes the progressive relationship between the digits of numbers, sorting each digit in turn to obtain the final sorting result.</p>"},{"location":"chapter_sorting/radix_sort/#11101-algorithm-flow","title":"11.10.1 \u00a0 Algorithm Flow","text":"<p>Taking student ID data as an example, assume the lowest digit is the \\(1\\)st digit and the highest digit is the \\(8\\)th digit. The flow of radix sort is shown in Figure 11-18.</p> <ol> <li>Initialize the digit \\(k = 1\\).</li> <li>Perform \"counting sort\" on the \\(k\\)th digit of the student IDs. After completion, the data will be sorted from smallest to largest according to the \\(k\\)th digit.</li> <li>Increase \\(k\\) by \\(1\\), then return to step <code>2.</code> and continue iterating until all digits are sorted, at which point the process ends.</li> </ol> <p></p> <p> Figure 11-18 \u00a0 Radix sort algorithm flow </p> <p>Below we analyze the code implementation. For a \\(d\\)-base number \\(x\\), to get its \\(k\\)th digit \\(x_k\\), the following calculation formula can be used:</p> \\[ x_k = \\lfloor\\frac{x}{d^{k-1}}\\rfloor \\bmod d \\] <p>Where \\(\\lfloor a \\rfloor\\) denotes rounding down the floating-point number \\(a\\), and \\(\\bmod \\: d\\) denotes taking the modulo (remainder) with respect to \\(d\\). For student ID data, \\(d = 10\\) and \\(k \\in [1, 8]\\).</p> <p>Additionally, we need to slightly modify the counting sort code to make it sort based on the \\(k\\)th digit of the number:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby radix_sort.py<pre><code>def digit(num: int, exp: int) -&gt; int:\n    \"\"\"Get the k-th digit of element num, where exp = 10^(k-1)\"\"\"\n    # Passing exp instead of k can avoid repeated expensive exponentiation here\n    return (num // exp) % 10\n\ndef counting_sort_digit(nums: list[int], exp: int):\n    \"\"\"Counting sort (based on nums k-th digit)\"\"\"\n    # Decimal digit range is 0~9, therefore need a bucket array of length 10\n    counter = [0] * 10\n    n = len(nums)\n    # Count the occurrence of digits 0~9\n    for i in range(n):\n        d = digit(nums[i], exp)  # Get the k-th digit of nums[i], noted as d\n        counter[d] += 1  # Count the occurrence of digit d\n    # Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for i in range(1, 10):\n        counter[i] += counter[i - 1]\n    # Traverse in reverse, based on bucket statistics, place each element into res\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        d = digit(nums[i], exp)\n        j = counter[d] - 1  # Get the index j for d in the array\n        res[j] = nums[i]  # Place the current element at index j\n        counter[d] -= 1  # Decrease the count of d by 1\n    # Use result to overwrite the original array nums\n    for i in range(n):\n        nums[i] = res[i]\n\ndef radix_sort(nums: list[int]):\n    \"\"\"Radix sort\"\"\"\n    # Get the maximum element of the array, used to determine the maximum number of digits\n    m = max(nums)\n    # Traverse from the lowest to the highest digit\n    exp = 1\n    while exp &lt;= m:\n        # Perform counting sort on the k-th digit of array elements\n        # k = 1 -&gt; exp = 1\n        # k = 2 -&gt; exp = 10\n        # i.e., exp = 10^(k-1)\n        counting_sort_digit(nums, exp)\n        exp *= 10\n</code></pre> radix_sort.cpp<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nint digit(int num, int exp) {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return (num / exp) % 10;\n}\n\n/* Counting sort (based on nums k-th digit) */\nvoid countingSortDigit(vector&lt;int&gt; &amp;nums, int exp) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    vector&lt;int&gt; counter(10, 0);\n    int n = nums.size();\n    // Count the occurrence of digits 0~9\n    for (int i = 0; i &lt; n; i++) {\n        int d = digit(nums[i], exp); // Get the k-th digit of nums[i], noted as d\n        counter[d]++;                // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    vector&lt;int&gt; res(n, 0);\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int d = digit(nums[i], exp);\n        int j = counter[d] - 1; // Get the index j for d in the array\n        res[j] = nums[i];       // Place the current element at index j\n        counter[d]--;           // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for (int i = 0; i &lt; n; i++)\n        nums[i] = res[i];\n}\n\n/* Radix sort */\nvoid radixSort(vector&lt;int&gt; &amp;nums) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    int m = *max_element(nums.begin(), nums.end());\n    // Traverse from the lowest to the highest digit\n    for (int exp = 1; exp &lt;= m; exp *= 10)\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n}\n</code></pre> radix_sort.java<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nint digit(int num, int exp) {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return (num / exp) % 10;\n}\n\n/* Counting sort (based on nums k-th digit) */\nvoid countingSortDigit(int[] nums, int exp) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    int[] counter = new int[10];\n    int n = nums.length;\n    // Count the occurrence of digits 0~9\n    for (int i = 0; i &lt; n; i++) {\n        int d = digit(nums[i], exp); // Get the k-th digit of nums[i], noted as d\n        counter[d]++;                // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int d = digit(nums[i], exp);\n        int j = counter[d] - 1; // Get the index j for d in the array\n        res[j] = nums[i];       // Place the current element at index j\n        counter[d]--;           // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for (int i = 0; i &lt; n; i++)\n        nums[i] = res[i];\n}\n\n/* Radix sort */\nvoid radixSort(int[] nums) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    int m = Integer.MIN_VALUE;\n    for (int num : nums)\n        if (num &gt; m)\n            m = num;\n    // Traverse from the lowest to the highest digit\n    for (int exp = 1; exp &lt;= m; exp *= 10) {\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.cs<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nint Digit(int num, int exp) {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return (num / exp) % 10;\n}\n\n/* Counting sort (based on nums k-th digit) */\nvoid CountingSortDigit(int[] nums, int exp) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    int[] counter = new int[10];\n    int n = nums.Length;\n    // Count the occurrence of digits 0~9\n    for (int i = 0; i &lt; n; i++) {\n        int d = Digit(nums[i], exp); // Get the k-th digit of nums[i], noted as d\n        counter[d]++;                // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int d = Digit(nums[i], exp);\n        int j = counter[d] - 1; // Get the index j for d in the array\n        res[j] = nums[i];       // Place the current element at index j\n        counter[d]--;           // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n\n/* Radix sort */\nvoid RadixSort(int[] nums) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    int m = int.MinValue;\n    foreach (int num in nums) {\n        if (num &gt; m) m = num;\n    }\n    // Traverse from the lowest to the highest digit\n    for (int exp = 1; exp &lt;= m; exp *= 10) {\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        CountingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.go<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nfunc digit(num, exp int) int {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return (num / exp) % 10\n}\n\n/* Counting sort (based on nums k-th digit) */\nfunc countingSortDigit(nums []int, exp int) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    counter := make([]int, 10)\n    n := len(nums)\n    // Count the occurrence of digits 0~9\n    for i := 0; i &lt; n; i++ {\n        d := digit(nums[i], exp) // Get the k-th digit of nums[i], noted as d\n        counter[d]++             // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for i := 1; i &lt; 10; i++ {\n        counter[i] += counter[i-1]\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    res := make([]int, n)\n    for i := n - 1; i &gt;= 0; i-- {\n        d := digit(nums[i], exp)\n        j := counter[d] - 1 // Get the index j for d in the array\n        res[j] = nums[i]    // Place the current element at index j\n        counter[d]--        // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for i := 0; i &lt; n; i++ {\n        nums[i] = res[i]\n    }\n}\n\n/* Radix sort */\nfunc radixSort(nums []int) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    max := math.MinInt\n    for _, num := range nums {\n        if num &gt; max {\n            max = num\n        }\n    }\n    // Traverse from the lowest to the highest digit\n    for exp := 1; max &gt;= exp; exp *= 10 {\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums, exp)\n    }\n}\n</code></pre> radix_sort.swift<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nfunc digit(num: Int, exp: Int) -&gt; Int {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    (num / exp) % 10\n}\n\n/* Counting sort (based on nums k-th digit) */\nfunc countingSortDigit(nums: inout [Int], exp: Int) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    var counter = Array(repeating: 0, count: 10)\n    // Count the occurrence of digits 0~9\n    for i in nums.indices {\n        let d = digit(num: nums[i], exp: exp) // Get the k-th digit of nums[i], noted as d\n        counter[d] += 1 // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for i in 1 ..&lt; 10 {\n        counter[i] += counter[i - 1]\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    var res = Array(repeating: 0, count: nums.count)\n    for i in nums.indices.reversed() {\n        let d = digit(num: nums[i], exp: exp)\n        let j = counter[d] - 1 // Get the index j for d in the array\n        res[j] = nums[i] // Place the current element at index j\n        counter[d] -= 1 // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for i in nums.indices {\n        nums[i] = res[i]\n    }\n}\n\n/* Radix sort */\nfunc radixSort(nums: inout [Int]) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    var m = Int.min\n    for num in nums {\n        if num &gt; m {\n            m = num\n        }\n    }\n    // Traverse from the lowest to the highest digit\n    for exp in sequence(first: 1, next: { m &gt;= ($0 * 10) ? $0 * 10 : nil }) {\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums: &amp;nums, exp: exp)\n    }\n}\n</code></pre> radix_sort.js<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nfunction digit(num, exp) {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return Math.floor(num / exp) % 10;\n}\n\n/* Counting sort (based on nums k-th digit) */\nfunction countingSortDigit(nums, exp) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    const counter = new Array(10).fill(0);\n    const n = nums.length;\n    // Count the occurrence of digits 0~9\n    for (let i = 0; i &lt; n; i++) {\n        const d = digit(nums[i], exp); // Get the k-th digit of nums[i], noted as d\n        counter[d]++; // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for (let i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    const res = new Array(n).fill(0);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const d = digit(nums[i], exp);\n        const j = counter[d] - 1; // Get the index j for d in the array\n        res[j] = nums[i]; // Place the current element at index j\n        counter[d]--; // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n\n/* Radix sort */\nfunction radixSort(nums) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    let m = Math.max(... nums);\n    // Traverse from the lowest to the highest digit\n    for (let exp = 1; exp &lt;= m; exp *= 10) {\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.ts<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nfunction digit(num: number, exp: number): number {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return Math.floor(num / exp) % 10;\n}\n\n/* Counting sort (based on nums k-th digit) */\nfunction countingSortDigit(nums: number[], exp: number): void {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    const counter = new Array(10).fill(0);\n    const n = nums.length;\n    // Count the occurrence of digits 0~9\n    for (let i = 0; i &lt; n; i++) {\n        const d = digit(nums[i], exp); // Get the k-th digit of nums[i], noted as d\n        counter[d]++; // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for (let i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    const res = new Array(n).fill(0);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const d = digit(nums[i], exp);\n        const j = counter[d] - 1; // Get the index j for d in the array\n        res[j] = nums[i]; // Place the current element at index j\n        counter[d]--; // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n\n/* Radix sort */\nfunction radixSort(nums: number[]): void {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    let m: number = Math.max(... nums);\n    // Traverse from the lowest to the highest digit\n    for (let exp = 1; exp &lt;= m; exp *= 10) {\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.dart<pre><code>/* Get k-th digit of element _num, where exp = 10^(k-1) */\nint digit(int _num, int exp) {\n  // Passing exp instead of k can avoid repeated expensive exponentiation here\n  return (_num ~/ exp) % 10;\n}\n\n/* Counting sort (based on nums k-th digit) */\nvoid countingSortDigit(List&lt;int&gt; nums, int exp) {\n  // Decimal digit range is 0~9, therefore need a bucket array of length 10\n  List&lt;int&gt; counter = List&lt;int&gt;.filled(10, 0);\n  int n = nums.length;\n  // Count the occurrence of digits 0~9\n  for (int i = 0; i &lt; n; i++) {\n    int d = digit(nums[i], exp); // Get the k-th digit of nums[i], noted as d\n    counter[d]++; // Count the occurrence of digit d\n  }\n  // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n  for (int i = 1; i &lt; 10; i++) {\n    counter[i] += counter[i - 1];\n  }\n  // Traverse in reverse, based on bucket statistics, place each element into res\n  List&lt;int&gt; res = List&lt;int&gt;.filled(n, 0);\n  for (int i = n - 1; i &gt;= 0; i--) {\n    int d = digit(nums[i], exp);\n    int j = counter[d] - 1; // Get the index j for d in the array\n    res[j] = nums[i]; // Place the current element at index j\n    counter[d]--; // Decrease the count of d by 1\n  }\n  // Use result to overwrite the original array nums\n  for (int i = 0; i &lt; n; i++) nums[i] = res[i];\n}\n\n/* Radix sort */\nvoid radixSort(List&lt;int&gt; nums) {\n  // Get the maximum element of the array, used to determine the maximum number of digits\n  // In Dart, int length is 64 bits\n  int m = -1 &lt;&lt; 63;\n  for (int _num in nums) if (_num &gt; m) m = _num;\n  // Traverse from the lowest to the highest digit\n  for (int exp = 1; exp &lt;= m; exp *= 10)\n    // Perform counting sort on the k-th digit of array elements\n    // k = 1 -&gt; exp = 1\n    // k = 2 -&gt; exp = 10\n    // i.e., exp = 10^(k-1)\n    countingSortDigit(nums, exp);\n}\n</code></pre> radix_sort.rs<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nfn digit(num: i32, exp: i32) -&gt; usize {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return ((num / exp) % 10) as usize;\n}\n\n/* Counting sort (based on nums k-th digit) */\nfn counting_sort_digit(nums: &amp;mut [i32], exp: i32) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    let mut counter = [0; 10];\n    let n = nums.len();\n    // Count the occurrence of digits 0~9\n    for i in 0..n {\n        let d = digit(nums[i], exp); // Get the k-th digit of nums[i], noted as d\n        counter[d] += 1; // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for i in 1..10 {\n        counter[i] += counter[i - 1];\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    let mut res = vec![0; n];\n    for i in (0..n).rev() {\n        let d = digit(nums[i], exp);\n        let j = counter[d] - 1; // Get the index j for d in the array\n        res[j] = nums[i]; // Place the current element at index j\n        counter[d] -= 1; // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    nums.copy_from_slice(&amp;res);\n}\n\n/* Radix sort */\nfn radix_sort(nums: &amp;mut [i32]) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    let m = *nums.into_iter().max().unwrap();\n    // Traverse from the lowest to the highest digit\n    let mut exp = 1;\n    while exp &lt;= m {\n        counting_sort_digit(nums, exp);\n        exp *= 10;\n    }\n}\n</code></pre> radix_sort.c<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nint digit(int num, int exp) {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return (num / exp) % 10;\n}\n\n/* Counting sort (based on nums k-th digit) */\nvoid countingSortDigit(int nums[], int size, int exp) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    int *counter = (int *)malloc((sizeof(int) * 10));\n    memset(counter, 0, sizeof(int) * 10); // Initialize to 0 to support subsequent memory release\n    // Count the occurrence of digits 0~9\n    for (int i = 0; i &lt; size; i++) {\n        // Get the k-th digit of nums[i], noted as d\n        int d = digit(nums[i], exp);\n        // Count the occurrence of digit d\n        counter[d]++;\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    int *res = (int *)malloc(sizeof(int) * size);\n    for (int i = size - 1; i &gt;= 0; i--) {\n        int d = digit(nums[i], exp);\n        int j = counter[d] - 1; // Get the index j for d in the array\n        res[j] = nums[i];       // Place the current element at index j\n        counter[d]--;           // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for (int i = 0; i &lt; size; i++) {\n        nums[i] = res[i];\n    }\n    // Free memory\n    free(res);\n    free(counter);\n}\n\n/* Radix sort */\nvoid radixSort(int nums[], int size) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    int max = INT32_MIN;\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] &gt; max) {\n            max = nums[i];\n        }\n    }\n    // Traverse from the lowest to the highest digit\n    for (int exp = 1; max &gt;= exp; exp *= 10)\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums, size, exp);\n}\n</code></pre> radix_sort.kt<pre><code>/* Get the k-th digit of element num, where exp = 10^(k-1) */\nfun digit(num: Int, exp: Int): Int {\n    // Passing exp instead of k can avoid repeated expensive exponentiation here\n    return (num / exp) % 10\n}\n\n/* Counting sort (based on nums k-th digit) */\nfun countingSortDigit(nums: IntArray, exp: Int) {\n    // Decimal digit range is 0~9, therefore need a bucket array of length 10\n    val counter = IntArray(10)\n    val n = nums.size\n    // Count the occurrence of digits 0~9\n    for (i in 0..&lt;n) {\n        val d = digit(nums[i], exp) // Get the k-th digit of nums[i], noted as d\n        counter[d]++                // Count the occurrence of digit d\n    }\n    // Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n    for (i in 1..9) {\n        counter[i] += counter[i - 1]\n    }\n    // Traverse in reverse, based on bucket statistics, place each element into res\n    val res = IntArray(n)\n    for (i in n - 1 downTo 0) {\n        val d = digit(nums[i], exp)\n        val j = counter[d] - 1 // Get the index j for d in the array\n        res[j] = nums[i]       // Place the current element at index j\n        counter[d]--           // Decrease the count of d by 1\n    }\n    // Use result to overwrite the original array nums\n    for (i in 0..&lt;n)\n        nums[i] = res[i]\n}\n\n/* Radix sort */\nfun radixSort(nums: IntArray) {\n    // Get the maximum element of the array, used to determine the maximum number of digits\n    var m = Int.MIN_VALUE\n    for (num in nums) if (num &gt; m) m = num\n    var exp = 1\n    // Traverse from the lowest to the highest digit\n    while (exp &lt;= m) {\n        // Perform counting sort on the k-th digit of array elements\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // i.e., exp = 10^(k-1)\n        countingSortDigit(nums, exp)\n        exp *= 10\n    }\n}\n</code></pre> radix_sort.rb<pre><code>### Get k-th digit of element num, where exp = 10^(k-1) ###\ndef digit(num, exp)\n  # Passing exp instead of k avoids expensive exponentiation calculations\n  (num / exp) % 10\nend\n\n### Counting sort (sort by k-th digit of nums) ###\ndef counting_sort_digit(nums, exp)\n  # Decimal digit range is 0~9, therefore need a bucket array of length 10\n  counter = Array.new(10, 0)\n  n = nums.length\n  # Count the occurrence of digits 0~9\n  for i in 0...n\n    d = digit(nums[i], exp) # Get the k-th digit of nums[i], noted as d\n    counter[d] += 1 # Count the occurrence of digit d\n  end\n  # Calculate prefix sum, converting \"occurrence count\" into \"array index\"\n  (1...10).each { |i| counter[i] += counter[i - 1] }\n  # Traverse in reverse, based on bucket statistics, place each element into res\n  res = Array.new(n, 0)\n  for i in (n - 1).downto(0)\n    d = digit(nums[i], exp)\n    j = counter[d] - 1 # Get the index j for d in the array\n    res[j] = nums[i] # Place the current element at index j\n    counter[d] -= 1 # Decrease the count of d by 1\n  end\n  # Use result to overwrite the original array nums\n  (0...n).each { |i| nums[i] = res[i] }\nend\n\n### Radix sort ###\ndef radix_sort(nums)\n  # Get the maximum element of the array, used to determine the maximum number of digits\n  m = nums.max\n  # Traverse from the lowest to the highest digit\n  exp = 1\n  while exp &lt;= m\n    # Perform counting sort on the k-th digit of array elements\n    # k = 1 -&gt; exp = 1\n    # k = 2 -&gt; exp = 10\n    # i.e., exp = 10^(k-1)\n    counting_sort_digit(nums, exp)\n    exp *= 10\n  end\nend\n</code></pre> <p>Why start sorting from the lowest digit?</p> <p>In successive sorting rounds, the result of a later round will override the result of an earlier round. For example, if the first round result is \\(a &lt; b\\), while the second round result is \\(a &gt; b\\), then the second round's result will replace the first round's result. Since higher-order digits have higher priority than lower-order digits, we should sort the lower digits first and then sort the higher digits.</p>"},{"location":"chapter_sorting/radix_sort/#11102-algorithm-characteristics","title":"11.10.2 \u00a0 Algorithm Characteristics","text":"<p>Compared to counting sort, radix sort is suitable for larger numerical ranges, but the prerequisite is that the data must be representable in a fixed number of digits, and the number of digits should not be too large. For example, floating-point numbers are not suitable for radix sort because their number of digits \\(k\\) may be too large, potentially leading to time complexity \\(O(nk) \\gg O(n^2)\\).</p> <ul> <li>Time complexity of \\(O(nk)\\), non-adaptive sorting: Let the data volume be \\(n\\), the data be in base \\(d\\), and the maximum number of digits be \\(k\\). Then performing counting sort on a certain digit uses \\(O(n + d)\\) time, and sorting all \\(k\\) digits uses \\(O((n + d)k)\\) time. Typically, both \\(d\\) and \\(k\\) are relatively small, and the time complexity approaches \\(O(n)\\).</li> <li>Space complexity of \\(O(n + d)\\), non-in-place sorting: Same as counting sort, radix sort requires auxiliary arrays <code>res</code> and <code>counter</code> of lengths \\(n\\) and \\(d\\).</li> <li>Stable sorting: When counting sort is stable, radix sort is also stable; when counting sort is unstable, radix sort cannot guarantee obtaining correct sorting results.</li> </ul>"},{"location":"chapter_sorting/selection_sort/","title":"11.2 \u00a0 Selection Sort","text":"<p>Selection sort (selection sort) works very simply: it opens a loop, and in each round, selects the smallest element from the unsorted interval and places it at the end of the sorted interval.</p> <p>Assume the array has length \\(n\\). The algorithm flow of selection sort is shown in Figure 11-2.</p> <ol> <li>Initially, all elements are unsorted, i.e., the unsorted (index) interval is \\([0, n-1]\\).</li> <li>Select the smallest element in the interval \\([0, n-1]\\) and swap it with the element at index \\(0\\). After completion, the first element of the array is sorted.</li> <li>Select the smallest element in the interval \\([1, n-1]\\) and swap it with the element at index \\(1\\). After completion, the first 2 elements of the array are sorted.</li> <li>And so on. After \\(n - 1\\) rounds of selection and swapping, the first \\(n - 1\\) elements of the array are sorted.</li> <li>The only remaining element must be the largest element, requiring no sorting, so the array sorting is complete.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-2 \u00a0 Selection sort steps </p> <p>In the code, we use \\(k\\) to record the smallest element within the unsorted interval:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby selection_sort.py<pre><code>def selection_sort(nums: list[int]):\n    \"\"\"Selection sort\"\"\"\n    n = len(nums)\n    # Outer loop: unsorted interval is [i, n-1]\n    for i in range(n - 1):\n        # Inner loop: find the smallest element within the unsorted interval\n        k = i\n        for j in range(i + 1, n):\n            if nums[j] &lt; nums[k]:\n                k = j  # Record the index of the smallest element\n        # Swap the smallest element with the first element of the unsorted interval\n        nums[i], nums[k] = nums[k], nums[i]\n</code></pre> selection_sort.cpp<pre><code>/* Selection sort */\nvoid selectionSort(vector&lt;int&gt; &amp;nums) {\n    int n = nums.size();\n    // Outer loop: unsorted interval is [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // Inner loop: find the smallest element within the unsorted interval\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // Record the index of the smallest element\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        swap(nums[i], nums[k]);\n    }\n}\n</code></pre> selection_sort.java<pre><code>/* Selection sort */\nvoid selectionSort(int[] nums) {\n    int n = nums.length;\n    // Outer loop: unsorted interval is [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // Inner loop: find the smallest element within the unsorted interval\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // Record the index of the smallest element\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        int temp = nums[i];\n        nums[i] = nums[k];\n        nums[k] = temp;\n    }\n}\n</code></pre> selection_sort.cs<pre><code>/* Selection sort */\nvoid SelectionSort(int[] nums) {\n    int n = nums.Length;\n    // Outer loop: unsorted interval is [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // Inner loop: find the smallest element within the unsorted interval\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // Record the index of the smallest element\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        (nums[k], nums[i]) = (nums[i], nums[k]);\n    }\n}\n</code></pre> selection_sort.go<pre><code>/* Selection sort */\nfunc selectionSort(nums []int) {\n    n := len(nums)\n    // Outer loop: unsorted interval is [i, n-1]\n    for i := 0; i &lt; n-1; i++ {\n        // Inner loop: find the smallest element within the unsorted interval\n        k := i\n        for j := i + 1; j &lt; n; j++ {\n            if nums[j] &lt; nums[k] {\n                // Record the index of the smallest element\n                k = j\n            }\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        nums[i], nums[k] = nums[k], nums[i]\n\n    }\n}\n</code></pre> selection_sort.swift<pre><code>/* Selection sort */\nfunc selectionSort(nums: inout [Int]) {\n    // Outer loop: unsorted interval is [i, n-1]\n    for i in nums.indices.dropLast() {\n        // Inner loop: find the smallest element within the unsorted interval\n        var k = i\n        for j in nums.indices.dropFirst(i + 1) {\n            if nums[j] &lt; nums[k] {\n                k = j // Record the index of the smallest element\n            }\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        nums.swapAt(i, k)\n    }\n}\n</code></pre> selection_sort.js<pre><code>/* Selection sort */\nfunction selectionSort(nums) {\n    let n = nums.length;\n    // Outer loop: unsorted interval is [i, n-1]\n    for (let i = 0; i &lt; n - 1; i++) {\n        // Inner loop: find the smallest element within the unsorted interval\n        let k = i;\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k]) {\n                k = j; // Record the index of the smallest element\n            }\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        [nums[i], nums[k]] = [nums[k], nums[i]];\n    }\n}\n</code></pre> selection_sort.ts<pre><code>/* Selection sort */\nfunction selectionSort(nums: number[]): void {\n    let n = nums.length;\n    // Outer loop: unsorted interval is [i, n-1]\n    for (let i = 0; i &lt; n - 1; i++) {\n        // Inner loop: find the smallest element within the unsorted interval\n        let k = i;\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k]) {\n                k = j; // Record the index of the smallest element\n            }\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        [nums[i], nums[k]] = [nums[k], nums[i]];\n    }\n}\n</code></pre> selection_sort.dart<pre><code>/* Selection sort */\nvoid selectionSort(List&lt;int&gt; nums) {\n  int n = nums.length;\n  // Outer loop: unsorted interval is [i, n-1]\n  for (int i = 0; i &lt; n - 1; i++) {\n    // Inner loop: find the smallest element within the unsorted interval\n    int k = i;\n    for (int j = i + 1; j &lt; n; j++) {\n      if (nums[j] &lt; nums[k]) k = j; // Record the index of the smallest element\n    }\n    // Swap the smallest element with the first element of the unsorted interval\n    int temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n  }\n}\n</code></pre> selection_sort.rs<pre><code>/* Selection sort */\nfn selection_sort(nums: &amp;mut [i32]) {\n    if nums.is_empty() {\n        return;\n    }\n    let n = nums.len();\n    // Outer loop: unsorted interval is [i, n-1]\n    for i in 0..n - 1 {\n        // Inner loop: find the smallest element within the unsorted interval\n        let mut k = i;\n        for j in i + 1..n {\n            if nums[j] &lt; nums[k] {\n                k = j; // Record the index of the smallest element\n            }\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        nums.swap(i, k);\n    }\n}\n</code></pre> selection_sort.c<pre><code>/* Selection sort */\nvoid selectionSort(int nums[], int n) {\n    // Outer loop: unsorted interval is [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // Inner loop: find the smallest element within the unsorted interval\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // Record the index of the smallest element\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        int temp = nums[i];\n        nums[i] = nums[k];\n        nums[k] = temp;\n    }\n}\n</code></pre> selection_sort.kt<pre><code>/* Selection sort */\nfun selectionSort(nums: IntArray) {\n    val n = nums.size\n    // Outer loop: unsorted interval is [i, n-1]\n    for (i in 0..&lt;n - 1) {\n        var k = i\n        // Inner loop: find the smallest element within the unsorted interval\n        for (j in i + 1..&lt;n) {\n            if (nums[j] &lt; nums[k])\n                k = j // Record the index of the smallest element\n        }\n        // Swap the smallest element with the first element of the unsorted interval\n        val temp = nums[i]\n        nums[i] = nums[k]\n        nums[k] = temp\n    }\n}\n</code></pre> selection_sort.rb<pre><code>### Selection sort ###\ndef selection_sort(nums)\n  n = nums.length\n  # Outer loop: unsorted interval is [i, n-1]\n  for i in 0...(n - 1)\n    # Inner loop: find the smallest element within the unsorted interval\n    k = i\n    for j in (i + 1)...n\n      if nums[j] &lt; nums[k]\n        k = j # Record the index of the smallest element\n      end\n    end\n    # Swap the smallest element with the first element of the unsorted interval\n    nums[i], nums[k] = nums[k], nums[i]\n  end\nend\n</code></pre>"},{"location":"chapter_sorting/selection_sort/#1121-algorithm-characteristics","title":"11.2.1 \u00a0 Algorithm Characteristics","text":"<ul> <li>Time complexity of \\(O(n^2)\\), non-adaptive sorting: The outer loop has \\(n - 1\\) rounds in total. The length of the unsorted interval in the first round is \\(n\\), and the length of the unsorted interval in the last round is \\(2\\). That is, each round of the outer loop contains \\(n\\), \\(n - 1\\), \\(\\dots\\), \\(3\\), \\(2\\) inner loop iterations, summing to \\(\\frac{(n - 1)(n + 2)}{2}\\).</li> <li>Space complexity of \\(O(1)\\), in-place sorting: Pointers \\(i\\) and \\(j\\) use a constant amount of extra space.</li> <li>Non-stable sorting: As shown in Figure 11-3, element <code>nums[i]</code> may be swapped to the right of an element equal to it, causing a change in their relative order.</li> </ul> <p> Figure 11-3 \u00a0 Selection sort non-stability example </p>"},{"location":"chapter_sorting/sorting_algorithm/","title":"11.1 \u00a0 Sorting Algorithm","text":"<p>Sorting algorithm (sorting algorithm) is used to arrange a group of data in a specific order. Sorting algorithms have extensive applications because ordered data can usually be searched, analyzed, and processed more efficiently.</p> <p>As shown in Figure 11-1, data types in sorting algorithms can be integers, floating-point numbers, characters, or strings, etc. The sorting criterion can be set according to requirements, such as numerical size, character ASCII code order, or custom rules.</p> <p></p> <p> Figure 11-1 \u00a0 Data type and criterion examples </p>"},{"location":"chapter_sorting/sorting_algorithm/#1111-evaluation-dimensions","title":"11.1.1 \u00a0 Evaluation Dimensions","text":"<p>Execution efficiency: We expect the time complexity of sorting algorithms to be as low as possible, with a smaller total number of operations (reducing the constant factor in time complexity). For large data volumes, execution efficiency is particularly important.</p> <p>In-place property: As the name implies, in-place sorting achieves sorting by operating directly on the original array without requiring additional auxiliary arrays, thus saving memory. Typically, in-place sorting involves fewer data movement operations and runs faster.</p> <p>Stability: Stable sorting ensures that the relative order of equal elements in the array does not change after sorting is completed.</p> <p>Stable sorting is a necessary condition for multi-level sorting scenarios. Suppose we have a table storing student information, where column 1 and column 2 are name and age, respectively. In this case, unstable sorting may cause the ordered nature of the input data to be lost:</p> <pre><code># Input Data Is Sorted by Name\n# (name, age)\n  ('A', 19)\n  ('B', 18)\n  ('C', 21)\n  ('D', 19)\n  ('E', 23)\n\n# Assuming We Use an Unstable Sorting Algorithm to Sort the List by Age,\n# In the Result, the Relative Positions of ('D', 19) and ('A', 19) Are Changed,\n# And the Property That the Input Data Is Sorted by Name Is Lost\n  ('B', 18)\n  ('D', 19)\n  ('A', 19)\n  ('C', 21)\n  ('E', 23)\n</code></pre> <p>Adaptability: Adaptive sorting can utilize the existing order information in the input data to reduce the amount of computation, achieving better time efficiency. The best-case time complexity of adaptive sorting algorithms is typically better than the average time complexity.</p> <p>Comparison-based or not: Comparison-based sorting relies on comparison operators (\\(&lt;\\), \\(=\\), \\(&gt;\\)) to determine the relative order of elements, thereby sorting the entire array, with a theoretical optimal time complexity of \\(O(n \\log n)\\). Non-comparison sorting does not use comparison operators and can achieve a time complexity of \\(O(n)\\), but its versatility is relatively limited.</p>"},{"location":"chapter_sorting/sorting_algorithm/#1112-ideal-sorting-algorithm","title":"11.1.2 \u00a0 Ideal Sorting Algorithm","text":"<p>Fast execution, in-place, stable, adaptive, good versatility. Clearly, no sorting algorithm has been discovered to date that combines all of these characteristics. Therefore, when selecting a sorting algorithm, it is necessary to decide based on the specific characteristics of the data and the requirements of the problem.</p> <p>Next, we will learn about various sorting algorithms together and analyze the advantages and disadvantages of each sorting algorithm based on the above evaluation dimensions.</p>"},{"location":"chapter_sorting/summary/","title":"11.11 \u00a0 Summary","text":""},{"location":"chapter_sorting/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Bubble sort achieves sorting by swapping adjacent elements. By adding a flag to enable early return, we can optimize the best-case time complexity of bubble sort to \\(O(n)\\).</li> <li>Insertion sort completes sorting by inserting elements from the unsorted interval into the correct position in the sorted interval each round. Although the time complexity of insertion sort is \\(O(n^2)\\), it is very popular in small data volume sorting tasks because it involves relatively few unit operations.</li> <li>Quick sort is implemented based on sentinel partitioning operations. In sentinel partitioning, it is possible to select the worst pivot every time, causing the time complexity to degrade to \\(O(n^2)\\). Introducing median pivot or random pivot can reduce the probability of such degradation. By preferentially recursing on the shorter sub-interval, the recursion depth can be effectively reduced, optimizing the space complexity to \\(O(\\log n)\\).</li> <li>Merge sort includes two phases: divide and merge, which typically embody the divide-and-conquer strategy. In merge sort, sorting an array requires creating auxiliary arrays, with a space complexity of \\(O(n)\\); however, the space complexity of sorting a linked list can be optimized to \\(O(1)\\).</li> <li>Bucket sort consists of three steps: distributing data into buckets, sorting within buckets, and merging results. It also embodies the divide-and-conquer strategy and is suitable for very large data volumes. The key to bucket sort is distributing data evenly.</li> <li>Counting sort is a special case of bucket sort, which achieves sorting by counting the number of occurrences of data. Counting sort is suitable for situations where the data volume is large but the data range is limited, and requires that data can be converted to positive integers.</li> <li>Radix sort achieves data sorting by sorting digit by digit, requiring that data can be represented as fixed-digit numbers.</li> <li>Overall, we hope to find a sorting algorithm that is efficient, stable, in-place, and adaptive, with good versatility. However, just like other data structures and algorithms, no sorting algorithm has been found so far that simultaneously possesses all these characteristics. In practical applications, we need to select the appropriate sorting algorithm based on the specific characteristics of the data.</li> <li>Figure 11-19 compares mainstream sorting algorithms in terms of efficiency, stability, in-place property, and adaptability.</li> </ul> <p> Figure 11-19 \u00a0 Sorting algorithm comparison </p>"},{"location":"chapter_sorting/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: In what situations is the stability of sorting algorithms necessary?</p> <p>In reality, we may sort based on a certain attribute of objects. For example, students have two attributes: name and height. We want to implement multi-level sorting: first sort by name to get <code>(A, 180) (B, 185) (C, 170) (D, 170)</code>; then sort by height. Because the sorting algorithm is unstable, we may get <code>(D, 170) (C, 170) (A, 180) (B, 185)</code>.</p> <p>It can be seen that the positions of students D and C have been swapped, and the orderliness of names has been disrupted, which is something we don't want to see.</p> <p>Q: Can the order of \"searching from right to left\" and \"searching from left to right\" in sentinel partitioning be swapped?</p> <p>No. When we use the leftmost element as the pivot, we must first \"search from right to left\" and then \"search from left to right\". This conclusion is somewhat counterintuitive; let's analyze the reason.</p> <p>The last step of sentinel partitioning <code>partition()</code> is to swap <code>nums[left]</code> and <code>nums[i]</code>. After the swap is complete, the elements to the left of the pivot are all <code>&lt;=</code> the pivot, which requires that <code>nums[left] &gt;= nums[i]</code> must hold before the last swap. Suppose we first \"search from left to right\", then if we cannot find an element larger than the pivot, we will exit the loop when <code>i == j</code>, at which point it may be that <code>nums[j] == nums[i] &gt; nums[left]</code>. In other words, the last swap operation will swap an element larger than the pivot to the leftmost end of the array, causing sentinel partitioning to fail.</p> <p>For example, given the array <code>[0, 0, 0, 0, 1]</code>, if we first \"search from left to right\", the array after sentinel partitioning is <code>[1, 0, 0, 0, 0]</code>, which is incorrect.</p> <p>Thinking deeper, if we select <code>nums[right]</code> as the pivot, then it's exactly the opposite - we must first \"search from left to right\".</p> <p>Q: Regarding the optimization of recursion depth in quick sort, why can selecting the shorter array ensure that the recursion depth does not exceed \\(\\log n\\)?</p> <p>The recursion depth is the number of currently unreturned recursive methods. Each round of sentinel partitioning divides the original array into two sub-arrays. After recursion depth optimization, the length of the sub-array to be recursively processed is at most half of the original array length. Assuming the worst case is always half the length, the final recursion depth will be \\(\\log n\\).</p> <p>Reviewing the original quick sort, we may continuously recurse on the longer array. In the worst case, it would be \\(n\\), \\(n - 1\\), \\(\\dots\\), \\(2\\), \\(1\\), with a recursion depth of \\(n\\). Recursion depth optimization can avoid this situation.</p> <p>Q: When all elements in the array are equal, is the time complexity of quick sort \\(O(n^2)\\)? How should this degenerate case be handled?</p> <p>Yes. For this situation, consider partitioning the array into three parts through sentinel partitioning: less than, equal to, and greater than the pivot. Only recursively process the less than and greater than parts. Under this method, an array where all input elements are equal can complete sorting in just one round of sentinel partitioning.</p> <p>Q: Why is the worst-case time complexity of bucket sort \\(O(n^2)\\)?</p> <p>In the worst case, all elements are distributed into the same bucket. If we use an \\(O(n^2)\\) algorithm to sort these elements, the time complexity will be \\(O(n^2)\\).</p>"},{"location":"chapter_stack_and_queue/","title":"Chapter 5. \u00a0 Stack and Queue","text":"<p>Abstract</p> <p>Stacks are like stacking cats, while queues are like cats lining up.</p> <p>They represent LIFO (Last In First Out) and FIFO (First In First Out) logic, respectively.</p>"},{"location":"chapter_stack_and_queue/#chapter-contents","title":"Chapter contents","text":"<ul> <li>5.1 \u00a0 Stack</li> <li>5.2 \u00a0 Queue</li> <li>5.3 \u00a0 Double-Ended Queue</li> <li>5.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_stack_and_queue/deque/","title":"5.3 \u00a0 Deque","text":"<p>In a queue, we can only remove elements from the front or add elements at the rear. As shown in Figure 5-7, a double-ended queue (deque) provides greater flexibility, allowing the addition or removal of elements at both the front and rear.</p> <p></p> <p> Figure 5-7 \u00a0 Operations of deque </p>"},{"location":"chapter_stack_and_queue/deque/#531-common-deque-operations","title":"5.3.1 \u00a0 Common Deque Operations","text":"<p>The common operations on a deque are shown in Table 5-3. The specific method names depend on the programming language used.</p> <p> Table 5-3 \u00a0 Efficiency of Deque Operations </p> Method Description Time Complexity <code>push_first()</code> Add element to front \\(O(1)\\) <code>push_last()</code> Add element to rear \\(O(1)\\) <code>pop_first()</code> Remove front element \\(O(1)\\) <code>pop_last()</code> Remove rear element \\(O(1)\\) <code>peek_first()</code> Access front element \\(O(1)\\) <code>peek_last()</code> Access rear element \\(O(1)\\) <p>Similarly, we can directly use the deque classes already implemented in programming languages:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby deque.py<pre><code>from collections import deque\n\n# Initialize deque\ndeq: deque[int] = deque()\n\n# Enqueue elements\ndeq.append(2)      # Add to rear\ndeq.append(5)\ndeq.append(4)\ndeq.appendleft(3)  # Add to front\ndeq.appendleft(1)\n\n# Access elements\nfront: int = deq[0]  # Front element\nrear: int = deq[-1]  # Rear element\n\n# Dequeue elements\npop_front: int = deq.popleft()  # Front element dequeue\npop_rear: int = deq.pop()       # Rear element dequeue\n\n# Get deque length\nsize: int = len(deq)\n\n# Check if deque is empty\nis_empty: bool = len(deq) == 0\n</code></pre> deque.cpp<pre><code>/* Initialize deque */\ndeque&lt;int&gt; deque;\n\n/* Enqueue elements */\ndeque.push_back(2);   // Add to rear\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3);  // Add to front\ndeque.push_front(1);\n\n/* Access elements */\nint front = deque.front(); // Front element\nint back = deque.back();   // Rear element\n\n/* Dequeue elements */\ndeque.pop_front();  // Front element dequeue\ndeque.pop_back();   // Rear element dequeue\n\n/* Get deque length */\nint size = deque.size();\n\n/* Check if deque is empty */\nbool empty = deque.empty();\n</code></pre> deque.java<pre><code>/* Initialize deque */\nDeque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n\n/* Enqueue elements */\ndeque.offerLast(2);   // Add to rear\ndeque.offerLast(5);\ndeque.offerLast(4);\ndeque.offerFirst(3);  // Add to front\ndeque.offerFirst(1);\n\n/* Access elements */\nint peekFirst = deque.peekFirst();  // Front element\nint peekLast = deque.peekLast();    // Rear element\n\n/* Dequeue elements */\nint popFirst = deque.pollFirst();  // Front element dequeue\nint popLast = deque.pollLast();    // Rear element dequeue\n\n/* Get deque length */\nint size = deque.size();\n\n/* Check if deque is empty */\nboolean isEmpty = deque.isEmpty();\n</code></pre> deque.cs<pre><code>/* Initialize deque */\n// In C#, use LinkedList as a deque\nLinkedList&lt;int&gt; deque = new();\n\n/* Enqueue elements */\ndeque.AddLast(2);   // Add to rear\ndeque.AddLast(5);\ndeque.AddLast(4);\ndeque.AddFirst(3);  // Add to front\ndeque.AddFirst(1);\n\n/* Access elements */\nint peekFirst = deque.First.Value;  // Front element\nint peekLast = deque.Last.Value;    // Rear element\n\n/* Dequeue elements */\ndeque.RemoveFirst();  // Front element dequeue\ndeque.RemoveLast();   // Rear element dequeue\n\n/* Get deque length */\nint size = deque.Count;\n\n/* Check if deque is empty */\nbool isEmpty = deque.Count == 0;\n</code></pre> deque_test.go<pre><code>/* Initialize deque */\n// In Go, use list as a deque\ndeque := list.New()\n\n/* Enqueue elements */\ndeque.PushBack(2)      // Add to rear\ndeque.PushBack(5)\ndeque.PushBack(4)\ndeque.PushFront(3)     // Add to front\ndeque.PushFront(1)\n\n/* Access elements */\nfront := deque.Front() // Front element\nrear := deque.Back()   // Rear element\n\n/* Dequeue elements */\ndeque.Remove(front)    // Front element dequeue\ndeque.Remove(rear)     // Rear element dequeue\n\n/* Get deque length */\nsize := deque.Len()\n\n/* Check if deque is empty */\nisEmpty := deque.Len() == 0\n</code></pre> deque.swift<pre><code>/* Initialize deque */\n// Swift does not have a built-in deque class, can use Array as a deque\nvar deque: [Int] = []\n\n/* Enqueue elements */\ndeque.append(2) // Add to rear\ndeque.append(5)\ndeque.append(4)\ndeque.insert(3, at: 0) // Add to front\ndeque.insert(1, at: 0)\n\n/* Access elements */\nlet peekFirst = deque.first! // Front element\nlet peekLast = deque.last! // Rear element\n\n/* Dequeue elements */\n// When using Array simulation, popFirst has O(n) complexity\nlet popFirst = deque.removeFirst() // Front element dequeue\nlet popLast = deque.removeLast() // Rear element dequeue\n\n/* Get deque length */\nlet size = deque.count\n\n/* Check if deque is empty */\nlet isEmpty = deque.isEmpty\n</code></pre> deque.js<pre><code>/* Initialize deque */\n// JavaScript does not have a built-in deque, can only use Array as a deque\nconst deque = [];\n\n/* Enqueue elements */\ndeque.push(2);\ndeque.push(5);\ndeque.push(4);\n// Please note that since it's an array, unshift() has O(n) time complexity\ndeque.unshift(3);\ndeque.unshift(1);\n\n/* Access elements */\nconst peekFirst = deque[0];\nconst peekLast = deque[deque.length - 1];\n\n/* Dequeue elements */\n// Please note that since it's an array, shift() has O(n) time complexity\nconst popFront = deque.shift();\nconst popBack = deque.pop();\n\n/* Get deque length */\nconst size = deque.length;\n\n/* Check if deque is empty */\nconst isEmpty = size === 0;\n</code></pre> deque.ts<pre><code>/* Initialize deque */\n// TypeScript does not have a built-in deque, can only use Array as a deque\nconst deque: number[] = [];\n\n/* Enqueue elements */\ndeque.push(2);\ndeque.push(5);\ndeque.push(4);\n// Please note that since it's an array, unshift() has O(n) time complexity\ndeque.unshift(3);\ndeque.unshift(1);\n\n/* Access elements */\nconst peekFirst: number = deque[0];\nconst peekLast: number = deque[deque.length - 1];\n\n/* Dequeue elements */\n// Please note that since it's an array, shift() has O(n) time complexity\nconst popFront: number = deque.shift() as number;\nconst popBack: number = deque.pop() as number;\n\n/* Get deque length */\nconst size: number = deque.length;\n\n/* Check if deque is empty */\nconst isEmpty: boolean = size === 0;\n</code></pre> deque.dart<pre><code>/* Initialize deque */\n// In Dart, Queue is defined as a deque\nQueue&lt;int&gt; deque = Queue&lt;int&gt;();\n\n/* Enqueue elements */\ndeque.addLast(2);  // Add to rear\ndeque.addLast(5);\ndeque.addLast(4);\ndeque.addFirst(3); // Add to front\ndeque.addFirst(1);\n\n/* Access elements */\nint peekFirst = deque.first; // Front element\nint peekLast = deque.last;   // Rear element\n\n/* Dequeue elements */\nint popFirst = deque.removeFirst(); // Front element dequeue\nint popLast = deque.removeLast();   // Rear element dequeue\n\n/* Get deque length */\nint size = deque.length;\n\n/* Check if deque is empty */\nbool isEmpty = deque.isEmpty;\n</code></pre> deque.rs<pre><code>/* Initialize deque */\nlet mut deque: VecDeque&lt;u32&gt; = VecDeque::new();\n\n/* Enqueue elements */\ndeque.push_back(2);  // Add to rear\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3); // Add to front\ndeque.push_front(1);\n\n/* Access elements */\nif let Some(front) = deque.front() { // Front element\n}\nif let Some(rear) = deque.back() {   // Rear element\n}\n\n/* Dequeue elements */\nif let Some(pop_front) = deque.pop_front() { // Front element dequeue\n}\nif let Some(pop_rear) = deque.pop_back() {   // Rear element dequeue\n}\n\n/* Get deque length */\nlet size = deque.len();\n\n/* Check if deque is empty */\nlet is_empty = deque.is_empty();\n</code></pre> deque.c<pre><code>// C does not provide a built-in deque\n</code></pre> deque.kt<pre><code>/* Initialize deque */\nval deque = LinkedList&lt;Int&gt;()\n\n/* Enqueue elements */\ndeque.offerLast(2)  // Add to rear\ndeque.offerLast(5)\ndeque.offerLast(4)\ndeque.offerFirst(3) // Add to front\ndeque.offerFirst(1)\n\n/* Access elements */\nval peekFirst = deque.peekFirst() // Front element\nval peekLast = deque.peekLast()   // Rear element\n\n/* Dequeue elements */\nval popFirst = deque.pollFirst() // Front element dequeue\nval popLast = deque.pollLast()   // Rear element dequeue\n\n/* Get deque length */\nval size = deque.size\n\n/* Check if deque is empty */\nval isEmpty = deque.isEmpty()\n</code></pre> deque.rb<pre><code># Initialize deque\n# Ruby does not have a built-in deque, can only use Array as a deque\ndeque = []\n\n# Enqueue elements\ndeque &lt;&lt; 2\ndeque &lt;&lt; 5\ndeque &lt;&lt; 4\n# Please note that since it's an array, Array#unshift has O(n) time complexity\ndeque.unshift(3)\ndeque.unshift(1)\n\n# Access elements\npeek_first = deque.first\npeek_last = deque.last\n\n# Dequeue elements\n# Please note that since it's an array, Array#shift has O(n) time complexity\npop_front = deque.shift\npop_back = deque.pop\n\n# Get deque length\nsize = deque.length\n\n# Check if deque is empty\nis_empty = size.zero?\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/deque/#532-deque-implementation","title":"5.3.2 \u00a0 Deque Implementation *","text":"<p>The implementation of a deque is similar to that of a queue. You can choose either a linked list or an array as the underlying data structure.</p>"},{"location":"chapter_stack_and_queue/deque/#1-doubly-linked-list-implementation","title":"1. \u00a0 Doubly Linked List Implementation","text":"<p>Reviewing the previous section, we used a regular singly linked list to implement a queue because it conveniently allows deleting the head node (corresponding to dequeue) and adding new nodes after the tail node (corresponding to enqueue).</p> <p>For a deque, both the front and rear can perform enqueue and dequeue operations. In other words, a deque needs to implement operations in the opposite direction as well. For this reason, we use a \"doubly linked list\" as the underlying data structure for the deque.</p> <p>As shown in Figure 5-8, we treat the head and tail nodes of the doubly linked list as the front and rear of the deque, implementing functionality to add and remove nodes at both ends.</p> LinkedListDequepush_last()push_first()pop_last()pop_first() <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 5-8 \u00a0 Enqueue and dequeue operations in linked list implementation of deque </p> <p>The implementation code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linkedlist_deque.py<pre><code>class ListNode:\n    \"\"\"Doubly linked list node\"\"\"\n\n    def __init__(self, val: int):\n        \"\"\"Constructor\"\"\"\n        self.val: int = val\n        self.next: ListNode | None = None  # Successor node reference\n        self.prev: ListNode | None = None  # Predecessor node reference\n\nclass LinkedListDeque:\n    \"\"\"Double-ended queue based on doubly linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self._front: ListNode | None = None  # Head node front\n        self._rear: ListNode | None = None  # Tail node rear\n        self._size: int = 0  # Length of the double-ended queue\n\n    def size(self) -&gt; int:\n        \"\"\"Get the length of the double-ended queue\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the double-ended queue is empty\"\"\"\n        return self._size == 0\n\n    def push(self, num: int, is_front: bool):\n        \"\"\"Enqueue operation\"\"\"\n        node = ListNode(num)\n        # If the linked list is empty, make both front and rear point to node\n        if self.is_empty():\n            self._front = self._rear = node\n        # Front of the queue enqueue operation\n        elif is_front:\n            # Add node to the head of the linked list\n            self._front.prev = node\n            node.next = self._front\n            self._front = node  # Update head node\n        # Rear of the queue enqueue operation\n        else:\n            # Add node to the tail of the linked list\n            self._rear.next = node\n            node.prev = self._rear\n            self._rear = node  # Update tail node\n        self._size += 1  # Update queue length\n\n    def push_first(self, num: int):\n        \"\"\"Front of the queue enqueue\"\"\"\n        self.push(num, True)\n\n    def push_last(self, num: int):\n        \"\"\"Rear of the queue enqueue\"\"\"\n        self.push(num, False)\n\n    def pop(self, is_front: bool) -&gt; int:\n        \"\"\"Dequeue operation\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Double-ended queue is empty\")\n        # Front of the queue dequeue operation\n        if is_front:\n            val: int = self._front.val  # Temporarily store head node value\n            # Delete head node\n            fnext: ListNode | None = self._front.next\n            if fnext is not None:\n                fnext.prev = None\n                self._front.next = None\n            self._front = fnext  # Update head node\n        # Rear of the queue dequeue operation\n        else:\n            val: int = self._rear.val  # Temporarily store tail node value\n            # Delete tail node\n            rprev: ListNode | None = self._rear.prev\n            if rprev is not None:\n                rprev.next = None\n                self._rear.prev = None\n            self._rear = rprev  # Update tail node\n        self._size -= 1  # Update queue length\n        return val\n\n    def pop_first(self) -&gt; int:\n        \"\"\"Front of the queue dequeue\"\"\"\n        return self.pop(True)\n\n    def pop_last(self) -&gt; int:\n        \"\"\"Rear of the queue dequeue\"\"\"\n        return self.pop(False)\n\n    def peek_first(self) -&gt; int:\n        \"\"\"Access front of the queue element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Double-ended queue is empty\")\n        return self._front.val\n\n    def peek_last(self) -&gt; int:\n        \"\"\"Access rear of the queue element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Double-ended queue is empty\")\n        return self._rear.val\n\n    def to_array(self) -&gt; list[int]:\n        \"\"\"Return array for printing\"\"\"\n        node = self._front\n        res = [0] * self.size()\n        for i in range(self.size()):\n            res[i] = node.val\n            node = node.next\n        return res\n</code></pre> linkedlist_deque.cpp<pre><code>/* Doubly linked list node */\nstruct DoublyListNode {\n    int val;              // Node value\n    DoublyListNode *next; // Successor node pointer\n    DoublyListNode *prev; // Predecessor node pointer\n    DoublyListNode(int val) : val(val), prev(nullptr), next(nullptr) {\n    }\n};\n\n/* Double-ended queue based on doubly linked list implementation */\nclass LinkedListDeque {\n  private:\n    DoublyListNode *front, *rear; // Head node front, tail node rear\n    int queSize = 0;              // Length of the double-ended queue\n\n  public:\n    /* Constructor */\n    LinkedListDeque() : front(nullptr), rear(nullptr) {\n    }\n\n    /* Destructor */\n    ~LinkedListDeque() {\n        // Traverse linked list to delete nodes and free memory\n        DoublyListNode *pre, *cur = front;\n        while (cur != nullptr) {\n            pre = cur;\n            cur = cur-&gt;next;\n            delete pre;\n        }\n    }\n\n    /* Get the length of the double-ended queue */\n    int size() {\n        return queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* Enqueue operation */\n    void push(int num, bool isFront) {\n        DoublyListNode *node = new DoublyListNode(num);\n        // If the linked list is empty, make both front and rear point to node\n        if (isEmpty())\n            front = rear = node;\n        // Front of the queue enqueue operation\n        else if (isFront) {\n            // Add node to the head of the linked list\n            front-&gt;prev = node;\n            node-&gt;next = front;\n            front = node; // Update head node\n        // Rear of the queue enqueue operation\n        } else {\n            // Add node to the tail of the linked list\n            rear-&gt;next = node;\n            node-&gt;prev = rear;\n            rear = node; // Update tail node\n        }\n        queSize++; // Update queue length\n    }\n\n    /* Front of the queue enqueue */\n    void pushFirst(int num) {\n        push(num, true);\n    }\n\n    /* Rear of the queue enqueue */\n    void pushLast(int num) {\n        push(num, false);\n    }\n\n    /* Dequeue operation */\n    int pop(bool isFront) {\n        if (isEmpty())\n            throw out_of_range(\"Queue is empty\");\n        int val;\n        // Temporarily store head node value\n        if (isFront) {\n            val = front-&gt;val; // Delete head node\n            // Delete head node\n            DoublyListNode *fNext = front-&gt;next;\n            if (fNext != nullptr) {\n                fNext-&gt;prev = nullptr;\n                front-&gt;next = nullptr;\n            }\n            delete front;\n            front = fNext; // Update head node\n        // Temporarily store tail node value\n        } else {\n            val = rear-&gt;val; // Delete tail node\n            // Update tail node\n            DoublyListNode *rPrev = rear-&gt;prev;\n            if (rPrev != nullptr) {\n                rPrev-&gt;next = nullptr;\n                rear-&gt;prev = nullptr;\n            }\n            delete rear;\n            rear = rPrev; // Update tail node\n        }\n        queSize--; // Update queue length\n        return val;\n    }\n\n    /* Rear of the queue dequeue */\n    int popFirst() {\n        return pop(true);\n    }\n\n    /* Access rear of the queue element */\n    int popLast() {\n        return pop(false);\n    }\n\n    /* Return list for printing */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"Deque is empty\");\n        return front-&gt;val;\n    }\n\n    /* Driver Code */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"Deque is empty\");\n        return rear-&gt;val;\n    }\n\n    /* Return array for printing */\n    vector&lt;int&gt; toVector() {\n        DoublyListNode *node = front;\n        vector&lt;int&gt; res(size());\n        for (int i = 0; i &lt; res.size(); i++) {\n            res[i] = node-&gt;val;\n            node = node-&gt;next;\n        }\n        return res;\n    }\n};\n</code></pre> linkedlist_deque.java<pre><code>/* Doubly linked list node */\nclass ListNode {\n    int val; // Node value\n    ListNode next; // Successor node reference\n    ListNode prev; // Predecessor node reference\n\n    ListNode(int val) {\n        this.val = val;\n        prev = next = null;\n    }\n}\n\n/* Double-ended queue based on doubly linked list implementation */\nclass LinkedListDeque {\n    private ListNode front, rear; // Head node front, tail node rear\n    private int queSize = 0; // Length of the double-ended queue\n\n    public LinkedListDeque() {\n        front = rear = null;\n    }\n\n    /* Get the length of the double-ended queue */\n    public int size() {\n        return queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* Enqueue operation */\n    private void push(int num, boolean isFront) {\n        ListNode node = new ListNode(num);\n        // If the linked list is empty, make both front and rear point to node\n        if (isEmpty())\n            front = rear = node;\n        // Front of the queue enqueue operation\n        else if (isFront) {\n            // Add node to the head of the linked list\n            front.prev = node;\n            node.next = front;\n            front = node; // Update head node\n        // Rear of the queue enqueue operation\n        } else {\n            // Add node to the tail of the linked list\n            rear.next = node;\n            node.prev = rear;\n            rear = node; // Update tail node\n        }\n        queSize++; // Update queue length\n    }\n\n    /* Front of the queue enqueue */\n    public void pushFirst(int num) {\n        push(num, true);\n    }\n\n    /* Rear of the queue enqueue */\n    public void pushLast(int num) {\n        push(num, false);\n    }\n\n    /* Dequeue operation */\n    private int pop(boolean isFront) {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        int val;\n        // Temporarily store head node value\n        if (isFront) {\n            val = front.val; // Delete head node\n            // Delete head node\n            ListNode fNext = front.next;\n            if (fNext != null) {\n                fNext.prev = null;\n                front.next = null;\n            }\n            front = fNext; // Update head node\n        // Temporarily store tail node value\n        } else {\n            val = rear.val; // Delete tail node\n            // Update tail node\n            ListNode rPrev = rear.prev;\n            if (rPrev != null) {\n                rPrev.next = null;\n                rear.prev = null;\n            }\n            rear = rPrev; // Update tail node\n        }\n        queSize--; // Update queue length\n        return val;\n    }\n\n    /* Rear of the queue dequeue */\n    public int popFirst() {\n        return pop(true);\n    }\n\n    /* Access rear of the queue element */\n    public int popLast() {\n        return pop(false);\n    }\n\n    /* Return list for printing */\n    public int peekFirst() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return front.val;\n    }\n\n    /* Driver Code */\n    public int peekLast() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return rear.val;\n    }\n\n    /* Return array for printing */\n    public int[] toArray() {\n        ListNode node = front;\n        int[] res = new int[size()];\n        for (int i = 0; i &lt; res.length; i++) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_deque.cs<pre><code>/* Doubly linked list node */\nclass ListNode(int val) {\n    public int val = val;       // Node value\n    public ListNode? next = null; // Successor node reference\n    public ListNode? prev = null; // Predecessor node reference\n}\n\n/* Double-ended queue based on doubly linked list implementation */\nclass LinkedListDeque {\n    ListNode? front, rear; // Head node front, tail node rear\n    int queSize = 0;      // Length of the double-ended queue\n\n    public LinkedListDeque() {\n        front = null;\n        rear = null;\n    }\n\n    /* Get the length of the double-ended queue */\n    public int Size() {\n        return queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* Enqueue operation */\n    void Push(int num, bool isFront) {\n        ListNode node = new(num);\n        // If the linked list is empty, make both front and rear point to node\n        if (IsEmpty()) {\n            front = node;\n            rear = node;\n        }\n        // Front of the queue enqueue operation\n        else if (isFront) {\n            // Add node to the head of the linked list\n            front!.prev = node;\n            node.next = front;\n            front = node; // Update head node\n        }\n        // Rear of the queue enqueue operation\n        else {\n            // Add node to the tail of the linked list\n            rear!.next = node;\n            node.prev = rear;\n            rear = node;  // Update tail node\n        }\n\n        queSize++; // Update queue length\n    }\n\n    /* Front of the queue enqueue */\n    public void PushFirst(int num) {\n        Push(num, true);\n    }\n\n    /* Rear of the queue enqueue */\n    public void PushLast(int num) {\n        Push(num, false);\n    }\n\n    /* Dequeue operation */\n    int? Pop(bool isFront) {\n        if (IsEmpty())\n            throw new Exception();\n        int? val;\n        // Temporarily store head node value\n        if (isFront) {\n            val = front?.val; // Delete head node\n            // Delete head node\n            ListNode? fNext = front?.next;\n            if (fNext != null) {\n                fNext.prev = null;\n                front!.next = null;\n            }\n            front = fNext;   // Update head node\n        }\n        // Temporarily store tail node value\n        else {\n            val = rear?.val;  // Delete tail node\n            // Update tail node\n            ListNode? rPrev = rear?.prev;\n            if (rPrev != null) {\n                rPrev.next = null;\n                rear!.prev = null;\n            }\n            rear = rPrev;    // Update tail node\n        }\n\n        queSize--; // Update queue length\n        return val;\n    }\n\n    /* Rear of the queue dequeue */\n    public int? PopFirst() {\n        return Pop(true);\n    }\n\n    /* Access rear of the queue element */\n    public int? PopLast() {\n        return Pop(false);\n    }\n\n    /* Return list for printing */\n    public int? PeekFirst() {\n        if (IsEmpty())\n            throw new Exception();\n        return front?.val;\n    }\n\n    /* Driver Code */\n    public int? PeekLast() {\n        if (IsEmpty())\n            throw new Exception();\n        return rear?.val;\n    }\n\n    /* Return array for printing */\n    public int?[] ToArray() {\n        ListNode? node = front;\n        int?[] res = new int?[Size()];\n        for (int i = 0; i &lt; res.Length; i++) {\n            res[i] = node?.val;\n            node = node?.next;\n        }\n\n        return res;\n    }\n}\n</code></pre> linkedlist_deque.go<pre><code>/* Double-ended queue based on doubly linked list implementation */\ntype linkedListDeque struct {\n    // Use built-in package list\n    data *list.List\n}\n\n/* Initialize deque */\nfunc newLinkedListDeque() *linkedListDeque {\n    return &amp;linkedListDeque{\n        data: list.New(),\n    }\n}\n\n/* Front element enqueue */\nfunc (s *linkedListDeque) pushFirst(value any) {\n    s.data.PushFront(value)\n}\n\n/* Rear element enqueue */\nfunc (s *linkedListDeque) pushLast(value any) {\n    s.data.PushBack(value)\n}\n\n/* Check if the double-ended queue is empty */\nfunc (s *linkedListDeque) popFirst() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* Rear element dequeue */\nfunc (s *linkedListDeque) popLast() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* Return list for printing */\nfunc (s *linkedListDeque) peekFirst() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    return e.Value\n}\n\n/* Driver Code */\nfunc (s *linkedListDeque) peekLast() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    return e.Value\n}\n\n/* Get the length of the queue */\nfunc (s *linkedListDeque) size() int {\n    return s.data.Len()\n}\n\n/* Check if the queue is empty */\nfunc (s *linkedListDeque) isEmpty() bool {\n    return s.data.Len() == 0\n}\n\n/* Get List for printing */\nfunc (s *linkedListDeque) toList() *list.List {\n    return s.data\n}\n</code></pre> linkedlist_deque.swift<pre><code>/* Doubly linked list node */\nclass ListNode {\n    var val: Int // Node value\n    var next: ListNode? // Successor node reference\n    weak var prev: ListNode? // Predecessor node reference\n\n    init(val: Int) {\n        self.val = val\n    }\n}\n\n/* Double-ended queue based on doubly linked list implementation */\nclass LinkedListDeque {\n    private var front: ListNode? // Head node front\n    private var rear: ListNode? // Tail node rear\n    private var _size: Int // Length of the double-ended queue\n\n    init() {\n        _size = 0\n    }\n\n    /* Get the length of the double-ended queue */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* Check if the double-ended queue is empty */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* Enqueue operation */\n    private func push(num: Int, isFront: Bool) {\n        let node = ListNode(val: num)\n        // If the linked list is empty, make both front and rear point to node\n        if isEmpty() {\n            front = node\n            rear = node\n        }\n        // Front of the queue enqueue operation\n        else if isFront {\n            // Add node to the head of the linked list\n            front?.prev = node\n            node.next = front\n            front = node // Update head node\n        }\n        // Rear of the queue enqueue operation\n        else {\n            // Add node to the tail of the linked list\n            rear?.next = node\n            node.prev = rear\n            rear = node // Update tail node\n        }\n        _size += 1 // Update queue length\n    }\n\n    /* Front of the queue enqueue */\n    func pushFirst(num: Int) {\n        push(num: num, isFront: true)\n    }\n\n    /* Rear of the queue enqueue */\n    func pushLast(num: Int) {\n        push(num: num, isFront: false)\n    }\n\n    /* Dequeue operation */\n    private func pop(isFront: Bool) -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Deque is empty\")\n        }\n        let val: Int\n        // Temporarily store head node value\n        if isFront {\n            val = front!.val // Delete head node\n            // Delete head node\n            let fNext = front?.next\n            if fNext != nil {\n                fNext?.prev = nil\n                front?.next = nil\n            }\n            front = fNext // Update head node\n        }\n        // Temporarily store tail node value\n        else {\n            val = rear!.val // Delete tail node\n            // Update tail node\n            let rPrev = rear?.prev\n            if rPrev != nil {\n                rPrev?.next = nil\n                rear?.prev = nil\n            }\n            rear = rPrev // Update tail node\n        }\n        _size -= 1 // Update queue length\n        return val\n    }\n\n    /* Rear of the queue dequeue */\n    func popFirst() -&gt; Int {\n        pop(isFront: true)\n    }\n\n    /* Access rear of the queue element */\n    func popLast() -&gt; Int {\n        pop(isFront: false)\n    }\n\n    /* Return list for printing */\n    func peekFirst() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Deque is empty\")\n        }\n        return front!.val\n    }\n\n    /* Driver Code */\n    func peekLast() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Deque is empty\")\n        }\n        return rear!.val\n    }\n\n    /* Return array for printing */\n    func toArray() -&gt; [Int] {\n        var node = front\n        var res = Array(repeating: 0, count: size())\n        for i in res.indices {\n            res[i] = node!.val\n            node = node?.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_deque.js<pre><code>/* Doubly linked list node */\nclass ListNode {\n    prev; // Predecessor node reference (pointer)\n    next; // Successor node reference (pointer)\n    val; // Node value\n\n    constructor(val) {\n        this.val = val;\n        this.next = null;\n        this.prev = null;\n    }\n}\n\n/* Double-ended queue based on doubly linked list implementation */\nclass LinkedListDeque {\n    #front; // Head node front\n    #rear; // Tail node rear\n    #queSize; // Length of the double-ended queue\n\n    constructor() {\n        this.#front = null;\n        this.#rear = null;\n        this.#queSize = 0;\n    }\n\n    /* Rear of the queue enqueue operation */\n    pushLast(val) {\n        const node = new ListNode(val);\n        // If the linked list is empty, make both front and rear point to node\n        if (this.#queSize === 0) {\n            this.#front = node;\n            this.#rear = node;\n        } else {\n            // Add node to the tail of the linked list\n            this.#rear.next = node;\n            node.prev = this.#rear;\n            this.#rear = node; // Update tail node\n        }\n        this.#queSize++;\n    }\n\n    /* Front of the queue enqueue operation */\n    pushFirst(val) {\n        const node = new ListNode(val);\n        // If the linked list is empty, make both front and rear point to node\n        if (this.#queSize === 0) {\n            this.#front = node;\n            this.#rear = node;\n        } else {\n            // Add node to the head of the linked list\n            this.#front.prev = node;\n            node.next = this.#front;\n            this.#front = node; // Update head node\n        }\n        this.#queSize++;\n    }\n\n    /* Temporarily store tail node value */\n    popLast() {\n        if (this.#queSize === 0) {\n            return null;\n        }\n        const value = this.#rear.val; // Store tail node value\n        // Update tail node\n        let temp = this.#rear.prev;\n        if (temp !== null) {\n            temp.next = null;\n            this.#rear.prev = null;\n        }\n        this.#rear = temp; // Update tail node\n        this.#queSize--;\n        return value;\n    }\n\n    /* Temporarily store head node value */\n    popFirst() {\n        if (this.#queSize === 0) {\n            return null;\n        }\n        const value = this.#front.val; // Store tail node value\n        // Delete head node\n        let temp = this.#front.next;\n        if (temp !== null) {\n            temp.prev = null;\n            this.#front.next = null;\n        }\n        this.#front = temp; // Update head node\n        this.#queSize--;\n        return value;\n    }\n\n    /* Driver Code */\n    peekLast() {\n        return this.#queSize === 0 ? null : this.#rear.val;\n    }\n\n    /* Return list for printing */\n    peekFirst() {\n        return this.#queSize === 0 ? null : this.#front.val;\n    }\n\n    /* Get the length of the double-ended queue */\n    size() {\n        return this.#queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    isEmpty() {\n        return this.#queSize === 0;\n    }\n\n    /* Print deque */\n    print() {\n        const arr = [];\n        let temp = this.#front;\n        while (temp !== null) {\n            arr.push(temp.val);\n            temp = temp.next;\n        }\n        console.log('[' + arr.join(', ') + ']');\n    }\n}\n</code></pre> linkedlist_deque.ts<pre><code>/* Doubly linked list node */\nclass ListNode {\n    prev: ListNode; // Predecessor node reference (pointer)\n    next: ListNode; // Successor node reference (pointer)\n    val: number; // Node value\n\n    constructor(val: number) {\n        this.val = val;\n        this.next = null;\n        this.prev = null;\n    }\n}\n\n/* Double-ended queue based on doubly linked list implementation */\nclass LinkedListDeque {\n    private front: ListNode; // Head node front\n    private rear: ListNode; // Tail node rear\n    private queSize: number; // Length of the double-ended queue\n\n    constructor() {\n        this.front = null;\n        this.rear = null;\n        this.queSize = 0;\n    }\n\n    /* Rear of the queue enqueue operation */\n    pushLast(val: number): void {\n        const node: ListNode = new ListNode(val);\n        // If the linked list is empty, make both front and rear point to node\n        if (this.queSize === 0) {\n            this.front = node;\n            this.rear = node;\n        } else {\n            // Add node to the tail of the linked list\n            this.rear.next = node;\n            node.prev = this.rear;\n            this.rear = node; // Update tail node\n        }\n        this.queSize++;\n    }\n\n    /* Front of the queue enqueue operation */\n    pushFirst(val: number): void {\n        const node: ListNode = new ListNode(val);\n        // If the linked list is empty, make both front and rear point to node\n        if (this.queSize === 0) {\n            this.front = node;\n            this.rear = node;\n        } else {\n            // Add node to the head of the linked list\n            this.front.prev = node;\n            node.next = this.front;\n            this.front = node; // Update head node\n        }\n        this.queSize++;\n    }\n\n    /* Temporarily store tail node value */\n    popLast(): number {\n        if (this.queSize === 0) {\n            return null;\n        }\n        const value: number = this.rear.val; // Store tail node value\n        // Update tail node\n        let temp: ListNode = this.rear.prev;\n        if (temp !== null) {\n            temp.next = null;\n            this.rear.prev = null;\n        }\n        this.rear = temp; // Update tail node\n        this.queSize--;\n        return value;\n    }\n\n    /* Temporarily store head node value */\n    popFirst(): number {\n        if (this.queSize === 0) {\n            return null;\n        }\n        const value: number = this.front.val; // Store tail node value\n        // Delete head node\n        let temp: ListNode = this.front.next;\n        if (temp !== null) {\n            temp.prev = null;\n            this.front.next = null;\n        }\n        this.front = temp; // Update head node\n        this.queSize--;\n        return value;\n    }\n\n    /* Driver Code */\n    peekLast(): number {\n        return this.queSize === 0 ? null : this.rear.val;\n    }\n\n    /* Return list for printing */\n    peekFirst(): number {\n        return this.queSize === 0 ? null : this.front.val;\n    }\n\n    /* Get the length of the double-ended queue */\n    size(): number {\n        return this.queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    isEmpty(): boolean {\n        return this.queSize === 0;\n    }\n\n    /* Print deque */\n    print(): void {\n        const arr: number[] = [];\n        let temp: ListNode = this.front;\n        while (temp !== null) {\n            arr.push(temp.val);\n            temp = temp.next;\n        }\n        console.log('[' + arr.join(', ') + ']');\n    }\n}\n</code></pre> linkedlist_deque.dart<pre><code>/* Doubly linked list node */\nclass ListNode {\n  int val; // Node value\n  ListNode? next; // Successor node reference\n  ListNode? prev; // Predecessor node reference\n\n  ListNode(this.val, {this.next, this.prev});\n}\n\n/* Deque implemented based on doubly linked list */\nclass LinkedListDeque {\n  late ListNode? _front; // Head node _front\n  late ListNode? _rear; // Tail node _rear\n  int _queSize = 0; // Length of the double-ended queue\n\n  LinkedListDeque() {\n    this._front = null;\n    this._rear = null;\n  }\n\n  /* Get deque length */\n  int size() {\n    return this._queSize;\n  }\n\n  /* Check if the double-ended queue is empty */\n  bool isEmpty() {\n    return size() == 0;\n  }\n\n  /* Enqueue operation */\n  void push(int _num, bool isFront) {\n    final ListNode node = ListNode(_num);\n    if (isEmpty()) {\n      // If list is empty, let both _front and _rear point to node\n      _front = _rear = node;\n    } else if (isFront) {\n      // Front of the queue enqueue operation\n      // Add node to the head of the linked list\n      _front!.prev = node;\n      node.next = _front;\n      _front = node; // Update head node\n    } else {\n      // Rear of the queue enqueue operation\n      // Add node to the tail of the linked list\n      _rear!.next = node;\n      node.prev = _rear;\n      _rear = node; // Update tail node\n    }\n    _queSize++; // Update queue length\n  }\n\n  /* Front of the queue enqueue */\n  void pushFirst(int _num) {\n    push(_num, true);\n  }\n\n  /* Rear of the queue enqueue */\n  void pushLast(int _num) {\n    push(_num, false);\n  }\n\n  /* Dequeue operation */\n  int? pop(bool isFront) {\n    // If queue is empty, return null directly\n    if (isEmpty()) {\n      return null;\n    }\n    final int val;\n    if (isFront) {\n      // Temporarily store head node value\n      val = _front!.val; // Delete head node\n      // Delete head node\n      ListNode? fNext = _front!.next;\n      if (fNext != null) {\n        fNext.prev = null;\n        _front!.next = null;\n      }\n      _front = fNext; // Update head node\n    } else {\n      // Temporarily store tail node value\n      val = _rear!.val; // Delete tail node\n      // Update tail node\n      ListNode? rPrev = _rear!.prev;\n      if (rPrev != null) {\n        rPrev.next = null;\n        _rear!.prev = null;\n      }\n      _rear = rPrev; // Update tail node\n    }\n    _queSize--; // Update queue length\n    return val;\n  }\n\n  /* Rear of the queue dequeue */\n  int? popFirst() {\n    return pop(true);\n  }\n\n  /* Access rear of the queue element */\n  int? popLast() {\n    return pop(false);\n  }\n\n  /* Return list for printing */\n  int? peekFirst() {\n    return _front?.val;\n  }\n\n  /* Driver Code */\n  int? peekLast() {\n    return _rear?.val;\n  }\n\n  /* Return array for printing */\n  List&lt;int&gt; toArray() {\n    ListNode? node = _front;\n    final List&lt;int&gt; res = [];\n    for (int i = 0; i &lt; _queSize; i++) {\n      res.add(node!.val);\n      node = node.next;\n    }\n    return res;\n  }\n}\n</code></pre> linkedlist_deque.rs<pre><code>/* Doubly linked list node */\npub struct ListNode&lt;T&gt; {\n    pub val: T,                                 // Node value\n    pub next: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // Successor node pointer\n    pub prev: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // Predecessor node pointer\n}\n\nimpl&lt;T&gt; ListNode&lt;T&gt; {\n    pub fn new(val: T) -&gt; Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt; {\n        Rc::new(RefCell::new(ListNode {\n            val,\n            next: None,\n            prev: None,\n        }))\n    }\n}\n\n/* Double-ended queue based on doubly linked list implementation */\n#[allow(dead_code)]\npub struct LinkedListDeque&lt;T&gt; {\n    front: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // Head node front\n    rear: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;,  // Tail node rear\n    que_size: usize,                         // Length of the double-ended queue\n}\n\nimpl&lt;T: Copy&gt; LinkedListDeque&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            front: None,\n            rear: None,\n            que_size: 0,\n        }\n    }\n\n    /* Get the length of the double-ended queue */\n    pub fn size(&amp;self) -&gt; usize {\n        return self.que_size;\n    }\n\n    /* Check if the double-ended queue is empty */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        return self.que_size == 0;\n    }\n\n    /* Enqueue operation */\n    fn push(&amp;mut self, num: T, is_front: bool) {\n        let node = ListNode::new(num);\n        // Front of the queue enqueue operation\n        if is_front {\n            match self.front.take() {\n                // If the linked list is empty, make both front and rear point to node\n                None =&gt; {\n                    self.rear = Some(node.clone());\n                    self.front = Some(node);\n                }\n                // Add node to the head of the linked list\n                Some(old_front) =&gt; {\n                    old_front.borrow_mut().prev = Some(node.clone());\n                    node.borrow_mut().next = Some(old_front);\n                    self.front = Some(node); // Update head node\n                }\n            }\n        }\n        // Rear of the queue enqueue operation\n        else {\n            match self.rear.take() {\n                // If the linked list is empty, make both front and rear point to node\n                None =&gt; {\n                    self.front = Some(node.clone());\n                    self.rear = Some(node);\n                }\n                // Add node to the tail of the linked list\n                Some(old_rear) =&gt; {\n                    old_rear.borrow_mut().next = Some(node.clone());\n                    node.borrow_mut().prev = Some(old_rear);\n                    self.rear = Some(node); // Update tail node\n                }\n            }\n        }\n        self.que_size += 1; // Update queue length\n    }\n\n    /* Front of the queue enqueue */\n    pub fn push_first(&amp;mut self, num: T) {\n        self.push(num, true);\n    }\n\n    /* Rear of the queue enqueue */\n    pub fn push_last(&amp;mut self, num: T) {\n        self.push(num, false);\n    }\n\n    /* Dequeue operation */\n    fn pop(&amp;mut self, is_front: bool) -&gt; Option&lt;T&gt; {\n        // If queue is empty, return None directly\n        if self.is_empty() {\n            return None;\n        };\n        // Temporarily store head node value\n        if is_front {\n            self.front.take().map(|old_front| {\n                match old_front.borrow_mut().next.take() {\n                    Some(new_front) =&gt; {\n                        new_front.borrow_mut().prev.take();\n                        self.front = Some(new_front); // Update head node\n                    }\n                    None =&gt; {\n                        self.rear.take();\n                    }\n                }\n                self.que_size -= 1; // Update queue length\n                old_front.borrow().val\n            })\n        }\n        // Temporarily store tail node value\n        else {\n            self.rear.take().map(|old_rear| {\n                match old_rear.borrow_mut().prev.take() {\n                    Some(new_rear) =&gt; {\n                        new_rear.borrow_mut().next.take();\n                        self.rear = Some(new_rear); // Update tail node\n                    }\n                    None =&gt; {\n                        self.front.take();\n                    }\n                }\n                self.que_size -= 1; // Update queue length\n                old_rear.borrow().val\n            })\n        }\n    }\n\n    /* Rear of the queue dequeue */\n    pub fn pop_first(&amp;mut self) -&gt; Option&lt;T&gt; {\n        return self.pop(true);\n    }\n\n    /* Access rear of the queue element */\n    pub fn pop_last(&amp;mut self) -&gt; Option&lt;T&gt; {\n        return self.pop(false);\n    }\n\n    /* Return list for printing */\n    pub fn peek_first(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.front.as_ref()\n    }\n\n    /* Driver Code */\n    pub fn peek_last(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.rear.as_ref()\n    }\n\n    /* Return array for printing */\n    pub fn to_array(&amp;self, head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;) -&gt; Vec&lt;T&gt; {\n        let mut res: Vec&lt;T&gt; = Vec::new();\n        fn recur&lt;T: Copy&gt;(cur: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, res: &amp;mut Vec&lt;T&gt;) {\n            if let Some(cur) = cur {\n                res.push(cur.borrow().val);\n                recur(cur.borrow().next.as_ref(), res);\n            }\n        }\n\n        recur(head, &amp;mut res);\n        res\n    }\n}\n</code></pre> linkedlist_deque.c<pre><code>/* Doubly linked list node */\ntypedef struct DoublyListNode {\n    int val;                     // Node value\n    struct DoublyListNode *next; // Successor node\n    struct DoublyListNode *prev; // Predecessor node\n} DoublyListNode;\n\n/* Constructor */\nDoublyListNode *newDoublyListNode(int num) {\n    DoublyListNode *new = (DoublyListNode *)malloc(sizeof(DoublyListNode));\n    new-&gt;val = num;\n    new-&gt;next = NULL;\n    new-&gt;prev = NULL;\n    return new;\n}\n\n/* Destructor */\nvoid delDoublyListNode(DoublyListNode *node) {\n    free(node);\n}\n\n/* Double-ended queue based on doubly linked list implementation */\ntypedef struct {\n    DoublyListNode *front, *rear; // Head node front, tail node rear\n    int queSize;                  // Length of the double-ended queue\n} LinkedListDeque;\n\n/* Constructor */\nLinkedListDeque *newLinkedListDeque() {\n    LinkedListDeque *deque = (LinkedListDeque *)malloc(sizeof(LinkedListDeque));\n    deque-&gt;front = NULL;\n    deque-&gt;rear = NULL;\n    deque-&gt;queSize = 0;\n    return deque;\n}\n\n/* Destructor */\nvoid delLinkedListdeque(LinkedListDeque *deque) {\n    // Free all nodes\n    for (int i = 0; i &lt; deque-&gt;queSize &amp;&amp; deque-&gt;front != NULL; i++) {\n        DoublyListNode *tmp = deque-&gt;front;\n        deque-&gt;front = deque-&gt;front-&gt;next;\n        free(tmp);\n    }\n    // Free deque structure\n    free(deque);\n}\n\n/* Get the length of the queue */\nint size(LinkedListDeque *deque) {\n    return deque-&gt;queSize;\n}\n\n/* Check if the queue is empty */\nbool empty(LinkedListDeque *deque) {\n    return (size(deque) == 0);\n}\n\n/* Enqueue */\nvoid push(LinkedListDeque *deque, int num, bool isFront) {\n    DoublyListNode *node = newDoublyListNode(num);\n    // If list is empty, set both front and rear to node\n    if (empty(deque)) {\n        deque-&gt;front = deque-&gt;rear = node;\n    }\n    // Front of the queue enqueue operation\n    else if (isFront) {\n        // Add node to the head of the linked list\n        deque-&gt;front-&gt;prev = node;\n        node-&gt;next = deque-&gt;front;\n        deque-&gt;front = node; // Update head node\n    }\n    // Rear of the queue enqueue operation\n    else {\n        // Add node to the tail of the linked list\n        deque-&gt;rear-&gt;next = node;\n        node-&gt;prev = deque-&gt;rear;\n        deque-&gt;rear = node;\n    }\n    deque-&gt;queSize++; // Update queue length\n}\n\n/* Front of the queue enqueue */\nvoid pushFirst(LinkedListDeque *deque, int num) {\n    push(deque, num, true);\n}\n\n/* Rear of the queue enqueue */\nvoid pushLast(LinkedListDeque *deque, int num) {\n    push(deque, num, false);\n}\n\n/* Return list for printing */\nint peekFirst(LinkedListDeque *deque) {\n    assert(size(deque) &amp;&amp; deque-&gt;front);\n    return deque-&gt;front-&gt;val;\n}\n\n/* Driver Code */\nint peekLast(LinkedListDeque *deque) {\n    assert(size(deque) &amp;&amp; deque-&gt;rear);\n    return deque-&gt;rear-&gt;val;\n}\n\n/* Dequeue */\nint pop(LinkedListDeque *deque, bool isFront) {\n    if (empty(deque))\n        return -1;\n    int val;\n    // Temporarily store head node value\n    if (isFront) {\n        val = peekFirst(deque); // Delete head node\n        DoublyListNode *fNext = deque-&gt;front-&gt;next;\n        if (fNext) {\n            fNext-&gt;prev = NULL;\n            deque-&gt;front-&gt;next = NULL;\n        }\n        delDoublyListNode(deque-&gt;front);\n        deque-&gt;front = fNext; // Update head node\n    }\n    // Temporarily store tail node value\n    else {\n        val = peekLast(deque); // Delete tail node\n        DoublyListNode *rPrev = deque-&gt;rear-&gt;prev;\n        if (rPrev) {\n            rPrev-&gt;next = NULL;\n            deque-&gt;rear-&gt;prev = NULL;\n        }\n        delDoublyListNode(deque-&gt;rear);\n        deque-&gt;rear = rPrev; // Update tail node\n    }\n    deque-&gt;queSize--; // Update queue length\n    return val;\n}\n\n/* Rear of the queue dequeue */\nint popFirst(LinkedListDeque *deque) {\n    return pop(deque, true);\n}\n\n/* Access rear of the queue element */\nint popLast(LinkedListDeque *deque) {\n    return pop(deque, false);\n}\n\n/* Print queue */\nvoid printLinkedListDeque(LinkedListDeque *deque) {\n    int *arr = malloc(sizeof(int) * deque-&gt;queSize);\n    // Copy data from list to array\n    int i;\n    DoublyListNode *node;\n    for (i = 0, node = deque-&gt;front; i &lt; deque-&gt;queSize; i++) {\n        arr[i] = node-&gt;val;\n        node = node-&gt;next;\n    }\n    printArray(arr, deque-&gt;queSize);\n    free(arr);\n}\n</code></pre> linkedlist_deque.kt<pre><code>/* Doubly linked list node */\nclass ListNode(var _val: Int) {\n    // Node value\n    var next: ListNode? = null // Successor node reference\n    var prev: ListNode? = null // Predecessor node reference\n}\n\n/* Double-ended queue based on doubly linked list implementation */\nclass LinkedListDeque {\n    private var front: ListNode? = null // Head node front\n    private var rear: ListNode? = null // Tail node rear\n    private var queSize: Int = 0 // Length of the double-ended queue\n\n    /* Get the length of the double-ended queue */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* Check if the double-ended queue is empty */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* Enqueue operation */\n    fun push(num: Int, isFront: Boolean) {\n        val node = ListNode(num)\n        // If the linked list is empty, make both front and rear point to node\n        if (isEmpty()) {\n            rear = node\n            front = rear\n            // Front of the queue enqueue operation\n        } else if (isFront) {\n            // Add node to the head of the linked list\n            front?.prev = node\n            node.next = front\n            front = node // Update head node\n            // Rear of the queue enqueue operation\n        } else {\n            // Add node to the tail of the linked list\n            rear?.next = node\n            node.prev = rear\n            rear = node // Update tail node\n        }\n        queSize++ // Update queue length\n    }\n\n    /* Front of the queue enqueue */\n    fun pushFirst(num: Int) {\n        push(num, true)\n    }\n\n    /* Rear of the queue enqueue */\n    fun pushLast(num: Int) {\n        push(num, false)\n    }\n\n    /* Dequeue operation */\n    fun pop(isFront: Boolean): Int {\n        if (isEmpty()) \n            throw IndexOutOfBoundsException()\n        val _val: Int\n        // Temporarily store head node value\n        if (isFront) {\n            _val = front!!._val // Delete head node\n            // Delete head node\n            val fNext = front!!.next\n            if (fNext != null) {\n                fNext.prev = null\n                front!!.next = null\n            }\n            front = fNext // Update head node\n            // Temporarily store tail node value\n        } else {\n            _val = rear!!._val // Delete tail node\n            // Update tail node\n            val rPrev = rear!!.prev\n            if (rPrev != null) {\n                rPrev.next = null\n                rear!!.prev = null\n            }\n            rear = rPrev // Update tail node\n        }\n        queSize-- // Update queue length\n        return _val\n    }\n\n    /* Rear of the queue dequeue */\n    fun popFirst(): Int {\n        return pop(true)\n    }\n\n    /* Access rear of the queue element */\n    fun popLast(): Int {\n        return pop(false)\n    }\n\n    /* Return list for printing */\n    fun peekFirst(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return front!!._val\n    }\n\n    /* Driver Code */\n    fun peekLast(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return rear!!._val\n    }\n\n    /* Return array for printing */\n    fun toArray(): IntArray {\n        var node = front\n        val res = IntArray(size())\n        for (i in res.indices) {\n            res[i] = node!!._val\n            node = node.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_deque.rb<pre><code>=begin\nFile: linkedlist_deque.rb\nCreated Time: 2024-04-06\nAuthor: Xuan Khoa Tu Nguyen (ngxktuzkai2000@gmail.com)\n=end\n\n### Doubly linked list node\nclass ListNode\n  attr_accessor :val\n  attr_accessor :next # Successor node reference\n  attr_accessor :prev # Predecessor node reference\n\n  ### Constructor ###\n  def initialize(val)\n    @val = val\n  end\nend\n\n### Deque based on doubly linked list ###\nclass LinkedListDeque\n  ### Get deque length ###\n  attr_reader :size\n\n  ### Constructor ###\n  def initialize\n    @front = nil  # Head node front\n    @rear = nil   # Tail node rear\n    @size = 0     # Length of the double-ended queue\n  end\n\n  ### Check if deque is empty ###\n  def is_empty?\n    size.zero?\n  end\n\n  ### Enqueue operation ###\n  def push(num, is_front)\n    node = ListNode.new(num)\n    # If list is empty, set both front and rear to node\n    if is_empty?\n      @front = @rear = node\n    # Front of the queue enqueue operation\n    elsif is_front\n      # Add node to the head of the linked list\n      @front.prev = node\n      node.next = @front\n      @front = node # Update head node\n    # Rear of the queue enqueue operation\n    else\n      # Add node to the tail of the linked list\n      @rear.next = node\n      node.prev = @rear\n      @rear = node # Update tail node\n    end\n    @size += 1 # Update queue length\n  end\n\n  ### Enqueue at front ###\n  def push_first(num)\n    push(num, true)\n  end\n\n  ### Enqueue at rear ###\n  def push_last(num)\n    push(num, false)\n  end\n\n  ### Dequeue operation ###\n  def pop(is_front)\n    raise IndexError, 'Deque is empty' if is_empty?\n\n    # Temporarily store head node value\n    if is_front\n      val = @front.val # Delete head node\n      # Delete head node\n      fnext = @front.next\n      unless fnext.nil?\n        fnext.prev = nil\n        @front.next = nil\n      end\n      @front = fnext # Update head node\n    # Temporarily store tail node value\n    else\n      val = @rear.val # Delete tail node\n      # Update tail node\n      rprev = @rear.prev\n      unless rprev.nil?\n        rprev.next = nil\n        @rear.prev = nil\n      end\n      @rear = rprev # Update tail node\n    end\n    @size -= 1 # Update queue length\n\n    val\n  end\n\n  ### Dequeue from front ###\n  def pop_first\n    pop(true)\n  end\n\n  ### Dequeue from front ###\n  def pop_last\n    pop(false)\n  end\n\n  ### Access front element ###\n  def peek_first\n    raise IndexError, 'Deque is empty' if is_empty?\n\n    @front.val\n  end\n\n  ### Access rear element ###\n  def peek_last\n    raise IndexError, 'Deque is empty' if is_empty?\n\n    @rear.val\n  end\n\n  ### Return array for printing ###\n  def to_array\n    node = @front\n    res = Array.new(size, 0)\n    for i in 0...size\n      res[i] = node.val\n      node = node.next\n    end\n    res\n  end\nend\n</code></pre>"},{"location":"chapter_stack_and_queue/deque/#2-array-implementation","title":"2. \u00a0 Array Implementation","text":"<p>As shown in Figure 5-9, similar to implementing a queue based on an array, we can also use a circular array to implement a deque.</p> ArrayDequepush_last()push_first()pop_last()pop_first() <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 5-9 \u00a0 Enqueue and dequeue operations in array implementation of deque </p> <p>Based on the queue implementation, we only need to add methods for \"enqueue at front\" and \"dequeue from rear\":</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array_deque.py<pre><code>class ArrayDeque:\n    \"\"\"Double-ended queue based on circular array implementation\"\"\"\n\n    def __init__(self, capacity: int):\n        \"\"\"Constructor\"\"\"\n        self._nums: list[int] = [0] * capacity\n        self._front: int = 0\n        self._size: int = 0\n\n    def capacity(self) -&gt; int:\n        \"\"\"Get the capacity of the double-ended queue\"\"\"\n        return len(self._nums)\n\n    def size(self) -&gt; int:\n        \"\"\"Get the length of the double-ended queue\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the double-ended queue is empty\"\"\"\n        return self._size == 0\n\n    def index(self, i: int) -&gt; int:\n        \"\"\"Calculate circular array index\"\"\"\n        # Use modulo operation to wrap the array head and tail together\n        # When i passes the tail of the array, return to the head\n        # When i passes the head of the array, return to the tail\n        return (i + self.capacity()) % self.capacity()\n\n    def push_first(self, num: int):\n        \"\"\"Front of the queue enqueue\"\"\"\n        if self._size == self.capacity():\n            print(\"Double-ended queue is full\")\n            return\n        # Front pointer moves one position to the left\n        # Use modulo operation to wrap front around to the tail after passing the head of the array\n        self._front = self.index(self._front - 1)\n        # Add num to the front of the queue\n        self._nums[self._front] = num\n        self._size += 1\n\n    def push_last(self, num: int):\n        \"\"\"Rear of the queue enqueue\"\"\"\n        if self._size == self.capacity():\n            print(\"Double-ended queue is full\")\n            return\n        # Calculate rear pointer, points to rear index + 1\n        rear = self.index(self._front + self._size)\n        # Add num to the rear of the queue\n        self._nums[rear] = num\n        self._size += 1\n\n    def pop_first(self) -&gt; int:\n        \"\"\"Front of the queue dequeue\"\"\"\n        num = self.peek_first()\n        # Front pointer moves one position backward\n        self._front = self.index(self._front + 1)\n        self._size -= 1\n        return num\n\n    def pop_last(self) -&gt; int:\n        \"\"\"Rear of the queue dequeue\"\"\"\n        num = self.peek_last()\n        self._size -= 1\n        return num\n\n    def peek_first(self) -&gt; int:\n        \"\"\"Access front of the queue element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Double-ended queue is empty\")\n        return self._nums[self._front]\n\n    def peek_last(self) -&gt; int:\n        \"\"\"Access rear of the queue element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Double-ended queue is empty\")\n        # Calculate tail element index\n        last = self.index(self._front + self._size - 1)\n        return self._nums[last]\n\n    def to_array(self) -&gt; list[int]:\n        \"\"\"Return array for printing\"\"\"\n        # Only convert list elements within the valid length range\n        res = []\n        for i in range(self._size):\n            res.append(self._nums[self.index(self._front + i)])\n        return res\n</code></pre> array_deque.cpp<pre><code>/* Double-ended queue based on circular array implementation */\nclass ArrayDeque {\n  private:\n    vector&lt;int&gt; nums; // Array for storing double-ended queue elements\n    int front;        // Front pointer, points to the front of the queue element\n    int queSize;      // Double-ended queue length\n\n  public:\n    /* Constructor */\n    ArrayDeque(int capacity) {\n        nums.resize(capacity);\n        front = queSize = 0;\n    }\n\n    /* Get the capacity of the double-ended queue */\n    int capacity() {\n        return nums.size();\n    }\n\n    /* Get the length of the double-ended queue */\n    int size() {\n        return queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* Calculate circular array index */\n    int index(int i) {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        return (i + capacity()) % capacity();\n    }\n\n    /* Front of the queue enqueue */\n    void pushFirst(int num) {\n        if (queSize == capacity()) {\n            cout &lt;&lt; \"Double-ended queue is full\" &lt;&lt; endl;\n            return;\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        front = index(front - 1);\n        // Add num to front of queue\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* Rear of the queue enqueue */\n    void pushLast(int num) {\n        if (queSize == capacity()) {\n            cout &lt;&lt; \"Double-ended queue is full\" &lt;&lt; endl;\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        int rear = index(front + queSize);\n        // Front pointer moves one position backward\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* Rear of the queue dequeue */\n    int popFirst() {\n        int num = peekFirst();\n        // Move front pointer backward by one position\n        front = index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* Access rear of the queue element */\n    int popLast() {\n        int num = peekLast();\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"Deque is empty\");\n        return nums[front];\n    }\n\n    /* Driver Code */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"Deque is empty\");\n        // Initialize double-ended queue\n        int last = index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* Return array for printing */\n    vector&lt;int&gt; toVector() {\n        // Elements enqueue\n        vector&lt;int&gt; res(queSize);\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[index(j)];\n        }\n        return res;\n    }\n};\n</code></pre> array_deque.java<pre><code>/* Double-ended queue based on circular array implementation */\nclass ArrayDeque {\n    private int[] nums; // Array for storing double-ended queue elements\n    private int front; // Front pointer, points to the front of the queue element\n    private int queSize; // Double-ended queue length\n\n    /* Constructor */\n    public ArrayDeque(int capacity) {\n        this.nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* Get the capacity of the double-ended queue */\n    public int capacity() {\n        return nums.length;\n    }\n\n    /* Get the length of the double-ended queue */\n    public int size() {\n        return queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    public boolean isEmpty() {\n        return queSize == 0;\n    }\n\n    /* Calculate circular array index */\n    private int index(int i) {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        return (i + capacity()) % capacity();\n    }\n\n    /* Front of the queue enqueue */\n    public void pushFirst(int num) {\n        if (queSize == capacity()) {\n            System.out.println(\"Double-ended queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        front = index(front - 1);\n        // Add num to front of queue\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* Rear of the queue enqueue */\n    public void pushLast(int num) {\n        if (queSize == capacity()) {\n            System.out.println(\"Double-ended queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        int rear = index(front + queSize);\n        // Front pointer moves one position backward\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* Rear of the queue dequeue */\n    public int popFirst() {\n        int num = peekFirst();\n        // Move front pointer backward by one position\n        front = index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* Access rear of the queue element */\n    public int popLast() {\n        int num = peekLast();\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int peekFirst() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return nums[front];\n    }\n\n    /* Driver Code */\n    public int peekLast() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        // Initialize double-ended queue\n        int last = index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* Return array for printing */\n    public int[] toArray() {\n        // Elements enqueue\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.cs<pre><code>/* Double-ended queue based on circular array implementation */\nclass ArrayDeque {\n    int[] nums;  // Array for storing double-ended queue elements\n    int front;   // Front pointer, points to the front of the queue element\n    int queSize; // Double-ended queue length\n\n    /* Constructor */\n    public ArrayDeque(int capacity) {\n        nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* Get the capacity of the double-ended queue */\n    int Capacity() {\n        return nums.Length;\n    }\n\n    /* Get the length of the double-ended queue */\n    public int Size() {\n        return queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    public bool IsEmpty() {\n        return queSize == 0;\n    }\n\n    /* Calculate circular array index */\n    int Index(int i) {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        return (i + Capacity()) % Capacity();\n    }\n\n    /* Front of the queue enqueue */\n    public void PushFirst(int num) {\n        if (queSize == Capacity()) {\n            Console.WriteLine(\"Double-ended queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        front = Index(front - 1);\n        // Add num to front of queue\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* Rear of the queue enqueue */\n    public void PushLast(int num) {\n        if (queSize == Capacity()) {\n            Console.WriteLine(\"Double-ended queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        int rear = Index(front + queSize);\n        // Front pointer moves one position backward\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* Rear of the queue dequeue */\n    public int PopFirst() {\n        int num = PeekFirst();\n        // Move front pointer backward by one position\n        front = Index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* Access rear of the queue element */\n    public int PopLast() {\n        int num = PeekLast();\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int PeekFirst() {\n        if (IsEmpty()) {\n            throw new InvalidOperationException();\n        }\n        return nums[front];\n    }\n\n    /* Driver Code */\n    public int PeekLast() {\n        if (IsEmpty()) {\n            throw new InvalidOperationException();\n        }\n        // Initialize double-ended queue\n        int last = Index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* Return array for printing */\n    public int[] ToArray() {\n        // Elements enqueue\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[Index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.go<pre><code>/* Double-ended queue based on circular array implementation */\ntype arrayDeque struct {\n    nums        []int // Array for storing double-ended queue elements\n    front       int   // Front pointer, points to the front of the queue element\n    queSize     int   // Double-ended queue length\n    queCapacity int   // Queue capacity (maximum number of elements)\n}\n\n/* Access front of the queue element */\nfunc newArrayDeque(queCapacity int) *arrayDeque {\n    return &amp;arrayDeque{\n        nums:        make([]int, queCapacity),\n        queCapacity: queCapacity,\n        front:       0,\n        queSize:     0,\n    }\n}\n\n/* Get the length of the double-ended queue */\nfunc (q *arrayDeque) size() int {\n    return q.queSize\n}\n\n/* Check if the double-ended queue is empty */\nfunc (q *arrayDeque) isEmpty() bool {\n    return q.queSize == 0\n}\n\n/* Calculate circular array index */\nfunc (q *arrayDeque) index(i int) int {\n    // Use modulo operation to wrap the array head and tail together\n    // When i passes the tail of the array, return to the head\n    // When i passes the head of the array, return to the tail\n    return (i + q.queCapacity) % q.queCapacity\n}\n\n/* Front of the queue enqueue */\nfunc (q *arrayDeque) pushFirst(num int) {\n    if q.queSize == q.queCapacity {\n        fmt.Println(\"Double-ended queue is full\")\n        return\n    }\n    // Use modulo operation to wrap front around to the tail after passing the head of the array\n    // Add num to the front of the queue\n    q.front = q.index(q.front - 1)\n    // Add num to front of queue\n    q.nums[q.front] = num\n    q.queSize++\n}\n\n/* Rear of the queue enqueue */\nfunc (q *arrayDeque) pushLast(num int) {\n    if q.queSize == q.queCapacity {\n        fmt.Println(\"Double-ended queue is full\")\n        return\n    }\n    // Use modulo operation to wrap rear around to the head after passing the tail of the array\n    rear := q.index(q.front + q.queSize)\n    // Front pointer moves one position backward\n    q.nums[rear] = num\n    q.queSize++\n}\n\n/* Rear of the queue dequeue */\nfunc (q *arrayDeque) popFirst() any {\n    num := q.peekFirst()\n    if num == nil {\n        return nil\n    }\n    // Move front pointer backward by one position\n    q.front = q.index(q.front + 1)\n    q.queSize--\n    return num\n}\n\n/* Access rear of the queue element */\nfunc (q *arrayDeque) popLast() any {\n    num := q.peekLast()\n    if num == nil {\n        return nil\n    }\n    q.queSize--\n    return num\n}\n\n/* Return list for printing */\nfunc (q *arrayDeque) peekFirst() any {\n    if q.isEmpty() {\n        return nil\n    }\n    return q.nums[q.front]\n}\n\n/* Driver Code */\nfunc (q *arrayDeque) peekLast() any {\n    if q.isEmpty() {\n        return nil\n    }\n    // Initialize double-ended queue\n    last := q.index(q.front + q.queSize - 1)\n    return q.nums[last]\n}\n\n/* Get Slice for printing */\nfunc (q *arrayDeque) toSlice() []int {\n    // Elements enqueue\n    res := make([]int, q.queSize)\n    for i, j := 0, q.front; i &lt; q.queSize; i++ {\n        res[i] = q.nums[q.index(j)]\n        j++\n    }\n    return res\n}\n</code></pre> array_deque.swift<pre><code>/* Double-ended queue based on circular array implementation */\nclass ArrayDeque {\n    private var nums: [Int] // Array for storing double-ended queue elements\n    private var front: Int // Front pointer, points to the front of the queue element\n    private var _size: Int // Double-ended queue length\n\n    /* Constructor */\n    init(capacity: Int) {\n        nums = Array(repeating: 0, count: capacity)\n        front = 0\n        _size = 0\n    }\n\n    /* Get the capacity of the double-ended queue */\n    func capacity() -&gt; Int {\n        nums.count\n    }\n\n    /* Get the length of the double-ended queue */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* Check if the double-ended queue is empty */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* Calculate circular array index */\n    private func index(i: Int) -&gt; Int {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        (i + capacity()) % capacity()\n    }\n\n    /* Front of the queue enqueue */\n    func pushFirst(num: Int) {\n        if size() == capacity() {\n            print(\"Double-ended queue is full\")\n            return\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        front = index(i: front - 1)\n        // Add num to front of queue\n        nums[front] = num\n        _size += 1\n    }\n\n    /* Rear of the queue enqueue */\n    func pushLast(num: Int) {\n        if size() == capacity() {\n            print(\"Double-ended queue is full\")\n            return\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        let rear = index(i: front + size())\n        // Front pointer moves one position backward\n        nums[rear] = num\n        _size += 1\n    }\n\n    /* Rear of the queue dequeue */\n    func popFirst() -&gt; Int {\n        let num = peekFirst()\n        // Move front pointer backward by one position\n        front = index(i: front + 1)\n        _size -= 1\n        return num\n    }\n\n    /* Access rear of the queue element */\n    func popLast() -&gt; Int {\n        let num = peekLast()\n        _size -= 1\n        return num\n    }\n\n    /* Return list for printing */\n    func peekFirst() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Deque is empty\")\n        }\n        return nums[front]\n    }\n\n    /* Driver Code */\n    func peekLast() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Deque is empty\")\n        }\n        // Initialize double-ended queue\n        let last = index(i: front + size() - 1)\n        return nums[last]\n    }\n\n    /* Return array for printing */\n    func toArray() -&gt; [Int] {\n        // Elements enqueue\n        (front ..&lt; front + size()).map { nums[index(i: $0)] }\n    }\n}\n</code></pre> array_deque.js<pre><code>/* Double-ended queue based on circular array implementation */\nclass ArrayDeque {\n    #nums; // Array for storing double-ended queue elements\n    #front; // Front pointer, points to the front of the queue element\n    #queSize; // Double-ended queue length\n\n    /* Constructor */\n    constructor(capacity) {\n        this.#nums = new Array(capacity);\n        this.#front = 0;\n        this.#queSize = 0;\n    }\n\n    /* Get the capacity of the double-ended queue */\n    capacity() {\n        return this.#nums.length;\n    }\n\n    /* Get the length of the double-ended queue */\n    size() {\n        return this.#queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    isEmpty() {\n        return this.#queSize === 0;\n    }\n\n    /* Calculate circular array index */\n    index(i) {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        return (i + this.capacity()) % this.capacity();\n    }\n\n    /* Front of the queue enqueue */\n    pushFirst(num) {\n        if (this.#queSize === this.capacity()) {\n            console.log('Double-ended queue is full');\n            return;\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        this.#front = this.index(this.#front - 1);\n        // Add num to front of queue\n        this.#nums[this.#front] = num;\n        this.#queSize++;\n    }\n\n    /* Rear of the queue enqueue */\n    pushLast(num) {\n        if (this.#queSize === this.capacity()) {\n            console.log('Double-ended queue is full');\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        const rear = this.index(this.#front + this.#queSize);\n        // Front pointer moves one position backward\n        this.#nums[rear] = num;\n        this.#queSize++;\n    }\n\n    /* Rear of the queue dequeue */\n    popFirst() {\n        const num = this.peekFirst();\n        // Move front pointer backward by one position\n        this.#front = this.index(this.#front + 1);\n        this.#queSize--;\n        return num;\n    }\n\n    /* Access rear of the queue element */\n    popLast() {\n        const num = this.peekLast();\n        this.#queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peekFirst() {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        return this.#nums[this.#front];\n    }\n\n    /* Driver Code */\n    peekLast() {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        // Initialize double-ended queue\n        const last = this.index(this.#front + this.#queSize - 1);\n        return this.#nums[last];\n    }\n\n    /* Return array for printing */\n    toArray() {\n        // Elements enqueue\n        const res = [];\n        for (let i = 0, j = this.#front; i &lt; this.#queSize; i++, j++) {\n            res[i] = this.#nums[this.index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.ts<pre><code>/* Double-ended queue based on circular array implementation */\nclass ArrayDeque {\n    private nums: number[]; // Array for storing double-ended queue elements\n    private front: number; // Front pointer, points to the front of the queue element\n    private queSize: number; // Double-ended queue length\n\n    /* Constructor */\n    constructor(capacity: number) {\n        this.nums = new Array(capacity);\n        this.front = 0;\n        this.queSize = 0;\n    }\n\n    /* Get the capacity of the double-ended queue */\n    capacity(): number {\n        return this.nums.length;\n    }\n\n    /* Get the length of the double-ended queue */\n    size(): number {\n        return this.queSize;\n    }\n\n    /* Check if the double-ended queue is empty */\n    isEmpty(): boolean {\n        return this.queSize === 0;\n    }\n\n    /* Calculate circular array index */\n    index(i: number): number {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        return (i + this.capacity()) % this.capacity();\n    }\n\n    /* Front of the queue enqueue */\n    pushFirst(num: number): void {\n        if (this.queSize === this.capacity()) {\n            console.log('Double-ended queue is full');\n            return;\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        this.front = this.index(this.front - 1);\n        // Add num to front of queue\n        this.nums[this.front] = num;\n        this.queSize++;\n    }\n\n    /* Rear of the queue enqueue */\n    pushLast(num: number): void {\n        if (this.queSize === this.capacity()) {\n            console.log('Double-ended queue is full');\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        const rear: number = this.index(this.front + this.queSize);\n        // Front pointer moves one position backward\n        this.nums[rear] = num;\n        this.queSize++;\n    }\n\n    /* Rear of the queue dequeue */\n    popFirst(): number {\n        const num: number = this.peekFirst();\n        // Move front pointer backward by one position\n        this.front = this.index(this.front + 1);\n        this.queSize--;\n        return num;\n    }\n\n    /* Access rear of the queue element */\n    popLast(): number {\n        const num: number = this.peekLast();\n        this.queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peekFirst(): number {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        return this.nums[this.front];\n    }\n\n    /* Driver Code */\n    peekLast(): number {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        // Initialize double-ended queue\n        const last = this.index(this.front + this.queSize - 1);\n        return this.nums[last];\n    }\n\n    /* Return array for printing */\n    toArray(): number[] {\n        // Elements enqueue\n        const res: number[] = [];\n        for (let i = 0, j = this.front; i &lt; this.queSize; i++, j++) {\n            res[i] = this.nums[this.index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.dart<pre><code>/* Double-ended queue based on circular array implementation */\nclass ArrayDeque {\n  late List&lt;int&gt; _nums; // Array for storing double-ended queue elements\n  late int _front; // Front pointer, points to the front of the queue element\n  late int _queSize; // Double-ended queue length\n\n  /* Constructor */\n  ArrayDeque(int capacity) {\n    this._nums = List.filled(capacity, 0);\n    this._front = this._queSize = 0;\n  }\n\n  /* Get the capacity of the double-ended queue */\n  int capacity() {\n    return _nums.length;\n  }\n\n  /* Get the length of the double-ended queue */\n  int size() {\n    return _queSize;\n  }\n\n  /* Check if the double-ended queue is empty */\n  bool isEmpty() {\n    return _queSize == 0;\n  }\n\n  /* Calculate circular array index */\n  int index(int i) {\n    // Use modulo operation to wrap the array head and tail together\n    // When i passes the tail of the array, return to the head\n    // When i passes the head of the array, return to the tail\n    return (i + capacity()) % capacity();\n  }\n\n  /* Front of the queue enqueue */\n  void pushFirst(int _num) {\n    if (_queSize == capacity()) {\n      throw Exception(\"Double-ended queue is full\");\n    }\n    // Use modulo operation to wrap front around to the tail after passing the head of the array\n    // Use modulo operation to wrap _front from array head back to tail\n    _front = index(_front - 1);\n    // Add _num to queue front\n    _nums[_front] = _num;\n    _queSize++;\n  }\n\n  /* Rear of the queue enqueue */\n  void pushLast(int _num) {\n    if (_queSize == capacity()) {\n      throw Exception(\"Double-ended queue is full\");\n    }\n    // Use modulo operation to wrap rear around to the head after passing the tail of the array\n    int rear = index(_front + _queSize);\n    // Add _num to queue rear\n    _nums[rear] = _num;\n    _queSize++;\n  }\n\n  /* Rear of the queue dequeue */\n  int popFirst() {\n    int _num = peekFirst();\n    // Move front pointer right by one\n    _front = index(_front + 1);\n    _queSize--;\n    return _num;\n  }\n\n  /* Access rear of the queue element */\n  int popLast() {\n    int _num = peekLast();\n    _queSize--;\n    return _num;\n  }\n\n  /* Return list for printing */\n  int peekFirst() {\n    if (isEmpty()) {\n      throw Exception(\"Deque is empty\");\n    }\n    return _nums[_front];\n  }\n\n  /* Driver Code */\n  int peekLast() {\n    if (isEmpty()) {\n      throw Exception(\"Deque is empty\");\n    }\n    // Initialize double-ended queue\n    int last = index(_front + _queSize - 1);\n    return _nums[last];\n  }\n\n  /* Return array for printing */\n  List&lt;int&gt; toArray() {\n    // Elements enqueue\n    List&lt;int&gt; res = List.filled(_queSize, 0);\n    for (int i = 0, j = _front; i &lt; _queSize; i++, j++) {\n      res[i] = _nums[index(j)];\n    }\n    return res;\n  }\n}\n</code></pre> array_deque.rs<pre><code>/* Double-ended queue based on circular array implementation */\nstruct ArrayDeque&lt;T&gt; {\n    nums: Vec&lt;T&gt;,    // Array for storing double-ended queue elements\n    front: usize,    // Front pointer, points to the front of the queue element\n    que_size: usize, // Double-ended queue length\n}\n\nimpl&lt;T: Copy + Default&gt; ArrayDeque&lt;T&gt; {\n    /* Constructor */\n    pub fn new(capacity: usize) -&gt; Self {\n        Self {\n            nums: vec![T::default(); capacity],\n            front: 0,\n            que_size: 0,\n        }\n    }\n\n    /* Get the capacity of the double-ended queue */\n    pub fn capacity(&amp;self) -&gt; usize {\n        self.nums.len()\n    }\n\n    /* Get the length of the double-ended queue */\n    pub fn size(&amp;self) -&gt; usize {\n        self.que_size\n    }\n\n    /* Check if the double-ended queue is empty */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        self.que_size == 0\n    }\n\n    /* Calculate circular array index */\n    fn index(&amp;self, i: i32) -&gt; usize {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        ((i + self.capacity() as i32) % self.capacity() as i32) as usize\n    }\n\n    /* Front of the queue enqueue */\n    pub fn push_first(&amp;mut self, num: T) {\n        if self.que_size == self.capacity() {\n            println!(\"Double-ended queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        self.front = self.index(self.front as i32 - 1);\n        // Add num to front of queue\n        self.nums[self.front] = num;\n        self.que_size += 1;\n    }\n\n    /* Rear of the queue enqueue */\n    pub fn push_last(&amp;mut self, num: T) {\n        if self.que_size == self.capacity() {\n            println!(\"Double-ended queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        let rear = self.index(self.front as i32 + self.que_size as i32);\n        // Front pointer moves one position backward\n        self.nums[rear] = num;\n        self.que_size += 1;\n    }\n\n    /* Rear of the queue dequeue */\n    fn pop_first(&amp;mut self) -&gt; T {\n        let num = self.peek_first();\n        // Move front pointer backward by one position\n        self.front = self.index(self.front as i32 + 1);\n        self.que_size -= 1;\n        num\n    }\n\n    /* Access rear of the queue element */\n    fn pop_last(&amp;mut self) -&gt; T {\n        let num = self.peek_last();\n        self.que_size -= 1;\n        num\n    }\n\n    /* Return list for printing */\n    fn peek_first(&amp;self) -&gt; T {\n        if self.is_empty() {\n            panic!(\"Deque is empty\")\n        };\n        self.nums[self.front]\n    }\n\n    /* Driver Code */\n    fn peek_last(&amp;self) -&gt; T {\n        if self.is_empty() {\n            panic!(\"Deque is empty\")\n        };\n        // Initialize double-ended queue\n        let last = self.index(self.front as i32 + self.que_size as i32 - 1);\n        self.nums[last]\n    }\n\n    /* Return array for printing */\n    fn to_array(&amp;self) -&gt; Vec&lt;T&gt; {\n        // Elements enqueue\n        let mut res = vec![T::default(); self.que_size];\n        let mut j = self.front;\n        for i in 0..self.que_size {\n            res[i] = self.nums[self.index(j as i32)];\n            j += 1;\n        }\n        res\n    }\n}\n</code></pre> array_deque.c<pre><code>/* Double-ended queue based on circular array implementation */\ntypedef struct {\n    int *nums;       // Array for storing queue elements\n    int front;       // Front pointer, points to the front of the queue element\n    int queSize;     // Rear pointer, points to rear + 1\n    int queCapacity; // Queue capacity\n} ArrayDeque;\n\n/* Constructor */\nArrayDeque *newArrayDeque(int capacity) {\n    ArrayDeque *deque = (ArrayDeque *)malloc(sizeof(ArrayDeque));\n    // Initialize array\n    deque-&gt;queCapacity = capacity;\n    deque-&gt;nums = (int *)malloc(sizeof(int) * deque-&gt;queCapacity);\n    deque-&gt;front = deque-&gt;queSize = 0;\n    return deque;\n}\n\n/* Destructor */\nvoid delArrayDeque(ArrayDeque *deque) {\n    free(deque-&gt;nums);\n    free(deque);\n}\n\n/* Get the capacity of the double-ended queue */\nint capacity(ArrayDeque *deque) {\n    return deque-&gt;queCapacity;\n}\n\n/* Get the length of the double-ended queue */\nint size(ArrayDeque *deque) {\n    return deque-&gt;queSize;\n}\n\n/* Check if the double-ended queue is empty */\nbool empty(ArrayDeque *deque) {\n    return deque-&gt;queSize == 0;\n}\n\n/* Calculate circular array index */\nint dequeIndex(ArrayDeque *deque, int i) {\n    // Use modulo operation to wrap the array head and tail together\n    // When i exceeds array end, wrap to head\n    // When i passes the head of the array, return to the tail\n    return ((i + capacity(deque)) % capacity(deque));\n}\n\n/* Front of the queue enqueue */\nvoid pushFirst(ArrayDeque *deque, int num) {\n    if (deque-&gt;queSize == capacity(deque)) {\n        printf(\"Deque is full\\r\\n\");\n        return;\n    }\n    // Use modulo operation to wrap front around to the tail after passing the head of the array\n    // Use modulo to wrap front from array head to rear\n    deque-&gt;front = dequeIndex(deque, deque-&gt;front - 1);\n    // Add num to queue front\n    deque-&gt;nums[deque-&gt;front] = num;\n    deque-&gt;queSize++;\n}\n\n/* Rear of the queue enqueue */\nvoid pushLast(ArrayDeque *deque, int num) {\n    if (deque-&gt;queSize == capacity(deque)) {\n        printf(\"Deque is full\\r\\n\");\n        return;\n    }\n    // Use modulo operation to wrap rear around to the head after passing the tail of the array\n    int rear = dequeIndex(deque, deque-&gt;front + deque-&gt;queSize);\n    // Front pointer moves one position backward\n    deque-&gt;nums[rear] = num;\n    deque-&gt;queSize++;\n}\n\n/* Return list for printing */\nint peekFirst(ArrayDeque *deque) {\n    // Access error: Deque is empty\n    assert(empty(deque) == 0);\n    return deque-&gt;nums[deque-&gt;front];\n}\n\n/* Driver Code */\nint peekLast(ArrayDeque *deque) {\n    // Access error: Deque is empty\n    assert(empty(deque) == 0);\n    int last = dequeIndex(deque, deque-&gt;front + deque-&gt;queSize - 1);\n    return deque-&gt;nums[last];\n}\n\n/* Rear of the queue dequeue */\nint popFirst(ArrayDeque *deque) {\n    int num = peekFirst(deque);\n    // Move front pointer backward by one position\n    deque-&gt;front = dequeIndex(deque, deque-&gt;front + 1);\n    deque-&gt;queSize--;\n    return num;\n}\n\n/* Access rear of the queue element */\nint popLast(ArrayDeque *deque) {\n    int num = peekLast(deque);\n    deque-&gt;queSize--;\n    return num;\n}\n\n/* Return array for printing */\nint *toArray(ArrayDeque *deque, int *queSize) {\n    *queSize = deque-&gt;queSize;\n    int *res = (int *)calloc(deque-&gt;queSize, sizeof(int));\n    int j = deque-&gt;front;\n    for (int i = 0; i &lt; deque-&gt;queSize; i++) {\n        res[i] = deque-&gt;nums[j % deque-&gt;queCapacity];\n        j++;\n    }\n    return res;\n}\n</code></pre> array_deque.kt<pre><code>/* Constructor */\nclass ArrayDeque(capacity: Int) {\n    private var nums: IntArray = IntArray(capacity) // Array for storing double-ended queue elements\n    private var front: Int = 0 // Front pointer, points to the front of the queue element\n    private var queSize: Int = 0 // Double-ended queue length\n\n    /* Get the capacity of the double-ended queue */\n    fun capacity(): Int {\n        return nums.size\n    }\n\n    /* Get the length of the double-ended queue */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* Check if the double-ended queue is empty */\n    fun isEmpty(): Boolean {\n        return queSize == 0\n    }\n\n    /* Calculate circular array index */\n    private fun index(i: Int): Int {\n        // Use modulo operation to wrap the array head and tail together\n        // When i passes the tail of the array, return to the head\n        // When i passes the head of the array, return to the tail\n        return (i + capacity()) % capacity()\n    }\n\n    /* Front of the queue enqueue */\n    fun pushFirst(num: Int) {\n        if (queSize == capacity()) {\n            println(\"Double-ended queue is full\")\n            return\n        }\n        // Use modulo operation to wrap front around to the tail after passing the head of the array\n        // Add num to the front of the queue\n        front = index(front - 1)\n        // Add num to front of queue\n        nums[front] = num\n        queSize++\n    }\n\n    /* Rear of the queue enqueue */\n    fun pushLast(num: Int) {\n        if (queSize == capacity()) {\n            println(\"Double-ended queue is full\")\n            return\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        val rear = index(front + queSize)\n        // Front pointer moves one position backward\n        nums[rear] = num\n        queSize++\n    }\n\n    /* Rear of the queue dequeue */\n    fun popFirst(): Int {\n        val num = peekFirst()\n        // Move front pointer backward by one position\n        front = index(front + 1)\n        queSize--\n        return num\n    }\n\n    /* Access rear of the queue element */\n    fun popLast(): Int {\n        val num = peekLast()\n        queSize--\n        return num\n    }\n\n    /* Return list for printing */\n    fun peekFirst(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return nums[front]\n    }\n\n    /* Driver Code */\n    fun peekLast(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        // Initialize double-ended queue\n        val last = index(front + queSize - 1)\n        return nums[last]\n    }\n\n    /* Return array for printing */\n    fun toArray(): IntArray {\n        // Elements enqueue\n        val res = IntArray(queSize)\n        var i = 0\n        var j = front\n        while (i &lt; queSize) {\n            res[i] = nums[index(j)]\n            i++\n            j++\n        }\n        return res\n    }\n}\n</code></pre> array_deque.rb<pre><code>### Deque based on circular array ###\nclass ArrayDeque\n  ### Get deque length ###\n  attr_reader :size\n\n  ### Constructor ###\n  def initialize(capacity)\n    @nums = Array.new(capacity, 0)\n    @front = 0\n    @size = 0\n  end\n\n  ### Get deque capacity ###\n  def capacity\n    @nums.length\n  end\n\n  ### Check if deque is empty ###\n  def is_empty?\n    size.zero?\n  end\n\n  ### Enqueue at front ###\n  def push_first(num)\n    if size == capacity\n      puts 'Double-ended queue is full'\n      return\n    end\n\n    # Use modulo operation to wrap front around to the tail after passing the head of the array\n    # Add num to the front of the queue\n    @front = index(@front - 1)\n    # Add num to front of queue\n    @nums[@front] = num\n    @size += 1\n  end\n\n  ### Enqueue at rear ###\n  def push_last(num)\n    if size == capacity\n      puts 'Double-ended queue is full'\n      return\n    end\n\n    # Use modulo operation to wrap rear around to the head after passing the tail of the array\n    rear = index(@front + size)\n    # Front pointer moves one position backward\n    @nums[rear] = num\n    @size += 1\n  end\n\n  ### Dequeue from front ###\n  def pop_first\n    num = peek_first\n    # Move front pointer backward by one position\n    @front = index(@front + 1)\n    @size -= 1\n    num\n  end\n\n  ### Dequeue from rear ###\n  def pop_last\n    num = peek_last\n    @size -= 1\n    num\n  end\n\n  ### Access front element ###\n  def peek_first\n    raise IndexError, 'Deque is empty' if is_empty?\n\n    @nums[@front]\n  end\n\n  ### Access rear element ###\n  def peek_last\n    raise IndexError, 'Deque is empty' if is_empty?\n\n    # Initialize double-ended queue\n    last = index(@front + size - 1)\n    @nums[last]\n  end\n\n  ### Return array for printing ###\n  def to_array\n    # Elements enqueue\n    res = []\n    for i in 0...size\n      res &lt;&lt; @nums[index(@front + i)]\n    end\n    res\n  end\n\n  private\n\n  ### Calculate circular array index ###\n  def index(i)\n    # Use modulo operation to wrap the array head and tail together\n    # When i passes the tail of the array, return to the head\n    # When i passes the head of the array, return to the tail\n    (i + capacity) % capacity\n  end\nend\n</code></pre>"},{"location":"chapter_stack_and_queue/deque/#533-deque-applications","title":"5.3.3 \u00a0 Deque Applications","text":"<p>A deque combines the logic of both stacks and queues. Therefore, it can implement all application scenarios of both, while providing greater flexibility.</p> <p>We know that the \"undo\" function in software is typically implemented using a stack: the system pushes each change operation onto the stack and then implements undo through pop. However, considering system resource limitations, software usually limits the number of undo steps (for example, only allowing 50 steps to be saved). When the stack length exceeds 50, the software needs to perform a deletion operation at the bottom of the stack (front of the queue). But a stack cannot implement this functionality, so a deque is needed to replace the stack. Note that the core logic of \"undo\" still follows the LIFO principle of a stack; it's just that the deque can more flexibly implement some additional logic.</p>"},{"location":"chapter_stack_and_queue/queue/","title":"5.2 \u00a0 Queue","text":"<p>A queue is a linear data structure that follows the First In First Out (FIFO) rule. As the name suggests, a queue simulates the phenomenon of lining up, where newcomers continuously join the end of the queue, while people at the front of the queue leave one by one.</p> <p>As shown in Figure 5-4, we call the front of the queue the \"front\" and the end the \"rear.\" The operation of adding an element to the rear is called \"enqueue,\" and the operation of removing the front element is called \"dequeue.\"</p> <p></p> <p> Figure 5-4 \u00a0 FIFO rule of queue </p>"},{"location":"chapter_stack_and_queue/queue/#521-common-queue-operations","title":"5.2.1 \u00a0 Common Queue Operations","text":"<p>The common operations on a queue are shown in Table 5-2. Note that method names may vary across different programming languages. We adopt the same naming convention as for stacks here.</p> <p> Table 5-2 \u00a0 Efficiency of Queue Operations </p> Method Description Time Complexity <code>push()</code> Enqueue element, add element to rear \\(O(1)\\) <code>pop()</code> Dequeue front element \\(O(1)\\) <code>peek()</code> Access front element \\(O(1)\\) <p>We can directly use the ready-made queue classes in programming languages:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby queue.py<pre><code>from collections import deque\n\n# Initialize queue\n# In Python, we generally use the deque class as a queue\n# Although queue.Queue() is a pure queue class, it is not very user-friendly, so it is not recommended\nque: deque[int] = deque()\n\n# Enqueue elements\nque.append(1)\nque.append(3)\nque.append(2)\nque.append(5)\nque.append(4)\n\n# Access front element\nfront: int = que[0]\n\n# Dequeue element\npop: int = que.popleft()\n\n# Get queue length\nsize: int = len(que)\n\n# Check if queue is empty\nis_empty: bool = len(que) == 0\n</code></pre> queue.cpp<pre><code>/* Initialize queue */\nqueue&lt;int&gt; queue;\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access front element */\nint front = queue.front();\n\n/* Dequeue element */\nqueue.pop();\n\n/* Get queue length */\nint size = queue.size();\n\n/* Check if queue is empty */\nbool empty = queue.empty();\n</code></pre> queue.java<pre><code>/* Initialize queue */\nQueue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n\n/* Enqueue elements */\nqueue.offer(1);\nqueue.offer(3);\nqueue.offer(2);\nqueue.offer(5);\nqueue.offer(4);\n\n/* Access front element */\nint peek = queue.peek();\n\n/* Dequeue element */\nint pop = queue.poll();\n\n/* Get queue length */\nint size = queue.size();\n\n/* Check if queue is empty */\nboolean isEmpty = queue.isEmpty();\n</code></pre> queue.cs<pre><code>/* Initialize queue */\nQueue&lt;int&gt; queue = new();\n\n/* Enqueue elements */\nqueue.Enqueue(1);\nqueue.Enqueue(3);\nqueue.Enqueue(2);\nqueue.Enqueue(5);\nqueue.Enqueue(4);\n\n/* Access front element */\nint peek = queue.Peek();\n\n/* Dequeue element */\nint pop = queue.Dequeue();\n\n/* Get queue length */\nint size = queue.Count;\n\n/* Check if queue is empty */\nbool isEmpty = queue.Count == 0;\n</code></pre> queue_test.go<pre><code>/* Initialize queue */\n// In Go, use list as a queue\nqueue := list.New()\n\n/* Enqueue elements */\nqueue.PushBack(1)\nqueue.PushBack(3)\nqueue.PushBack(2)\nqueue.PushBack(5)\nqueue.PushBack(4)\n\n/* Access front element */\npeek := queue.Front()\n\n/* Dequeue element */\npop := queue.Front()\nqueue.Remove(pop)\n\n/* Get queue length */\nsize := queue.Len()\n\n/* Check if queue is empty */\nisEmpty := queue.Len() == 0\n</code></pre> queue.swift<pre><code>/* Initialize queue */\n// Swift does not have a built-in queue class, can use Array as a queue\nvar queue: [Int] = []\n\n/* Enqueue elements */\nqueue.append(1)\nqueue.append(3)\nqueue.append(2)\nqueue.append(5)\nqueue.append(4)\n\n/* Access front element */\nlet peek = queue.first!\n\n/* Dequeue element */\n// Since it's an array, removeFirst has O(n) complexity\nlet pool = queue.removeFirst()\n\n/* Get queue length */\nlet size = queue.count\n\n/* Check if queue is empty */\nlet isEmpty = queue.isEmpty\n</code></pre> queue.js<pre><code>/* Initialize queue */\n// JavaScript does not have a built-in queue, can use Array as a queue\nconst queue = [];\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access front element */\nconst peek = queue[0];\n\n/* Dequeue element */\n// The underlying structure is an array, so shift() has O(n) time complexity\nconst pop = queue.shift();\n\n/* Get queue length */\nconst size = queue.length;\n\n/* Check if queue is empty */\nconst empty = queue.length === 0;\n</code></pre> queue.ts<pre><code>/* Initialize queue */\n// TypeScript does not have a built-in queue, can use Array as a queue\nconst queue: number[] = [];\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access front element */\nconst peek = queue[0];\n\n/* Dequeue element */\n// The underlying structure is an array, so shift() has O(n) time complexity\nconst pop = queue.shift();\n\n/* Get queue length */\nconst size = queue.length;\n\n/* Check if queue is empty */\nconst empty = queue.length === 0;\n</code></pre> queue.dart<pre><code>/* Initialize queue */\n// In Dart, the Queue class is a deque and can also be used as a queue\nQueue&lt;int&gt; queue = Queue();\n\n/* Enqueue elements */\nqueue.add(1);\nqueue.add(3);\nqueue.add(2);\nqueue.add(5);\nqueue.add(4);\n\n/* Access front element */\nint peek = queue.first;\n\n/* Dequeue element */\nint pop = queue.removeFirst();\n\n/* Get queue length */\nint size = queue.length;\n\n/* Check if queue is empty */\nbool isEmpty = queue.isEmpty;\n</code></pre> queue.rs<pre><code>/* Initialize deque */\n// In Rust, use deque as a regular queue\nlet mut deque: VecDeque&lt;u32&gt; = VecDeque::new();\n\n/* Enqueue elements */\ndeque.push_back(1);\ndeque.push_back(3);\ndeque.push_back(2);\ndeque.push_back(5);\ndeque.push_back(4);\n\n/* Access front element */\nif let Some(front) = deque.front() {\n}\n\n/* Dequeue element */\nif let Some(pop) = deque.pop_front() {\n}\n\n/* Get queue length */\nlet size = deque.len();\n\n/* Check if queue is empty */\nlet is_empty = deque.is_empty();\n</code></pre> queue.c<pre><code>// C does not provide a built-in queue\n</code></pre> queue.kt<pre><code>/* Initialize queue */\nval queue = LinkedList&lt;Int&gt;()\n\n/* Enqueue elements */\nqueue.offer(1)\nqueue.offer(3)\nqueue.offer(2)\nqueue.offer(5)\nqueue.offer(4)\n\n/* Access front element */\nval peek = queue.peek()\n\n/* Dequeue element */\nval pop = queue.poll()\n\n/* Get queue length */\nval size = queue.size\n\n/* Check if queue is empty */\nval isEmpty = queue.isEmpty()\n</code></pre> queue.rb<pre><code># Initialize queue\n# Ruby's built-in queue (Thread::Queue) does not have peek and traversal methods, can use Array as a queue\nqueue = []\n\n# Enqueue elements\nqueue.push(1)\nqueue.push(3)\nqueue.push(2)\nqueue.push(5)\nqueue.push(4)\n\n# Access front element\npeek = queue.first\n\n# Dequeue element\n# Please note that since it's an array, Array#shift has O(n) time complexity\npop = queue.shift\n\n# Get queue length\nsize = queue.length\n\n# Check if queue is empty\nis_empty = queue.empty?\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/queue/#522-queue-implementation","title":"5.2.2 \u00a0 Queue Implementation","text":"<p>To implement a queue, we need a data structure that allows adding elements at one end and removing elements at the other end. Both linked lists and arrays meet this requirement.</p>"},{"location":"chapter_stack_and_queue/queue/#1-linked-list-implementation","title":"1. \u00a0 Linked List Implementation","text":"<p>As shown in Figure 5-5, we can treat the \"head node\" and \"tail node\" of a linked list as the \"front\" and \"rear\" of the queue, respectively, with the rule that nodes can only be added at the rear and removed from the front.</p> LinkedListQueuepush()pop() <p></p> <p></p> <p></p> <p> Figure 5-5 \u00a0 Enqueue and dequeue operations in linked list implementation of queue </p> <p>Below is the code for implementing a queue using a linked list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linkedlist_queue.py<pre><code>class LinkedListQueue:\n    \"\"\"Queue based on linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self._front: ListNode | None = None  # Head node front\n        self._rear: ListNode | None = None  # Tail node rear\n        self._size: int = 0\n\n    def size(self) -&gt; int:\n        \"\"\"Get the length of the queue\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the queue is empty\"\"\"\n        return self._size == 0\n\n    def push(self, num: int):\n        \"\"\"Enqueue\"\"\"\n        # Add num after the tail node\n        node = ListNode(num)\n        # If the queue is empty, make both front and rear point to the node\n        if self._front is None:\n            self._front = node\n            self._rear = node\n        # If the queue is not empty, add the node after the tail node\n        else:\n            self._rear.next = node\n            self._rear = node\n        self._size += 1\n\n    def pop(self) -&gt; int:\n        \"\"\"Dequeue\"\"\"\n        num = self.peek()\n        # Delete head node\n        self._front = self._front.next\n        self._size -= 1\n        return num\n\n    def peek(self) -&gt; int:\n        \"\"\"Access front of the queue element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self._front.val\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"Convert to list for printing\"\"\"\n        queue = []\n        temp = self._front\n        while temp:\n            queue.append(temp.val)\n            temp = temp.next\n        return queue\n</code></pre> linkedlist_queue.cpp<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue {\n  private:\n    ListNode *front, *rear; // Head node front, tail node rear\n    int queSize;\n\n  public:\n    LinkedListQueue() {\n        front = nullptr;\n        rear = nullptr;\n        queSize = 0;\n    }\n\n    ~LinkedListQueue() {\n        // Traverse linked list to delete nodes and free memory\n        freeMemoryLinkedList(front);\n    }\n\n    /* Get the length of the queue */\n    int size() {\n        return queSize;\n    }\n\n    /* Check if the queue is empty */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* Enqueue */\n    void push(int num) {\n        // Add num after the tail node\n        ListNode *node = new ListNode(num);\n        // If the queue is empty, make both front and rear point to the node\n        if (front == nullptr) {\n            front = node;\n            rear = node;\n        }\n        // If the queue is not empty, add the node after the tail node\n        else {\n            rear-&gt;next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* Dequeue */\n    int pop() {\n        int num = peek();\n        // Delete head node\n        ListNode *tmp = front;\n        front = front-&gt;next;\n        // Free memory\n        delete tmp;\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    int peek() {\n        if (size() == 0)\n            throw out_of_range(\"Queue is empty\");\n        return front-&gt;val;\n    }\n\n    /* Convert linked list to Vector and return */\n    vector&lt;int&gt; toVector() {\n        ListNode *node = front;\n        vector&lt;int&gt; res(size());\n        for (int i = 0; i &lt; res.size(); i++) {\n            res[i] = node-&gt;val;\n            node = node-&gt;next;\n        }\n        return res;\n    }\n};\n</code></pre> linkedlist_queue.java<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue {\n    private ListNode front, rear; // Head node front, tail node rear\n    private int queSize = 0;\n\n    public LinkedListQueue() {\n        front = null;\n        rear = null;\n    }\n\n    /* Get the length of the queue */\n    public int size() {\n        return queSize;\n    }\n\n    /* Check if the queue is empty */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* Enqueue */\n    public void push(int num) {\n        // Add num after the tail node\n        ListNode node = new ListNode(num);\n        // If the queue is empty, make both front and rear point to the node\n        if (front == null) {\n            front = node;\n            rear = node;\n        // If the queue is not empty, add the node after the tail node\n        } else {\n            rear.next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* Dequeue */\n    public int pop() {\n        int num = peek();\n        // Delete head node\n        front = front.next;\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return front.val;\n    }\n\n    /* Convert linked list to Array and return */\n    public int[] toArray() {\n        ListNode node = front;\n        int[] res = new int[size()];\n        for (int i = 0; i &lt; res.length; i++) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.cs<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue {\n    ListNode? front, rear;  // Head node front, tail node rear\n    int queSize = 0;\n\n    public LinkedListQueue() {\n        front = null;\n        rear = null;\n    }\n\n    /* Get the length of the queue */\n    public int Size() {\n        return queSize;\n    }\n\n    /* Check if the queue is empty */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* Enqueue */\n    public void Push(int num) {\n        // Add num after the tail node\n        ListNode node = new(num);\n        // If the queue is empty, make both front and rear point to the node\n        if (front == null) {\n            front = node;\n            rear = node;\n            // If the queue is not empty, add the node after the tail node\n        } else if (rear != null) {\n            rear.next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* Dequeue */\n    public int Pop() {\n        int num = Peek();\n        // Delete head node\n        front = front?.next;\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return front!.val;\n    }\n\n    /* Convert linked list to Array and return */\n    public int[] ToArray() {\n        if (front == null)\n            return [];\n\n        ListNode? node = front;\n        int[] res = new int[Size()];\n        for (int i = 0; i &lt; res.Length; i++) {\n            res[i] = node!.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.go<pre><code>/* Queue based on linked list implementation */\ntype linkedListQueue struct {\n    // Use built-in package list to implement queue\n    data *list.List\n}\n\n/* Access front of the queue element */\nfunc newLinkedListQueue() *linkedListQueue {\n    return &amp;linkedListQueue{\n        data: list.New(),\n    }\n}\n\n/* Enqueue */\nfunc (s *linkedListQueue) push(value any) {\n    s.data.PushBack(value)\n}\n\n/* Dequeue */\nfunc (s *linkedListQueue) pop() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* Return list for printing */\nfunc (s *linkedListQueue) peek() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    return e.Value\n}\n\n/* Get the length of the queue */\nfunc (s *linkedListQueue) size() int {\n    return s.data.Len()\n}\n\n/* Check if the queue is empty */\nfunc (s *linkedListQueue) isEmpty() bool {\n    return s.data.Len() == 0\n}\n\n/* Get List for printing */\nfunc (s *linkedListQueue) toList() *list.List {\n    return s.data\n}\n</code></pre> linkedlist_queue.swift<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue {\n    private var front: ListNode? // Head node\n    private var rear: ListNode? // Tail node\n    private var _size: Int\n\n    init() {\n        _size = 0\n    }\n\n    /* Get the length of the queue */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* Check if the queue is empty */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* Enqueue */\n    func push(num: Int) {\n        // Add num after the tail node\n        let node = ListNode(x: num)\n        // If the queue is empty, make both front and rear point to the node\n        if front == nil {\n            front = node\n            rear = node\n        }\n        // If the queue is not empty, add the node after the tail node\n        else {\n            rear?.next = node\n            rear = node\n        }\n        _size += 1\n    }\n\n    /* Dequeue */\n    @discardableResult\n    func pop() -&gt; Int {\n        let num = peek()\n        // Delete head node\n        front = front?.next\n        _size -= 1\n        return num\n    }\n\n    /* Return list for printing */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Queue is empty\")\n        }\n        return front!.val\n    }\n\n    /* Convert linked list to Array and return */\n    func toArray() -&gt; [Int] {\n        var node = front\n        var res = Array(repeating: 0, count: size())\n        for i in res.indices {\n            res[i] = node!.val\n            node = node?.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_queue.js<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue {\n    #front; // Front node #front\n    #rear; // Rear node #rear\n    #queSize = 0;\n\n    constructor() {\n        this.#front = null;\n        this.#rear = null;\n    }\n\n    /* Get the length of the queue */\n    get size() {\n        return this.#queSize;\n    }\n\n    /* Check if the queue is empty */\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    /* Enqueue */\n    push(num) {\n        // Add num after the tail node\n        const node = new ListNode(num);\n        // If the queue is empty, make both front and rear point to the node\n        if (!this.#front) {\n            this.#front = node;\n            this.#rear = node;\n            // If the queue is not empty, add the node after the tail node\n        } else {\n            this.#rear.next = node;\n            this.#rear = node;\n        }\n        this.#queSize++;\n    }\n\n    /* Dequeue */\n    pop() {\n        const num = this.peek();\n        // Delete head node\n        this.#front = this.#front.next;\n        this.#queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peek() {\n        if (this.size === 0) throw new Error('Queue is empty');\n        return this.#front.val;\n    }\n\n    /* Convert linked list to Array and return */\n    toArray() {\n        let node = this.#front;\n        const res = new Array(this.size);\n        for (let i = 0; i &lt; res.length; i++) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.ts<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue {\n    private front: ListNode | null; // Head node front\n    private rear: ListNode | null; // Tail node rear\n    private queSize: number = 0;\n\n    constructor() {\n        this.front = null;\n        this.rear = null;\n    }\n\n    /* Get the length of the queue */\n    get size(): number {\n        return this.queSize;\n    }\n\n    /* Check if the queue is empty */\n    isEmpty(): boolean {\n        return this.size === 0;\n    }\n\n    /* Enqueue */\n    push(num: number): void {\n        // Add num after the tail node\n        const node = new ListNode(num);\n        // If the queue is empty, make both front and rear point to the node\n        if (!this.front) {\n            this.front = node;\n            this.rear = node;\n            // If the queue is not empty, add the node after the tail node\n        } else {\n            this.rear!.next = node;\n            this.rear = node;\n        }\n        this.queSize++;\n    }\n\n    /* Dequeue */\n    pop(): number {\n        const num = this.peek();\n        if (!this.front) throw new Error('Queue is empty');\n        // Delete head node\n        this.front = this.front.next;\n        this.queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peek(): number {\n        if (this.size === 0) throw new Error('Queue is empty');\n        return this.front!.val;\n    }\n\n    /* Convert linked list to Array and return */\n    toArray(): number[] {\n        let node = this.front;\n        const res = new Array&lt;number&gt;(this.size);\n        for (let i = 0; i &lt; res.length; i++) {\n            res[i] = node!.val;\n            node = node!.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.dart<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue {\n  ListNode? _front; // Head node _front\n  ListNode? _rear; // Tail node _rear\n  int _queSize = 0; // Queue length\n\n  LinkedListQueue() {\n    _front = null;\n    _rear = null;\n  }\n\n  /* Get the length of the queue */\n  int size() {\n    return _queSize;\n  }\n\n  /* Check if the queue is empty */\n  bool isEmpty() {\n    return _queSize == 0;\n  }\n\n  /* Enqueue */\n  void push(int _num) {\n    // Add _num after tail node\n    final node = ListNode(_num);\n    // If the queue is empty, make both front and rear point to the node\n    if (_front == null) {\n      _front = node;\n      _rear = node;\n    } else {\n      // If the queue is not empty, add the node after the tail node\n      _rear!.next = node;\n      _rear = node;\n    }\n    _queSize++;\n  }\n\n  /* Dequeue */\n  int pop() {\n    final int _num = peek();\n    // Delete head node\n    _front = _front!.next;\n    _queSize--;\n    return _num;\n  }\n\n  /* Return list for printing */\n  int peek() {\n    if (_queSize == 0) {\n      throw Exception('Queue is empty');\n    }\n    return _front!.val;\n  }\n\n  /* Convert linked list to Array and return */\n  List&lt;int&gt; toArray() {\n    ListNode? node = _front;\n    final List&lt;int&gt; queue = [];\n    while (node != null) {\n      queue.add(node.val);\n      node = node.next;\n    }\n    return queue;\n  }\n}\n</code></pre> linkedlist_queue.rs<pre><code>/* Queue based on linked list implementation */\n#[allow(dead_code)]\npub struct LinkedListQueue&lt;T&gt; {\n    front: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // Head node front\n    rear: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;,  // Tail node rear\n    que_size: usize,                         // Queue length\n}\n\nimpl&lt;T: Copy&gt; LinkedListQueue&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            front: None,\n            rear: None,\n            que_size: 0,\n        }\n    }\n\n    /* Get the length of the queue */\n    pub fn size(&amp;self) -&gt; usize {\n        return self.que_size;\n    }\n\n    /* Check if the queue is empty */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        return self.que_size == 0;\n    }\n\n    /* Enqueue */\n    pub fn push(&amp;mut self, num: T) {\n        // Add num after the tail node\n        let new_rear = ListNode::new(num);\n        match self.rear.take() {\n            // If the queue is not empty, add the node after the tail node\n            Some(old_rear) =&gt; {\n                old_rear.borrow_mut().next = Some(new_rear.clone());\n                self.rear = Some(new_rear);\n            }\n            // If the queue is empty, make both front and rear point to the node\n            None =&gt; {\n                self.front = Some(new_rear.clone());\n                self.rear = Some(new_rear);\n            }\n        }\n        self.que_size += 1;\n    }\n\n    /* Dequeue */\n    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {\n        self.front.take().map(|old_front| {\n            match old_front.borrow_mut().next.take() {\n                Some(new_front) =&gt; {\n                    self.front = Some(new_front);\n                }\n                None =&gt; {\n                    self.rear.take();\n                }\n            }\n            self.que_size -= 1;\n            old_front.borrow().val\n        })\n    }\n\n    /* Return list for printing */\n    pub fn peek(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.front.as_ref()\n    }\n\n    /* Convert linked list to Array and return */\n    pub fn to_array(&amp;self, head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;) -&gt; Vec&lt;T&gt; {\n        let mut res: Vec&lt;T&gt; = Vec::new();\n\n        fn recur&lt;T: Copy&gt;(cur: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, res: &amp;mut Vec&lt;T&gt;) {\n            if let Some(cur) = cur {\n                res.push(cur.borrow().val);\n                recur(cur.borrow().next.as_ref(), res);\n            }\n        }\n\n        recur(head, &amp;mut res);\n\n        res\n    }\n}\n</code></pre> linkedlist_queue.c<pre><code>/* Queue based on linked list implementation */\ntypedef struct {\n    ListNode *front, *rear;\n    int queSize;\n} LinkedListQueue;\n\n/* Constructor */\nLinkedListQueue *newLinkedListQueue() {\n    LinkedListQueue *queue = (LinkedListQueue *)malloc(sizeof(LinkedListQueue));\n    queue-&gt;front = NULL;\n    queue-&gt;rear = NULL;\n    queue-&gt;queSize = 0;\n    return queue;\n}\n\n/* Destructor */\nvoid delLinkedListQueue(LinkedListQueue *queue) {\n    // Free all nodes\n    while (queue-&gt;front != NULL) {\n        ListNode *tmp = queue-&gt;front;\n        queue-&gt;front = queue-&gt;front-&gt;next;\n        free(tmp);\n    }\n    // Free queue structure\n    free(queue);\n}\n\n/* Get the length of the queue */\nint size(LinkedListQueue *queue) {\n    return queue-&gt;queSize;\n}\n\n/* Check if the queue is empty */\nbool empty(LinkedListQueue *queue) {\n    return (size(queue) == 0);\n}\n\n/* Enqueue */\nvoid push(LinkedListQueue *queue, int num) {\n    // Add node at tail\n    ListNode *node = newListNode(num);\n    // If the queue is empty, make both front and rear point to the node\n    if (queue-&gt;front == NULL) {\n        queue-&gt;front = node;\n        queue-&gt;rear = node;\n    }\n    // If the queue is not empty, add the node after the tail node\n    else {\n        queue-&gt;rear-&gt;next = node;\n        queue-&gt;rear = node;\n    }\n    queue-&gt;queSize++;\n}\n\n/* Return list for printing */\nint peek(LinkedListQueue *queue) {\n    assert(size(queue) &amp;&amp; queue-&gt;front);\n    return queue-&gt;front-&gt;val;\n}\n\n/* Dequeue */\nint pop(LinkedListQueue *queue) {\n    int num = peek(queue);\n    ListNode *tmp = queue-&gt;front;\n    queue-&gt;front = queue-&gt;front-&gt;next;\n    free(tmp);\n    queue-&gt;queSize--;\n    return num;\n}\n\n/* Print queue */\nvoid printLinkedListQueue(LinkedListQueue *queue) {\n    int *arr = malloc(sizeof(int) * queue-&gt;queSize);\n    // Copy data from list to array\n    int i;\n    ListNode *node;\n    for (i = 0, node = queue-&gt;front; i &lt; queue-&gt;queSize; i++) {\n        arr[i] = node-&gt;val;\n        node = node-&gt;next;\n    }\n    printArray(arr, queue-&gt;queSize);\n    free(arr);\n}\n</code></pre> linkedlist_queue.kt<pre><code>/* Queue based on linked list implementation */\nclass LinkedListQueue(\n    // Head node front, tail node rear\n    private var front: ListNode? = null,\n    private var rear: ListNode? = null,\n    private var queSize: Int = 0\n) {\n\n    /* Get the length of the queue */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* Check if the queue is empty */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* Enqueue */\n    fun push(num: Int) {\n        // Add num after the tail node\n        val node = ListNode(num)\n        // If the queue is empty, make both front and rear point to the node\n        if (front == null) {\n            front = node\n            rear = node\n            // If the queue is not empty, add the node after the tail node\n        } else {\n            rear?.next = node\n            rear = node\n        }\n        queSize++\n    }\n\n    /* Dequeue */\n    fun pop(): Int {\n        val num = peek()\n        // Delete head node\n        front = front?.next\n        queSize--\n        return num\n    }\n\n    /* Return list for printing */\n    fun peek(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return front!!._val\n    }\n\n    /* Convert linked list to Array and return */\n    fun toArray(): IntArray {\n        var node = front\n        val res = IntArray(size())\n        for (i in res.indices) {\n            res[i] = node!!._val\n            node = node.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_queue.rb<pre><code>### Queue based on linked list ###\nclass LinkedListQueue\n  ### Get queue length ###\n  attr_reader :size\n\n  ### Constructor ###\n  def initialize\n    @front = nil  # Head node front\n    @rear = nil   # Tail node rear\n    @size = 0\n  end\n\n  ### Check if queue is empty ###\n  def is_empty?\n    @front.nil?\n  end\n\n  ### Enqueue ###\n  def push(num)\n    # Add num after the tail node\n    node = ListNode.new(num)\n\n    # If queue is empty, set both front and rear to this node\n    if @front.nil?\n      @front = node\n      @rear = node\n    # If queue is not empty, add this node after rear\n    else\n      @rear.next = node\n      @rear = node\n    end\n\n    @size += 1\n  end\n\n  ### Dequeue ###\n  def pop\n    num = peek\n    # Delete head node\n    @front = @front.next\n    @size -= 1\n    num\n  end\n\n  ### Access front element ###\n  def peek\n    raise IndexError, 'Queue is empty' if is_empty?\n\n    @front.val\n  end\n\n  ### Convert linked list to Array and return ###\n  def to_array\n    queue = []\n    temp = @front\n    while temp\n      queue &lt;&lt; temp.val\n      temp = temp.next\n    end\n    queue\n  end\nend\n</code></pre>"},{"location":"chapter_stack_and_queue/queue/#2-array-implementation","title":"2. \u00a0 Array Implementation","text":"<p>Deleting the first element in an array has a time complexity of \\(O(n)\\), which would make the dequeue operation inefficient. However, we can use the following clever method to avoid this problem.</p> <p>We can use a variable <code>front</code> to point to the index of the front element and maintain a variable <code>size</code> to record the queue length. We define <code>rear = front + size</code>, which calculates the position right after the rear element.</p> <p>Based on this design, the valid interval containing elements in the array is <code>[front, rear - 1]</code>. The implementation methods for various operations are shown in Figure 5-6:</p> <ul> <li>Enqueue operation: Assign the input element to the <code>rear</code> index and increase <code>size</code> by 1.</li> <li>Dequeue operation: Simply increase <code>front</code> by 1 and decrease <code>size</code> by 1.</li> </ul> <p>As you can see, both enqueue and dequeue operations require only one operation, with a time complexity of \\(O(1)\\).</p> ArrayQueuepush()pop() <p></p> <p></p> <p></p> <p> Figure 5-6 \u00a0 Enqueue and dequeue operations in array implementation of queue </p> <p>You may notice a problem: as we continuously enqueue and dequeue, both <code>front</code> and <code>rear</code> move to the right. When they reach the end of the array, they cannot continue moving. To solve this problem, we can treat the array as a \"circular array\" with head and tail connected.</p> <p>For a circular array, we need to let <code>front</code> or <code>rear</code> wrap around to the beginning of the array when they cross the end. This periodic pattern can be implemented using the \"modulo operation,\" as shown in the code below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array_queue.py<pre><code>class ArrayQueue:\n    \"\"\"Queue based on circular array implementation\"\"\"\n\n    def __init__(self, size: int):\n        \"\"\"Constructor\"\"\"\n        self._nums: list[int] = [0] * size  # Array for storing queue elements\n        self._front: int = 0  # Front pointer, points to the front of the queue element\n        self._size: int = 0  # Queue length\n\n    def capacity(self) -&gt; int:\n        \"\"\"Get the capacity of the queue\"\"\"\n        return len(self._nums)\n\n    def size(self) -&gt; int:\n        \"\"\"Get the length of the queue\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the queue is empty\"\"\"\n        return self._size == 0\n\n    def push(self, num: int):\n        \"\"\"Enqueue\"\"\"\n        if self._size == self.capacity():\n            raise IndexError(\"Queue is full\")\n        # Calculate rear pointer, points to rear index + 1\n        # Use modulo operation to wrap rear around to the head after passing the tail of the array\n        rear: int = (self._front + self._size) % self.capacity()\n        # Add num to the rear of the queue\n        self._nums[rear] = num\n        self._size += 1\n\n    def pop(self) -&gt; int:\n        \"\"\"Dequeue\"\"\"\n        num: int = self.peek()\n        # Front pointer moves one position backward, if it passes the tail, return to the head of the array\n        self._front = (self._front + 1) % self.capacity()\n        self._size -= 1\n        return num\n\n    def peek(self) -&gt; int:\n        \"\"\"Access front of the queue element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self._nums[self._front]\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"Return list for printing\"\"\"\n        res = [0] * self.size()\n        j: int = self._front\n        for i in range(self.size()):\n            res[i] = self._nums[(j % self.capacity())]\n            j += 1\n        return res\n</code></pre> array_queue.cpp<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue {\n  private:\n    int *nums;       // Array for storing queue elements\n    int front;       // Front pointer, points to the front of the queue element\n    int queSize;     // Queue length\n    int queCapacity; // Queue capacity\n\n  public:\n    ArrayQueue(int capacity) {\n        // Initialize array\n        nums = new int[capacity];\n        queCapacity = capacity;\n        front = queSize = 0;\n    }\n\n    ~ArrayQueue() {\n        delete[] nums;\n    }\n\n    /* Get the capacity of the queue */\n    int capacity() {\n        return queCapacity;\n    }\n\n    /* Get the length of the queue */\n    int size() {\n        return queSize;\n    }\n\n    /* Check if the queue is empty */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* Enqueue */\n    void push(int num) {\n        if (queSize == queCapacity) {\n            cout &lt;&lt; \"Queue is full\" &lt;&lt; endl;\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        int rear = (front + queSize) % queCapacity;\n        // Front pointer moves one position backward\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* Dequeue */\n    int pop() {\n        int num = peek();\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        front = (front + 1) % queCapacity;\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    int peek() {\n        if (isEmpty())\n            throw out_of_range(\"Queue is empty\");\n        return nums[front];\n    }\n\n    /* Convert array to Vector and return */\n    vector&lt;int&gt; toVector() {\n        // Elements enqueue\n        vector&lt;int&gt; arr(queSize);\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            arr[i] = nums[j % queCapacity];\n        }\n        return arr;\n    }\n};\n</code></pre> array_queue.java<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue {\n    private int[] nums; // Array for storing queue elements\n    private int front; // Front pointer, points to the front of the queue element\n    private int queSize; // Queue length\n\n    public ArrayQueue(int capacity) {\n        nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* Get the capacity of the queue */\n    public int capacity() {\n        return nums.length;\n    }\n\n    /* Get the length of the queue */\n    public int size() {\n        return queSize;\n    }\n\n    /* Check if the queue is empty */\n    public boolean isEmpty() {\n        return queSize == 0;\n    }\n\n    /* Enqueue */\n    public void push(int num) {\n        if (queSize == capacity()) {\n            System.out.println(\"Queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        int rear = (front + queSize) % capacity();\n        // Front pointer moves one position backward\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* Dequeue */\n    public int pop() {\n        int num = peek();\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        front = (front + 1) % capacity();\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return nums[front];\n    }\n\n    /* Return array */\n    public int[] toArray() {\n        // Elements enqueue\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[j % capacity()];\n        }\n        return res;\n    }\n}\n</code></pre> array_queue.cs<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue {\n    int[] nums;  // Array for storing queue elements\n    int front;   // Front pointer, points to the front of the queue element\n    int queSize; // Queue length\n\n    public ArrayQueue(int capacity) {\n        nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* Get the capacity of the queue */\n    int Capacity() {\n        return nums.Length;\n    }\n\n    /* Get the length of the queue */\n    public int Size() {\n        return queSize;\n    }\n\n    /* Check if the queue is empty */\n    public bool IsEmpty() {\n        return queSize == 0;\n    }\n\n    /* Enqueue */\n    public void Push(int num) {\n        if (queSize == Capacity()) {\n            Console.WriteLine(\"Queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        int rear = (front + queSize) % Capacity();\n        // Front pointer moves one position backward\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* Dequeue */\n    public int Pop() {\n        int num = Peek();\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        front = (front + 1) % Capacity();\n        queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return nums[front];\n    }\n\n    /* Return array */\n    public int[] ToArray() {\n        // Elements enqueue\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[j % this.Capacity()];\n        }\n        return res;\n    }\n}\n</code></pre> array_queue.go<pre><code>/* Queue based on circular array implementation */\ntype arrayQueue struct {\n    nums        []int // Array for storing queue elements\n    front       int   // Front pointer, points to the front of the queue element\n    queSize     int   // Queue length\n    queCapacity int   // Queue capacity (maximum number of elements)\n}\n\n/* Access front of the queue element */\nfunc newArrayQueue(queCapacity int) *arrayQueue {\n    return &amp;arrayQueue{\n        nums:        make([]int, queCapacity),\n        queCapacity: queCapacity,\n        front:       0,\n        queSize:     0,\n    }\n}\n\n/* Get the length of the queue */\nfunc (q *arrayQueue) size() int {\n    return q.queSize\n}\n\n/* Check if the queue is empty */\nfunc (q *arrayQueue) isEmpty() bool {\n    return q.queSize == 0\n}\n\n/* Enqueue */\nfunc (q *arrayQueue) push(num int) {\n    // When rear == queCapacity, queue is full\n    if q.queSize == q.queCapacity {\n        return\n    }\n    // Use modulo operation to wrap rear around to the head after passing the tail of the array\n    // Add num to the rear of the queue\n    rear := (q.front + q.queSize) % q.queCapacity\n    // Front pointer moves one position backward\n    q.nums[rear] = num\n    q.queSize++\n}\n\n/* Dequeue */\nfunc (q *arrayQueue) pop() any {\n    num := q.peek()\n    if num == nil {\n        return nil\n    }\n\n    // Move front pointer backward by one position, if it passes the tail, return to array head\n    q.front = (q.front + 1) % q.queCapacity\n    q.queSize--\n    return num\n}\n\n/* Return list for printing */\nfunc (q *arrayQueue) peek() any {\n    if q.isEmpty() {\n        return nil\n    }\n    return q.nums[q.front]\n}\n\n/* Get Slice for printing */\nfunc (q *arrayQueue) toSlice() []int {\n    rear := (q.front + q.queSize)\n    if rear &gt;= q.queCapacity {\n        rear %= q.queCapacity\n        return append(q.nums[q.front:], q.nums[:rear]...)\n    }\n    return q.nums[q.front:rear]\n}\n</code></pre> array_queue.swift<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue {\n    private var nums: [Int] // Array for storing queue elements\n    private var front: Int // Front pointer, points to the front of the queue element\n    private var _size: Int // Queue length\n\n    init(capacity: Int) {\n        // Initialize array\n        nums = Array(repeating: 0, count: capacity)\n        front = 0\n        _size = 0\n    }\n\n    /* Get the capacity of the queue */\n    func capacity() -&gt; Int {\n        nums.count\n    }\n\n    /* Get the length of the queue */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* Check if the queue is empty */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* Enqueue */\n    func push(num: Int) {\n        if size() == capacity() {\n            print(\"Queue is full\")\n            return\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        let rear = (front + size()) % capacity()\n        // Front pointer moves one position backward\n        nums[rear] = num\n        _size += 1\n    }\n\n    /* Dequeue */\n    @discardableResult\n    func pop() -&gt; Int {\n        let num = peek()\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        front = (front + 1) % capacity()\n        _size -= 1\n        return num\n    }\n\n    /* Return list for printing */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Queue is empty\")\n        }\n        return nums[front]\n    }\n\n    /* Return array */\n    func toArray() -&gt; [Int] {\n        // Elements enqueue\n        (front ..&lt; front + size()).map { nums[$0 % capacity()] }\n    }\n}\n</code></pre> array_queue.js<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue {\n    #nums; // Array for storing queue elements\n    #front = 0; // Front pointer, points to the front of the queue element\n    #queSize = 0; // Queue length\n\n    constructor(capacity) {\n        this.#nums = new Array(capacity);\n    }\n\n    /* Get the capacity of the queue */\n    get capacity() {\n        return this.#nums.length;\n    }\n\n    /* Get the length of the queue */\n    get size() {\n        return this.#queSize;\n    }\n\n    /* Check if the queue is empty */\n    isEmpty() {\n        return this.#queSize === 0;\n    }\n\n    /* Enqueue */\n    push(num) {\n        if (this.size === this.capacity) {\n            console.log('Queue is full');\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        const rear = (this.#front + this.size) % this.capacity;\n        // Front pointer moves one position backward\n        this.#nums[rear] = num;\n        this.#queSize++;\n    }\n\n    /* Dequeue */\n    pop() {\n        const num = this.peek();\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        this.#front = (this.#front + 1) % this.capacity;\n        this.#queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peek() {\n        if (this.isEmpty()) throw new Error('Queue is empty');\n        return this.#nums[this.#front];\n    }\n\n    /* Return Array */\n    toArray() {\n        // Elements enqueue\n        const arr = new Array(this.size);\n        for (let i = 0, j = this.#front; i &lt; this.size; i++, j++) {\n            arr[i] = this.#nums[j % this.capacity];\n        }\n        return arr;\n    }\n}\n</code></pre> array_queue.ts<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue {\n    private nums: number[]; // Array for storing queue elements\n    private front: number; // Front pointer, points to the front of the queue element\n    private queSize: number; // Queue length\n\n    constructor(capacity: number) {\n        this.nums = new Array(capacity);\n        this.front = this.queSize = 0;\n    }\n\n    /* Get the capacity of the queue */\n    get capacity(): number {\n        return this.nums.length;\n    }\n\n    /* Get the length of the queue */\n    get size(): number {\n        return this.queSize;\n    }\n\n    /* Check if the queue is empty */\n    isEmpty(): boolean {\n        return this.queSize === 0;\n    }\n\n    /* Enqueue */\n    push(num: number): void {\n        if (this.size === this.capacity) {\n            console.log('Queue is full');\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        const rear = (this.front + this.queSize) % this.capacity;\n        // Front pointer moves one position backward\n        this.nums[rear] = num;\n        this.queSize++;\n    }\n\n    /* Dequeue */\n    pop(): number {\n        const num = this.peek();\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        this.front = (this.front + 1) % this.capacity;\n        this.queSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peek(): number {\n        if (this.isEmpty()) throw new Error('Queue is empty');\n        return this.nums[this.front];\n    }\n\n    /* Return Array */\n    toArray(): number[] {\n        // Elements enqueue\n        const arr = new Array(this.size);\n        for (let i = 0, j = this.front; i &lt; this.size; i++, j++) {\n            arr[i] = this.nums[j % this.capacity];\n        }\n        return arr;\n    }\n}\n</code></pre> array_queue.dart<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue {\n  late List&lt;int&gt; _nums; // Array for storing queue elements\n  late int _front; // Front pointer, points to the front of the queue element\n  late int _queSize; // Queue length\n\n  ArrayQueue(int capacity) {\n    _nums = List.filled(capacity, 0);\n    _front = _queSize = 0;\n  }\n\n  /* Get the capacity of the queue */\n  int capaCity() {\n    return _nums.length;\n  }\n\n  /* Get the length of the queue */\n  int size() {\n    return _queSize;\n  }\n\n  /* Check if the queue is empty */\n  bool isEmpty() {\n    return _queSize == 0;\n  }\n\n  /* Enqueue */\n  void push(int _num) {\n    if (_queSize == capaCity()) {\n      throw Exception(\"Queue is full\");\n    }\n    // Use modulo operation to wrap rear around to the head after passing the tail of the array\n    // Add num to the rear of the queue\n    int rear = (_front + _queSize) % capaCity();\n    // Add _num to queue rear\n    _nums[rear] = _num;\n    _queSize++;\n  }\n\n  /* Dequeue */\n  int pop() {\n    int _num = peek();\n    // Move front pointer backward by one position, if it passes the tail, return to array head\n    _front = (_front + 1) % capaCity();\n    _queSize--;\n    return _num;\n  }\n\n  /* Return list for printing */\n  int peek() {\n    if (isEmpty()) {\n      throw Exception(\"Queue is empty\");\n    }\n    return _nums[_front];\n  }\n\n  /* Return Array */\n  List&lt;int&gt; toArray() {\n    // Elements enqueue\n    final List&lt;int&gt; res = List.filled(_queSize, 0);\n    for (int i = 0, j = _front; i &lt; _queSize; i++, j++) {\n      res[i] = _nums[j % capaCity()];\n    }\n    return res;\n  }\n}\n</code></pre> array_queue.rs<pre><code>/* Queue based on circular array implementation */\nstruct ArrayQueue&lt;T&gt; {\n    nums: Vec&lt;T&gt;,      // Array for storing queue elements\n    front: i32,        // Front pointer, points to the front of the queue element\n    que_size: i32,     // Queue length\n    que_capacity: i32, // Queue capacity\n}\n\nimpl&lt;T: Copy + Default&gt; ArrayQueue&lt;T&gt; {\n    /* Constructor */\n    fn new(capacity: i32) -&gt; ArrayQueue&lt;T&gt; {\n        ArrayQueue {\n            nums: vec![T::default(); capacity as usize],\n            front: 0,\n            que_size: 0,\n            que_capacity: capacity,\n        }\n    }\n\n    /* Get the capacity of the queue */\n    fn capacity(&amp;self) -&gt; i32 {\n        self.que_capacity\n    }\n\n    /* Get the length of the queue */\n    fn size(&amp;self) -&gt; i32 {\n        self.que_size\n    }\n\n    /* Check if the queue is empty */\n    fn is_empty(&amp;self) -&gt; bool {\n        self.que_size == 0\n    }\n\n    /* Enqueue */\n    fn push(&amp;mut self, num: T) {\n        if self.que_size == self.capacity() {\n            println!(\"Queue is full\");\n            return;\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        let rear = (self.front + self.que_size) % self.que_capacity;\n        // Front pointer moves one position backward\n        self.nums[rear as usize] = num;\n        self.que_size += 1;\n    }\n\n    /* Dequeue */\n    fn pop(&amp;mut self) -&gt; T {\n        let num = self.peek();\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        self.front = (self.front + 1) % self.que_capacity;\n        self.que_size -= 1;\n        num\n    }\n\n    /* Return list for printing */\n    fn peek(&amp;self) -&gt; T {\n        if self.is_empty() {\n            panic!(\"index out of bounds\");\n        }\n        self.nums[self.front as usize]\n    }\n\n    /* Return array */\n    fn to_vector(&amp;self) -&gt; Vec&lt;T&gt; {\n        let cap = self.que_capacity;\n        let mut j = self.front;\n        let mut arr = vec![T::default(); cap as usize];\n        for i in 0..self.que_size {\n            arr[i as usize] = self.nums[(j % cap) as usize];\n            j += 1;\n        }\n        arr\n    }\n}\n</code></pre> array_queue.c<pre><code>/* Queue based on circular array implementation */\ntypedef struct {\n    int *nums;       // Array for storing queue elements\n    int front;       // Front pointer, points to the front of the queue element\n    int queSize;     // Rear pointer, points to rear + 1\n    int queCapacity; // Queue capacity\n} ArrayQueue;\n\n/* Constructor */\nArrayQueue *newArrayQueue(int capacity) {\n    ArrayQueue *queue = (ArrayQueue *)malloc(sizeof(ArrayQueue));\n    // Initialize array\n    queue-&gt;queCapacity = capacity;\n    queue-&gt;nums = (int *)malloc(sizeof(int) * queue-&gt;queCapacity);\n    queue-&gt;front = queue-&gt;queSize = 0;\n    return queue;\n}\n\n/* Destructor */\nvoid delArrayQueue(ArrayQueue *queue) {\n    free(queue-&gt;nums);\n    free(queue);\n}\n\n/* Get the capacity of the queue */\nint capacity(ArrayQueue *queue) {\n    return queue-&gt;queCapacity;\n}\n\n/* Get the length of the queue */\nint size(ArrayQueue *queue) {\n    return queue-&gt;queSize;\n}\n\n/* Check if the queue is empty */\nbool empty(ArrayQueue *queue) {\n    return queue-&gt;queSize == 0;\n}\n\n/* Return list for printing */\nint peek(ArrayQueue *queue) {\n    assert(size(queue) != 0);\n    return queue-&gt;nums[queue-&gt;front];\n}\n\n/* Enqueue */\nvoid push(ArrayQueue *queue, int num) {\n    if (size(queue) == capacity(queue)) {\n        printf(\"Queue is full\\r\\n\");\n        return;\n    }\n    // Use modulo operation to wrap rear around to the head after passing the tail of the array\n    // Add num to the rear of the queue\n    int rear = (queue-&gt;front + queue-&gt;queSize) % queue-&gt;queCapacity;\n    // Front pointer moves one position backward\n    queue-&gt;nums[rear] = num;\n    queue-&gt;queSize++;\n}\n\n/* Dequeue */\nint pop(ArrayQueue *queue) {\n    int num = peek(queue);\n    // Move front pointer backward by one position, if it passes the tail, return to array head\n    queue-&gt;front = (queue-&gt;front + 1) % queue-&gt;queCapacity;\n    queue-&gt;queSize--;\n    return num;\n}\n\n/* Return array for printing */\nint *toArray(ArrayQueue *queue, int *queSize) {\n    *queSize = queue-&gt;queSize;\n    int *res = (int *)calloc(queue-&gt;queSize, sizeof(int));\n    int j = queue-&gt;front;\n    for (int i = 0; i &lt; queue-&gt;queSize; i++) {\n        res[i] = queue-&gt;nums[j % queue-&gt;queCapacity];\n        j++;\n    }\n    return res;\n}\n</code></pre> array_queue.kt<pre><code>/* Queue based on circular array implementation */\nclass ArrayQueue(capacity: Int) {\n    private val nums: IntArray = IntArray(capacity) // Array for storing queue elements\n    private var front: Int = 0 // Front pointer, points to the front of the queue element\n    private var queSize: Int = 0 // Queue length\n\n    /* Get the capacity of the queue */\n    fun capacity(): Int {\n        return nums.size\n    }\n\n    /* Get the length of the queue */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* Check if the queue is empty */\n    fun isEmpty(): Boolean {\n        return queSize == 0\n    }\n\n    /* Enqueue */\n    fun push(num: Int) {\n        if (queSize == capacity()) {\n            println(\"Queue is full\")\n            return\n        }\n        // Use modulo operation to wrap rear around to the head after passing the tail of the array\n        // Add num to the rear of the queue\n        val rear = (front + queSize) % capacity()\n        // Front pointer moves one position backward\n        nums[rear] = num\n        queSize++\n    }\n\n    /* Dequeue */\n    fun pop(): Int {\n        val num = peek()\n        // Move front pointer backward by one position, if it passes the tail, return to array head\n        front = (front + 1) % capacity()\n        queSize--\n        return num\n    }\n\n    /* Return list for printing */\n    fun peek(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return nums[front]\n    }\n\n    /* Return array */\n    fun toArray(): IntArray {\n        // Elements enqueue\n        val res = IntArray(queSize)\n        var i = 0\n        var j = front\n        while (i &lt; queSize) {\n            res[i] = nums[j % capacity()]\n            i++\n            j++\n        }\n        return res\n    }\n}\n</code></pre> array_queue.rb<pre><code>### Queue based on circular array ###\nclass ArrayQueue\n  ### Get queue length ###\n  attr_reader :size\n\n  ### Constructor ###\n  def initialize(size)\n    @nums = Array.new(size, 0) # Array for storing queue elements\n    @front = 0 # Front pointer, points to the front of the queue element\n    @size = 0 # Queue length\n  end\n\n  ### Get queue capacity ###\n  def capacity\n    @nums.length\n  end\n\n  ### Check if queue is empty ###\n  def is_empty?\n    size.zero?\n  end\n\n  ### Enqueue ###\n  def push(num)\n    raise IndexError, 'Queue is full' if size == capacity\n\n    # Use modulo operation to wrap rear around to the head after passing the tail of the array\n    # Add num to the rear of the queue\n    rear = (@front + size) % capacity\n    # Front pointer moves one position backward\n    @nums[rear] = num\n    @size += 1\n  end\n\n  ### Dequeue ###\n  def pop\n    num = peek\n    # Move front pointer backward by one position, if it passes the tail, return to array head\n    @front = (@front + 1) % capacity\n    @size -= 1\n    num\n  end\n\n  ### Access front element ###\n  def peek\n    raise IndexError, 'Queue is empty' if is_empty?\n\n    @nums[@front]\n  end\n\n  ### Return list for printing ###\n  def to_array\n    res = Array.new(size, 0)\n    j = @front\n\n    for i in 0...size\n      res[i] = @nums[j % capacity]\n      j += 1\n    end\n\n    res\n  end\nend\n</code></pre> <p>The queue implemented above still has limitations: its length is immutable. However, this problem is not difficult to solve. We can replace the array with a dynamic array to introduce an expansion mechanism. Interested readers can try to implement this themselves.</p> <p>The comparison conclusions for the two implementations are consistent with those for stacks and will not be repeated here.</p>"},{"location":"chapter_stack_and_queue/queue/#523-typical-applications-of-queue","title":"5.2.3 \u00a0 Typical Applications of Queue","text":"<ul> <li>Taobao orders. After shoppers place orders, the orders are added to a queue, and the system subsequently processes the orders in the queue according to their sequence. During Double Eleven, massive orders are generated in a short time, and high concurrency becomes a key challenge that engineers need to tackle.</li> <li>Various to-do tasks. Any scenario that needs to implement \"first come, first served\" functionality, such as a printer's task queue or a restaurant's order queue, can effectively maintain the processing order using queues.</li> </ul>"},{"location":"chapter_stack_and_queue/stack/","title":"5.1 \u00a0 Stack","text":"<p>A stack is a linear data structure that follows the Last In First Out (LIFO) logic.</p> <p>We can compare a stack to a pile of plates on a table. If we specify that only one plate can be moved at a time, then to get the bottom plate, we must first remove the plates above it one by one. If we replace the plates with various types of elements (such as integers, characters, objects, etc.), we get the stack data structure.</p> <p>As shown in Figure 5-1, we call the top of the stacked elements the \"top\" and the bottom the \"base.\" The operation of adding an element to the top is called \"push,\" and the operation of removing the top element is called \"pop.\"</p> <p></p> <p> Figure 5-1 \u00a0 LIFO rule of stack </p>"},{"location":"chapter_stack_and_queue/stack/#511-common-stack-operations","title":"5.1.1 \u00a0 Common Stack Operations","text":"<p>The common operations on a stack are shown in Table 5-1. The specific method names depend on the programming language used. Here, we use the common naming convention of <code>push()</code>, <code>pop()</code>, and <code>peek()</code>.</p> <p> Table 5-1 \u00a0 Efficiency of Stack Operations </p> Method Description Time Complexity <code>push()</code> Push element onto stack (add to top) \\(O(1)\\) <code>pop()</code> Pop top element from stack \\(O(1)\\) <code>peek()</code> Access top element \\(O(1)\\) <p>Typically, we can directly use the built-in stack class provided by the programming language. However, some languages may not provide a dedicated stack class. In these cases, we can use the language's \"array\" or \"linked list\" as a stack and ignore operations unrelated to the stack in the program logic.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby stack.py<pre><code># Initialize stack\n# Python does not have a built-in stack class, can use list as a stack\nstack: list[int] = []\n\n# Push elements\nstack.append(1)\nstack.append(3)\nstack.append(2)\nstack.append(5)\nstack.append(4)\n\n# Access top element\npeek: int = stack[-1]\n\n# Pop element\npop: int = stack.pop()\n\n# Get stack length\nsize: int = len(stack)\n\n# Check if empty\nis_empty: bool = len(stack) == 0\n</code></pre> stack.cpp<pre><code>/* Initialize stack */\nstack&lt;int&gt; stack;\n\n/* Push elements */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access top element */\nint top = stack.top();\n\n/* Pop element */\nstack.pop(); // No return value\n\n/* Get stack length */\nint size = stack.size();\n\n/* Check if empty */\nbool empty = stack.empty();\n</code></pre> stack.java<pre><code>/* Initialize stack */\nStack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n\n/* Push elements */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access top element */\nint peek = stack.peek();\n\n/* Pop element */\nint pop = stack.pop();\n\n/* Get stack length */\nint size = stack.size();\n\n/* Check if empty */\nboolean isEmpty = stack.isEmpty();\n</code></pre> stack.cs<pre><code>/* Initialize stack */\nStack&lt;int&gt; stack = new();\n\n/* Push elements */\nstack.Push(1);\nstack.Push(3);\nstack.Push(2);\nstack.Push(5);\nstack.Push(4);\n\n/* Access top element */\nint peek = stack.Peek();\n\n/* Pop element */\nint pop = stack.Pop();\n\n/* Get stack length */\nint size = stack.Count;\n\n/* Check if empty */\nbool isEmpty = stack.Count == 0;\n</code></pre> stack_test.go<pre><code>/* Initialize stack */\n// In Go, it is recommended to use Slice as a stack\nvar stack []int\n\n/* Push elements */\nstack = append(stack, 1)\nstack = append(stack, 3)\nstack = append(stack, 2)\nstack = append(stack, 5)\nstack = append(stack, 4)\n\n/* Access top element */\npeek := stack[len(stack)-1]\n\n/* Pop element */\npop := stack[len(stack)-1]\nstack = stack[:len(stack)-1]\n\n/* Get stack length */\nsize := len(stack)\n\n/* Check if empty */\nisEmpty := len(stack) == 0\n</code></pre> stack.swift<pre><code>/* Initialize stack */\n// Swift does not have a built-in stack class, can use Array as a stack\nvar stack: [Int] = []\n\n/* Push elements */\nstack.append(1)\nstack.append(3)\nstack.append(2)\nstack.append(5)\nstack.append(4)\n\n/* Access top element */\nlet peek = stack.last!\n\n/* Pop element */\nlet pop = stack.removeLast()\n\n/* Get stack length */\nlet size = stack.count\n\n/* Check if empty */\nlet isEmpty = stack.isEmpty\n</code></pre> stack.js<pre><code>/* Initialize stack */\n// JavaScript does not have a built-in stack class, can use Array as a stack\nconst stack = [];\n\n/* Push elements */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access top element */\nconst peek = stack[stack.length-1];\n\n/* Pop element */\nconst pop = stack.pop();\n\n/* Get stack length */\nconst size = stack.length;\n\n/* Check if empty */\nconst is_empty = stack.length === 0;\n</code></pre> stack.ts<pre><code>/* Initialize stack */\n// TypeScript does not have a built-in stack class, can use Array as a stack\nconst stack: number[] = [];\n\n/* Push elements */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access top element */\nconst peek = stack[stack.length - 1];\n\n/* Pop element */\nconst pop = stack.pop();\n\n/* Get stack length */\nconst size = stack.length;\n\n/* Check if empty */\nconst is_empty = stack.length === 0;\n</code></pre> stack.dart<pre><code>/* Initialize stack */\n// Dart does not have a built-in stack class, can use List as a stack\nList&lt;int&gt; stack = [];\n\n/* Push elements */\nstack.add(1);\nstack.add(3);\nstack.add(2);\nstack.add(5);\nstack.add(4);\n\n/* Access top element */\nint peek = stack.last;\n\n/* Pop element */\nint pop = stack.removeLast();\n\n/* Get stack length */\nint size = stack.length;\n\n/* Check if empty */\nbool isEmpty = stack.isEmpty;\n</code></pre> stack.rs<pre><code>/* Initialize stack */\n// Use Vec as a stack\nlet mut stack: Vec&lt;i32&gt; = Vec::new();\n\n/* Push elements */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access top element */\nlet top = stack.last().unwrap();\n\n/* Pop element */\nlet pop = stack.pop().unwrap();\n\n/* Get stack length */\nlet size = stack.len();\n\n/* Check if empty */\nlet is_empty = stack.is_empty();\n</code></pre> stack.c<pre><code>// C does not provide a built-in stack\n</code></pre> stack.kt<pre><code>/* Initialize stack */\nval stack = Stack&lt;Int&gt;()\n\n/* Push elements */\nstack.push(1)\nstack.push(3)\nstack.push(2)\nstack.push(5)\nstack.push(4)\n\n/* Access top element */\nval peek = stack.peek()\n\n/* Pop element */\nval pop = stack.pop()\n\n/* Get stack length */\nval size = stack.size\n\n/* Check if empty */\nval isEmpty = stack.isEmpty()\n</code></pre> stack.rb<pre><code># Initialize stack\n# Ruby does not have a built-in stack class, can use Array as a stack\nstack = []\n\n# Push elements\nstack &lt;&lt; 1\nstack &lt;&lt; 3\nstack &lt;&lt; 2\nstack &lt;&lt; 5\nstack &lt;&lt; 4\n\n# Access top element\npeek = stack.last\n\n# Pop element\npop = stack.pop\n\n# Get stack length\nsize = stack.length\n\n# Check if empty\nis_empty = stack.empty?\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/stack/#512-stack-implementation","title":"5.1.2 \u00a0 Stack Implementation","text":"<p>To gain a deeper understanding of how a stack operates, let's try implementing a stack class ourselves.</p> <p>A stack follows the LIFO principle, so we can only add or remove elements at the top. However, both arrays and linked lists allow adding and removing elements at any position. Therefore, a stack can be viewed as a restricted array or linked list. In other words, we can \"shield\" some irrelevant operations of arrays or linked lists so that their external logic conforms to the characteristics of a stack.</p>"},{"location":"chapter_stack_and_queue/stack/#1-linked-list-implementation","title":"1. \u00a0 Linked List Implementation","text":"<p>When implementing a stack using a linked list, we can treat the head node of the linked list as the top of the stack and the tail node as the base.</p> <p>As shown in Figure 5-2, for the push operation, we simply insert an element at the head of the linked list. This node insertion method is called the \"head insertion method.\" For the pop operation, we just need to remove the head node from the linked list.</p> LinkedListStackpush()pop() <p></p> <p></p> <p></p> <p> Figure 5-2 \u00a0 Push and pop operations in linked list implementation of stack </p> <p>Below is sample code for implementing a stack based on a linked list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby linkedlist_stack.py<pre><code>class LinkedListStack:\n    \"\"\"Stack based on linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self._peek: ListNode | None = None\n        self._size: int = 0\n\n    def size(self) -&gt; int:\n        \"\"\"Get the length of the stack\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the stack is empty\"\"\"\n        return self._size == 0\n\n    def push(self, val: int):\n        \"\"\"Push\"\"\"\n        node = ListNode(val)\n        node.next = self._peek\n        self._peek = node\n        self._size += 1\n\n    def pop(self) -&gt; int:\n        \"\"\"Pop\"\"\"\n        num = self.peek()\n        self._peek = self._peek.next\n        self._size -= 1\n        return num\n\n    def peek(self) -&gt; int:\n        \"\"\"Access top of the stack element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self._peek.val\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"Convert to list for printing\"\"\"\n        arr = []\n        node = self._peek\n        while node:\n            arr.append(node.val)\n            node = node.next\n        arr.reverse()\n        return arr\n</code></pre> linkedlist_stack.cpp<pre><code>/* Stack based on linked list implementation */\nclass LinkedListStack {\n  private:\n    ListNode *stackTop; // Use head node as stack top\n    int stkSize;        // Stack length\n\n  public:\n    LinkedListStack() {\n        stackTop = nullptr;\n        stkSize = 0;\n    }\n\n    ~LinkedListStack() {\n        // Traverse linked list to delete nodes and free memory\n        freeMemoryLinkedList(stackTop);\n    }\n\n    /* Get the length of the stack */\n    int size() {\n        return stkSize;\n    }\n\n    /* Check if the stack is empty */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* Push */\n    void push(int num) {\n        ListNode *node = new ListNode(num);\n        node-&gt;next = stackTop;\n        stackTop = node;\n        stkSize++;\n    }\n\n    /* Pop */\n    int pop() {\n        int num = top();\n        ListNode *tmp = stackTop;\n        stackTop = stackTop-&gt;next;\n        // Free memory\n        delete tmp;\n        stkSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    int top() {\n        if (isEmpty())\n            throw out_of_range(\"Stack is empty\");\n        return stackTop-&gt;val;\n    }\n\n    /* Convert List to Array and return */\n    vector&lt;int&gt; toVector() {\n        ListNode *node = stackTop;\n        vector&lt;int&gt; res(size());\n        for (int i = res.size() - 1; i &gt;= 0; i--) {\n            res[i] = node-&gt;val;\n            node = node-&gt;next;\n        }\n        return res;\n    }\n};\n</code></pre> linkedlist_stack.java<pre><code>/* Stack based on linked list implementation */\nclass LinkedListStack {\n    private ListNode stackPeek; // Use head node as stack top\n    private int stkSize = 0; // Stack length\n\n    public LinkedListStack() {\n        stackPeek = null;\n    }\n\n    /* Get the length of the stack */\n    public int size() {\n        return stkSize;\n    }\n\n    /* Check if the stack is empty */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* Push */\n    public void push(int num) {\n        ListNode node = new ListNode(num);\n        node.next = stackPeek;\n        stackPeek = node;\n        stkSize++;\n    }\n\n    /* Pop */\n    public int pop() {\n        int num = peek();\n        stackPeek = stackPeek.next;\n        stkSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return stackPeek.val;\n    }\n\n    /* Convert List to Array and return */\n    public int[] toArray() {\n        ListNode node = stackPeek;\n        int[] res = new int[size()];\n        for (int i = res.length - 1; i &gt;= 0; i--) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.cs<pre><code>/* Stack based on linked list implementation */\nclass LinkedListStack {\n    ListNode? stackPeek;  // Use head node as stack top\n    int stkSize = 0;   // Stack length\n\n    public LinkedListStack() {\n        stackPeek = null;\n    }\n\n    /* Get the length of the stack */\n    public int Size() {\n        return stkSize;\n    }\n\n    /* Check if the stack is empty */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* Push */\n    public void Push(int num) {\n        ListNode node = new(num) {\n            next = stackPeek\n        };\n        stackPeek = node;\n        stkSize++;\n    }\n\n    /* Pop */\n    public int Pop() {\n        int num = Peek();\n        stackPeek = stackPeek!.next;\n        stkSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return stackPeek!.val;\n    }\n\n    /* Convert List to Array and return */\n    public int[] ToArray() {\n        if (stackPeek == null)\n            return [];\n\n        ListNode? node = stackPeek;\n        int[] res = new int[Size()];\n        for (int i = res.Length - 1; i &gt;= 0; i--) {\n            res[i] = node!.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.go<pre><code>/* Stack based on linked list implementation */\ntype linkedListStack struct {\n    // Use built-in package list to implement stack\n    data *list.List\n}\n\n/* Access top of the stack element */\nfunc newLinkedListStack() *linkedListStack {\n    return &amp;linkedListStack{\n        data: list.New(),\n    }\n}\n\n/* Push */\nfunc (s *linkedListStack) push(value int) {\n    s.data.PushBack(value)\n}\n\n/* Pop */\nfunc (s *linkedListStack) pop() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* Return list for printing */\nfunc (s *linkedListStack) peek() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    return e.Value\n}\n\n/* Get the length of the stack */\nfunc (s *linkedListStack) size() int {\n    return s.data.Len()\n}\n\n/* Check if the stack is empty */\nfunc (s *linkedListStack) isEmpty() bool {\n    return s.data.Len() == 0\n}\n\n/* Get List for printing */\nfunc (s *linkedListStack) toList() *list.List {\n    return s.data\n}\n</code></pre> linkedlist_stack.swift<pre><code>/* Stack based on linked list implementation */\nclass LinkedListStack {\n    private var _peek: ListNode? // Use head node as stack top\n    private var _size: Int // Stack length\n\n    init() {\n        _size = 0\n    }\n\n    /* Get the length of the stack */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* Check if the stack is empty */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* Push */\n    func push(num: Int) {\n        let node = ListNode(x: num)\n        node.next = _peek\n        _peek = node\n        _size += 1\n    }\n\n    /* Pop */\n    @discardableResult\n    func pop() -&gt; Int {\n        let num = peek()\n        _peek = _peek?.next\n        _size -= 1\n        return num\n    }\n\n    /* Return list for printing */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Stack is empty\")\n        }\n        return _peek!.val\n    }\n\n    /* Convert List to Array and return */\n    func toArray() -&gt; [Int] {\n        var node = _peek\n        var res = Array(repeating: 0, count: size())\n        for i in res.indices.reversed() {\n            res[i] = node!.val\n            node = node?.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_stack.js<pre><code>/* Stack based on linked list implementation */\nclass LinkedListStack {\n    #stackPeek; // Use head node as stack top\n    #stkSize = 0; // Stack length\n\n    constructor() {\n        this.#stackPeek = null;\n    }\n\n    /* Get the length of the stack */\n    get size() {\n        return this.#stkSize;\n    }\n\n    /* Check if the stack is empty */\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    /* Push */\n    push(num) {\n        const node = new ListNode(num);\n        node.next = this.#stackPeek;\n        this.#stackPeek = node;\n        this.#stkSize++;\n    }\n\n    /* Pop */\n    pop() {\n        const num = this.peek();\n        this.#stackPeek = this.#stackPeek.next;\n        this.#stkSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peek() {\n        if (!this.#stackPeek) throw new Error('Stack is empty');\n        return this.#stackPeek.val;\n    }\n\n    /* Convert linked list to Array and return */\n    toArray() {\n        let node = this.#stackPeek;\n        const res = new Array(this.size);\n        for (let i = res.length - 1; i &gt;= 0; i--) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.ts<pre><code>/* Stack based on linked list implementation */\nclass LinkedListStack {\n    private stackPeek: ListNode | null; // Use head node as stack top\n    private stkSize: number = 0; // Stack length\n\n    constructor() {\n        this.stackPeek = null;\n    }\n\n    /* Get the length of the stack */\n    get size(): number {\n        return this.stkSize;\n    }\n\n    /* Check if the stack is empty */\n    isEmpty(): boolean {\n        return this.size === 0;\n    }\n\n    /* Push */\n    push(num: number): void {\n        const node = new ListNode(num);\n        node.next = this.stackPeek;\n        this.stackPeek = node;\n        this.stkSize++;\n    }\n\n    /* Pop */\n    pop(): number {\n        const num = this.peek();\n        if (!this.stackPeek) throw new Error('Stack is empty');\n        this.stackPeek = this.stackPeek.next;\n        this.stkSize--;\n        return num;\n    }\n\n    /* Return list for printing */\n    peek(): number {\n        if (!this.stackPeek) throw new Error('Stack is empty');\n        return this.stackPeek.val;\n    }\n\n    /* Convert linked list to Array and return */\n    toArray(): number[] {\n        let node = this.stackPeek;\n        const res = new Array&lt;number&gt;(this.size);\n        for (let i = res.length - 1; i &gt;= 0; i--) {\n            res[i] = node!.val;\n            node = node!.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.dart<pre><code>/* Stack implemented based on linked list class */\nclass LinkedListStack {\n  ListNode? _stackPeek; // Use head node as stack top\n  int _stkSize = 0; // Stack length\n\n  LinkedListStack() {\n    _stackPeek = null;\n  }\n\n  /* Get the length of the stack */\n  int size() {\n    return _stkSize;\n  }\n\n  /* Check if the stack is empty */\n  bool isEmpty() {\n    return _stkSize == 0;\n  }\n\n  /* Push */\n  void push(int _num) {\n    final ListNode node = ListNode(_num);\n    node.next = _stackPeek;\n    _stackPeek = node;\n    _stkSize++;\n  }\n\n  /* Pop */\n  int pop() {\n    final int _num = peek();\n    _stackPeek = _stackPeek!.next;\n    _stkSize--;\n    return _num;\n  }\n\n  /* Return list for printing */\n  int peek() {\n    if (_stackPeek == null) {\n      throw Exception(\"Stack is empty\");\n    }\n    return _stackPeek!.val;\n  }\n\n  /* Convert linked list to List and return */\n  List&lt;int&gt; toList() {\n    ListNode? node = _stackPeek;\n    List&lt;int&gt; list = [];\n    while (node != null) {\n      list.add(node.val);\n      node = node.next;\n    }\n    list = list.reversed.toList();\n    return list;\n  }\n}\n</code></pre> linkedlist_stack.rs<pre><code>/* Stack based on linked list implementation */\n#[allow(dead_code)]\npub struct LinkedListStack&lt;T&gt; {\n    stack_peek: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // Use head node as stack top\n    stk_size: usize,                              // Stack length\n}\n\nimpl&lt;T: Copy&gt; LinkedListStack&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            stack_peek: None,\n            stk_size: 0,\n        }\n    }\n\n    /* Get the length of the stack */\n    pub fn size(&amp;self) -&gt; usize {\n        return self.stk_size;\n    }\n\n    /* Check if the stack is empty */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        return self.size() == 0;\n    }\n\n    /* Push */\n    pub fn push(&amp;mut self, num: T) {\n        let node = ListNode::new(num);\n        node.borrow_mut().next = self.stack_peek.take();\n        self.stack_peek = Some(node);\n        self.stk_size += 1;\n    }\n\n    /* Pop */\n    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {\n        self.stack_peek.take().map(|old_head| {\n            self.stack_peek = old_head.borrow_mut().next.take();\n            self.stk_size -= 1;\n\n            old_head.borrow().val\n        })\n    }\n\n    /* Return list for printing */\n    pub fn peek(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.stack_peek.as_ref()\n    }\n\n    /* Convert List to Array and return */\n    pub fn to_array(&amp;self) -&gt; Vec&lt;T&gt; {\n        fn _to_array&lt;T: Sized + Copy&gt;(head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;) -&gt; Vec&lt;T&gt; {\n            if let Some(node) = head {\n                let mut nums = _to_array(node.borrow().next.as_ref());\n                nums.push(node.borrow().val);\n                return nums;\n            }\n            return Vec::new();\n        }\n\n        _to_array(self.peek())\n    }\n}\n</code></pre> linkedlist_stack.c<pre><code>/* Stack based on linked list implementation */\ntypedef struct {\n    ListNode *top; // Use head node as stack top\n    int size;      // Stack length\n} LinkedListStack;\n\n/* Constructor */\nLinkedListStack *newLinkedListStack() {\n    LinkedListStack *s = malloc(sizeof(LinkedListStack));\n    s-&gt;top = NULL;\n    s-&gt;size = 0;\n    return s;\n}\n\n/* Destructor */\nvoid delLinkedListStack(LinkedListStack *s) {\n    while (s-&gt;top) {\n        ListNode *n = s-&gt;top-&gt;next;\n        free(s-&gt;top);\n        s-&gt;top = n;\n    }\n    free(s);\n}\n\n/* Get the length of the stack */\nint size(LinkedListStack *s) {\n    return s-&gt;size;\n}\n\n/* Check if the stack is empty */\nbool isEmpty(LinkedListStack *s) {\n    return size(s) == 0;\n}\n\n/* Push */\nvoid push(LinkedListStack *s, int num) {\n    ListNode *node = (ListNode *)malloc(sizeof(ListNode));\n    node-&gt;next = s-&gt;top; // Update new node's pointer field\n    node-&gt;val = num;     // Update new node's data field\n    s-&gt;top = node;       // Update stack top\n    s-&gt;size++;           // Update stack size\n}\n\n/* Return list for printing */\nint peek(LinkedListStack *s) {\n    if (s-&gt;size == 0) {\n        printf(\"Stack is empty\\n\");\n        return INT_MAX;\n    }\n    return s-&gt;top-&gt;val;\n}\n\n/* Pop */\nint pop(LinkedListStack *s) {\n    int val = peek(s);\n    ListNode *tmp = s-&gt;top;\n    s-&gt;top = s-&gt;top-&gt;next;\n    // Free memory\n    free(tmp);\n    s-&gt;size--;\n    return val;\n}\n</code></pre> linkedlist_stack.kt<pre><code>/* Stack based on linked list implementation */\nclass LinkedListStack(\n    private var stackPeek: ListNode? = null, // Use head node as stack top\n    private var stkSize: Int = 0 // Stack length\n) {\n\n    /* Get the length of the stack */\n    fun size(): Int {\n        return stkSize\n    }\n\n    /* Check if the stack is empty */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* Push */\n    fun push(num: Int) {\n        val node = ListNode(num)\n        node.next = stackPeek\n        stackPeek = node\n        stkSize++\n    }\n\n    /* Pop */\n    fun pop(): Int? {\n        val num = peek()\n        stackPeek = stackPeek?.next\n        stkSize--\n        return num\n    }\n\n    /* Return list for printing */\n    fun peek(): Int? {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return stackPeek?._val\n    }\n\n    /* Convert List to Array and return */\n    fun toArray(): IntArray {\n        var node = stackPeek\n        val res = IntArray(size())\n        for (i in res.size - 1 downTo 0) {\n            res[i] = node?._val!!\n            node = node.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_stack.rb<pre><code>### Stack based on linked list ###\nclass LinkedListStack\n  attr_reader :size\n\n  ### Constructor ###\n  def initialize\n    @size = 0\n  end\n\n  ### Check if stack is empty ###\n  def is_empty?\n    @peek.nil?\n  end\n\n  ### Push ###\n  def push(val)\n    node = ListNode.new(val)\n    node.next = @peek\n    @peek = node\n    @size += 1\n  end\n\n  ### Pop ###\n  def pop\n    num = peek\n    @peek = @peek.next\n    @size -= 1\n    num\n  end\n\n  ### Access top element ###\n  def peek\n    raise IndexError, 'Stack is empty' if is_empty?\n\n    @peek.val\n  end\n\n  ### Convert linked list to Array and return ###\n  def to_array\n    arr = []\n    node = @peek\n    while node\n      arr &lt;&lt; node.val\n      node = node.next\n    end\n    arr.reverse\n  end\nend\n</code></pre>"},{"location":"chapter_stack_and_queue/stack/#2-array-implementation","title":"2. \u00a0 Array Implementation","text":"<p>When implementing a stack using an array, we can treat the end of the array as the top of the stack. As shown in Figure 5-3, push and pop operations correspond to adding and removing elements at the end of the array, both with a time complexity of \\(O(1)\\).</p> ArrayStackpush()pop() <p></p> <p></p> <p></p> <p> Figure 5-3 \u00a0 Push and pop operations in array implementation of stack </p> <p>Since elements pushed onto the stack may increase continuously, we can use a dynamic array, which eliminates the need to handle array expansion ourselves. Here is the sample code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array_stack.py<pre><code>class ArrayStack:\n    \"\"\"Stack based on array implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n        self._stack: list[int] = []\n\n    def size(self) -&gt; int:\n        \"\"\"Get the length of the stack\"\"\"\n        return len(self._stack)\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the stack is empty\"\"\"\n        return self.size() == 0\n\n    def push(self, item: int):\n        \"\"\"Push\"\"\"\n        self._stack.append(item)\n\n    def pop(self) -&gt; int:\n        \"\"\"Pop\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self._stack.pop()\n\n    def peek(self) -&gt; int:\n        \"\"\"Access top of the stack element\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Stack is empty\")\n        return self._stack[-1]\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"Return list for printing\"\"\"\n        return self._stack\n</code></pre> array_stack.cpp<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n  private:\n    vector&lt;int&gt; stack;\n\n  public:\n    /* Get the length of the stack */\n    int size() {\n        return stack.size();\n    }\n\n    /* Check if the stack is empty */\n    bool isEmpty() {\n        return stack.size() == 0;\n    }\n\n    /* Push */\n    void push(int num) {\n        stack.push_back(num);\n    }\n\n    /* Pop */\n    int pop() {\n        int num = top();\n        stack.pop_back();\n        return num;\n    }\n\n    /* Return list for printing */\n    int top() {\n        if (isEmpty())\n            throw out_of_range(\"Stack is empty\");\n        return stack.back();\n    }\n\n    /* Return Vector */\n    vector&lt;int&gt; toVector() {\n        return stack;\n    }\n};\n</code></pre> array_stack.java<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n    private ArrayList&lt;Integer&gt; stack;\n\n    public ArrayStack() {\n        // Initialize list (dynamic array)\n        stack = new ArrayList&lt;&gt;();\n    }\n\n    /* Get the length of the stack */\n    public int size() {\n        return stack.size();\n    }\n\n    /* Check if the stack is empty */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* Push */\n    public void push(int num) {\n        stack.add(num);\n    }\n\n    /* Pop */\n    public int pop() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return stack.remove(size() - 1);\n    }\n\n    /* Return list for printing */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return stack.get(size() - 1);\n    }\n\n    /* Convert List to Array and return */\n    public Object[] toArray() {\n        return stack.toArray();\n    }\n}\n</code></pre> array_stack.cs<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n    List&lt;int&gt; stack;\n    public ArrayStack() {\n        // Initialize list (dynamic array)\n        stack = [];\n    }\n\n    /* Get the length of the stack */\n    public int Size() {\n        return stack.Count;\n    }\n\n    /* Check if the stack is empty */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* Push */\n    public void Push(int num) {\n        stack.Add(num);\n    }\n\n    /* Pop */\n    public int Pop() {\n        if (IsEmpty())\n            throw new Exception();\n        var val = Peek();\n        stack.RemoveAt(Size() - 1);\n        return val;\n    }\n\n    /* Return list for printing */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return stack[Size() - 1];\n    }\n\n    /* Convert List to Array and return */\n    public int[] ToArray() {\n        return [.. stack];\n    }\n}\n</code></pre> array_stack.go<pre><code>/* Stack based on array implementation */\ntype arrayStack struct {\n    data []int // Data\n}\n\n/* Access top of the stack element */\nfunc newArrayStack() *arrayStack {\n    return &amp;arrayStack{\n        // Set stack length to 0, capacity to 16\n        data: make([]int, 0, 16),\n    }\n}\n\n/* Stack length */\nfunc (s *arrayStack) size() int {\n    return len(s.data)\n}\n\n/* Is stack empty */\nfunc (s *arrayStack) isEmpty() bool {\n    return s.size() == 0\n}\n\n/* Push */\nfunc (s *arrayStack) push(v int) {\n    // Slice will automatically expand\n    s.data = append(s.data, v)\n}\n\n/* Pop */\nfunc (s *arrayStack) pop() any {\n    val := s.peek()\n    s.data = s.data[:len(s.data)-1]\n    return val\n}\n\n/* Get stack top element */\nfunc (s *arrayStack) peek() any {\n    if s.isEmpty() {\n        return nil\n    }\n    val := s.data[len(s.data)-1]\n    return val\n}\n\n/* Get Slice for printing */\nfunc (s *arrayStack) toSlice() []int {\n    return s.data\n}\n</code></pre> array_stack.swift<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n    private var stack: [Int]\n\n    init() {\n        // Initialize list (dynamic array)\n        stack = []\n    }\n\n    /* Get the length of the stack */\n    func size() -&gt; Int {\n        stack.count\n    }\n\n    /* Check if the stack is empty */\n    func isEmpty() -&gt; Bool {\n        stack.isEmpty\n    }\n\n    /* Push */\n    func push(num: Int) {\n        stack.append(num)\n    }\n\n    /* Pop */\n    @discardableResult\n    func pop() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Stack is empty\")\n        }\n        return stack.removeLast()\n    }\n\n    /* Return list for printing */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"Stack is empty\")\n        }\n        return stack.last!\n    }\n\n    /* Convert List to Array and return */\n    func toArray() -&gt; [Int] {\n        stack\n    }\n}\n</code></pre> array_stack.js<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n    #stack;\n    constructor() {\n        this.#stack = [];\n    }\n\n    /* Get the length of the stack */\n    get size() {\n        return this.#stack.length;\n    }\n\n    /* Check if the stack is empty */\n    isEmpty() {\n        return this.#stack.length === 0;\n    }\n\n    /* Push */\n    push(num) {\n        this.#stack.push(num);\n    }\n\n    /* Pop */\n    pop() {\n        if (this.isEmpty()) throw new Error('Stack is empty');\n        return this.#stack.pop();\n    }\n\n    /* Return list for printing */\n    top() {\n        if (this.isEmpty()) throw new Error('Stack is empty');\n        return this.#stack[this.#stack.length - 1];\n    }\n\n    /* Return Array */\n    toArray() {\n        return this.#stack;\n    }\n}\n</code></pre> array_stack.ts<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n    private stack: number[];\n    constructor() {\n        this.stack = [];\n    }\n\n    /* Get the length of the stack */\n    get size(): number {\n        return this.stack.length;\n    }\n\n    /* Check if the stack is empty */\n    isEmpty(): boolean {\n        return this.stack.length === 0;\n    }\n\n    /* Push */\n    push(num: number): void {\n        this.stack.push(num);\n    }\n\n    /* Pop */\n    pop(): number | undefined {\n        if (this.isEmpty()) throw new Error('Stack is empty');\n        return this.stack.pop();\n    }\n\n    /* Return list for printing */\n    top(): number | undefined {\n        if (this.isEmpty()) throw new Error('Stack is empty');\n        return this.stack[this.stack.length - 1];\n    }\n\n    /* Return Array */\n    toArray() {\n        return this.stack;\n    }\n}\n</code></pre> array_stack.dart<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n  late List&lt;int&gt; _stack;\n  ArrayStack() {\n    _stack = [];\n  }\n\n  /* Get the length of the stack */\n  int size() {\n    return _stack.length;\n  }\n\n  /* Check if the stack is empty */\n  bool isEmpty() {\n    return _stack.isEmpty;\n  }\n\n  /* Push */\n  void push(int _num) {\n    _stack.add(_num);\n  }\n\n  /* Pop */\n  int pop() {\n    if (isEmpty()) {\n      throw Exception(\"Stack is empty\");\n    }\n    return _stack.removeLast();\n  }\n\n  /* Return list for printing */\n  int peek() {\n    if (isEmpty()) {\n      throw Exception(\"Stack is empty\");\n    }\n    return _stack.last;\n  }\n\n  /* Convert stack to Array and return */\n  List&lt;int&gt; toArray() =&gt; _stack;\n}\n</code></pre> array_stack.rs<pre><code>/* Stack based on array implementation */\nstruct ArrayStack&lt;T&gt; {\n    stack: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; ArrayStack&lt;T&gt; {\n    /* Access top of the stack element */\n    fn new() -&gt; ArrayStack&lt;T&gt; {\n        ArrayStack::&lt;T&gt; {\n            stack: Vec::&lt;T&gt;::new(),\n        }\n    }\n\n    /* Get the length of the stack */\n    fn size(&amp;self) -&gt; usize {\n        self.stack.len()\n    }\n\n    /* Check if the stack is empty */\n    fn is_empty(&amp;self) -&gt; bool {\n        self.size() == 0\n    }\n\n    /* Push */\n    fn push(&amp;mut self, num: T) {\n        self.stack.push(num);\n    }\n\n    /* Pop */\n    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {\n        self.stack.pop()\n    }\n\n    /* Return list for printing */\n    fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {\n        if self.is_empty() {\n            panic!(\"Stack is empty\")\n        };\n        self.stack.last()\n    }\n\n    /* Return &amp;Vec */\n    fn to_array(&amp;self) -&gt; &amp;Vec&lt;T&gt; {\n        &amp;self.stack\n    }\n}\n</code></pre> array_stack.c<pre><code>/* Stack based on array implementation */\ntypedef struct {\n    int *data;\n    int size;\n} ArrayStack;\n\n/* Constructor */\nArrayStack *newArrayStack() {\n    ArrayStack *stack = malloc(sizeof(ArrayStack));\n    // Initialize with large capacity to avoid expansion\n    stack-&gt;data = malloc(sizeof(int) * MAX_SIZE);\n    stack-&gt;size = 0;\n    return stack;\n}\n\n/* Destructor */\nvoid delArrayStack(ArrayStack *stack) {\n    free(stack-&gt;data);\n    free(stack);\n}\n\n/* Get the length of the stack */\nint size(ArrayStack *stack) {\n    return stack-&gt;size;\n}\n\n/* Check if the stack is empty */\nbool isEmpty(ArrayStack *stack) {\n    return stack-&gt;size == 0;\n}\n\n/* Push */\nvoid push(ArrayStack *stack, int num) {\n    if (stack-&gt;size == MAX_SIZE) {\n        printf(\"Stack is full\\n\");\n        return;\n    }\n    stack-&gt;data[stack-&gt;size] = num;\n    stack-&gt;size++;\n}\n\n/* Return list for printing */\nint peek(ArrayStack *stack) {\n    if (stack-&gt;size == 0) {\n        printf(\"Stack is empty\\n\");\n        return INT_MAX;\n    }\n    return stack-&gt;data[stack-&gt;size - 1];\n}\n\n/* Pop */\nint pop(ArrayStack *stack) {\n    int val = peek(stack);\n    stack-&gt;size--;\n    return val;\n}\n</code></pre> array_stack.kt<pre><code>/* Stack based on array implementation */\nclass ArrayStack {\n    // Initialize list (dynamic array)\n    private val stack = mutableListOf&lt;Int&gt;()\n\n    /* Get the length of the stack */\n    fun size(): Int {\n        return stack.size\n    }\n\n    /* Check if the stack is empty */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* Push */\n    fun push(num: Int) {\n        stack.add(num)\n    }\n\n    /* Pop */\n    fun pop(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return stack.removeAt(size() - 1)\n    }\n\n    /* Return list for printing */\n    fun peek(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return stack[size() - 1]\n    }\n\n    /* Convert List to Array and return */\n    fun toArray(): Array&lt;Any&gt; {\n        return stack.toTypedArray()\n    }\n}\n</code></pre> array_stack.rb<pre><code>### Stack based on array ###\nclass ArrayStack\n  ### Constructor ###\n  def initialize\n    @stack = []\n  end\n\n  ### Get stack length ###\n  def size\n    @stack.length\n  end\n\n  ### Check if stack is empty ###\n  def is_empty?\n    @stack.empty?\n  end\n\n  ### Push ###\n  def push(item)\n    @stack &lt;&lt; item\n  end\n\n  ### Pop ###\n  def pop\n    raise IndexError, 'Stack is empty' if is_empty?\n\n    @stack.pop\n  end\n\n  ### Access top element ###\n  def peek\n    raise IndexError, 'Stack is empty' if is_empty?\n\n    @stack.last\n  end\n\n  ### Return list for printing ###\n  def to_array\n    @stack\n  end\nend\n</code></pre>"},{"location":"chapter_stack_and_queue/stack/#513-comparison-of-the-two-implementations","title":"5.1.3 \u00a0 Comparison of the Two Implementations","text":"<p>Supported Operations</p> <p>Both implementations support all operations defined by the stack. The array implementation additionally supports random access, but this goes beyond the stack definition and is generally not used.</p> <p>Time Efficiency</p> <p>In the array-based implementation, both push and pop operations occur in pre-allocated contiguous memory, which has good cache locality and is therefore more efficient. However, if pushing exceeds the array capacity, it triggers an expansion mechanism, causing the time complexity of that particular push operation to become \\(O(n)\\).</p> <p>In the linked list-based implementation, list expansion is very flexible, and there is no issue of reduced efficiency due to array expansion. However, the push operation requires initializing a node object and modifying pointers, so it is relatively less efficient. Nevertheless, if the pushed elements are already node objects, the initialization step can be omitted, thereby improving efficiency.</p> <p>In summary, when the elements pushed and popped are basic data types such as <code>int</code> or <code>double</code>, we can draw the following conclusions:</p> <ul> <li>The array-based stack implementation has reduced efficiency when expansion is triggered, but since expansion is an infrequent operation, the average efficiency is higher.</li> <li>The linked list-based stack implementation can provide more stable efficiency performance.</li> </ul> <p>Space Efficiency</p> <p>When initializing a list, the system allocates an \"initial capacity\" that may exceed the actual need. Additionally, the expansion mechanism typically expands at a specific ratio (e.g., 2x), and the capacity after expansion may also exceed actual needs. Therefore, the array-based stack implementation may cause some space wastage.</p> <p>However, since linked list nodes need to store additional pointers, the space occupied by linked list nodes is relatively large.</p> <p>In summary, we cannot simply determine which implementation is more memory-efficient and need to analyze the specific situation.</p>"},{"location":"chapter_stack_and_queue/stack/#514-typical-applications-of-stack","title":"5.1.4 \u00a0 Typical Applications of Stack","text":"<ul> <li>Back and forward in browsers, undo and redo in software. Every time we open a new webpage, the browser pushes the previous page onto the stack, allowing us to return to the previous page via the back operation. The back operation is essentially performing a pop. To support both back and forward, two stacks are needed to work together.</li> <li>Program memory management. Each time a function is called, the system adds a stack frame to the top of the stack to record the function's context information. During recursion, the downward recursive phase continuously performs push operations, while the upward backtracking phase continuously performs pop operations.</li> </ul>"},{"location":"chapter_stack_and_queue/summary/","title":"5.4 \u00a0 Summary","text":""},{"location":"chapter_stack_and_queue/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>A stack is a data structure that follows the LIFO principle and can be implemented using arrays or linked lists.</li> <li>In terms of time efficiency, the array implementation of a stack has higher average efficiency, but during expansion, the time complexity of a single push operation degrades to \\(O(n)\\). In contrast, the linked list implementation of a stack provides more stable efficiency performance.</li> <li>In terms of space efficiency, the array implementation of a stack may lead to some degree of space wastage. However, it should be noted that the memory space occupied by linked list nodes is larger than that of array elements.</li> <li>A queue is a data structure that follows the FIFO principle and can also be implemented using arrays or linked lists. The conclusions regarding time efficiency and space efficiency comparisons for queues are similar to those for stacks mentioned above.</li> <li>A deque is a queue with greater flexibility that allows adding and removing elements at both ends.</li> </ul>"},{"location":"chapter_stack_and_queue/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Is the browser's forward and backward functionality implemented with a doubly linked list?</p> <p>The forward and backward functionality of a browser is essentially a manifestation of a \"stack.\" When a user visits a new page, that page is added to the top of the stack; when the user clicks the back button, that page is popped from the top of the stack. Using a deque can conveniently implement some additional operations, as mentioned in the \"Deque\" section.</p> <p>Q: After popping from the stack, do we need to free the memory of the popped node?</p> <p>If the popped node will still be needed later, then memory does not need to be freed. If it won't be used afterward, languages like Java and Python have automatic garbage collection, so manual memory deallocation is not required; in C and C++, manual memory deallocation is necessary.</p> <p>Q: A deque seems like two stacks joined together. What is its purpose?</p> <p>A deque is like a combination of a stack and a queue, or two stacks joined together. It exhibits the logic of both stack and queue, so it can implement all applications of stacks and queues, and is more flexible.</p> <p>Q: How are undo and redo specifically implemented?</p> <p>Use two stacks: stack <code>A</code> for undo and stack <code>B</code> for redo.</p> <ol> <li>Whenever the user performs an operation, push this operation onto stack <code>A</code> and clear stack <code>B</code>.</li> <li>When the user performs \"undo,\" pop the most recent operation from stack <code>A</code> and push it onto stack <code>B</code>.</li> <li>When the user performs \"redo,\" pop the most recent operation from stack <code>B</code> and push it onto stack <code>A</code>.</li> </ol>"},{"location":"chapter_tree/","title":"Chapter 7. \u00a0 Tree","text":"<p>Abstract</p> <p>Towering trees are full of vitality, with deep roots and lush leaves, spreading branches and flourishing.</p> <p>They show us the vivid form of divide and conquer in data.</p>"},{"location":"chapter_tree/#chapter-contents","title":"Chapter contents","text":"<ul> <li>7.1 \u00a0 Binary Tree</li> <li>7.2 \u00a0 Binary Tree Traversal</li> <li>7.3 \u00a0 Array Representation of Tree</li> <li>7.4 \u00a0 Binary Search Tree</li> <li>7.5 \u00a0 AVL Tree *</li> <li>7.6 \u00a0 Summary</li> </ul>"},{"location":"chapter_tree/array_representation_of_tree/","title":"7.3 \u00a0 Array Representation of Binary Trees","text":"<p>Under the linked list representation, the storage unit of a binary tree is a node <code>TreeNode</code>, and nodes are connected by pointers. The previous section introduced the basic operations of binary trees under the linked list representation.</p> <p>So, can we use an array to represent a binary tree? The answer is yes.</p>"},{"location":"chapter_tree/array_representation_of_tree/#731-representing-perfect-binary-trees","title":"7.3.1 \u00a0 Representing Perfect Binary Trees","text":"<p>Let's analyze a simple case first. Given a perfect binary tree, we store all nodes in an array according to the order of level-order traversal, where each node corresponds to a unique array index.</p> <p>Based on the characteristics of level-order traversal, we can derive a \"mapping formula\" between parent node index and child node indices: If a node's index is \\(i\\), then its left child index is \\(2i + 1\\) and its right child index is \\(2i + 2\\). Figure 7-12 shows the mapping relationships between various node indices.</p> <p></p> <p> Figure 7-12 \u00a0 Array representation of a perfect binary tree </p> <p>The mapping formula plays a role similar to the node references (pointers) in linked lists. Given any node in the array, we can access its left (right) child node using the mapping formula.</p>"},{"location":"chapter_tree/array_representation_of_tree/#732-representing-any-binary-tree","title":"7.3.2 \u00a0 Representing Any Binary Tree","text":"<p>Perfect binary trees are a special case; in the middle levels of a binary tree, there are typically many <code>None</code> values. Since the level-order traversal sequence does not include these <code>None</code> values, we cannot infer the number and distribution of <code>None</code> values based on this sequence alone. This means multiple binary tree structures can correspond to the same level-order traversal sequence.</p> <p>As shown in Figure 7-13, given a non-perfect binary tree, the above method of array representation fails.</p> <p></p> <p> Figure 7-13 \u00a0 Level-order traversal sequence corresponds to multiple binary tree possibilities </p> <p>To solve this problem, we can consider explicitly writing out all <code>None</code> values in the level-order traversal sequence. As shown in Figure 7-14, after this treatment, the level-order traversal sequence can uniquely represent a binary tree. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code># Array representation of a binary tree\n# Using None to represent empty slots\ntree = [1, 2, 3, 4, None, 6, 7, 8, 9, None, None, 12, None, None, 15]\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the maximum integer value INT_MAX to mark empty slots\nvector&lt;int&gt; tree = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the Integer wrapper class allows for using null to mark empty slots\nInteger[] tree = { 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 };\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using nullable int (int?) allows for using null to mark empty slots\nint?[] tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using an any type slice, allowing for nil to mark empty slots\ntree := []any{1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15}\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using optional Int (Int?) allows for using nil to mark empty slots\nlet tree: [Int?] = [1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15]\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nlet tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nlet tree: (number | null)[] = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using nullable int (int?) allows for using null to mark empty slots\nList&lt;int?&gt; tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using None to mark empty slots\nlet tree = [Some(1), Some(2), Some(3), Some(4), None, Some(6), Some(7), Some(8), Some(9), None, None, Some(12), None, None, Some(15)];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the maximum int value to mark empty slots, therefore, node values must not be INT_MAX\nint tree[] = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nval tree = arrayOf( 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 )\n</code></pre> <pre><code>### Array representation of a binary tree ###\n# Using nil to represent empty slots\ntree = [1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15]\n</code></pre> <p></p> <p> Figure 7-14 \u00a0 Array representation of any type of binary tree </p> <p>It's worth noting that complete binary trees are very well-suited for array representation. Recalling the definition of a complete binary tree, <code>None</code> only appears at the bottom level and towards the right, meaning all <code>None</code> values must appear at the end of the level-order traversal sequence.</p> <p>This means that when using an array to represent a complete binary tree, it's possible to omit storing all <code>None</code> values, which is very convenient. Figure 7-15 gives an example.</p> <p></p> <p> Figure 7-15 \u00a0 Array representation of a complete binary tree </p> <p>The following code implements a binary tree based on array representation, including the following operations:</p> <ul> <li>Given a certain node, obtain its value, left (right) child node, and parent node.</li> <li>Obtain the preorder, inorder, postorder, and level-order traversal sequences.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby array_binary_tree.py<pre><code>class ArrayBinaryTree:\n    \"\"\"Binary tree class represented by array\"\"\"\n\n    def __init__(self, arr: list[int | None]):\n        \"\"\"Constructor\"\"\"\n        self._tree = list(arr)\n\n    def size(self):\n        \"\"\"List capacity\"\"\"\n        return len(self._tree)\n\n    def val(self, i: int) -&gt; int | None:\n        \"\"\"Get value of node at index i\"\"\"\n        # If index is out of bounds, return None, representing empty position\n        if i &lt; 0 or i &gt;= self.size():\n            return None\n        return self._tree[i]\n\n    def left(self, i: int) -&gt; int | None:\n        \"\"\"Get index of left child node of node at index i\"\"\"\n        return 2 * i + 1\n\n    def right(self, i: int) -&gt; int | None:\n        \"\"\"Get index of right child node of node at index i\"\"\"\n        return 2 * i + 2\n\n    def parent(self, i: int) -&gt; int | None:\n        \"\"\"Get index of parent node of node at index i\"\"\"\n        return (i - 1) // 2\n\n    def level_order(self) -&gt; list[int]:\n        \"\"\"Level-order traversal\"\"\"\n        self.res = []\n        # Traverse array directly\n        for i in range(self.size()):\n            if self.val(i) is not None:\n                self.res.append(self.val(i))\n        return self.res\n\n    def dfs(self, i: int, order: str):\n        \"\"\"Depth-first traversal\"\"\"\n        if self.val(i) is None:\n            return\n        # Preorder traversal\n        if order == \"pre\":\n            self.res.append(self.val(i))\n        self.dfs(self.left(i), order)\n        # Inorder traversal\n        if order == \"in\":\n            self.res.append(self.val(i))\n        self.dfs(self.right(i), order)\n        # Postorder traversal\n        if order == \"post\":\n            self.res.append(self.val(i))\n\n    def pre_order(self) -&gt; list[int]:\n        \"\"\"Preorder traversal\"\"\"\n        self.res = []\n        self.dfs(0, order=\"pre\")\n        return self.res\n\n    def in_order(self) -&gt; list[int]:\n        \"\"\"Inorder traversal\"\"\"\n        self.res = []\n        self.dfs(0, order=\"in\")\n        return self.res\n\n    def post_order(self) -&gt; list[int]:\n        \"\"\"Postorder traversal\"\"\"\n        self.res = []\n        self.dfs(0, order=\"post\")\n        return self.res\n</code></pre> array_binary_tree.cpp<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree {\n  public:\n    /* Constructor */\n    ArrayBinaryTree(vector&lt;int&gt; arr) {\n        tree = arr;\n    }\n\n    /* List capacity */\n    int size() {\n        return tree.size();\n    }\n\n    /* Get value of node at index i */\n    int val(int i) {\n        // Return INT_MAX if index out of bounds, representing empty position\n        if (i &lt; 0 || i &gt;= size())\n            return INT_MAX;\n        return tree[i];\n    }\n\n    /* Get index of left child node of node at index i */\n    int left(int i) {\n        return 2 * i + 1;\n    }\n\n    /* Get index of right child node of node at index i */\n    int right(int i) {\n        return 2 * i + 2;\n    }\n\n    /* Get index of parent node of node at index i */\n    int parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    /* Level-order traversal */\n    vector&lt;int&gt; levelOrder() {\n        vector&lt;int&gt; res;\n        // Traverse array directly\n        for (int i = 0; i &lt; size(); i++) {\n            if (val(i) != INT_MAX)\n                res.push_back(val(i));\n        }\n        return res;\n    }\n\n    /* Preorder traversal */\n    vector&lt;int&gt; preOrder() {\n        vector&lt;int&gt; res;\n        dfs(0, \"pre\", res);\n        return res;\n    }\n\n    /* Inorder traversal */\n    vector&lt;int&gt; inOrder() {\n        vector&lt;int&gt; res;\n        dfs(0, \"in\", res);\n        return res;\n    }\n\n    /* Postorder traversal */\n    vector&lt;int&gt; postOrder() {\n        vector&lt;int&gt; res;\n        dfs(0, \"post\", res);\n        return res;\n    }\n\n  private:\n    vector&lt;int&gt; tree;\n\n    /* Depth-first traversal */\n    void dfs(int i, string order, vector&lt;int&gt; &amp;res) {\n        // If empty position, return\n        if (val(i) == INT_MAX)\n            return;\n        // Preorder traversal\n        if (order == \"pre\")\n            res.push_back(val(i));\n        dfs(left(i), order, res);\n        // Inorder traversal\n        if (order == \"in\")\n            res.push_back(val(i));\n        dfs(right(i), order, res);\n        // Postorder traversal\n        if (order == \"post\")\n            res.push_back(val(i));\n    }\n};\n</code></pre> array_binary_tree.java<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree {\n    private List&lt;Integer&gt; tree;\n\n    /* Constructor */\n    public ArrayBinaryTree(List&lt;Integer&gt; arr) {\n        tree = new ArrayList&lt;&gt;(arr);\n    }\n\n    /* List capacity */\n    public int size() {\n        return tree.size();\n    }\n\n    /* Get value of node at index i */\n    public Integer val(int i) {\n        // If index out of bounds, return null to represent empty position\n        if (i &lt; 0 || i &gt;= size())\n            return null;\n        return tree.get(i);\n    }\n\n    /* Get index of left child node of node at index i */\n    public Integer left(int i) {\n        return 2 * i + 1;\n    }\n\n    /* Get index of right child node of node at index i */\n    public Integer right(int i) {\n        return 2 * i + 2;\n    }\n\n    /* Get index of parent node of node at index i */\n    public Integer parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    /* Level-order traversal */\n    public List&lt;Integer&gt; levelOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        // Traverse array directly\n        for (int i = 0; i &lt; size(); i++) {\n            if (val(i) != null)\n                res.add(val(i));\n        }\n        return res;\n    }\n\n    /* Depth-first traversal */\n    private void dfs(Integer i, String order, List&lt;Integer&gt; res) {\n        // If empty position, return\n        if (val(i) == null)\n            return;\n        // Preorder traversal\n        if (\"pre\".equals(order))\n            res.add(val(i));\n        dfs(left(i), order, res);\n        // Inorder traversal\n        if (\"in\".equals(order))\n            res.add(val(i));\n        dfs(right(i), order, res);\n        // Postorder traversal\n        if (\"post\".equals(order))\n            res.add(val(i));\n    }\n\n    /* Preorder traversal */\n    public List&lt;Integer&gt; preOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        dfs(0, \"pre\", res);\n        return res;\n    }\n\n    /* Inorder traversal */\n    public List&lt;Integer&gt; inOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        dfs(0, \"in\", res);\n        return res;\n    }\n\n    /* Postorder traversal */\n    public List&lt;Integer&gt; postOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        dfs(0, \"post\", res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.cs<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree(List&lt;int?&gt; arr) {\n    List&lt;int?&gt; tree = new(arr);\n\n    /* List capacity */\n    public int Size() {\n        return tree.Count;\n    }\n\n    /* Get value of node at index i */\n    public int? Val(int i) {\n        // If index out of bounds, return null to represent empty position\n        if (i &lt; 0 || i &gt;= Size())\n            return null;\n        return tree[i];\n    }\n\n    /* Get index of left child node of node at index i */\n    public int Left(int i) {\n        return 2 * i + 1;\n    }\n\n    /* Get index of right child node of node at index i */\n    public int Right(int i) {\n        return 2 * i + 2;\n    }\n\n    /* Get index of parent node of node at index i */\n    public int Parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    /* Level-order traversal */\n    public List&lt;int&gt; LevelOrder() {\n        List&lt;int&gt; res = [];\n        // Traverse array directly\n        for (int i = 0; i &lt; Size(); i++) {\n            if (Val(i).HasValue)\n                res.Add(Val(i)!.Value);\n        }\n        return res;\n    }\n\n    /* Depth-first traversal */\n    void DFS(int i, string order, List&lt;int&gt; res) {\n        // If empty position, return\n        if (!Val(i).HasValue)\n            return;\n        // Preorder traversal\n        if (order == \"pre\")\n            res.Add(Val(i)!.Value);\n        DFS(Left(i), order, res);\n        // Inorder traversal\n        if (order == \"in\")\n            res.Add(Val(i)!.Value);\n        DFS(Right(i), order, res);\n        // Postorder traversal\n        if (order == \"post\")\n            res.Add(Val(i)!.Value);\n    }\n\n    /* Preorder traversal */\n    public List&lt;int&gt; PreOrder() {\n        List&lt;int&gt; res = [];\n        DFS(0, \"pre\", res);\n        return res;\n    }\n\n    /* Inorder traversal */\n    public List&lt;int&gt; InOrder() {\n        List&lt;int&gt; res = [];\n        DFS(0, \"in\", res);\n        return res;\n    }\n\n    /* Postorder traversal */\n    public List&lt;int&gt; PostOrder() {\n        List&lt;int&gt; res = [];\n        DFS(0, \"post\", res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.go<pre><code>/* Binary tree class represented by array */\ntype arrayBinaryTree struct {\n    tree []any\n}\n\n/* Constructor */\nfunc newArrayBinaryTree(arr []any) *arrayBinaryTree {\n    return &amp;arrayBinaryTree{\n        tree: arr,\n    }\n}\n\n/* List capacity */\nfunc (abt *arrayBinaryTree) size() int {\n    return len(abt.tree)\n}\n\n/* Get value of node at index i */\nfunc (abt *arrayBinaryTree) val(i int) any {\n    // If index out of bounds, return null to represent empty position\n    if i &lt; 0 || i &gt;= abt.size() {\n        return nil\n    }\n    return abt.tree[i]\n}\n\n/* Get index of left child node of node at index i */\nfunc (abt *arrayBinaryTree) left(i int) int {\n    return 2*i + 1\n}\n\n/* Get index of right child node of node at index i */\nfunc (abt *arrayBinaryTree) right(i int) int {\n    return 2*i + 2\n}\n\n/* Get index of parent node of node at index i */\nfunc (abt *arrayBinaryTree) parent(i int) int {\n    return (i - 1) / 2\n}\n\n/* Level-order traversal */\nfunc (abt *arrayBinaryTree) levelOrder() []any {\n    var res []any\n    // Traverse array directly\n    for i := 0; i &lt; abt.size(); i++ {\n        if abt.val(i) != nil {\n            res = append(res, abt.val(i))\n        }\n    }\n    return res\n}\n\n/* Depth-first traversal */\nfunc (abt *arrayBinaryTree) dfs(i int, order string, res *[]any) {\n    // If empty position, return\n    if abt.val(i) == nil {\n        return\n    }\n    // Preorder traversal\n    if order == \"pre\" {\n        *res = append(*res, abt.val(i))\n    }\n    abt.dfs(abt.left(i), order, res)\n    // Inorder traversal\n    if order == \"in\" {\n        *res = append(*res, abt.val(i))\n    }\n    abt.dfs(abt.right(i), order, res)\n    // Postorder traversal\n    if order == \"post\" {\n        *res = append(*res, abt.val(i))\n    }\n}\n\n/* Preorder traversal */\nfunc (abt *arrayBinaryTree) preOrder() []any {\n    var res []any\n    abt.dfs(0, \"pre\", &amp;res)\n    return res\n}\n\n/* Inorder traversal */\nfunc (abt *arrayBinaryTree) inOrder() []any {\n    var res []any\n    abt.dfs(0, \"in\", &amp;res)\n    return res\n}\n\n/* Postorder traversal */\nfunc (abt *arrayBinaryTree) postOrder() []any {\n    var res []any\n    abt.dfs(0, \"post\", &amp;res)\n    return res\n}\n</code></pre> array_binary_tree.swift<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree {\n    private var tree: [Int?]\n\n    /* Constructor */\n    init(arr: [Int?]) {\n        tree = arr\n    }\n\n    /* List capacity */\n    func size() -&gt; Int {\n        tree.count\n    }\n\n    /* Get value of node at index i */\n    func val(i: Int) -&gt; Int? {\n        // If index out of bounds, return null to represent empty position\n        if i &lt; 0 || i &gt;= size() {\n            return nil\n        }\n        return tree[i]\n    }\n\n    /* Get index of left child node of node at index i */\n    func left(i: Int) -&gt; Int {\n        2 * i + 1\n    }\n\n    /* Get index of right child node of node at index i */\n    func right(i: Int) -&gt; Int {\n        2 * i + 2\n    }\n\n    /* Get index of parent node of node at index i */\n    func parent(i: Int) -&gt; Int {\n        (i - 1) / 2\n    }\n\n    /* Level-order traversal */\n    func levelOrder() -&gt; [Int] {\n        var res: [Int] = []\n        // Traverse array directly\n        for i in 0 ..&lt; size() {\n            if let val = val(i: i) {\n                res.append(val)\n            }\n        }\n        return res\n    }\n\n    /* Depth-first traversal */\n    private func dfs(i: Int, order: String, res: inout [Int]) {\n        // If empty position, return\n        guard let val = val(i: i) else {\n            return\n        }\n        // Preorder traversal\n        if order == \"pre\" {\n            res.append(val)\n        }\n        dfs(i: left(i: i), order: order, res: &amp;res)\n        // Inorder traversal\n        if order == \"in\" {\n            res.append(val)\n        }\n        dfs(i: right(i: i), order: order, res: &amp;res)\n        // Postorder traversal\n        if order == \"post\" {\n            res.append(val)\n        }\n    }\n\n    /* Preorder traversal */\n    func preOrder() -&gt; [Int] {\n        var res: [Int] = []\n        dfs(i: 0, order: \"pre\", res: &amp;res)\n        return res\n    }\n\n    /* Inorder traversal */\n    func inOrder() -&gt; [Int] {\n        var res: [Int] = []\n        dfs(i: 0, order: \"in\", res: &amp;res)\n        return res\n    }\n\n    /* Postorder traversal */\n    func postOrder() -&gt; [Int] {\n        var res: [Int] = []\n        dfs(i: 0, order: \"post\", res: &amp;res)\n        return res\n    }\n}\n</code></pre> array_binary_tree.js<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree {\n    #tree;\n\n    /* Constructor */\n    constructor(arr) {\n        this.#tree = arr;\n    }\n\n    /* List capacity */\n    size() {\n        return this.#tree.length;\n    }\n\n    /* Get value of node at index i */\n    val(i) {\n        // If index out of bounds, return null to represent empty position\n        if (i &lt; 0 || i &gt;= this.size()) return null;\n        return this.#tree[i];\n    }\n\n    /* Get index of left child node of node at index i */\n    left(i) {\n        return 2 * i + 1;\n    }\n\n    /* Get index of right child node of node at index i */\n    right(i) {\n        return 2 * i + 2;\n    }\n\n    /* Get index of parent node of node at index i */\n    parent(i) {\n        return Math.floor((i - 1) / 2); // Floor division\n    }\n\n    /* Level-order traversal */\n    levelOrder() {\n        let res = [];\n        // Traverse array directly\n        for (let i = 0; i &lt; this.size(); i++) {\n            if (this.val(i) !== null) res.push(this.val(i));\n        }\n        return res;\n    }\n\n    /* Depth-first traversal */\n    #dfs(i, order, res) {\n        // If empty position, return\n        if (this.val(i) === null) return;\n        // Preorder traversal\n        if (order === 'pre') res.push(this.val(i));\n        this.#dfs(this.left(i), order, res);\n        // Inorder traversal\n        if (order === 'in') res.push(this.val(i));\n        this.#dfs(this.right(i), order, res);\n        // Postorder traversal\n        if (order === 'post') res.push(this.val(i));\n    }\n\n    /* Preorder traversal */\n    preOrder() {\n        const res = [];\n        this.#dfs(0, 'pre', res);\n        return res;\n    }\n\n    /* Inorder traversal */\n    inOrder() {\n        const res = [];\n        this.#dfs(0, 'in', res);\n        return res;\n    }\n\n    /* Postorder traversal */\n    postOrder() {\n        const res = [];\n        this.#dfs(0, 'post', res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.ts<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree {\n    #tree: (number | null)[];\n\n    /* Constructor */\n    constructor(arr: (number | null)[]) {\n        this.#tree = arr;\n    }\n\n    /* List capacity */\n    size(): number {\n        return this.#tree.length;\n    }\n\n    /* Get value of node at index i */\n    val(i: number): number | null {\n        // If index out of bounds, return null to represent empty position\n        if (i &lt; 0 || i &gt;= this.size()) return null;\n        return this.#tree[i];\n    }\n\n    /* Get index of left child node of node at index i */\n    left(i: number): number {\n        return 2 * i + 1;\n    }\n\n    /* Get index of right child node of node at index i */\n    right(i: number): number {\n        return 2 * i + 2;\n    }\n\n    /* Get index of parent node of node at index i */\n    parent(i: number): number {\n        return Math.floor((i - 1) / 2); // Floor division\n    }\n\n    /* Level-order traversal */\n    levelOrder(): number[] {\n        let res = [];\n        // Traverse array directly\n        for (let i = 0; i &lt; this.size(); i++) {\n            if (this.val(i) !== null) res.push(this.val(i));\n        }\n        return res;\n    }\n\n    /* Depth-first traversal */\n    #dfs(i: number, order: Order, res: (number | null)[]): void {\n        // If empty position, return\n        if (this.val(i) === null) return;\n        // Preorder traversal\n        if (order === 'pre') res.push(this.val(i));\n        this.#dfs(this.left(i), order, res);\n        // Inorder traversal\n        if (order === 'in') res.push(this.val(i));\n        this.#dfs(this.right(i), order, res);\n        // Postorder traversal\n        if (order === 'post') res.push(this.val(i));\n    }\n\n    /* Preorder traversal */\n    preOrder(): (number | null)[] {\n        const res = [];\n        this.#dfs(0, 'pre', res);\n        return res;\n    }\n\n    /* Inorder traversal */\n    inOrder(): (number | null)[] {\n        const res = [];\n        this.#dfs(0, 'in', res);\n        return res;\n    }\n\n    /* Postorder traversal */\n    postOrder(): (number | null)[] {\n        const res = [];\n        this.#dfs(0, 'post', res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.dart<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree {\n  late List&lt;int?&gt; _tree;\n\n  /* Constructor */\n  ArrayBinaryTree(this._tree);\n\n  /* List capacity */\n  int size() {\n    return _tree.length;\n  }\n\n  /* Get value of node at index i */\n  int? val(int i) {\n    // If index out of bounds, return null to represent empty position\n    if (i &lt; 0 || i &gt;= size()) {\n      return null;\n    }\n    return _tree[i];\n  }\n\n  /* Get index of left child node of node at index i */\n  int? left(int i) {\n    return 2 * i + 1;\n  }\n\n  /* Get index of right child node of node at index i */\n  int? right(int i) {\n    return 2 * i + 2;\n  }\n\n  /* Get index of parent node of node at index i */\n  int? parent(int i) {\n    return (i - 1) ~/ 2;\n  }\n\n  /* Level-order traversal */\n  List&lt;int&gt; levelOrder() {\n    List&lt;int&gt; res = [];\n    for (int i = 0; i &lt; size(); i++) {\n      if (val(i) != null) {\n        res.add(val(i)!);\n      }\n    }\n    return res;\n  }\n\n  /* Depth-first traversal */\n  void dfs(int i, String order, List&lt;int?&gt; res) {\n    // If empty position, return\n    if (val(i) == null) {\n      return;\n    }\n    // Preorder traversal\n    if (order == 'pre') {\n      res.add(val(i));\n    }\n    dfs(left(i)!, order, res);\n    // Inorder traversal\n    if (order == 'in') {\n      res.add(val(i));\n    }\n    dfs(right(i)!, order, res);\n    // Postorder traversal\n    if (order == 'post') {\n      res.add(val(i));\n    }\n  }\n\n  /* Preorder traversal */\n  List&lt;int?&gt; preOrder() {\n    List&lt;int?&gt; res = [];\n    dfs(0, 'pre', res);\n    return res;\n  }\n\n  /* Inorder traversal */\n  List&lt;int?&gt; inOrder() {\n    List&lt;int?&gt; res = [];\n    dfs(0, 'in', res);\n    return res;\n  }\n\n  /* Postorder traversal */\n  List&lt;int?&gt; postOrder() {\n    List&lt;int?&gt; res = [];\n    dfs(0, 'post', res);\n    return res;\n  }\n}\n</code></pre> array_binary_tree.rs<pre><code>/* Binary tree class represented by array */\nstruct ArrayBinaryTree {\n    tree: Vec&lt;Option&lt;i32&gt;&gt;,\n}\n\nimpl ArrayBinaryTree {\n    /* Constructor */\n    fn new(arr: Vec&lt;Option&lt;i32&gt;&gt;) -&gt; Self {\n        Self { tree: arr }\n    }\n\n    /* List capacity */\n    fn size(&amp;self) -&gt; i32 {\n        self.tree.len() as i32\n    }\n\n    /* Get value of node at index i */\n    fn val(&amp;self, i: i32) -&gt; Option&lt;i32&gt; {\n        // If index is out of bounds, return None, representing empty position\n        if i &lt; 0 || i &gt;= self.size() {\n            None\n        } else {\n            self.tree[i as usize]\n        }\n    }\n\n    /* Get index of left child node of node at index i */\n    fn left(&amp;self, i: i32) -&gt; i32 {\n        2 * i + 1\n    }\n\n    /* Get index of right child node of node at index i */\n    fn right(&amp;self, i: i32) -&gt; i32 {\n        2 * i + 2\n    }\n\n    /* Get index of parent node of node at index i */\n    fn parent(&amp;self, i: i32) -&gt; i32 {\n        (i - 1) / 2\n    }\n\n    /* Level-order traversal */\n    fn level_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        self.tree.iter().filter_map(|&amp;x| x).collect()\n    }\n\n    /* Depth-first traversal */\n    fn dfs(&amp;self, i: i32, order: &amp;'static str, res: &amp;mut Vec&lt;i32&gt;) {\n        if self.val(i).is_none() {\n            return;\n        }\n        let val = self.val(i).unwrap();\n        // Preorder traversal\n        if order == \"pre\" {\n            res.push(val);\n        }\n        self.dfs(self.left(i), order, res);\n        // Inorder traversal\n        if order == \"in\" {\n            res.push(val);\n        }\n        self.dfs(self.right(i), order, res);\n        // Postorder traversal\n        if order == \"post\" {\n            res.push(val);\n        }\n    }\n\n    /* Preorder traversal */\n    fn pre_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let mut res = vec![];\n        self.dfs(0, \"pre\", &amp;mut res);\n        res\n    }\n\n    /* Inorder traversal */\n    fn in_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let mut res = vec![];\n        self.dfs(0, \"in\", &amp;mut res);\n        res\n    }\n\n    /* Postorder traversal */\n    fn post_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let mut res = vec![];\n        self.dfs(0, \"post\", &amp;mut res);\n        res\n    }\n}\n</code></pre> array_binary_tree.c<pre><code>/* Binary tree structure in array representation */\ntypedef struct {\n    int *tree;\n    int size;\n} ArrayBinaryTree;\n\n/* Constructor */\nArrayBinaryTree *newArrayBinaryTree(int *arr, int arrSize) {\n    ArrayBinaryTree *abt = (ArrayBinaryTree *)malloc(sizeof(ArrayBinaryTree));\n    abt-&gt;tree = malloc(sizeof(int) * arrSize);\n    memcpy(abt-&gt;tree, arr, sizeof(int) * arrSize);\n    abt-&gt;size = arrSize;\n    return abt;\n}\n\n/* Destructor */\nvoid delArrayBinaryTree(ArrayBinaryTree *abt) {\n    free(abt-&gt;tree);\n    free(abt);\n}\n\n/* List capacity */\nint size(ArrayBinaryTree *abt) {\n    return abt-&gt;size;\n}\n\n/* Get value of node at index i */\nint val(ArrayBinaryTree *abt, int i) {\n    // Return INT_MAX if index out of bounds, representing empty position\n    if (i &lt; 0 || i &gt;= size(abt))\n        return INT_MAX;\n    return abt-&gt;tree[i];\n}\n\n/* Level-order traversal */\nint *levelOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    // Traverse array directly\n    for (int i = 0; i &lt; size(abt); i++) {\n        if (val(abt, i) != INT_MAX)\n            res[index++] = val(abt, i);\n    }\n    *returnSize = index;\n    return res;\n}\n\n/* Depth-first traversal */\nvoid dfs(ArrayBinaryTree *abt, int i, char *order, int *res, int *index) {\n    // If empty position, return\n    if (val(abt, i) == INT_MAX)\n        return;\n    // Preorder traversal\n    if (strcmp(order, \"pre\") == 0)\n        res[(*index)++] = val(abt, i);\n    dfs(abt, left(i), order, res, index);\n    // Inorder traversal\n    if (strcmp(order, \"in\") == 0)\n        res[(*index)++] = val(abt, i);\n    dfs(abt, right(i), order, res, index);\n    // Postorder traversal\n    if (strcmp(order, \"post\") == 0)\n        res[(*index)++] = val(abt, i);\n}\n\n/* Preorder traversal */\nint *preOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    dfs(abt, 0, \"pre\", res, &amp;index);\n    *returnSize = index;\n    return res;\n}\n\n/* Inorder traversal */\nint *inOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    dfs(abt, 0, \"in\", res, &amp;index);\n    *returnSize = index;\n    return res;\n}\n\n/* Postorder traversal */\nint *postOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    dfs(abt, 0, \"post\", res, &amp;index);\n    *returnSize = index;\n    return res;\n}\n</code></pre> array_binary_tree.kt<pre><code>/* Binary tree class represented by array */\nclass ArrayBinaryTree(val tree: MutableList&lt;Int?&gt;) {\n    /* List capacity */\n    fun size(): Int {\n        return tree.size\n    }\n\n    /* Get value of node at index i */\n    fun _val(i: Int): Int? {\n        // If index out of bounds, return null to represent empty position\n        if (i &lt; 0 || i &gt;= size()) return null\n        return tree[i]\n    }\n\n    /* Get index of left child node of node at index i */\n    fun left(i: Int): Int {\n        return 2 * i + 1\n    }\n\n    /* Get index of right child node of node at index i */\n    fun right(i: Int): Int {\n        return 2 * i + 2\n    }\n\n    /* Get index of parent node of node at index i */\n    fun parent(i: Int): Int {\n        return (i - 1) / 2\n    }\n\n    /* Level-order traversal */\n    fun levelOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        // Traverse array directly\n        for (i in 0..&lt;size()) {\n            if (_val(i) != null)\n                res.add(_val(i))\n        }\n        return res\n    }\n\n    /* Depth-first traversal */\n    fun dfs(i: Int, order: String, res: MutableList&lt;Int?&gt;) {\n        // If empty position, return\n        if (_val(i) == null)\n            return\n        // Preorder traversal\n        if (\"pre\" == order)\n            res.add(_val(i))\n        dfs(left(i), order, res)\n        // Inorder traversal\n        if (\"in\" == order)\n            res.add(_val(i))\n        dfs(right(i), order, res)\n        // Postorder traversal\n        if (\"post\" == order)\n            res.add(_val(i))\n    }\n\n    /* Preorder traversal */\n    fun preOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        dfs(0, \"pre\", res)\n        return res\n    }\n\n    /* Inorder traversal */\n    fun inOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        dfs(0, \"in\", res)\n        return res\n    }\n\n    /* Postorder traversal */\n    fun postOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        dfs(0, \"post\", res)\n        return res\n    }\n}\n</code></pre> array_binary_tree.rb<pre><code>### Array representation of binary tree class ###\nclass ArrayBinaryTree\n  ### Constructor ###\n  def initialize(arr)\n    @tree = arr.to_a\n  end\n\n  ### List capacity ###\n  def size\n    @tree.length\n  end\n\n  ### Get value of node at index i ###\n  def val(i)\n    # Return nil if index out of bounds, representing empty position\n    return if i &lt; 0 || i &gt;= size\n\n    @tree[i]\n  end\n\n  ### Get left child index of node at index i ###\n  def left(i)\n    2 * i + 1\n  end\n\n  ### Get right child index of node at index i ###\n  def right(i)\n    2 * i + 2\n  end\n\n  ### Get parent node index of node at index i ###\n  def parent(i)\n    (i - 1) / 2\n  end\n\n  ### Level-order traversal ###\n  def level_order\n    @res = []\n\n    # Traverse array directly\n    for i in 0...size\n      @res &lt;&lt; val(i) unless val(i).nil?\n    end\n\n    @res\n  end\n\n  ### Depth-first traversal ###\n  def dfs(i, order)\n    return if val(i).nil?\n    # Preorder traversal\n    @res &lt;&lt; val(i) if order == :pre\n    dfs(left(i), order)\n    # Inorder traversal\n    @res &lt;&lt; val(i) if order == :in\n    dfs(right(i), order)\n    # Postorder traversal\n    @res &lt;&lt; val(i) if order == :post\n  end\n\n  ### Pre-order traversal ###\n  def pre_order\n    @res = []\n    dfs(0, :pre)\n    @res\n  end\n\n  ### In-order traversal ###\n  def in_order\n    @res = []\n    dfs(0, :in)\n    @res\n  end\n\n  ### Post-order traversal ###\n  def post_order\n    @res = []\n    dfs(0, :post)\n    @res\n  end\nend\n</code></pre>"},{"location":"chapter_tree/array_representation_of_tree/#733-advantages-and-limitations","title":"7.3.3 \u00a0 Advantages and Limitations","text":"<p>The array representation of binary trees has the following advantages:</p> <ul> <li>Arrays are stored in contiguous memory space, which is cache-friendly, allowing faster access and traversal.</li> <li>It does not require storing pointers, which saves space.</li> <li>It allows random access to nodes.</li> </ul> <p>However, the array representation also has some limitations:</p> <ul> <li>Array storage requires contiguous memory space, so it is not suitable for storing trees with a large amount of data.</li> <li>Adding or removing nodes requires array insertion and deletion operations, which have lower efficiency.</li> <li>When there are many <code>None</code> values in the binary tree, the proportion of node data contained in the array is low, leading to lower space utilization.</li> </ul>"},{"location":"chapter_tree/avl_tree/","title":"7.5 \u00a0 Avl Tree *","text":"<p>In the \"Binary Search Tree\" section, we mentioned that after multiple insertion and removal operations, a binary search tree may degenerate into a linked list. In this case, the time complexity of all operations degrades from \\(O(\\log n)\\) to \\(O(n)\\).</p> <p>As shown in Figure 7-24, after two node removal operations, this binary search tree will degrade into a linked list.</p> <p></p> <p> Figure 7-24 \u00a0 Degradation of an AVL tree after removing nodes </p> <p>For example, in the perfect binary tree shown in Figure 7-25, after inserting two nodes, the tree will lean heavily to the left, and the time complexity of search operations will also degrade.</p> <p></p> <p> Figure 7-25 \u00a0 Degradation of an AVL tree after inserting nodes </p> <p>In 1962, G. M. Adelson-Velsky and E. M. Landis proposed the AVL tree in their paper \"An algorithm for the organization of information\". The paper described in detail a series of operations ensuring that after continuously adding and removing nodes, the AVL tree does not degenerate, thus keeping the time complexity of various operations at the \\(O(\\log n)\\) level. In other words, in scenarios requiring frequent insertions, deletions, searches, and modifications, the AVL tree can always maintain efficient data operation performance, making it very valuable in applications.</p>"},{"location":"chapter_tree/avl_tree/#751-common-terminology-in-avl-trees","title":"7.5.1 \u00a0 Common Terminology in Avl Trees","text":"<p>An AVL tree is both a binary search tree and a balanced binary tree, simultaneously satisfying all the properties of these two types of binary trees, hence it is a balanced binary search tree.</p>"},{"location":"chapter_tree/avl_tree/#1-node-height","title":"1. \u00a0 Node Height","text":"<p>Since the operations related to AVL trees require obtaining node heights, we need to add a <code>height</code> variable to the node class:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>class TreeNode:\n    \"\"\"AVL tree node\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                 # Node value\n        self.height: int = 0                # Node height\n        self.left: TreeNode | None = None   # Left child reference\n        self.right: TreeNode | None = None  # Right child reference\n</code></pre> <pre><code>/* AVL tree node */\nstruct TreeNode {\n    int val{};          // Node value\n    int height = 0;     // Node height\n    TreeNode *left{};   // Left child\n    TreeNode *right{};  // Right child\n    TreeNode() = default;\n    explicit TreeNode(int x) : val(x){}\n};\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    public int val;        // Node value\n    public int height;     // Node height\n    public TreeNode left;  // Left child\n    public TreeNode right; // Right child\n    public TreeNode(int x) { val = x; }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode(int? x) {\n    public int? val = x;    // Node value\n    public int height;      // Node height\n    public TreeNode? left;  // Left child reference\n    public TreeNode? right; // Right child reference\n}\n</code></pre> <pre><code>/* AVL tree node */\ntype TreeNode struct {\n    Val    int       // Node value\n    Height int       // Node height\n    Left   *TreeNode // Left child reference\n    Right  *TreeNode // Right child reference\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    var val: Int // Node value\n    var height: Int // Node height\n    var left: TreeNode? // Left child\n    var right: TreeNode? // Right child\n\n    init(x: Int) {\n        val = x\n        height = 0\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    val; // Node value\n    height; // Node height\n    left; // Left child pointer\n    right; // Right child pointer\n    constructor(val, left, right, height) {\n        this.val = val === undefined ? 0 : val;\n        this.height = height === undefined ? 0 : height;\n        this.left = left === undefined ? null : left;\n        this.right = right === undefined ? null : right;\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    val: number;            // Node value\n    height: number;         // Node height\n    left: TreeNode | null;  // Left child pointer\n    right: TreeNode | null; // Right child pointer\n    constructor(val?: number, height?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val;\n        this.height = height === undefined ? 0 : height; \n        this.left = left === undefined ? null : left; \n        this.right = right === undefined ? null : right; \n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n  int val;         // Node value\n  int height;      // Node height\n  TreeNode? left;  // Left child\n  TreeNode? right; // Right child\n  TreeNode(this.val, [this.height = 0, this.left, this.right]);\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* AVL tree node */\nstruct TreeNode {\n    val: i32,                               // Node value\n    height: i32,                            // Node height\n    left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,    // Left child\n    right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,   // Right child\n}\n\nimpl TreeNode {\n    /* Constructor */\n    fn new(val: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {\n        Rc::new(RefCell::new(Self {\n            val,\n            height: 0,\n            left: None,\n            right: None\n        }))\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\ntypedef struct TreeNode {\n    int val;\n    int height;\n    struct TreeNode *left;\n    struct TreeNode *right;\n} TreeNode;\n\n/* Constructor */\nTreeNode *newTreeNode(int val) {\n    TreeNode *node;\n\n    node = (TreeNode *)malloc(sizeof(TreeNode));\n    node-&gt;val = val;\n    node-&gt;height = 0;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode(val _val: Int) {  // Node value\n    val height: Int = 0          // Node height\n    val left: TreeNode? = null   // Left child\n    val right: TreeNode? = null  // Right child\n}\n</code></pre> <pre><code>### AVL tree node class ###\nclass TreeNode\n  attr_accessor :val    # Node value\n  attr_accessor :height # Node height\n  attr_accessor :left   # Left child reference\n  attr_accessor :right  # Right child reference\n\n  def initialize(val)\n    @val = val\n    @height = 0\n  end\nend\n</code></pre> <p>The \"node height\" refers to the distance from that node to its farthest leaf node, i.e., the number of \"edges\" passed. It is important to note that the height of a leaf node is \\(0\\), and the height of a null node is \\(-1\\). We will create two utility functions for getting and updating the height of a node:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby avl_tree.py<pre><code>def height(self, node: TreeNode | None) -&gt; int:\n    \"\"\"Get node height\"\"\"\n    # Empty node height is -1, leaf node height is 0\n    if node is not None:\n        return node.height\n    return -1\n\ndef update_height(self, node: TreeNode | None):\n    \"\"\"Update node height\"\"\"\n    # Node height equals the height of the tallest subtree + 1\n    node.height = max([self.height(node.left), self.height(node.right)]) + 1\n</code></pre> avl_tree.cpp<pre><code>/* Get node height */\nint height(TreeNode *node) {\n    // Empty node height is -1, leaf node height is 0\n    return node == nullptr ? -1 : node-&gt;height;\n}\n\n/* Update node height */\nvoid updateHeight(TreeNode *node) {\n    // Node height equals the height of the tallest subtree + 1\n    node-&gt;height = max(height(node-&gt;left), height(node-&gt;right)) + 1;\n}\n</code></pre> avl_tree.java<pre><code>/* Get node height */\nint height(TreeNode node) {\n    // Empty node height is -1, leaf node height is 0\n    return node == null ? -1 : node.height;\n}\n\n/* Update node height */\nvoid updateHeight(TreeNode node) {\n    // Node height equals the height of the tallest subtree + 1\n    node.height = Math.max(height(node.left), height(node.right)) + 1;\n}\n</code></pre> avl_tree.cs<pre><code>/* Get node height */\nint Height(TreeNode? node) {\n    // Empty node height is -1, leaf node height is 0\n    return node == null ? -1 : node.height;\n}\n\n/* Update node height */\nvoid UpdateHeight(TreeNode node) {\n    // Node height equals the height of the tallest subtree + 1\n    node.height = Math.Max(Height(node.left), Height(node.right)) + 1;\n}\n</code></pre> avl_tree.go<pre><code>/* Get node height */\nfunc (t *aVLTree) height(node *TreeNode) int {\n    // Empty node height is -1, leaf node height is 0\n    if node != nil {\n        return node.Height\n    }\n    return -1\n}\n\n/* Update node height */\nfunc (t *aVLTree) updateHeight(node *TreeNode) {\n    lh := t.height(node.Left)\n    rh := t.height(node.Right)\n    // Node height equals the height of the tallest subtree + 1\n    if lh &gt; rh {\n        node.Height = lh + 1\n    } else {\n        node.Height = rh + 1\n    }\n}\n</code></pre> avl_tree.swift<pre><code>/* Get node height */\nfunc height(node: TreeNode?) -&gt; Int {\n    // Empty node height is -1, leaf node height is 0\n    node?.height ?? -1\n}\n\n/* Update node height */\nfunc updateHeight(node: TreeNode?) {\n    // Node height equals the height of the tallest subtree + 1\n    node?.height = max(height(node: node?.left), height(node: node?.right)) + 1\n}\n</code></pre> avl_tree.js<pre><code>/* Get node height */\nheight(node) {\n    // Empty node height is -1, leaf node height is 0\n    return node === null ? -1 : node.height;\n}\n\n/* Update node height */\n#updateHeight(node) {\n    // Node height equals the height of the tallest subtree + 1\n    node.height =\n        Math.max(this.height(node.left), this.height(node.right)) + 1;\n}\n</code></pre> avl_tree.ts<pre><code>/* Get node height */\nheight(node: TreeNode): number {\n    // Empty node height is -1, leaf node height is 0\n    return node === null ? -1 : node.height;\n}\n\n/* Update node height */\nupdateHeight(node: TreeNode): void {\n    // Node height equals the height of the tallest subtree + 1\n    node.height =\n        Math.max(this.height(node.left), this.height(node.right)) + 1;\n}\n</code></pre> avl_tree.dart<pre><code>/* Get node height */\nint height(TreeNode? node) {\n  // Empty node height is -1, leaf node height is 0\n  return node == null ? -1 : node.height;\n}\n\n/* Update node height */\nvoid updateHeight(TreeNode? node) {\n  // Node height equals the height of the tallest subtree + 1\n  node!.height = max(height(node.left), height(node.right)) + 1;\n}\n</code></pre> avl_tree.rs<pre><code>/* Get node height */\nfn height(node: OptionTreeNodeRc) -&gt; i32 {\n    // Empty node height is -1, leaf node height is 0\n    match node {\n        Some(node) =&gt; node.borrow().height,\n        None =&gt; -1,\n    }\n}\n\n/* Update node height */\nfn update_height(node: OptionTreeNodeRc) {\n    if let Some(node) = node {\n        let left = node.borrow().left.clone();\n        let right = node.borrow().right.clone();\n        // Node height equals the height of the tallest subtree + 1\n        node.borrow_mut().height = std::cmp::max(Self::height(left), Self::height(right)) + 1;\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* Get node height */\nint height(TreeNode *node) {\n    // Empty node height is -1, leaf node height is 0\n    if (node != NULL) {\n        return node-&gt;height;\n    }\n    return -1;\n}\n\n/* Update node height */\nvoid updateHeight(TreeNode *node) {\n    int lh = height(node-&gt;left);\n    int rh = height(node-&gt;right);\n    // Node height equals the height of the tallest subtree + 1\n    if (lh &gt; rh) {\n        node-&gt;height = lh + 1;\n    } else {\n        node-&gt;height = rh + 1;\n    }\n}\n</code></pre> avl_tree.kt<pre><code>/* Get node height */\nfun height(node: TreeNode?): Int {\n    // Empty node height is -1, leaf node height is 0\n    return node?.height ?: -1\n}\n\n/* Update node height */\nfun updateHeight(node: TreeNode?) {\n    // Node height equals the height of the tallest subtree + 1\n    node?.height = max(height(node?.left), height(node?.right)) + 1\n}\n</code></pre> avl_tree.rb<pre><code>### Get node height ###\ndef height(node)\n  # Empty node height is -1, leaf node height is 0\n  return node.height unless node.nil?\n\n  -1\nend\n\n### Update node height ###\ndef update_height(node)\n  # Node height equals the height of the tallest subtree + 1\n  node.height = [height(node.left), height(node.right)].max + 1\nend\n</code></pre>"},{"location":"chapter_tree/avl_tree/#2-node-balance-factor","title":"2. \u00a0 Node Balance Factor","text":"<p>The balance factor of a node is defined as the height of the node's left subtree minus the height of its right subtree, and the balance factor of a null node is defined as \\(0\\). We also encapsulate the function to obtain the node's balance factor for convenient subsequent use:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby avl_tree.py<pre><code>def balance_factor(self, node: TreeNode | None) -&gt; int:\n    \"\"\"Get balance factor\"\"\"\n    # Empty node balance factor is 0\n    if node is None:\n        return 0\n    # Node balance factor = left subtree height - right subtree height\n    return self.height(node.left) - self.height(node.right)\n</code></pre> avl_tree.cpp<pre><code>/* Get balance factor */\nint balanceFactor(TreeNode *node) {\n    // Empty node balance factor is 0\n    if (node == nullptr)\n        return 0;\n    // Node balance factor = left subtree height - right subtree height\n    return height(node-&gt;left) - height(node-&gt;right);\n}\n</code></pre> avl_tree.java<pre><code>/* Get balance factor */\nint balanceFactor(TreeNode node) {\n    // Empty node balance factor is 0\n    if (node == null)\n        return 0;\n    // Node balance factor = left subtree height - right subtree height\n    return height(node.left) - height(node.right);\n}\n</code></pre> avl_tree.cs<pre><code>/* Get balance factor */\nint BalanceFactor(TreeNode? node) {\n    // Empty node balance factor is 0\n    if (node == null) return 0;\n    // Node balance factor = left subtree height - right subtree height\n    return Height(node.left) - Height(node.right);\n}\n</code></pre> avl_tree.go<pre><code>/* Get balance factor */\nfunc (t *aVLTree) balanceFactor(node *TreeNode) int {\n    // Empty node balance factor is 0\n    if node == nil {\n        return 0\n    }\n    // Node balance factor = left subtree height - right subtree height\n    return t.height(node.Left) - t.height(node.Right)\n}\n</code></pre> avl_tree.swift<pre><code>/* Get balance factor */\nfunc balanceFactor(node: TreeNode?) -&gt; Int {\n    // Empty node balance factor is 0\n    guard let node = node else { return 0 }\n    // Node balance factor = left subtree height - right subtree height\n    return height(node: node.left) - height(node: node.right)\n}\n</code></pre> avl_tree.js<pre><code>/* Get balance factor */\nbalanceFactor(node) {\n    // Empty node balance factor is 0\n    if (node === null) return 0;\n    // Node balance factor = left subtree height - right subtree height\n    return this.height(node.left) - this.height(node.right);\n}\n</code></pre> avl_tree.ts<pre><code>/* Get balance factor */\nbalanceFactor(node: TreeNode): number {\n    // Empty node balance factor is 0\n    if (node === null) return 0;\n    // Node balance factor = left subtree height - right subtree height\n    return this.height(node.left) - this.height(node.right);\n}\n</code></pre> avl_tree.dart<pre><code>/* Get balance factor */\nint balanceFactor(TreeNode? node) {\n  // Empty node balance factor is 0\n  if (node == null) return 0;\n  // Node balance factor = left subtree height - right subtree height\n  return height(node.left) - height(node.right);\n}\n</code></pre> avl_tree.rs<pre><code>/* Get balance factor */\nfn balance_factor(node: OptionTreeNodeRc) -&gt; i32 {\n    match node {\n        // Empty node balance factor is 0\n        None =&gt; 0,\n        // Node balance factor = left subtree height - right subtree height\n        Some(node) =&gt; {\n            Self::height(node.borrow().left.clone()) - Self::height(node.borrow().right.clone())\n        }\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* Get balance factor */\nint balanceFactor(TreeNode *node) {\n    // Empty node balance factor is 0\n    if (node == NULL) {\n        return 0;\n    }\n    // Node balance factor = left subtree height - right subtree height\n    return height(node-&gt;left) - height(node-&gt;right);\n}\n</code></pre> avl_tree.kt<pre><code>/* Get balance factor */\nfun balanceFactor(node: TreeNode?): Int {\n    // Empty node balance factor is 0\n    if (node == null) return 0\n    // Node balance factor = left subtree height - right subtree height\n    return height(node.left) - height(node.right)\n}\n</code></pre> avl_tree.rb<pre><code>### Get balance factor ###\ndef balance_factor(node)\n  # Empty node balance factor is 0\n  return 0 if node.nil?\n\n  # Node balance factor = left subtree height - right subtree height\n  height(node.left) - height(node.right)\nend\n</code></pre> <p>Tip</p> <p>Let the balance factor be \\(f\\), then the balance factor of any node in an AVL tree satisfies \\(-1 \\le f \\le 1\\).</p>"},{"location":"chapter_tree/avl_tree/#752-rotations-in-avl-trees","title":"7.5.2 \u00a0 Rotations in Avl Trees","text":"<p>The characteristic of AVL trees lies in the \"rotation\" operation, which can restore balance to unbalanced nodes without affecting the inorder traversal sequence of the binary tree. In other words, rotation operations can both maintain the property of a \"binary search tree\" and make the tree return to a \"balanced binary tree\".</p> <p>We call nodes with a balance factor absolute value \\(&gt; 1\\) \"unbalanced nodes\". Depending on the imbalance situation, rotation operations are divided into four types: right rotation, left rotation, left rotation then right rotation, and right rotation then left rotation. Below we describe these rotation operations in detail.</p>"},{"location":"chapter_tree/avl_tree/#1-right-rotation","title":"1. \u00a0 Right Rotation","text":"<p>As shown in Figure 7-26, the value below the node is the balance factor. From bottom to top, the first unbalanced node in the binary tree is \"node 3\". We focus on the subtree with this unbalanced node as the root, denoting the node as <code>node</code> and its left child as <code>child</code>, and perform a \"right rotation\" operation. After the right rotation is completed, the subtree regains balance and still maintains the properties of a binary search tree.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 7-26 \u00a0 Steps of right rotation </p> <p>As shown in Figure 7-27, when the <code>child</code> node has a right child (denoted as <code>grand_child</code>), a step needs to be added in the right rotation: set <code>grand_child</code> as the left child of <code>node</code>.</p> <p></p> <p> Figure 7-27 \u00a0 Right rotation with grand_child </p> <p>\"Right rotation\" is a figurative term; in practice, it is achieved by modifying node pointers, as shown in the following code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby avl_tree.py<pre><code>def right_rotate(self, node: TreeNode | None) -&gt; TreeNode | None:\n    \"\"\"Right rotation operation\"\"\"\n    child = node.left\n    grand_child = child.right\n    # Using child as pivot, rotate node to the right\n    child.right = node\n    node.left = grand_child\n    # Update node height\n    self.update_height(node)\n    self.update_height(child)\n    # Return root node of subtree after rotation\n    return child\n</code></pre> avl_tree.cpp<pre><code>/* Right rotation operation */\nTreeNode *rightRotate(TreeNode *node) {\n    TreeNode *child = node-&gt;left;\n    TreeNode *grandChild = child-&gt;right;\n    // Using child as pivot, rotate node to the right\n    child-&gt;right = node;\n    node-&gt;left = grandChild;\n    // Update node height\n    updateHeight(node);\n    updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.java<pre><code>/* Right rotation operation */\nTreeNode rightRotate(TreeNode node) {\n    TreeNode child = node.left;\n    TreeNode grandChild = child.right;\n    // Using child as pivot, rotate node to the right\n    child.right = node;\n    node.left = grandChild;\n    // Update node height\n    updateHeight(node);\n    updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.cs<pre><code>/* Right rotation operation */\nTreeNode? RightRotate(TreeNode? node) {\n    TreeNode? child = node?.left;\n    TreeNode? grandChild = child?.right;\n    // Using child as pivot, rotate node to the right\n    child.right = node;\n    node.left = grandChild;\n    // Update node height\n    UpdateHeight(node);\n    UpdateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.go<pre><code>/* Right rotation operation */\nfunc (t *aVLTree) rightRotate(node *TreeNode) *TreeNode {\n    child := node.Left\n    grandChild := child.Right\n    // Using child as pivot, rotate node to the right\n    child.Right = node\n    node.Left = grandChild\n    // Update node height\n    t.updateHeight(node)\n    t.updateHeight(child)\n    // Return root node of subtree after rotation\n    return child\n}\n</code></pre> avl_tree.swift<pre><code>/* Right rotation operation */\nfunc rightRotate(node: TreeNode?) -&gt; TreeNode? {\n    let child = node?.left\n    let grandChild = child?.right\n    // Using child as pivot, rotate node to the right\n    child?.right = node\n    node?.left = grandChild\n    // Update node height\n    updateHeight(node: node)\n    updateHeight(node: child)\n    // Return root node of subtree after rotation\n    return child\n}\n</code></pre> avl_tree.js<pre><code>/* Right rotation operation */\n#rightRotate(node) {\n    const child = node.left;\n    const grandChild = child.right;\n    // Using child as pivot, rotate node to the right\n    child.right = node;\n    node.left = grandChild;\n    // Update node height\n    this.#updateHeight(node);\n    this.#updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.ts<pre><code>/* Right rotation operation */\nrightRotate(node: TreeNode): TreeNode {\n    const child = node.left;\n    const grandChild = child.right;\n    // Using child as pivot, rotate node to the right\n    child.right = node;\n    node.left = grandChild;\n    // Update node height\n    this.updateHeight(node);\n    this.updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.dart<pre><code>/* Right rotation operation */\nTreeNode? rightRotate(TreeNode? node) {\n  TreeNode? child = node!.left;\n  TreeNode? grandChild = child!.right;\n  // Using child as pivot, rotate node to the right\n  child.right = node;\n  node.left = grandChild;\n  // Update node height\n  updateHeight(node);\n  updateHeight(child);\n  // Return root node of subtree after rotation\n  return child;\n}\n</code></pre> avl_tree.rs<pre><code>/* Right rotation operation */\nfn right_rotate(node: OptionTreeNodeRc) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(node) =&gt; {\n            let child = node.borrow().left.clone().unwrap();\n            let grand_child = child.borrow().right.clone();\n            // Using child as pivot, rotate node to the right\n            child.borrow_mut().right = Some(node.clone());\n            node.borrow_mut().left = grand_child;\n            // Update node height\n            Self::update_height(Some(node));\n            Self::update_height(Some(child.clone()));\n            // Return root node of subtree after rotation\n            Some(child)\n        }\n        None =&gt; None,\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* Right rotation operation */\nTreeNode *rightRotate(TreeNode *node) {\n    TreeNode *child, *grandChild;\n    child = node-&gt;left;\n    grandChild = child-&gt;right;\n    // Using child as pivot, rotate node to the right\n    child-&gt;right = node;\n    node-&gt;left = grandChild;\n    // Update node height\n    updateHeight(node);\n    updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.kt<pre><code>/* Right rotation operation */\nfun rightRotate(node: TreeNode?): TreeNode {\n    val child = node!!.left\n    val grandChild = child!!.right\n    // Using child as pivot, rotate node to the right\n    child.right = node\n    node.left = grandChild\n    // Update node height\n    updateHeight(node)\n    updateHeight(child)\n    // Return root node of subtree after rotation\n    return child\n}\n</code></pre> avl_tree.rb<pre><code>### Right rotation ###\ndef right_rotate(node)\n  child = node.left\n  grand_child = child.right\n  # Using child as pivot, rotate node to the right\n  child.right = node\n  node.left = grand_child\n  # Update node height\n  update_height(node)\n  update_height(child)\n  # Return root node of subtree after rotation\n  child\nend\n</code></pre>"},{"location":"chapter_tree/avl_tree/#2-left-rotation","title":"2. \u00a0 Left Rotation","text":"<p>Correspondingly, if considering the \"mirror\" of the above unbalanced binary tree, the \"left rotation\" operation shown in Figure 7-28 needs to be performed.</p> <p></p> <p> Figure 7-28 \u00a0 Left rotation operation </p> <p>Similarly, as shown in Figure 7-29, when the <code>child</code> node has a left child (denoted as <code>grand_child</code>), a step needs to be added in the left rotation: set <code>grand_child</code> as the right child of <code>node</code>.</p> <p></p> <p> Figure 7-29 \u00a0 Left rotation with grand_child </p> <p>It can be observed that right rotation and left rotation operations are mirror symmetric in logic, and the two imbalance cases they solve are also symmetric. Based on symmetry, we only need to replace all <code>left</code> in the right rotation implementation code with <code>right</code>, and all <code>right</code> with <code>left</code>, to obtain the left rotation implementation code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby avl_tree.py<pre><code>def left_rotate(self, node: TreeNode | None) -&gt; TreeNode | None:\n    \"\"\"Left rotation operation\"\"\"\n    child = node.right\n    grand_child = child.left\n    # Using child as pivot, rotate node to the left\n    child.left = node\n    node.right = grand_child\n    # Update node height\n    self.update_height(node)\n    self.update_height(child)\n    # Return root node of subtree after rotation\n    return child\n</code></pre> avl_tree.cpp<pre><code>/* Left rotation operation */\nTreeNode *leftRotate(TreeNode *node) {\n    TreeNode *child = node-&gt;right;\n    TreeNode *grandChild = child-&gt;left;\n    // Using child as pivot, rotate node to the left\n    child-&gt;left = node;\n    node-&gt;right = grandChild;\n    // Update node height\n    updateHeight(node);\n    updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.java<pre><code>/* Left rotation operation */\nTreeNode leftRotate(TreeNode node) {\n    TreeNode child = node.right;\n    TreeNode grandChild = child.left;\n    // Using child as pivot, rotate node to the left\n    child.left = node;\n    node.right = grandChild;\n    // Update node height\n    updateHeight(node);\n    updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.cs<pre><code>/* Left rotation operation */\nTreeNode? LeftRotate(TreeNode? node) {\n    TreeNode? child = node?.right;\n    TreeNode? grandChild = child?.left;\n    // Using child as pivot, rotate node to the left\n    child.left = node;\n    node.right = grandChild;\n    // Update node height\n    UpdateHeight(node);\n    UpdateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.go<pre><code>/* Left rotation operation */\nfunc (t *aVLTree) leftRotate(node *TreeNode) *TreeNode {\n    child := node.Right\n    grandChild := child.Left\n    // Using child as pivot, rotate node to the left\n    child.Left = node\n    node.Right = grandChild\n    // Update node height\n    t.updateHeight(node)\n    t.updateHeight(child)\n    // Return root node of subtree after rotation\n    return child\n}\n</code></pre> avl_tree.swift<pre><code>/* Left rotation operation */\nfunc leftRotate(node: TreeNode?) -&gt; TreeNode? {\n    let child = node?.right\n    let grandChild = child?.left\n    // Using child as pivot, rotate node to the left\n    child?.left = node\n    node?.right = grandChild\n    // Update node height\n    updateHeight(node: node)\n    updateHeight(node: child)\n    // Return root node of subtree after rotation\n    return child\n}\n</code></pre> avl_tree.js<pre><code>/* Left rotation operation */\n#leftRotate(node) {\n    const child = node.right;\n    const grandChild = child.left;\n    // Using child as pivot, rotate node to the left\n    child.left = node;\n    node.right = grandChild;\n    // Update node height\n    this.#updateHeight(node);\n    this.#updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.ts<pre><code>/* Left rotation operation */\nleftRotate(node: TreeNode): TreeNode {\n    const child = node.right;\n    const grandChild = child.left;\n    // Using child as pivot, rotate node to the left\n    child.left = node;\n    node.right = grandChild;\n    // Update node height\n    this.updateHeight(node);\n    this.updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.dart<pre><code>/* Left rotation operation */\nTreeNode? leftRotate(TreeNode? node) {\n  TreeNode? child = node!.right;\n  TreeNode? grandChild = child!.left;\n  // Using child as pivot, rotate node to the left\n  child.left = node;\n  node.right = grandChild;\n  // Update node height\n  updateHeight(node);\n  updateHeight(child);\n  // Return root node of subtree after rotation\n  return child;\n}\n</code></pre> avl_tree.rs<pre><code>/* Left rotation operation */\nfn left_rotate(node: OptionTreeNodeRc) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(node) =&gt; {\n            let child = node.borrow().right.clone().unwrap();\n            let grand_child = child.borrow().left.clone();\n            // Using child as pivot, rotate node to the left\n            child.borrow_mut().left = Some(node.clone());\n            node.borrow_mut().right = grand_child;\n            // Update node height\n            Self::update_height(Some(node));\n            Self::update_height(Some(child.clone()));\n            // Return root node of subtree after rotation\n            Some(child)\n        }\n        None =&gt; None,\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* Left rotation operation */\nTreeNode *leftRotate(TreeNode *node) {\n    TreeNode *child, *grandChild;\n    child = node-&gt;right;\n    grandChild = child-&gt;left;\n    // Using child as pivot, rotate node to the left\n    child-&gt;left = node;\n    node-&gt;right = grandChild;\n    // Update node height\n    updateHeight(node);\n    updateHeight(child);\n    // Return root node of subtree after rotation\n    return child;\n}\n</code></pre> avl_tree.kt<pre><code>/* Left rotation operation */\nfun leftRotate(node: TreeNode?): TreeNode {\n    val child = node!!.right\n    val grandChild = child!!.left\n    // Using child as pivot, rotate node to the left\n    child.left = node\n    node.right = grandChild\n    // Update node height\n    updateHeight(node)\n    updateHeight(child)\n    // Return root node of subtree after rotation\n    return child\n}\n</code></pre> avl_tree.rb<pre><code>### Left rotation ###\ndef left_rotate(node)\n  child = node.right\n  grand_child = child.left\n  # Using child as pivot, rotate node to the left\n  child.left = node\n  node.right = grand_child\n  # Update node height\n  update_height(node)\n  update_height(child)\n  # Return root node of subtree after rotation\n  child\nend\n</code></pre>"},{"location":"chapter_tree/avl_tree/#3-left-rotation-then-right-rotation","title":"3. \u00a0 Left Rotation Then Right Rotation","text":"<p>For the unbalanced node 3 in Figure 7-30, using either left rotation or right rotation alone cannot restore the subtree to balance. In this case, a \"left rotation\" needs to be performed on <code>child</code> first, followed by a \"right rotation\" on <code>node</code>.</p> <p></p> <p> Figure 7-30 \u00a0 Left-right rotation </p>"},{"location":"chapter_tree/avl_tree/#4-right-rotation-then-left-rotation","title":"4. \u00a0 Right Rotation Then Left Rotation","text":"<p>As shown in Figure 7-31, for the mirror case of the above unbalanced binary tree, a \"right rotation\" needs to be performed on <code>child</code> first, then a \"left rotation\" on <code>node</code>.</p> <p></p> <p> Figure 7-31 \u00a0 Right-left rotation </p>"},{"location":"chapter_tree/avl_tree/#5-choice-of-rotation","title":"5. \u00a0 Choice of Rotation","text":"<p>The four imbalances shown in Figure 7-32 correspond one-to-one with the above cases, requiring right rotation, left rotation then right rotation, right rotation then left rotation, and left rotation operations respectively.</p> <p></p> <p> Figure 7-32 \u00a0 The four rotation cases of AVL tree </p> <p>As shown in Table 7-3, we determine which case the unbalanced node belongs to by judging the signs of the balance factor of the unbalanced node and the balance factor of its taller-side child node.</p> <p> Table 7-3 \u00a0 Conditions for Choosing Among the Four Rotation Cases </p> Balance factor of the unbalanced node Balance factor of the child node Rotation method to apply \\(&gt; 1\\) (left-leaning tree) \\(\\geq 0\\) Right rotation \\(&gt; 1\\) (left-leaning tree) \\(&lt;0\\) Left rotation then right rotation \\(&lt; -1\\) (right-leaning tree) \\(\\leq 0\\) Left rotation \\(&lt; -1\\) (right-leaning tree) \\(&gt;0\\) Right rotation then left rotation <p>For ease of use, we encapsulate the rotation operations into a function. With this function, we can perform rotations for various imbalance situations, restoring balance to unbalanced nodes. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby avl_tree.py<pre><code>def rotate(self, node: TreeNode | None) -&gt; TreeNode | None:\n    \"\"\"Perform rotation operation to restore balance to this subtree\"\"\"\n    # Get balance factor of node\n    balance_factor = self.balance_factor(node)\n    # Left-leaning tree\n    if balance_factor &gt; 1:\n        if self.balance_factor(node.left) &gt;= 0:\n            # Right rotation\n            return self.right_rotate(node)\n        else:\n            # First left rotation then right rotation\n            node.left = self.left_rotate(node.left)\n            return self.right_rotate(node)\n    # Right-leaning tree\n    elif balance_factor &lt; -1:\n        if self.balance_factor(node.right) &lt;= 0:\n            # Left rotation\n            return self.left_rotate(node)\n        else:\n            # First right rotation then left rotation\n            node.right = self.right_rotate(node.right)\n            return self.left_rotate(node)\n    # Balanced tree, no rotation needed, return directly\n    return node\n</code></pre> avl_tree.cpp<pre><code>/* Perform rotation operation to restore balance to this subtree */\nTreeNode *rotate(TreeNode *node) {\n    // Get balance factor of node\n    int _balanceFactor = balanceFactor(node);\n    // Left-leaning tree\n    if (_balanceFactor &gt; 1) {\n        if (balanceFactor(node-&gt;left) &gt;= 0) {\n            // Right rotation\n            return rightRotate(node);\n        } else {\n            // First left rotation then right rotation\n            node-&gt;left = leftRotate(node-&gt;left);\n            return rightRotate(node);\n        }\n    }\n    // Right-leaning tree\n    if (_balanceFactor &lt; -1) {\n        if (balanceFactor(node-&gt;right) &lt;= 0) {\n            // Left rotation\n            return leftRotate(node);\n        } else {\n            // First right rotation then left rotation\n            node-&gt;right = rightRotate(node-&gt;right);\n            return leftRotate(node);\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node;\n}\n</code></pre> avl_tree.java<pre><code>/* Perform rotation operation to restore balance to this subtree */\nTreeNode rotate(TreeNode node) {\n    // Get balance factor of node\n    int balanceFactor = balanceFactor(node);\n    // Left-leaning tree\n    if (balanceFactor &gt; 1) {\n        if (balanceFactor(node.left) &gt;= 0) {\n            // Right rotation\n            return rightRotate(node);\n        } else {\n            // First left rotation then right rotation\n            node.left = leftRotate(node.left);\n            return rightRotate(node);\n        }\n    }\n    // Right-leaning tree\n    if (balanceFactor &lt; -1) {\n        if (balanceFactor(node.right) &lt;= 0) {\n            // Left rotation\n            return leftRotate(node);\n        } else {\n            // First right rotation then left rotation\n            node.right = rightRotate(node.right);\n            return leftRotate(node);\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node;\n}\n</code></pre> avl_tree.cs<pre><code>/* Perform rotation operation to restore balance to this subtree */\nTreeNode? Rotate(TreeNode? node) {\n    // Get balance factor of node\n    int balanceFactorInt = BalanceFactor(node);\n    // Left-leaning tree\n    if (balanceFactorInt &gt; 1) {\n        if (BalanceFactor(node?.left) &gt;= 0) {\n            // Right rotation\n            return RightRotate(node);\n        } else {\n            // First left rotation then right rotation\n            node!.left = LeftRotate(node!.left);\n            return RightRotate(node);\n        }\n    }\n    // Right-leaning tree\n    if (balanceFactorInt &lt; -1) {\n        if (BalanceFactor(node?.right) &lt;= 0) {\n            // Left rotation\n            return LeftRotate(node);\n        } else {\n            // First right rotation then left rotation\n            node!.right = RightRotate(node!.right);\n            return LeftRotate(node);\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node;\n}\n</code></pre> avl_tree.go<pre><code>/* Perform rotation operation to restore balance to this subtree */\nfunc (t *aVLTree) rotate(node *TreeNode) *TreeNode {\n    // Get balance factor of node\n    // Go recommends short variables, here bf refers to t.balanceFactor\n    bf := t.balanceFactor(node)\n    // Left-leaning tree\n    if bf &gt; 1 {\n        if t.balanceFactor(node.Left) &gt;= 0 {\n            // Right rotation\n            return t.rightRotate(node)\n        } else {\n            // First left rotation then right rotation\n            node.Left = t.leftRotate(node.Left)\n            return t.rightRotate(node)\n        }\n    }\n    // Right-leaning tree\n    if bf &lt; -1 {\n        if t.balanceFactor(node.Right) &lt;= 0 {\n            // Left rotation\n            return t.leftRotate(node)\n        } else {\n            // First right rotation then left rotation\n            node.Right = t.rightRotate(node.Right)\n            return t.leftRotate(node)\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node\n}\n</code></pre> avl_tree.swift<pre><code>/* Perform rotation operation to restore balance to this subtree */\nfunc rotate(node: TreeNode?) -&gt; TreeNode? {\n    // Get balance factor of node\n    let balanceFactor = balanceFactor(node: node)\n    // Left-leaning tree\n    if balanceFactor &gt; 1 {\n        if self.balanceFactor(node: node?.left) &gt;= 0 {\n            // Right rotation\n            return rightRotate(node: node)\n        } else {\n            // First left rotation then right rotation\n            node?.left = leftRotate(node: node?.left)\n            return rightRotate(node: node)\n        }\n    }\n    // Right-leaning tree\n    if balanceFactor &lt; -1 {\n        if self.balanceFactor(node: node?.right) &lt;= 0 {\n            // Left rotation\n            return leftRotate(node: node)\n        } else {\n            // First right rotation then left rotation\n            node?.right = rightRotate(node: node?.right)\n            return leftRotate(node: node)\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node\n}\n</code></pre> avl_tree.js<pre><code>/* Perform rotation operation to restore balance to this subtree */\n#rotate(node) {\n    // Get balance factor of node\n    const balanceFactor = this.balanceFactor(node);\n    // Left-leaning tree\n    if (balanceFactor &gt; 1) {\n        if (this.balanceFactor(node.left) &gt;= 0) {\n            // Right rotation\n            return this.#rightRotate(node);\n        } else {\n            // First left rotation then right rotation\n            node.left = this.#leftRotate(node.left);\n            return this.#rightRotate(node);\n        }\n    }\n    // Right-leaning tree\n    if (balanceFactor &lt; -1) {\n        if (this.balanceFactor(node.right) &lt;= 0) {\n            // Left rotation\n            return this.#leftRotate(node);\n        } else {\n            // First right rotation then left rotation\n            node.right = this.#rightRotate(node.right);\n            return this.#leftRotate(node);\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node;\n}\n</code></pre> avl_tree.ts<pre><code>/* Perform rotation operation to restore balance to this subtree */\nrotate(node: TreeNode): TreeNode {\n    // Get balance factor of node\n    const balanceFactor = this.balanceFactor(node);\n    // Left-leaning tree\n    if (balanceFactor &gt; 1) {\n        if (this.balanceFactor(node.left) &gt;= 0) {\n            // Right rotation\n            return this.rightRotate(node);\n        } else {\n            // First left rotation then right rotation\n            node.left = this.leftRotate(node.left);\n            return this.rightRotate(node);\n        }\n    }\n    // Right-leaning tree\n    if (balanceFactor &lt; -1) {\n        if (this.balanceFactor(node.right) &lt;= 0) {\n            // Left rotation\n            return this.leftRotate(node);\n        } else {\n            // First right rotation then left rotation\n            node.right = this.rightRotate(node.right);\n            return this.leftRotate(node);\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node;\n}\n</code></pre> avl_tree.dart<pre><code>/* Perform rotation operation to restore balance to this subtree */\nTreeNode? rotate(TreeNode? node) {\n  // Get balance factor of node\n  int factor = balanceFactor(node);\n  // Left-leaning tree\n  if (factor &gt; 1) {\n    if (balanceFactor(node!.left) &gt;= 0) {\n      // Right rotation\n      return rightRotate(node);\n    } else {\n      // First left rotation then right rotation\n      node.left = leftRotate(node.left);\n      return rightRotate(node);\n    }\n  }\n  // Right-leaning tree\n  if (factor &lt; -1) {\n    if (balanceFactor(node!.right) &lt;= 0) {\n      // Left rotation\n      return leftRotate(node);\n    } else {\n      // First right rotation then left rotation\n      node.right = rightRotate(node.right);\n      return leftRotate(node);\n    }\n  }\n  // Balanced tree, no rotation needed, return directly\n  return node;\n}\n</code></pre> avl_tree.rs<pre><code>/* Perform rotation operation to restore balance to this subtree */\nfn rotate(node: OptionTreeNodeRc) -&gt; OptionTreeNodeRc {\n    // Get balance factor of node\n    let balance_factor = Self::balance_factor(node.clone());\n    // Left-leaning tree\n    if balance_factor &gt; 1 {\n        let node = node.unwrap();\n        if Self::balance_factor(node.borrow().left.clone()) &gt;= 0 {\n            // Right rotation\n            Self::right_rotate(Some(node))\n        } else {\n            // First left rotation then right rotation\n            let left = node.borrow().left.clone();\n            node.borrow_mut().left = Self::left_rotate(left);\n            Self::right_rotate(Some(node))\n        }\n    }\n    // Right-leaning tree\n    else if balance_factor &lt; -1 {\n        let node = node.unwrap();\n        if Self::balance_factor(node.borrow().right.clone()) &lt;= 0 {\n            // Left rotation\n            Self::left_rotate(Some(node))\n        } else {\n            // First right rotation then left rotation\n            let right = node.borrow().right.clone();\n            node.borrow_mut().right = Self::right_rotate(right);\n            Self::left_rotate(Some(node))\n        }\n    } else {\n        // Balanced tree, no rotation needed, return directly\n        node\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* Perform rotation operation to restore balance to this subtree */\nTreeNode *rotate(TreeNode *node) {\n    // Get balance factor of node\n    int bf = balanceFactor(node);\n    // Left-leaning tree\n    if (bf &gt; 1) {\n        if (balanceFactor(node-&gt;left) &gt;= 0) {\n            // Right rotation\n            return rightRotate(node);\n        } else {\n            // First left rotation then right rotation\n            node-&gt;left = leftRotate(node-&gt;left);\n            return rightRotate(node);\n        }\n    }\n    // Right-leaning tree\n    if (bf &lt; -1) {\n        if (balanceFactor(node-&gt;right) &lt;= 0) {\n            // Left rotation\n            return leftRotate(node);\n        } else {\n            // First right rotation then left rotation\n            node-&gt;right = rightRotate(node-&gt;right);\n            return leftRotate(node);\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node;\n}\n</code></pre> avl_tree.kt<pre><code>/* Perform rotation operation to restore balance to this subtree */\nfun rotate(node: TreeNode): TreeNode {\n    // Get balance factor of node\n    val balanceFactor = balanceFactor(node)\n    // Left-leaning tree\n    if (balanceFactor &gt; 1) {\n        if (balanceFactor(node.left) &gt;= 0) {\n            // Right rotation\n            return rightRotate(node)\n        } else {\n            // First left rotation then right rotation\n            node.left = leftRotate(node.left)\n            return rightRotate(node)\n        }\n    }\n    // Right-leaning tree\n    if (balanceFactor &lt; -1) {\n        if (balanceFactor(node.right) &lt;= 0) {\n            // Left rotation\n            return leftRotate(node)\n        } else {\n            // First right rotation then left rotation\n            node.right = rightRotate(node.right)\n            return leftRotate(node)\n        }\n    }\n    // Balanced tree, no rotation needed, return directly\n    return node\n}\n</code></pre> avl_tree.rb<pre><code>### Perform rotation to rebalance subtree ###\ndef rotate(node)\n  # Get balance factor of node\n  balance_factor = balance_factor(node)\n  # Left-heavy tree\n  if balance_factor &gt; 1\n    if balance_factor(node.left) &gt;= 0\n      # Right rotation\n      return right_rotate(node)\n    else\n      # First left rotation then right rotation\n      node.left = left_rotate(node.left)\n      return right_rotate(node)\n    end\n  # Right-heavy tree\n  elsif balance_factor &lt; -1\n    if balance_factor(node.right) &lt;= 0\n      # Left rotation\n      return left_rotate(node)\n    else\n      # First right rotation then left rotation\n      node.right = right_rotate(node.right)\n      return left_rotate(node)\n    end\n  end\n  # Balanced tree, no rotation needed, return directly\n  node\nend\n</code></pre>"},{"location":"chapter_tree/avl_tree/#753-common-operations-in-avl-trees","title":"7.5.3 \u00a0 Common Operations in Avl Trees","text":""},{"location":"chapter_tree/avl_tree/#1-node-insertion","title":"1. \u00a0 Node Insertion","text":"<p>The node insertion operation in AVL trees is similar in principle to that in binary search trees. The only difference is that after inserting a node in an AVL tree, a series of unbalanced nodes may appear on the path from that node to the root. Therefore, we need to start from this node and perform rotation operations from bottom to top, restoring balance to all unbalanced nodes. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby avl_tree.py<pre><code>def insert(self, val):\n    \"\"\"Insert node\"\"\"\n    self._root = self.insert_helper(self._root, val)\n\ndef insert_helper(self, node: TreeNode | None, val: int) -&gt; TreeNode:\n    \"\"\"Recursively insert node (helper method)\"\"\"\n    if node is None:\n        return TreeNode(val)\n    # 1. Find insertion position and insert node\n    if val &lt; node.val:\n        node.left = self.insert_helper(node.left, val)\n    elif val &gt; node.val:\n        node.right = self.insert_helper(node.right, val)\n    else:\n        # Duplicate node not inserted, return directly\n        return node\n    # Update node height\n    self.update_height(node)\n    # 2. Perform rotation operation to restore balance to this subtree\n    return self.rotate(node)\n</code></pre> avl_tree.cpp<pre><code>/* Insert node */\nvoid insert(int val) {\n    root = insertHelper(root, val);\n}\n\n/* Recursively insert node (helper method) */\nTreeNode *insertHelper(TreeNode *node, int val) {\n    if (node == nullptr)\n        return new TreeNode(val);\n    /* 1. Find insertion position and insert node */\n    if (val &lt; node-&gt;val)\n        node-&gt;left = insertHelper(node-&gt;left, val);\n    else if (val &gt; node-&gt;val)\n        node-&gt;right = insertHelper(node-&gt;right, val);\n    else\n        return node;    // Duplicate node not inserted, return directly\n    updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.java<pre><code>/* Insert node */\nvoid insert(int val) {\n    root = insertHelper(root, val);\n}\n\n/* Recursively insert node (helper method) */\nTreeNode insertHelper(TreeNode node, int val) {\n    if (node == null)\n        return new TreeNode(val);\n    /* 1. Find insertion position and insert node */\n    if (val &lt; node.val)\n        node.left = insertHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = insertHelper(node.right, val);\n    else\n        return node; // Duplicate node not inserted, return directly\n    updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.cs<pre><code>/* Insert node */\nvoid Insert(int val) {\n    root = InsertHelper(root, val);\n}\n\n/* Recursively insert node (helper method) */\nTreeNode? InsertHelper(TreeNode? node, int val) {\n    if (node == null) return new TreeNode(val);\n    /* 1. Find insertion position and insert node */\n    if (val &lt; node.val)\n        node.left = InsertHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = InsertHelper(node.right, val);\n    else\n        return node;     // Duplicate node not inserted, return directly\n    UpdateHeight(node);  // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = Rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.go<pre><code>/* Insert node */\nfunc (t *aVLTree) insert(val int) {\n    t.root = t.insertHelper(t.root, val)\n}\n\n/* Recursively insert node (helper function) */\nfunc (t *aVLTree) insertHelper(node *TreeNode, val int) *TreeNode {\n    if node == nil {\n        return NewTreeNode(val)\n    }\n    /* 1. Find insertion position and insert node */\n    if val &lt; node.Val.(int) {\n        node.Left = t.insertHelper(node.Left, val)\n    } else if val &gt; node.Val.(int) {\n        node.Right = t.insertHelper(node.Right, val)\n    } else {\n        // Duplicate node not inserted, return directly\n        return node\n    }\n    // Update node height\n    t.updateHeight(node)\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = t.rotate(node)\n    // Return root node of subtree\n    return node\n}\n</code></pre> avl_tree.swift<pre><code>/* Insert node */\nfunc insert(val: Int) {\n    root = insertHelper(node: root, val: val)\n}\n\n/* Recursively insert node (helper method) */\nfunc insertHelper(node: TreeNode?, val: Int) -&gt; TreeNode? {\n    var node = node\n    if node == nil {\n        return TreeNode(x: val)\n    }\n    /* 1. Find insertion position and insert node */\n    if val &lt; node!.val {\n        node?.left = insertHelper(node: node?.left, val: val)\n    } else if val &gt; node!.val {\n        node?.right = insertHelper(node: node?.right, val: val)\n    } else {\n        return node // Duplicate node not inserted, return directly\n    }\n    updateHeight(node: node) // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node: node)\n    // Return root node of subtree\n    return node\n}\n</code></pre> avl_tree.js<pre><code>/* Insert node */\ninsert(val) {\n    this.root = this.#insertHelper(this.root, val);\n}\n\n/* Recursively insert node (helper method) */\n#insertHelper(node, val) {\n    if (node === null) return new TreeNode(val);\n    /* 1. Find insertion position and insert node */\n    if (val &lt; node.val) node.left = this.#insertHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = this.#insertHelper(node.right, val);\n    else return node; // Duplicate node not inserted, return directly\n    this.#updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = this.#rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.ts<pre><code>/* Insert node */\ninsert(val: number): void {\n    this.root = this.insertHelper(this.root, val);\n}\n\n/* Recursively insert node (helper method) */\ninsertHelper(node: TreeNode, val: number): TreeNode {\n    if (node === null) return new TreeNode(val);\n    /* 1. Find insertion position and insert node */\n    if (val &lt; node.val) {\n        node.left = this.insertHelper(node.left, val);\n    } else if (val &gt; node.val) {\n        node.right = this.insertHelper(node.right, val);\n    } else {\n        return node; // Duplicate node not inserted, return directly\n    }\n    this.updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = this.rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.dart<pre><code>/* Insert node */\nvoid insert(int val) {\n  root = insertHelper(root, val);\n}\n\n/* Recursively insert node (helper method) */\nTreeNode? insertHelper(TreeNode? node, int val) {\n  if (node == null) return TreeNode(val);\n  /* 1. Find insertion position and insert node */\n  if (val &lt; node.val)\n    node.left = insertHelper(node.left, val);\n  else if (val &gt; node.val)\n    node.right = insertHelper(node.right, val);\n  else\n    return node; // Duplicate node not inserted, return directly\n  updateHeight(node); // Update node height\n  /* 2. Perform rotation operation to restore balance to this subtree */\n  node = rotate(node);\n  // Return root node of subtree\n  return node;\n}\n</code></pre> avl_tree.rs<pre><code>/* Insert node */\nfn insert(&amp;mut self, val: i32) {\n    self.root = Self::insert_helper(self.root.clone(), val);\n}\n\n/* Recursively insert node (helper method) */\nfn insert_helper(node: OptionTreeNodeRc, val: i32) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(mut node) =&gt; {\n            /* 1. Find insertion position and insert node */\n            match {\n                let node_val = node.borrow().val;\n                node_val\n            }\n            .cmp(&amp;val)\n            {\n                Ordering::Greater =&gt; {\n                    let left = node.borrow().left.clone();\n                    node.borrow_mut().left = Self::insert_helper(left, val);\n                }\n                Ordering::Less =&gt; {\n                    let right = node.borrow().right.clone();\n                    node.borrow_mut().right = Self::insert_helper(right, val);\n                }\n                Ordering::Equal =&gt; {\n                    return Some(node); // Duplicate node not inserted, return directly\n                }\n            }\n            Self::update_height(Some(node.clone())); // Update node height\n\n            /* 2. Perform rotation operation to restore balance to this subtree */\n            node = Self::rotate(Some(node)).unwrap();\n            // Return root node of subtree\n            Some(node)\n        }\n        None =&gt; Some(TreeNode::new(val)),\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* Insert node */\nvoid insert(AVLTree *tree, int val) {\n    tree-&gt;root = insertHelper(tree-&gt;root, val);\n}\n\n/* Recursively insert node (helper function) */\nTreeNode *insertHelper(TreeNode *node, int val) {\n    if (node == NULL) {\n        return newTreeNode(val);\n    }\n    /* 1. Find insertion position and insert node */\n    if (val &lt; node-&gt;val) {\n        node-&gt;left = insertHelper(node-&gt;left, val);\n    } else if (val &gt; node-&gt;val) {\n        node-&gt;right = insertHelper(node-&gt;right, val);\n    } else {\n        // Duplicate node not inserted, return directly\n        return node;\n    }\n    // Update node height\n    updateHeight(node);\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.kt<pre><code>/* Insert node */\nfun insert(_val: Int) {\n    root = insertHelper(root, _val)\n}\n\n/* Recursively insert node (helper method) */\nfun insertHelper(n: TreeNode?, _val: Int): TreeNode {\n    if (n == null)\n        return TreeNode(_val)\n    var node = n\n    /* 1. Find insertion position and insert node */\n    if (_val &lt; node._val)\n        node.left = insertHelper(node.left, _val)\n    else if (_val &gt; node._val)\n        node.right = insertHelper(node.right, _val)\n    else\n        return node // Duplicate node not inserted, return directly\n    updateHeight(node) // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node)\n    // Return root node of subtree\n    return node\n}\n</code></pre> avl_tree.rb<pre><code>### Insert node ###\ndef insert(val)\n  @root = insert_helper(@root, val)\nend\n\n### Recursively insert node (helper method) ###\ndef insert_helper(node, val)\n  return TreeNode.new(val) if node.nil?\n  # 1. Find insertion position and insert node\n  if val &lt; node.val\n    node.left = insert_helper(node.left, val)\n  elsif val &gt; node.val\n    node.right = insert_helper(node.right, val)\n  else\n    # Duplicate node not inserted, return directly\n    return node\n  end\n  # Update node height\n  update_height(node)\n  # 2. Perform rotation operation to restore balance to this subtree\n  rotate(node)\nend\n</code></pre>"},{"location":"chapter_tree/avl_tree/#2-node-removal","title":"2. \u00a0 Node Removal","text":"<p>Similarly, on the basis of the binary search tree's node removal method, rotation operations need to be performed from bottom to top to restore balance to all unbalanced nodes. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby avl_tree.py<pre><code>def remove(self, val: int):\n    \"\"\"Delete node\"\"\"\n    self._root = self.remove_helper(self._root, val)\n\ndef remove_helper(self, node: TreeNode | None, val: int) -&gt; TreeNode | None:\n    \"\"\"Recursively delete node (helper method)\"\"\"\n    if node is None:\n        return None\n    # 1. Find node and delete\n    if val &lt; node.val:\n        node.left = self.remove_helper(node.left, val)\n    elif val &gt; node.val:\n        node.right = self.remove_helper(node.right, val)\n    else:\n        if node.left is None or node.right is None:\n            child = node.left or node.right\n            # Number of child nodes = 0, delete node directly and return\n            if child is None:\n                return None\n            # Number of child nodes = 1, delete node directly\n            else:\n                node = child\n        else:\n            # Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            temp = node.right\n            while temp.left is not None:\n                temp = temp.left\n            node.right = self.remove_helper(node.right, temp.val)\n            node.val = temp.val\n    # Update node height\n    self.update_height(node)\n    # 2. Perform rotation operation to restore balance to this subtree\n    return self.rotate(node)\n</code></pre> avl_tree.cpp<pre><code>/* Remove node */\nvoid remove(int val) {\n    root = removeHelper(root, val);\n}\n\n/* Recursively delete node (helper method) */\nTreeNode *removeHelper(TreeNode *node, int val) {\n    if (node == nullptr)\n        return nullptr;\n    /* 1. Find node and delete */\n    if (val &lt; node-&gt;val)\n        node-&gt;left = removeHelper(node-&gt;left, val);\n    else if (val &gt; node-&gt;val)\n        node-&gt;right = removeHelper(node-&gt;right, val);\n    else {\n        if (node-&gt;left == nullptr || node-&gt;right == nullptr) {\n            TreeNode *child = node-&gt;left != nullptr ? node-&gt;left : node-&gt;right;\n            // Number of child nodes = 0, delete node directly and return\n            if (child == nullptr) {\n                delete node;\n                return nullptr;\n            }\n            // Number of child nodes = 1, delete node directly\n            else {\n                delete node;\n                node = child;\n            }\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            TreeNode *temp = node-&gt;right;\n            while (temp-&gt;left != nullptr) {\n                temp = temp-&gt;left;\n            }\n            int tempVal = temp-&gt;val;\n            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);\n            node-&gt;val = tempVal;\n        }\n    }\n    updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.java<pre><code>/* Remove node */\nvoid remove(int val) {\n    root = removeHelper(root, val);\n}\n\n/* Recursively delete node (helper method) */\nTreeNode removeHelper(TreeNode node, int val) {\n    if (node == null)\n        return null;\n    /* 1. Find node and delete */\n    if (val &lt; node.val)\n        node.left = removeHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = removeHelper(node.right, val);\n    else {\n        if (node.left == null || node.right == null) {\n            TreeNode child = node.left != null ? node.left : node.right;\n            // Number of child nodes = 0, delete node directly and return\n            if (child == null)\n                return null;\n            // Number of child nodes = 1, delete node directly\n            else\n                node = child;\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            TreeNode temp = node.right;\n            while (temp.left != null) {\n                temp = temp.left;\n            }\n            node.right = removeHelper(node.right, temp.val);\n            node.val = temp.val;\n        }\n    }\n    updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.cs<pre><code>/* Remove node */\nvoid Remove(int val) {\n    root = RemoveHelper(root, val);\n}\n\n/* Recursively delete node (helper method) */\nTreeNode? RemoveHelper(TreeNode? node, int val) {\n    if (node == null) return null;\n    /* 1. Find node and delete */\n    if (val &lt; node.val)\n        node.left = RemoveHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = RemoveHelper(node.right, val);\n    else {\n        if (node.left == null || node.right == null) {\n            TreeNode? child = node.left ?? node.right;\n            // Number of child nodes = 0, delete node directly and return\n            if (child == null)\n                return null;\n            // Number of child nodes = 1, delete node directly\n            else\n                node = child;\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            TreeNode? temp = node.right;\n            while (temp.left != null) {\n                temp = temp.left;\n            }\n            node.right = RemoveHelper(node.right, temp.val!.Value);\n            node.val = temp.val;\n        }\n    }\n    UpdateHeight(node);  // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = Rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.go<pre><code>/* Remove node */\nfunc (t *aVLTree) remove(val int) {\n    t.root = t.removeHelper(t.root, val)\n}\n\n/* Recursively remove node (helper function) */\nfunc (t *aVLTree) removeHelper(node *TreeNode, val int) *TreeNode {\n    if node == nil {\n        return nil\n    }\n    /* 1. Find node and delete */\n    if val &lt; node.Val.(int) {\n        node.Left = t.removeHelper(node.Left, val)\n    } else if val &gt; node.Val.(int) {\n        node.Right = t.removeHelper(node.Right, val)\n    } else {\n        if node.Left == nil || node.Right == nil {\n            child := node.Left\n            if node.Right != nil {\n                child = node.Right\n            }\n            if child == nil {\n                // Number of child nodes = 0, delete node directly and return\n                return nil\n            } else {\n                // Number of child nodes = 1, delete node directly\n                node = child\n            }\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            temp := node.Right\n            for temp.Left != nil {\n                temp = temp.Left\n            }\n            node.Right = t.removeHelper(node.Right, temp.Val.(int))\n            node.Val = temp.Val\n        }\n    }\n    // Update node height\n    t.updateHeight(node)\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = t.rotate(node)\n    // Return root node of subtree\n    return node\n}\n</code></pre> avl_tree.swift<pre><code>/* Remove node */\nfunc remove(val: Int) {\n    root = removeHelper(node: root, val: val)\n}\n\n/* Recursively delete node (helper method) */\nfunc removeHelper(node: TreeNode?, val: Int) -&gt; TreeNode? {\n    var node = node\n    if node == nil {\n        return nil\n    }\n    /* 1. Find node and delete */\n    if val &lt; node!.val {\n        node?.left = removeHelper(node: node?.left, val: val)\n    } else if val &gt; node!.val {\n        node?.right = removeHelper(node: node?.right, val: val)\n    } else {\n        if node?.left == nil || node?.right == nil {\n            let child = node?.left ?? node?.right\n            // Number of child nodes = 0, delete node directly and return\n            if child == nil {\n                return nil\n            }\n            // Number of child nodes = 1, delete node directly\n            else {\n                node = child\n            }\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            var temp = node?.right\n            while temp?.left != nil {\n                temp = temp?.left\n            }\n            node?.right = removeHelper(node: node?.right, val: temp!.val)\n            node?.val = temp!.val\n        }\n    }\n    updateHeight(node: node) // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node: node)\n    // Return root node of subtree\n    return node\n}\n</code></pre> avl_tree.js<pre><code>/* Remove node */\nremove(val) {\n    this.root = this.#removeHelper(this.root, val);\n}\n\n/* Recursively delete node (helper method) */\n#removeHelper(node, val) {\n    if (node === null) return null;\n    /* 1. Find node and delete */\n    if (val &lt; node.val) node.left = this.#removeHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = this.#removeHelper(node.right, val);\n    else {\n        if (node.left === null || node.right === null) {\n            const child = node.left !== null ? node.left : node.right;\n            // Number of child nodes = 0, delete node directly and return\n            if (child === null) return null;\n            // Number of child nodes = 1, delete node directly\n            else node = child;\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            let temp = node.right;\n            while (temp.left !== null) {\n                temp = temp.left;\n            }\n            node.right = this.#removeHelper(node.right, temp.val);\n            node.val = temp.val;\n        }\n    }\n    this.#updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = this.#rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.ts<pre><code>/* Remove node */\nremove(val: number): void {\n    this.root = this.removeHelper(this.root, val);\n}\n\n/* Recursively delete node (helper method) */\nremoveHelper(node: TreeNode, val: number): TreeNode {\n    if (node === null) return null;\n    /* 1. Find node and delete */\n    if (val &lt; node.val) {\n        node.left = this.removeHelper(node.left, val);\n    } else if (val &gt; node.val) {\n        node.right = this.removeHelper(node.right, val);\n    } else {\n        if (node.left === null || node.right === null) {\n            const child = node.left !== null ? node.left : node.right;\n            // Number of child nodes = 0, delete node directly and return\n            if (child === null) {\n                return null;\n            } else {\n                // Number of child nodes = 1, delete node directly\n                node = child;\n            }\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            let temp = node.right;\n            while (temp.left !== null) {\n                temp = temp.left;\n            }\n            node.right = this.removeHelper(node.right, temp.val);\n            node.val = temp.val;\n        }\n    }\n    this.updateHeight(node); // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = this.rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.dart<pre><code>/* Remove node */\nvoid remove(int val) {\n  root = removeHelper(root, val);\n}\n\n/* Recursively delete node (helper method) */\nTreeNode? removeHelper(TreeNode? node, int val) {\n  if (node == null) return null;\n  /* 1. Find node and delete */\n  if (val &lt; node.val)\n    node.left = removeHelper(node.left, val);\n  else if (val &gt; node.val)\n    node.right = removeHelper(node.right, val);\n  else {\n    if (node.left == null || node.right == null) {\n      TreeNode? child = node.left ?? node.right;\n      // Number of child nodes = 0, delete node directly and return\n      if (child == null)\n        return null;\n      // Number of child nodes = 1, delete node directly\n      else\n        node = child;\n    } else {\n      // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n      TreeNode? temp = node.right;\n      while (temp!.left != null) {\n        temp = temp.left;\n      }\n      node.right = removeHelper(node.right, temp.val);\n      node.val = temp.val;\n    }\n  }\n  updateHeight(node); // Update node height\n  /* 2. Perform rotation operation to restore balance to this subtree */\n  node = rotate(node);\n  // Return root node of subtree\n  return node;\n}\n</code></pre> avl_tree.rs<pre><code>/* Remove node */\nfn remove(&amp;self, val: i32) {\n    Self::remove_helper(self.root.clone(), val);\n}\n\n/* Recursively delete node (helper method) */\nfn remove_helper(node: OptionTreeNodeRc, val: i32) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(mut node) =&gt; {\n            /* 1. Find node and delete */\n            if val &lt; node.borrow().val {\n                let left = node.borrow().left.clone();\n                node.borrow_mut().left = Self::remove_helper(left, val);\n            } else if val &gt; node.borrow().val {\n                let right = node.borrow().right.clone();\n                node.borrow_mut().right = Self::remove_helper(right, val);\n            } else if node.borrow().left.is_none() || node.borrow().right.is_none() {\n                let child = if node.borrow().left.is_some() {\n                    node.borrow().left.clone()\n                } else {\n                    node.borrow().right.clone()\n                };\n                match child {\n                    // Number of child nodes = 0, delete node directly and return\n                    None =&gt; {\n                        return None;\n                    }\n                    // Number of child nodes = 1, delete node directly\n                    Some(child) =&gt; node = child,\n                }\n            } else {\n                // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n                let mut temp = node.borrow().right.clone().unwrap();\n                loop {\n                    let temp_left = temp.borrow().left.clone();\n                    if temp_left.is_none() {\n                        break;\n                    }\n                    temp = temp_left.unwrap();\n                }\n                let right = node.borrow().right.clone();\n                node.borrow_mut().right = Self::remove_helper(right, temp.borrow().val);\n                node.borrow_mut().val = temp.borrow().val;\n            }\n            Self::update_height(Some(node.clone())); // Update node height\n\n            /* 2. Perform rotation operation to restore balance to this subtree */\n            node = Self::rotate(Some(node)).unwrap();\n            // Return root node of subtree\n            Some(node)\n        }\n        None =&gt; None,\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* Remove node */\n// Cannot use remove keyword here due to stdio.h inclusion\nvoid removeItem(AVLTree *tree, int val) {\n    TreeNode *root = removeHelper(tree-&gt;root, val);\n}\n\n/* Recursively remove node (helper function) */\nTreeNode *removeHelper(TreeNode *node, int val) {\n    TreeNode *child, *grandChild;\n    if (node == NULL) {\n        return NULL;\n    }\n    /* 1. Find node and delete */\n    if (val &lt; node-&gt;val) {\n        node-&gt;left = removeHelper(node-&gt;left, val);\n    } else if (val &gt; node-&gt;val) {\n        node-&gt;right = removeHelper(node-&gt;right, val);\n    } else {\n        if (node-&gt;left == NULL || node-&gt;right == NULL) {\n            child = node-&gt;left;\n            if (node-&gt;right != NULL) {\n                child = node-&gt;right;\n            }\n            // Number of child nodes = 0, delete node directly and return\n            if (child == NULL) {\n                return NULL;\n            } else {\n                // Number of child nodes = 1, delete node directly\n                node = child;\n            }\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            TreeNode *temp = node-&gt;right;\n            while (temp-&gt;left != NULL) {\n                temp = temp-&gt;left;\n            }\n            int tempVal = temp-&gt;val;\n            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);\n            node-&gt;val = tempVal;\n        }\n    }\n    // Update node height\n    updateHeight(node);\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node);\n    // Return root node of subtree\n    return node;\n}\n</code></pre> avl_tree.kt<pre><code>/* Remove node */\nfun remove(_val: Int) {\n    root = removeHelper(root, _val)\n}\n\n/* Recursively delete node (helper method) */\nfun removeHelper(n: TreeNode?, _val: Int): TreeNode? {\n    var node = n ?: return null\n    /* 1. Find node and delete */\n    if (_val &lt; node._val)\n        node.left = removeHelper(node.left, _val)\n    else if (_val &gt; node._val)\n        node.right = removeHelper(node.right, _val)\n    else {\n        if (node.left == null || node.right == null) {\n            val child = if (node.left != null)\n                node.left\n            else\n                node.right\n            // Number of child nodes = 0, delete node directly and return\n            if (child == null)\n                return null\n            // Number of child nodes = 1, delete node directly\n            else\n                node = child\n        } else {\n            // Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n            var temp = node.right\n            while (temp!!.left != null) {\n                temp = temp.left\n            }\n            node.right = removeHelper(node.right, temp._val)\n            node._val = temp._val\n        }\n    }\n    updateHeight(node) // Update node height\n    /* 2. Perform rotation operation to restore balance to this subtree */\n    node = rotate(node)\n    // Return root node of subtree\n    return node\n}\n</code></pre> avl_tree.rb<pre><code>### Delete node ###\ndef remove(val)\n  @root = remove_helper(@root, val)\nend\n\n### Recursively delete node (helper method) ###\ndef remove_helper(node, val)\n  return if node.nil?\n  # 1. Find node and delete\n  if val &lt; node.val\n    node.left = remove_helper(node.left, val)\n  elsif val &gt; node.val\n    node.right = remove_helper(node.right, val)\n  else\n    if node.left.nil? || node.right.nil?\n      child = node.left || node.right\n      # Number of child nodes = 0, delete node directly and return\n      return if child.nil?\n      # Number of child nodes = 1, delete node directly\n      node = child\n    else\n      # Number of child nodes = 2, delete the next node in inorder traversal and replace current node with it\n      temp = node.right\n      while !temp.left.nil?\n        temp = temp.left\n      end\n      node.right = remove_helper(node.right, temp.val)\n      node.val = temp.val\n    end\n  end\n  # Update node height\n  update_height(node)\n  # 2. Perform rotation operation to restore balance to this subtree\n  rotate(node)\nend\n</code></pre>"},{"location":"chapter_tree/avl_tree/#3-node-search","title":"3. \u00a0 Node Search","text":"<p>The node search operation in AVL trees is consistent with that in binary search trees, and will not be elaborated here.</p>"},{"location":"chapter_tree/avl_tree/#754-typical-applications-of-avl-trees","title":"7.5.4 \u00a0 Typical Applications of Avl Trees","text":"<ul> <li>Organizing and storing large-scale data, suitable for scenarios with high-frequency searches and low-frequency insertions and deletions.</li> <li>Used to build index systems in databases.</li> <li>Red-black trees are also a common type of balanced binary search tree. Compared to AVL trees, red-black trees have more relaxed balance conditions, require fewer rotation operations for node insertion and deletion, and have higher average efficiency for node addition and deletion operations.</li> </ul>"},{"location":"chapter_tree/binary_search_tree/","title":"7.4 \u00a0 Binary Search Tree","text":"<p>As shown in Figure 7-16, a binary search tree satisfies the following conditions.</p> <ol> <li>For the root node, the value of all nodes in the left subtree \\(&lt;\\) the value of the root node \\(&lt;\\) the value of all nodes in the right subtree.</li> <li>The left and right subtrees of any node are also binary search trees, i.e., they satisfy condition <code>1.</code> as well.</li> </ol> <p></p> <p> Figure 7-16 \u00a0 Binary search tree </p>"},{"location":"chapter_tree/binary_search_tree/#741-operations-on-a-binary-search-tree","title":"7.4.1 \u00a0 Operations on a Binary Search Tree","text":"<p>We encapsulate the binary search tree as a class <code>BinarySearchTree</code> and declare a member variable <code>root</code> pointing to the tree's root node.</p>"},{"location":"chapter_tree/binary_search_tree/#1-searching-for-a-node","title":"1. \u00a0 Searching for a Node","text":"<p>Given a target node value <code>num</code>, we can search according to the properties of the binary search tree. As shown in Figure 7-17, we declare a node <code>cur</code> and start from the binary tree's root node <code>root</code>, looping to compare the node value <code>cur.val</code> with <code>num</code>.</p> <ul> <li>If <code>cur.val &lt; num</code>, it means the target node is in <code>cur</code>'s right subtree, thus execute <code>cur = cur.right</code>.</li> <li>If <code>cur.val &gt; num</code>, it means the target node is in <code>cur</code>'s left subtree, thus execute <code>cur = cur.left</code>.</li> <li>If <code>cur.val = num</code>, it means the target node is found, exit the loop, and return the node.</li> </ul> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 7-17 \u00a0 Example of searching for a node in a binary search tree </p> <p>The search operation in a binary search tree works on the same principle as the binary search algorithm, both eliminating half of the cases in each round. The number of loop iterations is at most the height of the binary tree. When the binary tree is balanced, it uses \\(O(\\log n)\\) time. The example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_tree.py<pre><code>def search(self, num: int) -&gt; TreeNode | None:\n    \"\"\"Search node\"\"\"\n    cur = self._root\n    # Loop search, exit after passing leaf node\n    while cur is not None:\n        # Target node is in cur's right subtree\n        if cur.val &lt; num:\n            cur = cur.right\n        # Target node is in cur's left subtree\n        elif cur.val &gt; num:\n            cur = cur.left\n        # Found target node, exit loop\n        else:\n            break\n    return cur\n</code></pre> binary_search_tree.cpp<pre><code>/* Search node */\nTreeNode *search(int num) {\n    TreeNode *cur = root;\n    // Loop search, exit after passing leaf node\n    while (cur != nullptr) {\n        // Target node is in cur's right subtree\n        if (cur-&gt;val &lt; num)\n            cur = cur-&gt;right;\n        // Target node is in cur's left subtree\n        else if (cur-&gt;val &gt; num)\n            cur = cur-&gt;left;\n        // Found target node, exit loop\n        else\n            break;\n    }\n    // Return target node\n    return cur;\n}\n</code></pre> binary_search_tree.java<pre><code>/* Search node */\nTreeNode search(int num) {\n    TreeNode cur = root;\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Target node is in cur's right subtree\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // Target node is in cur's left subtree\n        else if (cur.val &gt; num)\n            cur = cur.left;\n        // Found target node, exit loop\n        else\n            break;\n    }\n    // Return target node\n    return cur;\n}\n</code></pre> binary_search_tree.cs<pre><code>/* Search node */\nTreeNode? Search(int num) {\n    TreeNode? cur = root;\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Target node is in cur's right subtree\n        if (cur.val &lt; num) cur =\n            cur.right;\n        // Target node is in cur's left subtree\n        else if (cur.val &gt; num)\n            cur = cur.left;\n        // Found target node, exit loop\n        else\n            break;\n    }\n    // Return target node\n    return cur;\n}\n</code></pre> binary_search_tree.go<pre><code>/* Search node */\nfunc (bst *binarySearchTree) search(num int) *TreeNode {\n    node := bst.root\n    // Loop search, exit after passing leaf node\n    for node != nil {\n        if node.Val.(int) &lt; num {\n            // Target node is in cur's right subtree\n            node = node.Right\n        } else if node.Val.(int) &gt; num {\n            // Target node is in cur's left subtree\n            node = node.Left\n        } else {\n            // Found target node, exit loop\n            break\n        }\n    }\n    // Return target node\n    return node\n}\n</code></pre> binary_search_tree.swift<pre><code>/* Search node */\nfunc search(num: Int) -&gt; TreeNode? {\n    var cur = root\n    // Loop search, exit after passing leaf node\n    while cur != nil {\n        // Target node is in cur's right subtree\n        if cur!.val &lt; num {\n            cur = cur?.right\n        }\n        // Target node is in cur's left subtree\n        else if cur!.val &gt; num {\n            cur = cur?.left\n        }\n        // Found target node, exit loop\n        else {\n            break\n        }\n    }\n    // Return target node\n    return cur\n}\n</code></pre> binary_search_tree.js<pre><code>/* Search node */\nsearch(num) {\n    let cur = this.root;\n    // Loop search, exit after passing leaf node\n    while (cur !== null) {\n        // Target node is in cur's right subtree\n        if (cur.val &lt; num) cur = cur.right;\n        // Target node is in cur's left subtree\n        else if (cur.val &gt; num) cur = cur.left;\n        // Found target node, exit loop\n        else break;\n    }\n    // Return target node\n    return cur;\n}\n</code></pre> binary_search_tree.ts<pre><code>/* Search node */\nsearch(num: number): TreeNode | null {\n    let cur = this.root;\n    // Loop search, exit after passing leaf node\n    while (cur !== null) {\n        // Target node is in cur's right subtree\n        if (cur.val &lt; num) cur = cur.right;\n        // Target node is in cur's left subtree\n        else if (cur.val &gt; num) cur = cur.left;\n        // Found target node, exit loop\n        else break;\n    }\n    // Return target node\n    return cur;\n}\n</code></pre> binary_search_tree.dart<pre><code>/* Search node */\nTreeNode? search(int _num) {\n  TreeNode? cur = _root;\n  // Loop search, exit after passing leaf node\n  while (cur != null) {\n    // Target node is in cur's right subtree\n    if (cur.val &lt; _num)\n      cur = cur.right;\n    // Target node is in cur's left subtree\n    else if (cur.val &gt; _num)\n      cur = cur.left;\n    // Found target node, exit loop\n    else\n      break;\n  }\n  // Return target node\n  return cur;\n}\n</code></pre> binary_search_tree.rs<pre><code>/* Search node */\npub fn search(&amp;self, num: i32) -&gt; OptionTreeNodeRc {\n    let mut cur = self.root.clone();\n    // Loop search, exit after passing leaf node\n    while let Some(node) = cur.clone() {\n        match num.cmp(&amp;node.borrow().val) {\n            // Target node is in cur's right subtree\n            Ordering::Greater =&gt; cur = node.borrow().right.clone(),\n            // Target node is in cur's left subtree\n            Ordering::Less =&gt; cur = node.borrow().left.clone(),\n            // Found target node, exit loop\n            Ordering::Equal =&gt; break,\n        }\n    }\n\n    // Return target node\n    cur\n}\n</code></pre> binary_search_tree.c<pre><code>/* Search node */\nTreeNode *search(BinarySearchTree *bst, int num) {\n    TreeNode *cur = bst-&gt;root;\n    // Loop search, exit after passing leaf node\n    while (cur != NULL) {\n        if (cur-&gt;val &lt; num) {\n            // Target node is in cur's right subtree\n            cur = cur-&gt;right;\n        } else if (cur-&gt;val &gt; num) {\n            // Target node is in cur's left subtree\n            cur = cur-&gt;left;\n        } else {\n            // Found target node, exit loop\n            break;\n        }\n    }\n    // Return target node\n    return cur;\n}\n</code></pre> binary_search_tree.kt<pre><code>/* Search node */\nfun search(num: Int): TreeNode? {\n    var cur = root\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Target node is in cur's right subtree\n        cur = if (cur._val &lt; num)\n            cur.right\n        // Target node is in cur's left subtree\n        else if (cur._val &gt; num)\n            cur.left\n        // Found target node, exit loop\n        else\n            break\n    }\n    // Return target node\n    return cur\n}\n</code></pre> binary_search_tree.rb<pre><code>### Search node ###\ndef search(num)\n  cur = @root\n\n  # Loop search, exit after passing leaf node\n  while !cur.nil?\n    # Target node is in cur's right subtree\n    if cur.val &lt; num\n      cur = cur.right\n    # Target node is in cur's left subtree\n    elsif cur.val &gt; num\n      cur = cur.left\n    # Found target node, exit loop\n    else\n      break\n    end\n  end\n\n  cur\nend\n</code></pre>"},{"location":"chapter_tree/binary_search_tree/#2-inserting-a-node","title":"2. \u00a0 Inserting a Node","text":"<p>Given an element <code>num</code> to be inserted, in order to maintain the property of the binary search tree \"left subtree &lt; root node &lt; right subtree,\" the insertion process is as shown in Figure 7-18.</p> <ol> <li>Finding the insertion position: Similar to the search operation, start from the root node and loop downward searching according to the size relationship between the current node value and <code>num</code>, until passing the leaf node (traversing to <code>None</code>) and then exit the loop.</li> <li>Insert the node at that position: Initialize node <code>num</code> and place it at the <code>None</code> position.</li> </ol> <p></p> <p> Figure 7-18 \u00a0 Inserting a node into a binary search tree </p> <p>In the code implementation, note the following two points:</p> <ul> <li>Binary search trees do not allow duplicate nodes; otherwise, it would violate its definition. Therefore, if the node to be inserted already exists in the tree, the insertion is not performed and it returns directly.</li> <li>To implement the node insertion, we need to use node <code>pre</code> to save the node from the previous loop iteration. This way, when traversing to <code>None</code>, we can obtain its parent node, thereby completing the node insertion operation.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_tree.py<pre><code>def insert(self, num: int):\n    \"\"\"Insert node\"\"\"\n    # If tree is empty, initialize root node\n    if self._root is None:\n        self._root = TreeNode(num)\n        return\n    # Loop search, exit after passing leaf node\n    cur, pre = self._root, None\n    while cur is not None:\n        # Found duplicate node, return directly\n        if cur.val == num:\n            return\n        pre = cur\n        # Insertion position is in cur's right subtree\n        if cur.val &lt; num:\n            cur = cur.right\n        # Insertion position is in cur's left subtree\n        else:\n            cur = cur.left\n    # Insert node\n    node = TreeNode(num)\n    if pre.val &lt; num:\n        pre.right = node\n    else:\n        pre.left = node\n</code></pre> binary_search_tree.cpp<pre><code>/* Insert node */\nvoid insert(int num) {\n    // If tree is empty, initialize root node\n    if (root == nullptr) {\n        root = new TreeNode(num);\n        return;\n    }\n    TreeNode *cur = root, *pre = nullptr;\n    // Loop search, exit after passing leaf node\n    while (cur != nullptr) {\n        // Found duplicate node, return directly\n        if (cur-&gt;val == num)\n            return;\n        pre = cur;\n        // Insertion position is in cur's right subtree\n        if (cur-&gt;val &lt; num)\n            cur = cur-&gt;right;\n        // Insertion position is in cur's left subtree\n        else\n            cur = cur-&gt;left;\n    }\n    // Insert node\n    TreeNode *node = new TreeNode(num);\n    if (pre-&gt;val &lt; num)\n        pre-&gt;right = node;\n    else\n        pre-&gt;left = node;\n}\n</code></pre> binary_search_tree.java<pre><code>/* Insert node */\nvoid insert(int num) {\n    // If tree is empty, initialize root node\n    if (root == null) {\n        root = new TreeNode(num);\n        return;\n    }\n    TreeNode cur = root, pre = null;\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Found duplicate node, return directly\n        if (cur.val == num)\n            return;\n        pre = cur;\n        // Insertion position is in cur's right subtree\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // Insertion position is in cur's left subtree\n        else\n            cur = cur.left;\n    }\n    // Insert node\n    TreeNode node = new TreeNode(num);\n    if (pre.val &lt; num)\n        pre.right = node;\n    else\n        pre.left = node;\n}\n</code></pre> binary_search_tree.cs<pre><code>/* Insert node */\nvoid Insert(int num) {\n    // If tree is empty, initialize root node\n    if (root == null) {\n        root = new TreeNode(num);\n        return;\n    }\n    TreeNode? cur = root, pre = null;\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Found duplicate node, return directly\n        if (cur.val == num)\n            return;\n        pre = cur;\n        // Insertion position is in cur's right subtree\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // Insertion position is in cur's left subtree\n        else\n            cur = cur.left;\n    }\n\n    // Insert node\n    TreeNode node = new(num);\n    if (pre != null) {\n        if (pre.val &lt; num)\n            pre.right = node;\n        else\n            pre.left = node;\n    }\n}\n</code></pre> binary_search_tree.go<pre><code>/* Insert node */\nfunc (bst *binarySearchTree) insert(num int) {\n    cur := bst.root\n    // If tree is empty, initialize root node\n    if cur == nil {\n        bst.root = NewTreeNode(num)\n        return\n    }\n    // Node position before the node to be inserted\n    var pre *TreeNode = nil\n    // Loop search, exit after passing leaf node\n    for cur != nil {\n        if cur.Val == num {\n            return\n        }\n        pre = cur\n        if cur.Val.(int) &lt; num {\n            cur = cur.Right\n        } else {\n            cur = cur.Left\n        }\n    }\n    // Insert node\n    node := NewTreeNode(num)\n    if pre.Val.(int) &lt; num {\n        pre.Right = node\n    } else {\n        pre.Left = node\n    }\n}\n</code></pre> binary_search_tree.swift<pre><code>/* Insert node */\nfunc insert(num: Int) {\n    // If tree is empty, initialize root node\n    if root == nil {\n        root = TreeNode(x: num)\n        return\n    }\n    var cur = root\n    var pre: TreeNode?\n    // Loop search, exit after passing leaf node\n    while cur != nil {\n        // Found duplicate node, return directly\n        if cur!.val == num {\n            return\n        }\n        pre = cur\n        // Insertion position is in cur's right subtree\n        if cur!.val &lt; num {\n            cur = cur?.right\n        }\n        // Insertion position is in cur's left subtree\n        else {\n            cur = cur?.left\n        }\n    }\n    // Insert node\n    let node = TreeNode(x: num)\n    if pre!.val &lt; num {\n        pre?.right = node\n    } else {\n        pre?.left = node\n    }\n}\n</code></pre> binary_search_tree.js<pre><code>/* Insert node */\ninsert(num) {\n    // If tree is empty, initialize root node\n    if (this.root === null) {\n        this.root = new TreeNode(num);\n        return;\n    }\n    let cur = this.root,\n        pre = null;\n    // Loop search, exit after passing leaf node\n    while (cur !== null) {\n        // Found duplicate node, return directly\n        if (cur.val === num) return;\n        pre = cur;\n        // Insertion position is in cur's right subtree\n        if (cur.val &lt; num) cur = cur.right;\n        // Insertion position is in cur's left subtree\n        else cur = cur.left;\n    }\n    // Insert node\n    const node = new TreeNode(num);\n    if (pre.val &lt; num) pre.right = node;\n    else pre.left = node;\n}\n</code></pre> binary_search_tree.ts<pre><code>/* Insert node */\ninsert(num: number): void {\n    // If tree is empty, initialize root node\n    if (this.root === null) {\n        this.root = new TreeNode(num);\n        return;\n    }\n    let cur: TreeNode | null = this.root,\n        pre: TreeNode | null = null;\n    // Loop search, exit after passing leaf node\n    while (cur !== null) {\n        // Found duplicate node, return directly\n        if (cur.val === num) return;\n        pre = cur;\n        // Insertion position is in cur's right subtree\n        if (cur.val &lt; num) cur = cur.right;\n        // Insertion position is in cur's left subtree\n        else cur = cur.left;\n    }\n    // Insert node\n    const node = new TreeNode(num);\n    if (pre!.val &lt; num) pre!.right = node;\n    else pre!.left = node;\n}\n</code></pre> binary_search_tree.dart<pre><code>/* Insert node */\nvoid insert(int _num) {\n  // If tree is empty, initialize root node\n  if (_root == null) {\n    _root = TreeNode(_num);\n    return;\n  }\n  TreeNode? cur = _root;\n  TreeNode? pre = null;\n  // Loop search, exit after passing leaf node\n  while (cur != null) {\n    // Found duplicate node, return directly\n    if (cur.val == _num) return;\n    pre = cur;\n    // Insertion position is in cur's right subtree\n    if (cur.val &lt; _num)\n      cur = cur.right;\n    // Insertion position is in cur's left subtree\n    else\n      cur = cur.left;\n  }\n  // Insert node\n  TreeNode? node = TreeNode(_num);\n  if (pre!.val &lt; _num)\n    pre.right = node;\n  else\n    pre.left = node;\n}\n</code></pre> binary_search_tree.rs<pre><code>/* Insert node */\npub fn insert(&amp;mut self, num: i32) {\n    // If tree is empty, initialize root node\n    if self.root.is_none() {\n        self.root = Some(TreeNode::new(num));\n        return;\n    }\n    let mut cur = self.root.clone();\n    let mut pre = None;\n    // Loop search, exit after passing leaf node\n    while let Some(node) = cur.clone() {\n        match num.cmp(&amp;node.borrow().val) {\n            // Found duplicate node, return directly\n            Ordering::Equal =&gt; return,\n            // Insertion position is in cur's right subtree\n            Ordering::Greater =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().right.clone();\n            }\n            // Insertion position is in cur's left subtree\n            Ordering::Less =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().left.clone();\n            }\n        }\n    }\n    // Insert node\n    let pre = pre.unwrap();\n    let node = Some(TreeNode::new(num));\n    if num &gt; pre.borrow().val {\n        pre.borrow_mut().right = node;\n    } else {\n        pre.borrow_mut().left = node;\n    }\n}\n</code></pre> binary_search_tree.c<pre><code>/* Insert node */\nvoid insert(BinarySearchTree *bst, int num) {\n    // If tree is empty, initialize root node\n    if (bst-&gt;root == NULL) {\n        bst-&gt;root = newTreeNode(num);\n        return;\n    }\n    TreeNode *cur = bst-&gt;root, *pre = NULL;\n    // Loop search, exit after passing leaf node\n    while (cur != NULL) {\n        // Found duplicate node, return directly\n        if (cur-&gt;val == num) {\n            return;\n        }\n        pre = cur;\n        if (cur-&gt;val &lt; num) {\n            // Insertion position is in cur's right subtree\n            cur = cur-&gt;right;\n        } else {\n            // Insertion position is in cur's left subtree\n            cur = cur-&gt;left;\n        }\n    }\n    // Insert node\n    TreeNode *node = newTreeNode(num);\n    if (pre-&gt;val &lt; num) {\n        pre-&gt;right = node;\n    } else {\n        pre-&gt;left = node;\n    }\n}\n</code></pre> binary_search_tree.kt<pre><code>/* Insert node */\nfun insert(num: Int) {\n    // If tree is empty, initialize root node\n    if (root == null) {\n        root = TreeNode(num)\n        return\n    }\n    var cur = root\n    var pre: TreeNode? = null\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Found duplicate node, return directly\n        if (cur._val == num)\n            return\n        pre = cur\n        // Insertion position is in cur's right subtree\n        cur = if (cur._val &lt; num)\n            cur.right\n        // Insertion position is in cur's left subtree\n        else\n            cur.left\n    }\n    // Insert node\n    val node = TreeNode(num)\n    if (pre?._val!! &lt; num)\n        pre.right = node\n    else\n        pre.left = node\n}\n</code></pre> binary_search_tree.rb<pre><code>### Insert node ###\ndef insert(num)\n  # If tree is empty, initialize root node\n  if @root.nil?\n    @root = TreeNode.new(num)\n    return\n  end\n\n  # Loop search, exit after passing leaf node\n  cur, pre = @root, nil\n  while !cur.nil?\n    # Found duplicate node, return directly\n    return if cur.val == num\n\n    pre = cur\n    # Insertion position is in cur's right subtree\n    if cur.val &lt; num\n      cur = cur.right\n    # Insertion position is in cur's left subtree\n    else\n      cur = cur.left\n    end\n  end\n\n  # Insert node\n  node = TreeNode.new(num)\n  if pre.val &lt; num\n    pre.right = node\n  else\n    pre.left = node\n  end\nend\n</code></pre> <p>Similar to searching for a node, inserting a node uses \\(O(\\log n)\\) time.</p>"},{"location":"chapter_tree/binary_search_tree/#3-removing-a-node","title":"3. \u00a0 Removing a Node","text":"<p>First, find the target node in the binary tree, then remove it. Similar to node insertion, we need to ensure that after the removal operation is completed, the binary search tree's property of \"left subtree \\(&lt;\\) root node \\(&lt;\\) right subtree\" is still maintained. Therefore, depending on the number of child nodes the target node has, we divide it into 0, 1, and 2 three cases, and execute the corresponding node removal operations.</p> <p>As shown in Figure 7-19, when the degree of the node to be removed is \\(0\\), it means the node is a leaf node and can be directly removed.</p> <p></p> <p> Figure 7-19 \u00a0 Removing a node in a binary search tree (degree 0) </p> <p>As shown in Figure 7-20, when the degree of the node to be removed is \\(1\\), replacing the node to be removed with its child node is sufficient.</p> <p></p> <p> Figure 7-20 \u00a0 Removing a node in a binary search tree (degree 1) </p> <p>When the degree of the node to be removed is \\(2\\), we cannot directly remove it; instead, we need to use a node to replace it. To maintain the binary search tree's property of \"left subtree \\(&lt;\\) root node \\(&lt;\\) right subtree,\" this node can be either the smallest node in the right subtree or the largest node in the left subtree.</p> <p>Assuming we choose the smallest node in the right subtree (the next node in the inorder traversal), the removal process is as shown in Figure 7-21.</p> <ol> <li>Find the next node of the node to be removed in the \"inorder traversal sequence,\" denoted as <code>tmp</code>.</li> <li>Replace the value of the node to be removed with the value of <code>tmp</code>, and recursively remove node <code>tmp</code> in the tree.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 7-21 \u00a0 Removing a node in a binary search tree (degree 2) </p> <p>The node removal operation also uses \\(O(\\log n)\\) time, where finding the node to be removed requires \\(O(\\log n)\\) time, and obtaining the inorder successor node requires \\(O(\\log n)\\) time. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_search_tree.py<pre><code>def remove(self, num: int):\n    \"\"\"Delete node\"\"\"\n    # If tree is empty, return directly\n    if self._root is None:\n        return\n    # Loop search, exit after passing leaf node\n    cur, pre = self._root, None\n    while cur is not None:\n        # Found node to delete, exit loop\n        if cur.val == num:\n            break\n        pre = cur\n        # Node to delete is in cur's right subtree\n        if cur.val &lt; num:\n            cur = cur.right\n        # Node to delete is in cur's left subtree\n        else:\n            cur = cur.left\n    # If no node to delete, return directly\n    if cur is None:\n        return\n\n    # Number of child nodes = 0 or 1\n    if cur.left is None or cur.right is None:\n        # When number of child nodes = 0 / 1, child = null / that child node\n        child = cur.left or cur.right\n        # Delete node cur\n        if cur != self._root:\n            if pre.left == cur:\n                pre.left = child\n            else:\n                pre.right = child\n        else:\n            # If deleted node is root node, reassign root node\n            self._root = child\n    # Number of child nodes = 2\n    else:\n        # Get next node of cur in inorder traversal\n        tmp: TreeNode = cur.right\n        while tmp.left is not None:\n            tmp = tmp.left\n        # Recursively delete node tmp\n        self.remove(tmp.val)\n        # Replace cur with tmp\n        cur.val = tmp.val\n</code></pre> binary_search_tree.cpp<pre><code>/* Remove node */\nvoid remove(int num) {\n    // If tree is empty, return directly\n    if (root == nullptr)\n        return;\n    TreeNode *cur = root, *pre = nullptr;\n    // Loop search, exit after passing leaf node\n    while (cur != nullptr) {\n        // Found node to delete, exit loop\n        if (cur-&gt;val == num)\n            break;\n        pre = cur;\n        // Node to delete is in cur's right subtree\n        if (cur-&gt;val &lt; num)\n            cur = cur-&gt;right;\n        // Node to delete is in cur's left subtree\n        else\n            cur = cur-&gt;left;\n    }\n    // If no node to delete, return directly\n    if (cur == nullptr)\n        return;\n    // Number of child nodes = 0 or 1\n    if (cur-&gt;left == nullptr || cur-&gt;right == nullptr) {\n        // When number of child nodes = 0 / 1, child = nullptr / that child node\n        TreeNode *child = cur-&gt;left != nullptr ? cur-&gt;left : cur-&gt;right;\n        // Delete node cur\n        if (cur != root) {\n            if (pre-&gt;left == cur)\n                pre-&gt;left = child;\n            else\n                pre-&gt;right = child;\n        } else {\n            // If deleted node is root node, reassign root node\n            root = child;\n        }\n        // Free memory\n        delete cur;\n    }\n    // Number of child nodes = 2\n    else {\n        // Get next node of cur in inorder traversal\n        TreeNode *tmp = cur-&gt;right;\n        while (tmp-&gt;left != nullptr) {\n            tmp = tmp-&gt;left;\n        }\n        int tmpVal = tmp-&gt;val;\n        // Recursively delete node tmp\n        remove(tmp-&gt;val);\n        // Replace cur with tmp\n        cur-&gt;val = tmpVal;\n    }\n}\n</code></pre> binary_search_tree.java<pre><code>/* Remove node */\nvoid remove(int num) {\n    // If tree is empty, return directly\n    if (root == null)\n        return;\n    TreeNode cur = root, pre = null;\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Found node to delete, exit loop\n        if (cur.val == num)\n            break;\n        pre = cur;\n        // Node to delete is in cur's right subtree\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // Node to delete is in cur's left subtree\n        else\n            cur = cur.left;\n    }\n    // If no node to delete, return directly\n    if (cur == null)\n        return;\n    // Number of child nodes = 0 or 1\n    if (cur.left == null || cur.right == null) {\n        // When number of child nodes = 0 / 1, child = null / that child node\n        TreeNode child = cur.left != null ? cur.left : cur.right;\n        // Delete node cur\n        if (cur != root) {\n            if (pre.left == cur)\n                pre.left = child;\n            else\n                pre.right = child;\n        } else {\n            // If deleted node is root node, reassign root node\n            root = child;\n        }\n    }\n    // Number of child nodes = 2\n    else {\n        // Get next node of cur in inorder traversal\n        TreeNode tmp = cur.right;\n        while (tmp.left != null) {\n            tmp = tmp.left;\n        }\n        // Recursively delete node tmp\n        remove(tmp.val);\n        // Replace cur with tmp\n        cur.val = tmp.val;\n    }\n}\n</code></pre> binary_search_tree.cs<pre><code>/* Remove node */\nvoid Remove(int num) {\n    // If tree is empty, return directly\n    if (root == null)\n        return;\n    TreeNode? cur = root, pre = null;\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Found node to delete, exit loop\n        if (cur.val == num)\n            break;\n        pre = cur;\n        // Node to delete is in cur's right subtree\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // Node to delete is in cur's left subtree\n        else\n            cur = cur.left;\n    }\n    // If no node to delete, return directly\n    if (cur == null)\n        return;\n    // Number of child nodes = 0 or 1\n    if (cur.left == null || cur.right == null) {\n        // When number of child nodes = 0 / 1, child = null / that child node\n        TreeNode? child = cur.left ?? cur.right;\n        // Delete node cur\n        if (cur != root) {\n            if (pre!.left == cur)\n                pre.left = child;\n            else\n                pre.right = child;\n        } else {\n            // If deleted node is root node, reassign root node\n            root = child;\n        }\n    }\n    // Number of child nodes = 2\n    else {\n        // Get next node of cur in inorder traversal\n        TreeNode? tmp = cur.right;\n        while (tmp.left != null) {\n            tmp = tmp.left;\n        }\n        // Recursively delete node tmp\n        Remove(tmp.val!.Value);\n        // Replace cur with tmp\n        cur.val = tmp.val;\n    }\n}\n</code></pre> binary_search_tree.go<pre><code>/* Remove node */\nfunc (bst *binarySearchTree) remove(num int) {\n    cur := bst.root\n    // If tree is empty, return directly\n    if cur == nil {\n        return\n    }\n    // Node position before the node to be removed\n    var pre *TreeNode = nil\n    // Loop search, exit after passing leaf node\n    for cur != nil {\n        if cur.Val == num {\n            break\n        }\n        pre = cur\n        if cur.Val.(int) &lt; num {\n            // Node to be removed is in right subtree\n            cur = cur.Right\n        } else {\n            // Node to be removed is in left subtree\n            cur = cur.Left\n        }\n    }\n    // If no node to delete, return directly\n    if cur == nil {\n        return\n    }\n    // Number of child nodes is 0 or 1\n    if cur.Left == nil || cur.Right == nil {\n        var child *TreeNode = nil\n        // Get child node of node to be removed\n        if cur.Left != nil {\n            child = cur.Left\n        } else {\n            child = cur.Right\n        }\n        // Delete node cur\n        if cur != bst.root {\n            if pre.Left == cur {\n                pre.Left = child\n            } else {\n                pre.Right = child\n            }\n        } else {\n            // If deleted node is root node, reassign root node\n            bst.root = child\n        }\n        // Number of child nodes is 2\n    } else {\n        // Get next node of node cur to be removed in in-order traversal\n        tmp := cur.Right\n        for tmp.Left != nil {\n            tmp = tmp.Left\n        }\n        // Recursively delete node tmp\n        bst.remove(tmp.Val.(int))\n        // Replace cur with tmp\n        cur.Val = tmp.Val\n    }\n}\n</code></pre> binary_search_tree.swift<pre><code>/* Remove node */\nfunc remove(num: Int) {\n    // If tree is empty, return directly\n    if root == nil {\n        return\n    }\n    var cur = root\n    var pre: TreeNode?\n    // Loop search, exit after passing leaf node\n    while cur != nil {\n        // Found node to delete, exit loop\n        if cur!.val == num {\n            break\n        }\n        pre = cur\n        // Node to delete is in cur's right subtree\n        if cur!.val &lt; num {\n            cur = cur?.right\n        }\n        // Node to delete is in cur's left subtree\n        else {\n            cur = cur?.left\n        }\n    }\n    // If no node to delete, return directly\n    if cur == nil {\n        return\n    }\n    // Number of child nodes = 0 or 1\n    if cur?.left == nil || cur?.right == nil {\n        // When number of child nodes = 0 / 1, child = null / that child node\n        let child = cur?.left ?? cur?.right\n        // Delete node cur\n        if cur !== root {\n            if pre?.left === cur {\n                pre?.left = child\n            } else {\n                pre?.right = child\n            }\n        } else {\n            // If deleted node is root node, reassign root node\n            root = child\n        }\n    }\n    // Number of child nodes = 2\n    else {\n        // Get next node of cur in inorder traversal\n        var tmp = cur?.right\n        while tmp?.left != nil {\n            tmp = tmp?.left\n        }\n        // Recursively delete node tmp\n        remove(num: tmp!.val)\n        // Replace cur with tmp\n        cur?.val = tmp!.val\n    }\n}\n</code></pre> binary_search_tree.js<pre><code>/* Remove node */\nremove(num) {\n    // If tree is empty, return directly\n    if (this.root === null) return;\n    let cur = this.root,\n        pre = null;\n    // Loop search, exit after passing leaf node\n    while (cur !== null) {\n        // Found node to delete, exit loop\n        if (cur.val === num) break;\n        pre = cur;\n        // Node to delete is in cur's right subtree\n        if (cur.val &lt; num) cur = cur.right;\n        // Node to delete is in cur's left subtree\n        else cur = cur.left;\n    }\n    // If no node to delete, return directly\n    if (cur === null) return;\n    // Number of child nodes = 0 or 1\n    if (cur.left === null || cur.right === null) {\n        // When number of child nodes = 0 / 1, child = null / that child node\n        const child = cur.left !== null ? cur.left : cur.right;\n        // Delete node cur\n        if (cur !== this.root) {\n            if (pre.left === cur) pre.left = child;\n            else pre.right = child;\n        } else {\n            // If deleted node is root node, reassign root node\n            this.root = child;\n        }\n    }\n    // Number of child nodes = 2\n    else {\n        // Get next node of cur in inorder traversal\n        let tmp = cur.right;\n        while (tmp.left !== null) {\n            tmp = tmp.left;\n        }\n        // Recursively delete node tmp\n        this.remove(tmp.val);\n        // Replace cur with tmp\n        cur.val = tmp.val;\n    }\n}\n</code></pre> binary_search_tree.ts<pre><code>/* Remove node */\nremove(num: number): void {\n    // If tree is empty, return directly\n    if (this.root === null) return;\n    let cur: TreeNode | null = this.root,\n        pre: TreeNode | null = null;\n    // Loop search, exit after passing leaf node\n    while (cur !== null) {\n        // Found node to delete, exit loop\n        if (cur.val === num) break;\n        pre = cur;\n        // Node to delete is in cur's right subtree\n        if (cur.val &lt; num) cur = cur.right;\n        // Node to delete is in cur's left subtree\n        else cur = cur.left;\n    }\n    // If no node to delete, return directly\n    if (cur === null) return;\n    // Number of child nodes = 0 or 1\n    if (cur.left === null || cur.right === null) {\n        // When number of child nodes = 0 / 1, child = null / that child node\n        const child: TreeNode | null =\n            cur.left !== null ? cur.left : cur.right;\n        // Delete node cur\n        if (cur !== this.root) {\n            if (pre!.left === cur) pre!.left = child;\n            else pre!.right = child;\n        } else {\n            // If deleted node is root node, reassign root node\n            this.root = child;\n        }\n    }\n    // Number of child nodes = 2\n    else {\n        // Get next node of cur in inorder traversal\n        let tmp: TreeNode | null = cur.right;\n        while (tmp!.left !== null) {\n            tmp = tmp!.left;\n        }\n        // Recursively delete node tmp\n        this.remove(tmp!.val);\n        // Replace cur with tmp\n        cur.val = tmp!.val;\n    }\n}\n</code></pre> binary_search_tree.dart<pre><code>/* Remove node */\nvoid remove(int _num) {\n  // If tree is empty, return directly\n  if (_root == null) return;\n  TreeNode? cur = _root;\n  TreeNode? pre = null;\n  // Loop search, exit after passing leaf node\n  while (cur != null) {\n    // Found node to delete, exit loop\n    if (cur.val == _num) break;\n    pre = cur;\n    // Node to delete is in cur's right subtree\n    if (cur.val &lt; _num)\n      cur = cur.right;\n    // Node to delete is in cur's left subtree\n    else\n      cur = cur.left;\n  }\n  // If no node to delete, return directly\n  if (cur == null) return;\n  // Number of child nodes = 0 or 1\n  if (cur.left == null || cur.right == null) {\n    // When number of child nodes = 0 / 1, child = null / that child node\n    TreeNode? child = cur.left ?? cur.right;\n    // Delete node cur\n    if (cur != _root) {\n      if (pre!.left == cur)\n        pre.left = child;\n      else\n        pre.right = child;\n    } else {\n      // If deleted node is root node, reassign root node\n      _root = child;\n    }\n  } else {\n    // Number of child nodes = 2\n    // Get next node of cur in inorder traversal\n    TreeNode? tmp = cur.right;\n    while (tmp!.left != null) {\n      tmp = tmp.left;\n    }\n    // Recursively delete node tmp\n    remove(tmp.val);\n    // Replace cur with tmp\n    cur.val = tmp.val;\n  }\n}\n</code></pre> binary_search_tree.rs<pre><code>/* Remove node */\npub fn remove(&amp;mut self, num: i32) {\n    // If tree is empty, return directly\n    if self.root.is_none() {\n        return;\n    }\n    let mut cur = self.root.clone();\n    let mut pre = None;\n    // Loop search, exit after passing leaf node\n    while let Some(node) = cur.clone() {\n        match num.cmp(&amp;node.borrow().val) {\n            // Found node to delete, exit loop\n            Ordering::Equal =&gt; break,\n            // Node to delete is in cur's right subtree\n            Ordering::Greater =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().right.clone();\n            }\n            // Node to delete is in cur's left subtree\n            Ordering::Less =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().left.clone();\n            }\n        }\n    }\n    // If no node to delete, return directly\n    if cur.is_none() {\n        return;\n    }\n    let cur = cur.unwrap();\n    let (left_child, right_child) = (cur.borrow().left.clone(), cur.borrow().right.clone());\n    match (left_child.clone(), right_child.clone()) {\n        // Number of child nodes = 0 or 1\n        (None, None) | (Some(_), None) | (None, Some(_)) =&gt; {\n            // When number of child nodes = 0 / 1, child = nullptr / that child node\n            let child = left_child.or(right_child);\n            let pre = pre.unwrap();\n            // Delete node cur\n            if !Rc::ptr_eq(&amp;cur, self.root.as_ref().unwrap()) {\n                let left = pre.borrow().left.clone();\n                if left.is_some() &amp;&amp; Rc::ptr_eq(left.as_ref().unwrap(), &amp;cur) {\n                    pre.borrow_mut().left = child;\n                } else {\n                    pre.borrow_mut().right = child;\n                }\n            } else {\n                // If deleted node is root node, reassign root node\n                self.root = child;\n            }\n        }\n        // Number of child nodes = 2\n        (Some(_), Some(_)) =&gt; {\n            // Get next node of cur in inorder traversal\n            let mut tmp = cur.borrow().right.clone();\n            while let Some(node) = tmp.clone() {\n                if node.borrow().left.is_some() {\n                    tmp = node.borrow().left.clone();\n                } else {\n                    break;\n                }\n            }\n            let tmp_val = tmp.unwrap().borrow().val;\n            // Recursively delete node tmp\n            self.remove(tmp_val);\n            // Replace cur with tmp\n            cur.borrow_mut().val = tmp_val;\n        }\n    }\n}\n</code></pre> binary_search_tree.c<pre><code>/* Remove node */\n// Cannot use remove keyword here due to stdio.h inclusion\nvoid removeItem(BinarySearchTree *bst, int num) {\n    // If tree is empty, return directly\n    if (bst-&gt;root == NULL)\n        return;\n    TreeNode *cur = bst-&gt;root, *pre = NULL;\n    // Loop search, exit after passing leaf node\n    while (cur != NULL) {\n        // Found node to delete, exit loop\n        if (cur-&gt;val == num)\n            break;\n        pre = cur;\n        if (cur-&gt;val &lt; num) {\n            // Node to delete is in right subtree of root\n            cur = cur-&gt;right;\n        } else {\n            // Node to delete is in left subtree of root\n            cur = cur-&gt;left;\n        }\n    }\n    // If no node to delete, return directly\n    if (cur == NULL)\n        return;\n    // Check if node to delete has children\n    if (cur-&gt;left == NULL || cur-&gt;right == NULL) {\n        /* Number of child nodes = 0 or 1 */\n        // When number of child nodes = 0 / 1, child = nullptr / that child node\n        TreeNode *child = cur-&gt;left != NULL ? cur-&gt;left : cur-&gt;right;\n        // Delete node cur\n        if (pre-&gt;left == cur) {\n            pre-&gt;left = child;\n        } else {\n            pre-&gt;right = child;\n        }\n        // Free memory\n        free(cur);\n    } else {\n        /* Number of child nodes = 2 */\n        // Get next node of cur in inorder traversal\n        TreeNode *tmp = cur-&gt;right;\n        while (tmp-&gt;left != NULL) {\n            tmp = tmp-&gt;left;\n        }\n        int tmpVal = tmp-&gt;val;\n        // Recursively delete node tmp\n        removeItem(bst, tmp-&gt;val);\n        // Replace cur with tmp\n        cur-&gt;val = tmpVal;\n    }\n}\n</code></pre> binary_search_tree.kt<pre><code>/* Remove node */\nfun remove(num: Int) {\n    // If tree is empty, return directly\n    if (root == null)\n        return\n    var cur = root\n    var pre: TreeNode? = null\n    // Loop search, exit after passing leaf node\n    while (cur != null) {\n        // Found node to delete, exit loop\n        if (cur._val == num)\n            break\n        pre = cur\n        // Node to delete is in cur's right subtree\n        cur = if (cur._val &lt; num)\n            cur.right\n        // Node to delete is in cur's left subtree\n        else\n            cur.left\n    }\n    // If no node to delete, return directly\n    if (cur == null)\n        return\n    // Number of child nodes = 0 or 1\n    if (cur.left == null || cur.right == null) {\n        // When number of child nodes = 0 / 1, child = null / that child node\n        val child = if (cur.left != null)\n            cur.left\n        else\n            cur.right\n        // Delete node cur\n        if (cur != root) {\n            if (pre!!.left == cur)\n                pre.left = child\n            else\n                pre.right = child\n        } else {\n            // If deleted node is root node, reassign root node\n            root = child\n        }\n        // Number of child nodes = 2\n    } else {\n        // Get next node of cur in inorder traversal\n        var tmp = cur.right\n        while (tmp!!.left != null) {\n            tmp = tmp.left\n        }\n        // Recursively delete node tmp\n        remove(tmp._val)\n        // Replace cur with tmp\n        cur._val = tmp._val\n    }\n}\n</code></pre> binary_search_tree.rb<pre><code>### Delete node ###\ndef remove(num)\n  # If tree is empty, return directly\n  return if @root.nil?\n\n  # Loop search, exit after passing leaf node\n  cur, pre = @root, nil\n  while !cur.nil?\n    # Found node to delete, exit loop\n    break if cur.val == num\n\n    pre = cur\n    # Node to delete is in cur's right subtree\n    if cur.val &lt; num\n      cur = cur.right\n    # Node to delete is in cur's left subtree\n    else\n      cur = cur.left\n    end\n  end\n  # If no node to delete, return directly\n  return if cur.nil?\n\n  # Number of child nodes = 0 or 1\n  if cur.left.nil? || cur.right.nil?\n    # When number of child nodes = 0 / 1, child = null / that child node\n    child = cur.left || cur.right\n    # Delete node cur\n    if cur != @root\n      if pre.left == cur\n        pre.left = child\n      else\n        pre.right = child\n      end\n    else\n      # If deleted node is root node, reassign root node\n      @root = child\n    end\n  # Number of child nodes = 2\n  else\n    # Get next node of cur in inorder traversal\n    tmp = cur.right\n    while !tmp.left.nil?\n      tmp = tmp.left\n    end\n    # Recursively delete node tmp\n    remove(tmp.val)\n    # Replace cur with tmp\n    cur.val = tmp.val\n  end\nend\n</code></pre>"},{"location":"chapter_tree/binary_search_tree/#4-inorder-traversal-is-ordered","title":"4. \u00a0 Inorder Traversal Is Ordered","text":"<p>As shown in Figure 7-22, the inorder traversal of a binary tree follows the \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\" traversal order, while the binary search tree satisfies the \"left child node \\(&lt;\\) root node \\(&lt;\\) right child node\" size relationship.</p> <p>This means that when performing an inorder traversal in a binary search tree, the next smallest node is always traversed first, thus yielding an important property: The inorder traversal sequence of a binary search tree is ascending.</p> <p>Using the property of inorder traversal being ascending, we can obtain ordered data in a binary search tree in only \\(O(n)\\) time, without the need for additional sorting operations, which is very efficient.</p> <p></p> <p> Figure 7-22 \u00a0 Inorder traversal sequence of a binary search tree </p>"},{"location":"chapter_tree/binary_search_tree/#742-efficiency-of-binary-search-trees","title":"7.4.2 \u00a0 Efficiency of Binary Search Trees","text":"<p>Given a set of data, we consider using an array or a binary search tree for storage. Observing Table 7-2, all operations in a binary search tree have logarithmic time complexity, providing stable and efficient performance. Arrays are more efficient than binary search trees only in scenarios with high-frequency additions and low-frequency searches and deletions.</p> <p> Table 7-2 \u00a0 Efficiency comparison between arrays and search trees </p> Unsorted array Binary search tree Search element \\(O(n)\\) \\(O(\\log n)\\) Insert element \\(O(1)\\) \\(O(\\log n)\\) Remove element \\(O(n)\\) \\(O(\\log n)\\) <p>In the ideal case, a binary search tree is \"balanced,\" such that any node can be found within \\(\\log n\\) loop iterations.</p> <p>However, if we continuously insert and remove nodes in a binary search tree, it may degenerate into a linked list as shown in Figure 7-23, where the time complexity of various operations also degrades to \\(O(n)\\).</p> <p></p> <p> Figure 7-23 \u00a0 Degradation of a binary search tree </p>"},{"location":"chapter_tree/binary_search_tree/#743-common-applications-of-binary-search-trees","title":"7.4.3 \u00a0 Common Applications of Binary Search Trees","text":"<ul> <li>Used as multi-level indexes in systems to implement efficient search, insertion, and removal operations.</li> <li>Serves as the underlying data structure for certain search algorithms.</li> <li>Used to store data streams to maintain their ordered state.</li> </ul>"},{"location":"chapter_tree/binary_tree/","title":"7.1 \u00a0 Binary Tree","text":"<p>A binary tree is a non-linear data structure that represents the derivation relationship between \"ancestors\" and \"descendants\" and embodies the divide-and-conquer logic of \"one divides into two\". Similar to a linked list, the basic unit of a binary tree is a node, and each node contains a value, a reference to its left child node, and a reference to its right child node.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby <pre><code>class TreeNode:\n    \"\"\"Binary tree node\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                # Node value\n        self.left: TreeNode | None = None  # Reference to left child node\n        self.right: TreeNode | None = None # Reference to right child node\n</code></pre> <pre><code>/* Binary tree node */\nstruct TreeNode {\n    int val;          // Node value\n    TreeNode *left;   // Pointer to left child node\n    TreeNode *right;  // Pointer to right child node\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    int val;         // Node value\n    TreeNode left;   // Reference to left child node\n    TreeNode right;  // Reference to right child node\n    TreeNode(int x) { val = x; }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode(int? x) {\n    public int? val = x;    // Node value\n    public TreeNode? left;  // Reference to left child node\n    public TreeNode? right; // Reference to right child node\n}\n</code></pre> <pre><code>/* Binary tree node */\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n/* Constructor */\nfunc NewTreeNode(v int) *TreeNode {\n    return &amp;TreeNode{\n        Left:  nil, // Pointer to left child node\n        Right: nil, // Pointer to right child node\n        Val:   v,   // Node value\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    var val: Int // Node value\n    var left: TreeNode? // Reference to left child node\n    var right: TreeNode? // Reference to right child node\n\n    init(x: Int) {\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    val; // Node value\n    left; // Pointer to left child node\n    right; // Pointer to right child node\n    constructor(val, left, right) {\n        this.val = val === undefined ? 0 : val;\n        this.left = left === undefined ? null : left;\n        this.right = right === undefined ? null : right;\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val; // Node value\n        this.left = left === undefined ? null : left; // Reference to left child node\n        this.right = right === undefined ? null : right; // Reference to right child node\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n  int val;         // Node value\n  TreeNode? left;  // Reference to left child node\n  TreeNode? right; // Reference to right child node\n  TreeNode(this.val, [this.left, this.right]);\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Binary tree node */\nstruct TreeNode {\n    val: i32,                               // Node value\n    left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,    // Reference to left child node\n    right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,   // Reference to right child node\n}\n\nimpl TreeNode {\n    /* Constructor */\n    fn new(val: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {\n        Rc::new(RefCell::new(Self {\n            val,\n            left: None,\n            right: None\n        }))\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\ntypedef struct TreeNode {\n    int val;                // Node value\n    int height;             // Node height\n    struct TreeNode *left;  // Pointer to left child node\n    struct TreeNode *right; // Pointer to right child node\n} TreeNode;\n\n/* Constructor */\nTreeNode *newTreeNode(int val) {\n    TreeNode *node;\n\n    node = (TreeNode *)malloc(sizeof(TreeNode));\n    node-&gt;val = val;\n    node-&gt;height = 0;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode(val _val: Int) {  // Node value\n    val left: TreeNode? = null   // Reference to left child node\n    val right: TreeNode? = null  // Reference to right child node\n}\n</code></pre> <pre><code>### Binary tree node class ###\nclass TreeNode\n  attr_accessor :val    # Node value\n  attr_accessor :left   # Reference to left child node\n  attr_accessor :right  # Reference to right child node\n\n  def initialize(val)\n    @val = val\n  end\nend\n</code></pre> <p>Each node has two references (pointers), pointing respectively to the left-child node and right-child node. This node is called the parent node of these two child nodes. When given a node of a binary tree, we call the tree formed by this node's left child and all nodes below it the left subtree of this node. Similarly, the right subtree can be defined.</p> <p>In a binary tree, except leaf nodes, all other nodes contain child nodes and non-empty subtrees. As shown in Figure 7-1, if \"Node 2\" is regarded as a parent node, its left and right child nodes are \"Node 4\" and \"Node 5\" respectively. The left subtree is formed by \"Node 4\" and all nodes beneath it, while the right subtree is formed by \"Node 5\" and all nodes beneath it.</p> <p></p> <p> Figure 7-1 \u00a0 Parent Node, child Node, subtree </p>"},{"location":"chapter_tree/binary_tree/#711-common-terminology-of-binary-trees","title":"7.1.1 \u00a0 Common Terminology of Binary Trees","text":"<p>The commonly used terminology of binary trees is shown in Figure 7-2.</p> <ul> <li>Root node: The node at the top level of a binary tree, which does not have a parent node.</li> <li>Leaf node: A node that does not have any child nodes, with both of its pointers pointing to <code>None</code>.</li> <li>Edge: A line segment that connects two nodes, representing a reference (pointer) between the nodes.</li> <li>The level of a node: It increases from top to bottom, with the root node being at level 1.</li> <li>The degree of a node: The number of child nodes that a node has. In a binary tree, the degree can be 0, 1, or 2.</li> <li>The height of a binary tree: The number of edges from the root node to the farthest leaf node.</li> <li>The depth of a node: The number of edges from the root node to the node.</li> <li>The height of a node: The number of edges from the farthest leaf node to the node.</li> </ul> <p></p> <p> Figure 7-2 \u00a0 Common Terminology of Binary Trees </p> <p>Tip</p> <p>Please note that we usually define \"height\" and \"depth\" as \"the number of edges traversed\", but some questions or textbooks may define them as \"the number of nodes traversed\". In this case, both height and depth need to be incremented by 1.</p>"},{"location":"chapter_tree/binary_tree/#712-basic-operations-of-binary-trees","title":"7.1.2 \u00a0 Basic Operations of Binary Trees","text":""},{"location":"chapter_tree/binary_tree/#1-initializing-a-binary-tree","title":"1. \u00a0 Initializing a Binary Tree","text":"<p>Similar to a linked list, the initialization of a binary tree involves first creating the nodes and then establishing the references (pointers) between them.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_tree.py<pre><code># Initializing a binary tree\n# Initializing nodes\nn1 = TreeNode(val=1)\nn2 = TreeNode(val=2)\nn3 = TreeNode(val=3)\nn4 = TreeNode(val=4)\nn5 = TreeNode(val=5)\n# Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.cpp<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode* n1 = new TreeNode(1);\nTreeNode* n2 = new TreeNode(2);\nTreeNode* n3 = new TreeNode(3);\nTreeNode* n4 = new TreeNode(4);\nTreeNode* n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1-&gt;left = n2;\nn1-&gt;right = n3;\nn2-&gt;left = n4;\nn2-&gt;right = n5;\n</code></pre> binary_tree.java<pre><code>// Initializing nodes\nTreeNode n1 = new TreeNode(1);\nTreeNode n2 = new TreeNode(2);\nTreeNode n3 = new TreeNode(3);\nTreeNode n4 = new TreeNode(4);\nTreeNode n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.cs<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode n1 = new(1);\nTreeNode n2 = new(2);\nTreeNode n3 = new(3);\nTreeNode n4 = new(4);\nTreeNode n5 = new(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.go<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nn1 := NewTreeNode(1)\nn2 := NewTreeNode(2)\nn3 := NewTreeNode(3)\nn4 := NewTreeNode(4)\nn5 := NewTreeNode(5)\n// Linking references (pointers) between nodes\nn1.Left = n2\nn1.Right = n3\nn2.Left = n4\nn2.Right = n5\n</code></pre> binary_tree.swift<pre><code>// Initializing nodes\nlet n1 = TreeNode(x: 1)\nlet n2 = TreeNode(x: 2)\nlet n3 = TreeNode(x: 3)\nlet n4 = TreeNode(x: 4)\nlet n5 = TreeNode(x: 5)\n// Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.js<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nlet n1 = new TreeNode(1),\n    n2 = new TreeNode(2),\n    n3 = new TreeNode(3),\n    n4 = new TreeNode(4),\n    n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.ts<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nlet n1 = new TreeNode(1),\n    n2 = new TreeNode(2),\n    n3 = new TreeNode(3),\n    n4 = new TreeNode(4),\n    n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.dart<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode n1 = new TreeNode(1);\nTreeNode n2 = new TreeNode(2);\nTreeNode n3 = new TreeNode(3);\nTreeNode n4 = new TreeNode(4);\nTreeNode n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.rs<pre><code>// Initializing nodes\nlet n1 = TreeNode::new(1);\nlet n2 = TreeNode::new(2);\nlet n3 = TreeNode::new(3);\nlet n4 = TreeNode::new(4);\nlet n5 = TreeNode::new(5);\n// Linking references (pointers) between nodes\nn1.borrow_mut().left = Some(n2.clone());\nn1.borrow_mut().right = Some(n3);\nn2.borrow_mut().left = Some(n4);\nn2.borrow_mut().right = Some(n5);\n</code></pre> binary_tree.c<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode *n1 = newTreeNode(1);\nTreeNode *n2 = newTreeNode(2);\nTreeNode *n3 = newTreeNode(3);\nTreeNode *n4 = newTreeNode(4);\nTreeNode *n5 = newTreeNode(5);\n// Linking references (pointers) between nodes\nn1-&gt;left = n2;\nn1-&gt;right = n3;\nn2-&gt;left = n4;\nn2-&gt;right = n5;\n</code></pre> binary_tree.kt<pre><code>// Initializing nodes\nval n1 = TreeNode(1)\nval n2 = TreeNode(2)\nval n3 = TreeNode(3)\nval n4 = TreeNode(4)\nval n5 = TreeNode(5)\n// Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.rb<pre><code># Initializing a binary tree\n# Initializing nodes\nn1 = TreeNode.new(1)\nn2 = TreeNode.new(2)\nn3 = TreeNode.new(3)\nn4 = TreeNode.new(4)\nn5 = TreeNode.new(5)\n# Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_tree/binary_tree/#2-inserting-and-removing-nodes","title":"2. \u00a0 Inserting and Removing Nodes","text":"<p>Similar to a linked list, inserting and removing nodes in a binary tree can be achieved by modifying pointers. Figure 7-3 provides an example.</p> <p></p> <p> Figure 7-3 \u00a0 Inserting and removing nodes in a binary tree </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_tree.py<pre><code># Inserting and removing nodes\np = TreeNode(0)\n# Inserting node P between n1 -&gt; n2\nn1.left = p\np.left = n2\n# Removing node P\nn1.left = n2\n</code></pre> binary_tree.cpp<pre><code>/* Inserting and removing nodes */\nTreeNode* P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1-&gt;left = P;\nP-&gt;left = n2;\n// Removing node P\nn1-&gt;left = n2;\n</code></pre> binary_tree.java<pre><code>TreeNode P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.cs<pre><code>/* Inserting and removing nodes */\nTreeNode P = new(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.go<pre><code>/* Inserting and removing nodes */\n// Inserting node P between n1 and n2\np := NewTreeNode(0)\nn1.Left = p\np.Left = n2\n// Removing node P\nn1.Left = n2\n</code></pre> binary_tree.swift<pre><code>let P = TreeNode(x: 0)\n// Inserting node P between n1 and n2\nn1.left = P\nP.left = n2\n// Removing node P\nn1.left = n2\n</code></pre> binary_tree.js<pre><code>/* Inserting and removing nodes */\nlet P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.ts<pre><code>/* Inserting and removing nodes */\nconst P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.dart<pre><code>/* Inserting and removing nodes */\nTreeNode P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.rs<pre><code>let p = TreeNode::new(0);\n// Inserting node P between n1 and n2\nn1.borrow_mut().left = Some(p.clone());\np.borrow_mut().left = Some(n2.clone());\n// Removing node P\nn1.borrow_mut().left = Some(n2);\n</code></pre> binary_tree.c<pre><code>/* Inserting and removing nodes */\nTreeNode *P = newTreeNode(0);\n// Inserting node P between n1 and n2\nn1-&gt;left = P;\nP-&gt;left = n2;\n// Removing node P\nn1-&gt;left = n2;\n</code></pre> binary_tree.kt<pre><code>val P = TreeNode(0)\n// Inserting node P between n1 and n2\nn1.left = P\nP.left = n2\n// Removing node P\nn1.left = n2\n</code></pre> binary_tree.rb<pre><code># Inserting and removing nodes\n_p = TreeNode.new(0)\n# Inserting node _p between n1 and n2\nn1.left = _p\n_p.left = n2\n# Removing node _p\nn1.left = n2\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Tip</p> <p>It should be noted that inserting nodes may change the original logical structure of the binary tree, while removing nodes typically involves removing the node and all its subtrees. Therefore, in a binary tree, insertion and removal are usually performed through a set of operations to achieve meaningful outcomes.</p>"},{"location":"chapter_tree/binary_tree/#713-common-types-of-binary-trees","title":"7.1.3 \u00a0 Common Types of Binary Trees","text":""},{"location":"chapter_tree/binary_tree/#1-perfect-binary-tree","title":"1. \u00a0 Perfect Binary Tree","text":"<p>As shown in Figure 7-4, a perfect binary tree has all levels completely filled with nodes. In a perfect binary tree, leaf nodes have a degree of \\(0\\), while all other nodes have a degree of \\(2\\). If the tree height is \\(h\\), the total number of nodes is \\(2^{h+1} - 1\\), exhibiting a standard exponential relationship that reflects the common phenomenon of cell division in nature.</p> <p>Tip</p> <p>Please note that in the Chinese community, a perfect binary tree is often referred to as a full binary tree.</p> <p></p> <p> Figure 7-4 \u00a0 Perfect binary tree </p>"},{"location":"chapter_tree/binary_tree/#2-complete-binary-tree","title":"2. \u00a0 Complete Binary Tree","text":"<p>As shown in Figure 7-5, a complete binary tree only allows the bottom level to be incompletely filled, and the nodes at the bottom level must be filled continuously from left to right. Note that a perfect binary tree is also a complete binary tree.</p> <p></p> <p> Figure 7-5 \u00a0 Complete binary tree </p>"},{"location":"chapter_tree/binary_tree/#3-full-binary-tree","title":"3. \u00a0 Full Binary Tree","text":"<p>As shown in Figure 7-6, in a full binary tree, all nodes except leaf nodes have two child nodes.</p> <p></p> <p> Figure 7-6 \u00a0 Full binary tree </p>"},{"location":"chapter_tree/binary_tree/#4-balanced-binary-tree","title":"4. \u00a0 Balanced Binary Tree","text":"<p>As shown in Figure 7-7, in a balanced binary tree, the absolute difference between the height of the left and right subtrees of any node does not exceed 1.</p> <p></p> <p> Figure 7-7 \u00a0 Balanced binary tree </p>"},{"location":"chapter_tree/binary_tree/#714-degeneration-of-binary-trees","title":"7.1.4 \u00a0 Degeneration of Binary Trees","text":"<p>Figure 7-8 shows the ideal and degenerate structures of binary trees. When every level of a binary tree is filled, it reaches the \"perfect binary tree\" state; when all nodes are biased toward one side, the binary tree degenerates into a \"linked list\".</p> <ul> <li>A perfect binary tree is the ideal case, fully leveraging the \"divide and conquer\" advantage of binary trees.</li> <li>A linked list represents the other extreme, where all operations become linear operations with time complexity degrading to \\(O(n)\\).</li> </ul> <p></p> <p> Figure 7-8 \u00a0 The Best and Worst Structures of Binary Trees </p> <p>As shown in Table 7-1, in the best and worst structures, the binary tree achieves either maximum or minimum values for leaf node count, total number of nodes, and height.</p> <p> Table 7-1 \u00a0 The Best and Worst Structures of Binary Trees </p> Perfect binary tree Linked list Number of nodes at level \\(i\\) \\(2^{i-1}\\) \\(1\\) Number of leaf nodes in a tree with height \\(h\\) \\(2^h\\) \\(1\\) Total number of nodes in a tree with height \\(h\\) \\(2^{h+1} - 1\\) \\(h + 1\\) Height of a tree with \\(n\\) total nodes \\(\\log_2 (n+1) - 1\\) \\(n - 1\\)"},{"location":"chapter_tree/binary_tree_traversal/","title":"7.2 \u00a0 Binary Tree Traversal","text":"<p>From a physical structure perspective, a tree is a data structure based on linked lists. Hence, its traversal method involves accessing nodes one by one through pointers. However, a tree is a non-linear data structure, which makes traversing a tree more complex than traversing a linked list, requiring the assistance of search algorithms.</p> <p>The common traversal methods for binary trees include level-order traversal, pre-order traversal, in-order traversal, and post-order traversal.</p>"},{"location":"chapter_tree/binary_tree_traversal/#721-level-order-traversal","title":"7.2.1 \u00a0 Level-Order Traversal","text":"<p>As shown in Figure 7-9, level-order traversal traverses the binary tree from top to bottom, layer by layer. Within each level, it visits nodes from left to right.</p> <p>Level-order traversal is essentially breadth-first traversal, also known as breadth-first search (BFS), which embodies a \"expanding outward circle by circle\" layer-by-layer traversal method.</p> <p></p> <p> Figure 7-9 \u00a0 Level-order traversal of a binary tree </p>"},{"location":"chapter_tree/binary_tree_traversal/#1-code-implementation","title":"1. \u00a0 Code Implementation","text":"<p>Breadth-first traversal is typically implemented with the help of a \"queue\". The queue follows the \"first in, first out\" rule, while breadth-first traversal follows the \"layer-by-layer progression\" rule; the underlying ideas of the two are consistent. The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_tree_bfs.py<pre><code>def level_order(root: TreeNode | None) -&gt; list[int]:\n    \"\"\"Level-order traversal\"\"\"\n    # Initialize queue, add root node\n    queue: deque[TreeNode] = deque()\n    queue.append(root)\n    # Initialize a list to save the traversal sequence\n    res = []\n    while queue:\n        node: TreeNode = queue.popleft()  # Dequeue\n        res.append(node.val)  # Save node value\n        if node.left is not None:\n            queue.append(node.left)  # Left child node enqueue\n        if node.right is not None:\n            queue.append(node.right)  # Right child node enqueue\n    return res\n</code></pre> binary_tree_bfs.cpp<pre><code>/* Level-order traversal */\nvector&lt;int&gt; levelOrder(TreeNode *root) {\n    // Initialize queue, add root node\n    queue&lt;TreeNode *&gt; queue;\n    queue.push(root);\n    // Initialize a list to save the traversal sequence\n    vector&lt;int&gt; vec;\n    while (!queue.empty()) {\n        TreeNode *node = queue.front();\n        queue.pop();              // Dequeue\n        vec.push_back(node-&gt;val); // Save node value\n        if (node-&gt;left != nullptr)\n            queue.push(node-&gt;left); // Left child node enqueue\n        if (node-&gt;right != nullptr)\n            queue.push(node-&gt;right); // Right child node enqueue\n    }\n    return vec;\n}\n</code></pre> binary_tree_bfs.java<pre><code>/* Level-order traversal */\nList&lt;Integer&gt; levelOrder(TreeNode root) {\n    // Initialize queue, add root node\n    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n    queue.add(root);\n    // Initialize a list to save the traversal sequence\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll(); // Dequeue\n        list.add(node.val);           // Save node value\n        if (node.left != null)\n            queue.offer(node.left);   // Left child node enqueue\n        if (node.right != null)\n            queue.offer(node.right);  // Right child node enqueue\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.cs<pre><code>/* Level-order traversal */\nList&lt;int&gt; LevelOrder(TreeNode root) {\n    // Initialize queue, add root node\n    Queue&lt;TreeNode&gt; queue = new();\n    queue.Enqueue(root);\n    // Initialize a list to save the traversal sequence\n    List&lt;int&gt; list = [];\n    while (queue.Count != 0) {\n        TreeNode node = queue.Dequeue(); // Dequeue\n        list.Add(node.val!.Value);       // Save node value\n        if (node.left != null)\n            queue.Enqueue(node.left);    // Left child node enqueue\n        if (node.right != null)\n            queue.Enqueue(node.right);   // Right child node enqueue\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.go<pre><code>/* Level-order traversal */\nfunc levelOrder(root *TreeNode) []any {\n    // Initialize queue, add root node\n    queue := list.New()\n    queue.PushBack(root)\n    // Initialize a slice to save traversal sequence\n    nums := make([]any, 0)\n    for queue.Len() &gt; 0 {\n        // Dequeue\n        node := queue.Remove(queue.Front()).(*TreeNode)\n        // Save node value\n        nums = append(nums, node.Val)\n        if node.Left != nil {\n            // Left child node enqueue\n            queue.PushBack(node.Left)\n        }\n        if node.Right != nil {\n            // Right child node enqueue\n            queue.PushBack(node.Right)\n        }\n    }\n    return nums\n}\n</code></pre> binary_tree_bfs.swift<pre><code>/* Level-order traversal */\nfunc levelOrder(root: TreeNode) -&gt; [Int] {\n    // Initialize queue, add root node\n    var queue: [TreeNode] = [root]\n    // Initialize a list to save the traversal sequence\n    var list: [Int] = []\n    while !queue.isEmpty {\n        let node = queue.removeFirst() // Dequeue\n        list.append(node.val) // Save node value\n        if let left = node.left {\n            queue.append(left) // Left child node enqueue\n        }\n        if let right = node.right {\n            queue.append(right) // Right child node enqueue\n        }\n    }\n    return list\n}\n</code></pre> binary_tree_bfs.js<pre><code>/* Level-order traversal */\nfunction levelOrder(root) {\n    // Initialize queue, add root node\n    const queue = [root];\n    // Initialize a list to save the traversal sequence\n    const list = [];\n    while (queue.length) {\n        let node = queue.shift(); // Dequeue\n        list.push(node.val); // Save node value\n        if (node.left) queue.push(node.left); // Left child node enqueue\n        if (node.right) queue.push(node.right); // Right child node enqueue\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.ts<pre><code>/* Level-order traversal */\nfunction levelOrder(root: TreeNode | null): number[] {\n    // Initialize queue, add root node\n    const queue = [root];\n    // Initialize a list to save the traversal sequence\n    const list: number[] = [];\n    while (queue.length) {\n        let node = queue.shift() as TreeNode; // Dequeue\n        list.push(node.val); // Save node value\n        if (node.left) {\n            queue.push(node.left); // Left child node enqueue\n        }\n        if (node.right) {\n            queue.push(node.right); // Right child node enqueue\n        }\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.dart<pre><code>/* Level-order traversal */\nList&lt;int&gt; levelOrder(TreeNode? root) {\n  // Initialize queue, add root node\n  Queue&lt;TreeNode?&gt; queue = Queue();\n  queue.add(root);\n  // Initialize a list to save the traversal sequence\n  List&lt;int&gt; res = [];\n  while (queue.isNotEmpty) {\n    TreeNode? node = queue.removeFirst(); // Dequeue\n    res.add(node!.val); // Save node value\n    if (node.left != null) queue.add(node.left); // Left child node enqueue\n    if (node.right != null) queue.add(node.right); // Right child node enqueue\n  }\n  return res;\n}\n</code></pre> binary_tree_bfs.rs<pre><code>/* Level-order traversal */\nfn level_order(root: &amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    // Initialize queue, add root node\n    let mut que = VecDeque::new();\n    que.push_back(root.clone());\n    // Initialize a list to save the traversal sequence\n    let mut vec = Vec::new();\n\n    while let Some(node) = que.pop_front() {\n        // Dequeue\n        vec.push(node.borrow().val); // Save node value\n        if let Some(left) = node.borrow().left.as_ref() {\n            que.push_back(left.clone()); // Left child node enqueue\n        }\n        if let Some(right) = node.borrow().right.as_ref() {\n            que.push_back(right.clone()); // Right child node enqueue\n        };\n    }\n    vec\n}\n</code></pre> binary_tree_bfs.c<pre><code>/* Level-order traversal */\nint *levelOrder(TreeNode *root, int *size) {\n    /* Auxiliary queue */\n    int front, rear;\n    int index, *arr;\n    TreeNode *node;\n    TreeNode **queue;\n\n    /* Auxiliary queue */\n    queue = (TreeNode **)malloc(sizeof(TreeNode *) * MAX_SIZE);\n    // Queue pointer\n    front = 0, rear = 0;\n    // Add root node\n    queue[rear++] = root;\n    // Initialize a list to save the traversal sequence\n    /* Auxiliary array */\n    arr = (int *)malloc(sizeof(int) * MAX_SIZE);\n    // Array pointer\n    index = 0;\n    while (front &lt; rear) {\n        // Dequeue\n        node = queue[front++];\n        // Save node value\n        arr[index++] = node-&gt;val;\n        if (node-&gt;left != NULL) {\n            // Left child node enqueue\n            queue[rear++] = node-&gt;left;\n        }\n        if (node-&gt;right != NULL) {\n            // Right child node enqueue\n            queue[rear++] = node-&gt;right;\n        }\n    }\n    // Update array length value\n    *size = index;\n    arr = realloc(arr, sizeof(int) * (*size));\n\n    // Free auxiliary array space\n    free(queue);\n    return arr;\n}\n</code></pre> binary_tree_bfs.kt<pre><code>/* Level-order traversal */\nfun levelOrder(root: TreeNode?): MutableList&lt;Int&gt; {\n    // Initialize queue, add root node\n    val queue = LinkedList&lt;TreeNode?&gt;()\n    queue.add(root)\n    // Initialize a list to save the traversal sequence\n    val list = mutableListOf&lt;Int&gt;()\n    while (queue.isNotEmpty()) {\n        val node = queue.poll()      // Dequeue\n        list.add(node?._val!!)       // Save node value\n        if (node.left != null)\n            queue.offer(node.left)   // Left child node enqueue\n        if (node.right != null)\n            queue.offer(node.right)  // Right child node enqueue\n    }\n    return list\n}\n</code></pre> binary_tree_bfs.rb<pre><code>### Level-order traversal ###\ndef level_order(root)\n  # Initialize queue, add root node\n  queue = [root]\n  # Initialize a list to save the traversal sequence\n  res = []\n  while !queue.empty?\n    node = queue.shift # Dequeue\n    res &lt;&lt; node.val # Save node value\n    queue &lt;&lt; node.left unless node.left.nil? # Left child node enqueue\n    queue &lt;&lt; node.right unless node.right.nil? # Right child node enqueue\n  end\n  res\nend\n</code></pre>"},{"location":"chapter_tree/binary_tree_traversal/#2-complexity-analysis","title":"2. \u00a0 Complexity Analysis","text":"<ul> <li>Time complexity is \\(O(n)\\): All nodes are visited once, using \\(O(n)\\) time, where \\(n\\) is the number of nodes.</li> <li>Space complexity is \\(O(n)\\): In the worst case, i.e., a full binary tree, before traversing to the bottom level, the queue contains at most \\((n + 1) / 2\\) nodes simultaneously, occupying \\(O(n)\\) space.</li> </ul>"},{"location":"chapter_tree/binary_tree_traversal/#722-preorder-inorder-and-postorder-traversal","title":"7.2.2 \u00a0 Preorder, Inorder, and Postorder Traversal","text":"<p>Correspondingly, preorder, inorder, and postorder traversals all belong to depth-first traversal, also known as depth-first search (DFS), which embodies a \"first go to the end, then backtrack and continue\" traversal method.</p> <p>Figure 7-10 shows how depth-first traversal works on a binary tree. Depth-first traversal is like \"walking\" around the perimeter of the entire binary tree, encountering three positions at each node, corresponding to preorder, inorder, and postorder traversal.</p> <p></p> <p> Figure 7-10 \u00a0 Preorder, inorder, and postorder traversal of a binary tree </p>"},{"location":"chapter_tree/binary_tree_traversal/#1-code-implementation_1","title":"1. \u00a0 Code Implementation","text":"<p>Depth-first search is usually implemented based on recursion:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRuby binary_tree_dfs.py<pre><code>def pre_order(root: TreeNode | None):\n    \"\"\"Preorder traversal\"\"\"\n    if root is None:\n        return\n    # Visit priority: root node -&gt; left subtree -&gt; right subtree\n    res.append(root.val)\n    pre_order(root=root.left)\n    pre_order(root=root.right)\n\ndef in_order(root: TreeNode | None):\n    \"\"\"Inorder traversal\"\"\"\n    if root is None:\n        return\n    # Visit priority: left subtree -&gt; root node -&gt; right subtree\n    in_order(root=root.left)\n    res.append(root.val)\n    in_order(root=root.right)\n\ndef post_order(root: TreeNode | None):\n    \"\"\"Postorder traversal\"\"\"\n    if root is None:\n        return\n    # Visit priority: left subtree -&gt; right subtree -&gt; root node\n    post_order(root=root.left)\n    post_order(root=root.right)\n    res.append(root.val)\n</code></pre> binary_tree_dfs.cpp<pre><code>/* Preorder traversal */\nvoid preOrder(TreeNode *root) {\n    if (root == nullptr)\n        return;\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    vec.push_back(root-&gt;val);\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n}\n\n/* Inorder traversal */\nvoid inOrder(TreeNode *root) {\n    if (root == nullptr)\n        return;\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(root-&gt;left);\n    vec.push_back(root-&gt;val);\n    inOrder(root-&gt;right);\n}\n\n/* Postorder traversal */\nvoid postOrder(TreeNode *root) {\n    if (root == nullptr)\n        return;\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(root-&gt;left);\n    postOrder(root-&gt;right);\n    vec.push_back(root-&gt;val);\n}\n</code></pre> binary_tree_dfs.java<pre><code>/* Preorder traversal */\nvoid preOrder(TreeNode root) {\n    if (root == null)\n        return;\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    list.add(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n}\n\n/* Inorder traversal */\nvoid inOrder(TreeNode root) {\n    if (root == null)\n        return;\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(root.left);\n    list.add(root.val);\n    inOrder(root.right);\n}\n\n/* Postorder traversal */\nvoid postOrder(TreeNode root) {\n    if (root == null)\n        return;\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(root.left);\n    postOrder(root.right);\n    list.add(root.val);\n}\n</code></pre> binary_tree_dfs.cs<pre><code>/* Preorder traversal */\nvoid PreOrder(TreeNode? root) {\n    if (root == null) return;\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    list.Add(root.val!.Value);\n    PreOrder(root.left);\n    PreOrder(root.right);\n}\n\n/* Inorder traversal */\nvoid InOrder(TreeNode? root) {\n    if (root == null) return;\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    InOrder(root.left);\n    list.Add(root.val!.Value);\n    InOrder(root.right);\n}\n\n/* Postorder traversal */\nvoid PostOrder(TreeNode? root) {\n    if (root == null) return;\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    PostOrder(root.left);\n    PostOrder(root.right);\n    list.Add(root.val!.Value);\n}\n</code></pre> binary_tree_dfs.go<pre><code>/* Preorder traversal */\nfunc preOrder(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    nums = append(nums, node.Val)\n    preOrder(node.Left)\n    preOrder(node.Right)\n}\n\n/* Inorder traversal */\nfunc inOrder(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(node.Left)\n    nums = append(nums, node.Val)\n    inOrder(node.Right)\n}\n\n/* Postorder traversal */\nfunc postOrder(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(node.Left)\n    postOrder(node.Right)\n    nums = append(nums, node.Val)\n}\n</code></pre> binary_tree_dfs.swift<pre><code>/* Preorder traversal */\nfunc preOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    list.append(root.val)\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n}\n\n/* Inorder traversal */\nfunc inOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(root: root.left)\n    list.append(root.val)\n    inOrder(root: root.right)\n}\n\n/* Postorder traversal */\nfunc postOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(root: root.left)\n    postOrder(root: root.right)\n    list.append(root.val)\n}\n</code></pre> binary_tree_dfs.js<pre><code>/* Preorder traversal */\nfunction preOrder(root) {\n    if (root === null) return;\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    list.push(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n}\n\n/* Inorder traversal */\nfunction inOrder(root) {\n    if (root === null) return;\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(root.left);\n    list.push(root.val);\n    inOrder(root.right);\n}\n\n/* Postorder traversal */\nfunction postOrder(root) {\n    if (root === null) return;\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(root.left);\n    postOrder(root.right);\n    list.push(root.val);\n}\n</code></pre> binary_tree_dfs.ts<pre><code>/* Preorder traversal */\nfunction preOrder(root: TreeNode | null): void {\n    if (root === null) {\n        return;\n    }\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    list.push(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n}\n\n/* Inorder traversal */\nfunction inOrder(root: TreeNode | null): void {\n    if (root === null) {\n        return;\n    }\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(root.left);\n    list.push(root.val);\n    inOrder(root.right);\n}\n\n/* Postorder traversal */\nfunction postOrder(root: TreeNode | null): void {\n    if (root === null) {\n        return;\n    }\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(root.left);\n    postOrder(root.right);\n    list.push(root.val);\n}\n</code></pre> binary_tree_dfs.dart<pre><code>/* Preorder traversal */\nvoid preOrder(TreeNode? node) {\n  if (node == null) return;\n  // Visit priority: root node -&gt; left subtree -&gt; right subtree\n  list.add(node.val);\n  preOrder(node.left);\n  preOrder(node.right);\n}\n\n/* Inorder traversal */\nvoid inOrder(TreeNode? node) {\n  if (node == null) return;\n  // Visit priority: left subtree -&gt; root node -&gt; right subtree\n  inOrder(node.left);\n  list.add(node.val);\n  inOrder(node.right);\n}\n\n/* Postorder traversal */\nvoid postOrder(TreeNode? node) {\n  if (node == null) return;\n  // Visit priority: left subtree -&gt; right subtree -&gt; root node\n  postOrder(node.left);\n  postOrder(node.right);\n  list.add(node.val);\n}\n</code></pre> binary_tree_dfs.rs<pre><code>/* Preorder traversal */\nfn pre_order(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut result = vec![];\n\n    fn dfs(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, res: &amp;mut Vec&lt;i32&gt;) {\n        if let Some(node) = root {\n            // Visit priority: root node -&gt; left subtree -&gt; right subtree\n            let node = node.borrow();\n            res.push(node.val);\n            dfs(node.left.as_ref(), res);\n            dfs(node.right.as_ref(), res);\n        }\n    }\n    dfs(root, &amp;mut result);\n\n    result\n}\n\n/* Inorder traversal */\nfn in_order(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut result = vec![];\n\n    fn dfs(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, res: &amp;mut Vec&lt;i32&gt;) {\n        if let Some(node) = root {\n            // Visit priority: left subtree -&gt; root node -&gt; right subtree\n            let node = node.borrow();\n            dfs(node.left.as_ref(), res);\n            res.push(node.val);\n            dfs(node.right.as_ref(), res);\n        }\n    }\n    dfs(root, &amp;mut result);\n\n    result\n}\n\n/* Postorder traversal */\nfn post_order(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut result = vec![];\n\n    fn dfs(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, res: &amp;mut Vec&lt;i32&gt;) {\n        if let Some(node) = root {\n            // Visit priority: left subtree -&gt; right subtree -&gt; root node\n            let node = node.borrow();\n            dfs(node.left.as_ref(), res);\n            dfs(node.right.as_ref(), res);\n            res.push(node.val);\n        }\n    }\n\n    dfs(root, &amp;mut result);\n\n    result\n}\n</code></pre> binary_tree_dfs.c<pre><code>/* Preorder traversal */\nvoid preOrder(TreeNode *root, int *size) {\n    if (root == NULL)\n        return;\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    arr[(*size)++] = root-&gt;val;\n    preOrder(root-&gt;left, size);\n    preOrder(root-&gt;right, size);\n}\n\n/* Inorder traversal */\nvoid inOrder(TreeNode *root, int *size) {\n    if (root == NULL)\n        return;\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(root-&gt;left, size);\n    arr[(*size)++] = root-&gt;val;\n    inOrder(root-&gt;right, size);\n}\n\n/* Postorder traversal */\nvoid postOrder(TreeNode *root, int *size) {\n    if (root == NULL)\n        return;\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(root-&gt;left, size);\n    postOrder(root-&gt;right, size);\n    arr[(*size)++] = root-&gt;val;\n}\n</code></pre> binary_tree_dfs.kt<pre><code>/* Preorder traversal */\nfun preOrder(root: TreeNode?) {\n    if (root == null) return\n    // Visit priority: root node -&gt; left subtree -&gt; right subtree\n    list.add(root._val)\n    preOrder(root.left)\n    preOrder(root.right)\n}\n\n/* Inorder traversal */\nfun inOrder(root: TreeNode?) {\n    if (root == null) return\n    // Visit priority: left subtree -&gt; root node -&gt; right subtree\n    inOrder(root.left)\n    list.add(root._val)\n    inOrder(root.right)\n}\n\n/* Postorder traversal */\nfun postOrder(root: TreeNode?) {\n    if (root == null) return\n    // Visit priority: left subtree -&gt; right subtree -&gt; root node\n    postOrder(root.left)\n    postOrder(root.right)\n    list.add(root._val)\n}\n</code></pre> binary_tree_dfs.rb<pre><code>### Pre-order traversal ###\ndef pre_order(root)\n  return if root.nil?\n\n  # Visit priority: root node -&gt; left subtree -&gt; right subtree\n  $res &lt;&lt; root.val\n  pre_order(root.left)\n  pre_order(root.right)\nend\n\n### In-order traversal ###\ndef in_order(root)\n  return if root.nil?\n\n  # Visit priority: left subtree -&gt; root node -&gt; right subtree\n  in_order(root.left)\n  $res &lt;&lt; root.val\n  in_order(root.right)\nend\n\n### Post-order traversal ###\ndef post_order(root)\n  return if root.nil?\n\n  # Visit priority: left subtree -&gt; right subtree -&gt; root node\n  post_order(root.left)\n  post_order(root.right)\n  $res &lt;&lt; root.val\nend\n</code></pre> <p>Tip</p> <p>Depth-first search can also be implemented based on iteration, interested readers can study this on their own.</p> <p>Figure 7-11 shows the recursive process of preorder traversal of a binary tree, which can be divided into two opposite parts: \"recursion\" and \"return\".</p> <ol> <li>\"Recursion\" means opening a new method, where the program accesses the next node in this process.</li> <li>\"Return\" means the function returns, indicating that the current node has been fully visited.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 7-11 \u00a0 The recursive process of preorder traversal </p>"},{"location":"chapter_tree/binary_tree_traversal/#2-complexity-analysis_1","title":"2. \u00a0 Complexity Analysis","text":"<ul> <li>Time complexity is \\(O(n)\\): All nodes are visited once, using \\(O(n)\\) time.</li> <li>Space complexity is \\(O(n)\\): In the worst case, i.e., the tree degenerates into a linked list, the recursion depth reaches \\(n\\), and the system occupies \\(O(n)\\) stack frame space.</li> </ul>"},{"location":"chapter_tree/summary/","title":"7.6 \u00a0 Summary","text":""},{"location":"chapter_tree/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>A binary tree is a non-linear data structure that embodies the divide-and-conquer logic of \"one divides into two\". Each binary tree node contains a value and two pointers, which respectively point to its left and right child nodes.</li> <li>For a certain node in a binary tree, the tree formed by its left (right) child node and all nodes below is called the left (right) subtree of that node.</li> <li>Related terminology of binary trees includes root node, leaf node, level, degree, edge, height, and depth.</li> <li>The initialization, node insertion, and node removal operations of binary trees are similar to those of linked lists.</li> <li>Common types of binary trees include perfect binary trees, complete binary trees, full binary trees, and balanced binary trees. The perfect binary tree is the ideal state, while the linked list is the worst state after degradation.</li> <li>A binary tree can be represented using an array by arranging node values and empty slots in level-order traversal sequence, and implementing pointers based on the index mapping relationship between parent and child nodes.</li> <li>Level-order traversal of a binary tree is a breadth-first search method, embodying a layer-by-layer traversal approach of \"expanding outward circle by circle\", typically implemented using a queue.</li> <li>Preorder, inorder, and postorder traversals all belong to depth-first search, embodying a traversal approach of \"first go to the end, then backtrack and continue\", typically implemented using recursion.</li> <li>A binary search tree is an efficient data structure for element searching, with search, insertion, and removal operations all having time complexity of \\(O(\\log n)\\). When a binary search tree degenerates into a linked list, all time complexities degrade to \\(O(n)\\).</li> <li>An AVL tree, also known as a balanced binary search tree, ensures the tree remains balanced after continuous node insertions and removals through rotation operations.</li> <li>Rotation operations in AVL trees include right rotation, left rotation, left rotation then right rotation, and right rotation then left rotation. After inserting or removing nodes, AVL trees perform rotation operations from bottom to top to restore the tree to balance.</li> </ul>"},{"location":"chapter_tree/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: For a binary tree with only one node, are both the height of the tree and the depth of the root node \\(0\\)?</p> <p>Yes, because height and depth are typically defined as \"the number of edges passed.\"</p> <p>Q: The insertion and removal in a binary tree are generally accomplished by a set of operations. What does \"a set of operations\" refer to here? Does it imply releasing the resources of the child nodes?</p> <p>Taking the binary search tree as an example, the operation of removing a node needs to be handled in three different scenarios, each requiring multiple steps of node operations.</p> <p>Q: Why does DFS traversal of binary trees have three orders: preorder, inorder, and postorder, and what are their uses?</p> <p>Similar to forward and reverse traversal of arrays, preorder, inorder, and postorder traversals are three methods of binary tree traversal that allow us to obtain a traversal result in a specific order. For example, in a binary search tree, since nodes satisfy the relationship <code>left child node value &lt; root node value &lt; right child node value</code>, we only need to traverse the tree with the priority of \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\" to obtain an ordered node sequence.</p> <p>Q: In a right rotation operation handling the relationship between unbalanced nodes <code>node</code>, <code>child</code>, and <code>grand_child</code>, doesn't the connection between <code>node</code> and its parent node get lost after the right rotation?</p> <p>We need to view this problem from a recursive perspective. The right rotation operation <code>right_rotate(root)</code> passes in the root node of the subtree and eventually returns the root node of the subtree after rotation with <code>return child</code>. The connection between the subtree's root node and its parent node is completed after the function returns, which is not within the maintenance scope of the right rotation operation.</p> <p>Q: In C++, functions are divided into <code>private</code> and <code>public</code> sections. What considerations are there for this? Why are the <code>height()</code> function and the <code>updateHeight()</code> function placed in <code>public</code> and <code>private</code>, respectively?</p> <p>It mainly depends on the method's usage scope. If a method is only used within the class, then it is designed as <code>private</code>. For example, calling <code>updateHeight()</code> alone by the user makes no sense, as it is only a step in insertion or removal operations. However, <code>height()</code> is used to access node height, similar to <code>vector.size()</code>, so it is set to <code>public</code> for ease of use.</p> <p>Q: How do you build a binary search tree from a set of input data? Is the choice of root node very important?</p> <p>Yes, the method for building a tree is provided in the <code>build_tree()</code> method in the binary search tree code. As for the choice of root node, we typically sort the input data, then select the middle element as the root node, and recursively build the left and right subtrees. This approach maximizes the tree's balance.</p> <p>Q: In Java, do you always have to use the <code>equals()</code> method for string comparison?</p> <p>In Java, for primitive data types, <code>==</code> is used to compare whether the values of two variables are equal. For reference types, the working principles of the two symbols are different.</p> <ul> <li><code>==</code>: Used to compare whether two variables point to the same object, i.e., whether their positions in memory are the same.</li> <li><code>equals()</code>: Used to compare whether the values of two objects are equal.</li> </ul> <p>Therefore, if we want to compare values, we should use <code>equals()</code>. However, strings initialized via <code>String a = \"hi\"; String b = \"hi\";</code> are stored in the string constant pool and point to the same object, so <code>a == b</code> can also be used to compare the contents of the two strings.</p> <p>Q: Before reaching the bottom level, is the number of nodes in the queue \\(2^h\\) in breadth-first traversal?</p> <p>Yes, for example, a full binary tree with height \\(h = 2\\) has a total of \\(n = 7\\) nodes, then the bottom level has \\(4 = 2^h = (n + 1) / 2\\) nodes.</p>"}]}